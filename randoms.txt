./node_modules/node-forge/README.md:1854:entropy is given, though if window.crypto.getRandomValues is available, it will
./node_modules/node-forge/lib/random.js:115:// add other sources of entropy only if window.crypto.getRandomValues is not
./node_modules/node-forge/lib/random.js:120:if(_crypto && _crypto.getRandomValues) {
./node_modules/node-forge/lib/random.js:122:    return _crypto.getRandomValues(arr);
./node_modules/node-forge/lib/prng.js:268:    // use window.crypto.getRandomValues strong source of entropy if available
./node_modules/node-forge/lib/prng.js:272:    if(_crypto && _crypto.getRandomValues) {
./node_modules/node-forge/lib/prng.js:274:        return _crypto.getRandomValues(arr);
./node_modules/xcode/node_modules/uuid/dist/umd/uuid.min.js:1:!function(r,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n((r=r||self).uuid={})}(this,(function(r){"use strict";var n="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto),e=new Uint8Array(16);function t(){if(!n)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return n(e)}for(var o,a,u=[],f=0;f<256;++f)u[f]=(f+256).toString(16).substr(1);function c(r,n){var e=n||0,t=u;return[t[r[e++]],t[r[e++]],t[r[e++]],t[r[e++]],"-",t[r[e++]],t[r[e++]],"-",t[r[e++]],t[r[e++]],"-",t[r[e++]],t[r[e++]],"-",t[r[e++]],t[r[e++]],t[r[e++]],t[r[e++]],t[r[e++]],t[r[e++]]].join("")}var i=0,s=0;function v(r,n,e){var t=function(r,t,o,a){var u=o&&a||0;if("string"==typeof r&&(r=function(r){r=unescape(encodeURIComponent(r));for(var n=new Array(r.length),e=0;e<r.length;e++)n[e]=r.charCodeAt(e);return n}(r)),"string"==typeof t&&(t=function(r){var n=[];return r.replace(/[a-fA-F0-9]{2}/g,(function(r){n.push(parseInt(r,16))})),n}(t)),!Array.isArray(r))throw TypeError("value must be an array of bytes");if(!Array.isArray(t)||16!==t.length)throw TypeError("namespace must be uuid string or an Array of 16 byte values");var f=e(t.concat(r));if(f[6]=15&f[6]|n,f[8]=63&f[8]|128,o)for(var i=0;i<16;++i)o[u+i]=f[i];return o||c(f)};try{t.name=r}catch(r){}return t.DNS="6ba7b810-9dad-11d1-80b4-00c04fd430c8",t.URL="6ba7b811-9dad-11d1-80b4-00c04fd430c8",t}function d(r,n){var e=(65535&r)+(65535&n);return(r>>16)+(n>>16)+(e>>16)<<16|65535&e}function l(r,n,e,t,o,a){return d((u=d(d(n,r),d(t,a)))<<(f=o)|u>>>32-f,e);var u,f}function p(r,n,e,t,o,a,u){return l(n&e|~n&t,r,n,o,a,u)}function y(r,n,e,t,o,a,u){return l(n&t|e&~t,r,n,o,a,u)}function h(r,n,e,t,o,a,u){return l(n^e^t,r,n,o,a,u)}function g(r,n,e,t,o,a,u){return l(e^(n|~t),r,n,o,a,u)}var m=v("v3",48,(function(r){if("string"==typeof r){var n=unescape(encodeURIComponent(r));r=new Array(n.length);for(var e=0;e<n.length;e++)r[e]=n.charCodeAt(e)}return function(r){var n,e,t,o=[],a=32*r.length;for(n=0;n<a;n+=8)e=r[n>>5]>>>n%32&255,t=parseInt("0123456789abcdef".charAt(e>>>4&15)+"0123456789abcdef".charAt(15&e),16),o.push(t);return o}(function(r,n){var e,t,o,a,u;r[n>>5]|=128<<n%32,r[14+(n+64>>>9<<4)]=n;var f=1732584193,c=-271733879,i=-1732584194,s=271733878;for(e=0;e<r.length;e+=16)t=f,o=c,a=i,u=s,f=p(f,c,i,s,r[e],7,-680876936),s=p(s,f,c,i,r[e+1],12,-389564586),i=p(i,s,f,c,r[e+2],17,606105819),c=p(c,i,s,f,r[e+3],22,-1044525330),f=p(f,c,i,s,r[e+4],7,-176418897),s=p(s,f,c,i,r[e+5],12,1200080426),i=p(i,s,f,c,r[e+6],17,-1473231341),c=p(c,i,s,f,r[e+7],22,-45705983),f=p(f,c,i,s,r[e+8],7,1770035416),s=p(s,f,c,i,r[e+9],12,-1958414417),i=p(i,s,f,c,r[e+10],17,-42063),c=p(c,i,s,f,r[e+11],22,-1990404162),f=p(f,c,i,s,r[e+12],7,1804603682),s=p(s,f,c,i,r[e+13],12,-40341101),i=p(i,s,f,c,r[e+14],17,-1502002290),c=p(c,i,s,f,r[e+15],22,1236535329),f=y(f,c,i,s,r[e+1],5,-165796510),s=y(s,f,c,i,r[e+6],9,-1069501632),i=y(i,s,f,c,r[e+11],14,643717713),c=y(c,i,s,f,r[e],20,-373897302),f=y(f,c,i,s,r[e+5],5,-701558691),s=y(s,f,c,i,r[e+10],9,38016083),i=y(i,s,f,c,r[e+15],14,-660478335),c=y(c,i,s,f,r[e+4],20,-405537848),f=y(f,c,i,s,r[e+9],5,568446438),s=y(s,f,c,i,r[e+14],9,-1019803690),i=y(i,s,f,c,r[e+3],14,-187363961),c=y(c,i,s,f,r[e+8],20,1163531501),f=y(f,c,i,s,r[e+13],5,-1444681467),s=y(s,f,c,i,r[e+2],9,-51403784),i=y(i,s,f,c,r[e+7],14,1735328473),c=y(c,i,s,f,r[e+12],20,-1926607734),f=h(f,c,i,s,r[e+5],4,-378558),s=h(s,f,c,i,r[e+8],11,-2022574463),i=h(i,s,f,c,r[e+11],16,1839030562),c=h(c,i,s,f,r[e+14],23,-35309556),f=h(f,c,i,s,r[e+1],4,-1530992060),s=h(s,f,c,i,r[e+4],11,1272893353),i=h(i,s,f,c,r[e+7],16,-155497632),c=h(c,i,s,f,r[e+10],23,-1094730640),f=h(f,c,i,s,r[e+13],4,681279174),s=h(s,f,c,i,r[e],11,-358537222),i=h(i,s,f,c,r[e+3],16,-722521979),c=h(c,i,s,f,r[e+6],23,76029189),f=h(f,c,i,s,r[e+9],4,-640364487),s=h(s,f,c,i,r[e+12],11,-421815835),i=h(i,s,f,c,r[e+15],16,530742520),c=h(c,i,s,f,r[e+2],23,-995338651),f=g(f,c,i,s,r[e],6,-198630844),s=g(s,f,c,i,r[e+7],10,1126891415),i=g(i,s,f,c,r[e+14],15,-1416354905),c=g(c,i,s,f,r[e+5],21,-57434055),f=g(f,c,i,s,r[e+12],6,1700485571),s=g(s,f,c,i,r[e+3],10,-1894986606),i=g(i,s,f,c,r[e+10],15,-1051523),c=g(c,i,s,f,r[e+1],21,-2054922799),f=g(f,c,i,s,r[e+8],6,1873313359),s=g(s,f,c,i,r[e+15],10,-30611744),i=g(i,s,f,c,r[e+6],15,-1560198380),c=g(c,i,s,f,r[e+13],21,1309151649),f=g(f,c,i,s,r[e+4],6,-145523070),s=g(s,f,c,i,r[e+11],10,-1120210379),i=g(i,s,f,c,r[e+2],15,718787259),c=g(c,i,s,f,r[e+9],21,-343485551),f=d(f,t),c=d(c,o),i=d(i,a),s=d(s,u);return[f,c,i,s]}(function(r){var n,e=[];for(e[(r.length>>2)-1]=void 0,n=0;n<e.length;n+=1)e[n]=0;var t=8*r.length;for(n=0;n<t;n+=8)e[n>>5]|=(255&r[n/8])<<n%32;return e}(r),8*r.length))}));function b(r,n,e,t){switch(r){case 0:return n&e^~n&t;case 1:return n^e^t;case 2:return n&e^n&t^e&t;case 3:return n^e^t}}function A(r,n){return r<<n|r>>>32-n}var w=v("v5",80,(function(r){var n=[1518500249,1859775393,2400959708,3395469782],e=[1732584193,4023233417,2562383102,271733878,3285377520];if("string"==typeof r){var t=unescape(encodeURIComponent(r));r=new Array(t.length);for(var o=0;o<t.length;o++)r[o]=t.charCodeAt(o)}r.push(128);var a=r.length/4+2,u=Math.ceil(a/16),f=new Array(u);for(o=0;o<u;o++){f[o]=new Array(16);for(var c=0;c<16;c++)f[o][c]=r[64*o+4*c]<<24|r[64*o+4*c+1]<<16|r[64*o+4*c+2]<<8|r[64*o+4*c+3]}for(f[u-1][14]=8*(r.length-1)/Math.pow(2,32),f[u-1][14]=Math.floor(f[u-1][14]),f[u-1][15]=8*(r.length-1)&4294967295,o=0;o<u;o++){for(var i=new Array(80),s=0;s<16;s++)i[s]=f[o][s];for(s=16;s<80;s++)i[s]=A(i[s-3]^i[s-8]^i[s-14]^i[s-16],1);var v=e[0],d=e[1],l=e[2],p=e[3],y=e[4];for(s=0;s<80;s++){var h=Math.floor(s/20),g=A(v,5)+b(h,d,l,p)+y+n[h]+i[s]>>>0;y=p,p=l,l=A(d,30)>>>0,d=v,v=g}e[0]=e[0]+v>>>0,e[1]=e[1]+d>>>0,e[2]=e[2]+l>>>0,e[3]=e[3]+p>>>0,e[4]=e[4]+y>>>0}return[e[0]>>24&255,e[0]>>16&255,e[0]>>8&255,255&e[0],e[1]>>24&255,e[1]>>16&255,e[1]>>8&255,255&e[1],e[2]>>24&255,e[2]>>16&255,e[2]>>8&255,255&e[2],e[3]>>24&255,e[3]>>16&255,e[3]>>8&255,255&e[3],e[4]>>24&255,e[4]>>16&255,e[4]>>8&255,255&e[4]]}));r.v1=function(r,n,e){var u=n&&e||0,f=n||[],v=(r=r||{}).node||o,d=void 0!==r.clockseq?r.clockseq:a;if(null==v||null==d){var l=r.random||(r.rng||t)();null==v&&(v=o=[1|l[0],l[1],l[2],l[3],l[4],l[5]]),null==d&&(d=a=16383&(l[6]<<8|l[7]))}var p=void 0!==r.msecs?r.msecs:(new Date).getTime(),y=void 0!==r.nsecs?r.nsecs:s+1,h=p-i+(y-s)/1e4;if(h<0&&void 0===r.clockseq&&(d=d+1&16383),(h<0||p>i)&&void 0===r.nsecs&&(y=0),y>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");i=p,s=y,a=d;var g=(1e4*(268435455&(p+=122192928e5))+y)%4294967296;f[u++]=g>>>24&255,f[u++]=g>>>16&255,f[u++]=g>>>8&255,f[u++]=255&g;var m=p/4294967296*1e4&268435455;f[u++]=m>>>8&255,f[u++]=255&m,f[u++]=m>>>24&15|16,f[u++]=m>>>16&255,f[u++]=d>>>8|128,f[u++]=255&d;for(var b=0;b<6;++b)f[u+b]=v[b];return n||c(f)},r.v3=m,r.v4=function(r,n,e){var o=n&&e||0;"string"==typeof r&&(n="binary"===r?new Array(16):null,r=null);var a=(r=r||{}).random||(r.rng||t)();if(a[6]=15&a[6]|64,a[8]=63&a[8]|128,n)for(var u=0;u<16;++u)n[o+u]=a[u];return n||c(a)},r.v5=w,Object.defineProperty(r,"__esModule",{value:!0})}));
./node_modules/xcode/node_modules/uuid/dist/umd/uuidv1.min.js:1:!function(e,o){"object"==typeof exports&&"undefined"!=typeof module?module.exports=o():"function"==typeof define&&define.amd?define(o):(e=e||self).uuidv1=o()}(this,(function(){"use strict";var e="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto),o=new Uint8Array(16);function n(){if(!e)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return e(o)}for(var t,r,u=[],s=0;s<256;++s)u[s]=(s+256).toString(16).substr(1);var i=0,d=0;return function(e,o,s){var a=o&&s||0,c=o||[],f=(e=e||{}).node||t,p=void 0!==e.clockseq?e.clockseq:r;if(null==f||null==p){var l=e.random||(e.rng||n)();null==f&&(f=t=[1|l[0],l[1],l[2],l[3],l[4],l[5]]),null==p&&(p=r=16383&(l[6]<<8|l[7]))}var m=void 0!==e.msecs?e.msecs:(new Date).getTime(),v=void 0!==e.nsecs?e.nsecs:d+1,y=m-i+(v-d)/1e4;if(y<0&&void 0===e.clockseq&&(p=p+1&16383),(y<0||m>i)&&void 0===e.nsecs&&(v=0),v>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");i=m,d=v,r=p;var g=(1e4*(268435455&(m+=122192928e5))+v)%4294967296;c[a++]=g>>>24&255,c[a++]=g>>>16&255,c[a++]=g>>>8&255,c[a++]=255&g;var h=m/4294967296*1e4&268435455;c[a++]=h>>>8&255,c[a++]=255&h,c[a++]=h>>>24&15|16,c[a++]=h>>>16&255,c[a++]=p>>>8|128,c[a++]=255&p;for(var w=0;w<6;++w)c[a+w]=f[w];return o||function(e,o){var n=o||0,t=u;return[t[e[n++]],t[e[n++]],t[e[n++]],t[e[n++]],"-",t[e[n++]],t[e[n++]],"-",t[e[n++]],t[e[n++]],"-",t[e[n++]],t[e[n++]],"-",t[e[n++]],t[e[n++]],t[e[n++]],t[e[n++]],t[e[n++]],t[e[n++]]].join("")}(c)}}));
./node_modules/xcode/node_modules/uuid/dist/umd/uuidv4.min.js:1:!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t=t||self).uuidv4=e()}(this,(function(){"use strict";var t="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto),e=new Uint8Array(16);function n(){if(!t)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return t(e)}for(var o=[],r=0;r<256;++r)o[r]=(r+256).toString(16).substr(1);return function(t,e,r){var u=e&&r||0;"string"==typeof t&&(e="binary"===t?new Array(16):null,t=null);var i=(t=t||{}).random||(t.rng||n)();if(i[6]=15&i[6]|64,i[8]=63&i[8]|128,e)for(var d=0;d<16;++d)e[u+d]=i[d];return e||function(t,e){var n=e||0,r=o;return[r[t[n++]],r[t[n++]],r[t[n++]],r[t[n++]],"-",r[t[n++]],r[t[n++]],"-",r[t[n++]],r[t[n++]],"-",r[t[n++]],r[t[n++]],"-",r[t[n++]],r[t[n++]],r[t[n++]],r[t[n++]],r[t[n++]],r[t[n++]]].join("")}(i)}}));
./node_modules/xcode/node_modules/uuid/dist/esm-browser/rng.js:6:var getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);
./node_modules/xcode/node_modules/uuid/dist/esm-browser/rng.js:11:    throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
./node_modules/xcode/node_modules/uuid/dist/rng-browser.js:12:var getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);
./node_modules/xcode/node_modules/uuid/dist/rng-browser.js:17:    throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
./node_modules/xcode/node_modules/uuid/README.md:341:[`crypto.getRandomValues()`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues)
./node_modules/@types/node/crypto.d.ts:3909:     * A convenient alias for {@link webcrypto.getRandomValues}. This
./node_modules/@types/node/crypto.d.ts:3911:     * web-compatible code use {@link webcrypto.getRandomValues} instead.
./node_modules/@orbitdb/core/dist/orbitdb.min.js:2:var OrbitDB;(()=>{var t={464:(t,e,r)=>{"use strict";const{fromCallback:n}=r(957),i=r(473),{getCallback:o,getOptions:s}=r(520),a=Symbol("promise"),c=Symbol("status"),u=Symbol("operations"),h=Symbol("finishClose"),l=Symbol("closeCallbacks");e.AbstractChainedBatch=class{constructor(t){if("object"!=typeof t||null===t)throw new TypeError("The first argument must be an abstract-level database, received "+(null===t?"null":typeof t));this[u]=[],this[l]=[],this[c]="open",this[h]=this[h].bind(this),this.db=t,this.db.attachResource(this),this.nextTick=t.nextTick}get length(){return this[u].length}put(t,e,r){if("open"!==this[c])throw new i("Batch is not open: cannot call put() after write() or close()",{code:"LEVEL_BATCH_NOT_OPEN"});const n=this.db._checkKey(t)||this.db._checkValue(e);if(n)throw n;const o=r&&null!=r.sublevel?r.sublevel:this.db,s=r,a=o.keyEncoding(r&&r.keyEncoding),h=o.valueEncoding(r&&r.valueEncoding),l=a.format;r={...r,keyEncoding:l,valueEncoding:h.format},o!==this.db&&(r.sublevel=null);const f=o.prefixKey(a.encode(t),l),d=h.encode(e);return this._put(f,d,r),this[u].push({...s,type:"put",key:t,value:e}),this}_put(t,e,r){}del(t,e){if("open"!==this[c])throw new i("Batch is not open: cannot call del() after write() or close()",{code:"LEVEL_BATCH_NOT_OPEN"});const r=this.db._checkKey(t);if(r)throw r;const n=e&&null!=e.sublevel?e.sublevel:this.db,o=e,s=n.keyEncoding(e&&e.keyEncoding),a=s.format;return e={...e,keyEncoding:a},n!==this.db&&(e.sublevel=null),this._del(n.prefixKey(s.encode(t),a),e),this[u].push({...o,type:"del",key:t}),this}_del(t,e){}clear(){if("open"!==this[c])throw new i("Batch is not open: cannot call clear() after write() or close()",{code:"LEVEL_BATCH_NOT_OPEN"});return this._clear(),this[u]=[],this}_clear(){}write(t,e){return e=o(t,e),e=n(e,a),t=s(t),"open"!==this[c]?this.nextTick(e,new i("Batch is not open: cannot call write() after write() or close()",{code:"LEVEL_BATCH_NOT_OPEN"})):0===this.length?this.close(e):(this[c]="writing",this._write(t,(t=>{this[c]="closing",this[l].push((()=>e(t))),t||this.db.emit("batch",this[u]),this._close(this[h])}))),e[a]}_write(t,e){}close(t){return t=n(t,a),"closing"===this[c]?this[l].push(t):"closed"===this[c]?this.nextTick(t):(this[l].push(t),"writing"!==this[c]&&(this[c]="closing",this._close(this[h]))),t[a]}_close(t){this.nextTick(t)}[h](){this[c]="closed",this.db.detachResource(this);const t=this[l];this[l]=[];for(const e of t)e()}}},961:(t,e,r)=>{"use strict";const{fromCallback:n}=r(957),i=r(473),{getOptions:o,getCallback:s}=r(520),a=Symbol("promise"),c=Symbol("callback"),u=Symbol("working"),h=Symbol("handleOne"),l=Symbol("handleMany"),f=Symbol("autoClose"),d=Symbol("finishWork"),y=Symbol("returnMany"),p=Symbol("closing"),g=Symbol("handleClose"),w=Symbol("closed"),b=Symbol("closeCallbacks"),m=Symbol("keyEncoding"),v=Symbol("valueEncoding"),E=Symbol("abortOnClose"),x=Symbol("legacy"),B=Symbol("keys"),A=Symbol("values"),k=Symbol("limit"),S=Symbol("count"),I=Object.freeze({}),T=()=>{};let C=!1;class U{constructor(t,e,r){if("object"!=typeof t||null===t)throw new TypeError("The first argument must be an abstract-level database, received "+(null===t?"null":typeof t));if("object"!=typeof e||null===e)throw new TypeError("The second argument must be an options object");this[w]=!1,this[b]=[],this[u]=!1,this[p]=!1,this[f]=!1,this[c]=null,this[h]=this[h].bind(this),this[l]=this[l].bind(this),this[g]=this[g].bind(this),this[m]=e[m],this[v]=e[v],this[x]=r,this[k]=Number.isInteger(e.limit)&&e.limit>=0?e.limit:1/0,this[S]=0,this[E]=!!e.abortOnClose,this.db=t,this.db.attachResource(this),this.nextTick=t.nextTick}get count(){return this[S]}get limit(){return this[k]}next(t){let e;if(void 0===t)e=new Promise(((e,r)=>{t=(t,n,i)=>{t?r(t):this[x]?void 0===n&&void 0===i?e():e([n,i]):e(n)}}));else if("function"!=typeof t)throw new TypeError("Callback must be a function");return this[p]?this.nextTick(t,new i("Iterator is not open: cannot call next() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"})):this[u]?this.nextTick(t,new i("Iterator is busy: cannot call next() until previous call has completed",{code:"LEVEL_ITERATOR_BUSY"})):(this[u]=!0,this[c]=t,this[S]>=this[k]?this.nextTick(this[h],null):this._next(this[h])),e}_next(t){this.nextTick(t)}nextv(t,e,r){return r=s(e,r),r=n(r,a),e=o(e,I),Number.isInteger(t)?(this[p]?this.nextTick(r,new i("Iterator is not open: cannot call nextv() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"})):this[u]?this.nextTick(r,new i("Iterator is busy: cannot call nextv() until previous call has completed",{code:"LEVEL_ITERATOR_BUSY"})):(t<1&&(t=1),this[k]<1/0&&(t=Math.min(t,this[k]-this[S])),this[u]=!0,this[c]=r,t<=0?this.nextTick(this[l],null,[]):this._nextv(t,e,this[l])),r[a]):(this.nextTick(r,new TypeError("The first argument 'size' must be an integer")),r[a])}_nextv(t,e,r){const n=[],i=(e,o,s)=>e?r(e):(this[x]?void 0===o&&void 0===s:void 0===o)?r(null,n):(n.push(this[x]?[o,s]:o),void(n.length===t?r(null,n):this._next(i)));this._next(i)}all(t,e){return e=s(t,e),e=n(e,a),t=o(t,I),this[p]?this.nextTick(e,new i("Iterator is not open: cannot call all() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"})):this[u]?this.nextTick(e,new i("Iterator is busy: cannot call all() until previous call has completed",{code:"LEVEL_ITERATOR_BUSY"})):(this[u]=!0,this[c]=e,this[f]=!0,this[S]>=this[k]?this.nextTick(this[l],null,[]):this._all(t,this[l])),e[a]}_all(t,e){let r=this[S];const n=[],i=()=>{const t=this[k]<1/0?Math.min(1e3,this[k]-r):1e3;t<=0?this.nextTick(e,null,n):this._nextv(t,I,o)},o=(t,o)=>{t?e(t):0===o.length?e(null,n):(n.push.apply(n,o),r+=o.length,i())};i()}[d](){const t=this[c];return this[E]&&null===t?T:(this[u]=!1,this[c]=null,this[p]&&this._close(this[g]),t)}[y](t,e,r){this[f]?this.close(t.bind(null,e,r)):t(e,r)}seek(t,e){if(e=o(e,I),this[p]);else{if(this[u])throw new i("Iterator is busy: cannot call seek() until next() has completed",{code:"LEVEL_ITERATOR_BUSY"});{const r=this.db.keyEncoding(e.keyEncoding||this[m]),n=r.format;e.keyEncoding!==n&&(e={...e,keyEncoding:n});const i=this.db.prefixKey(r.encode(t),n);this._seek(i,e)}}}_seek(t,e){throw new i("Iterator does not support seek()",{code:"LEVEL_NOT_SUPPORTED"})}close(t){return t=n(t,a),this[w]?this.nextTick(t):this[p]?this[b].push(t):(this[p]=!0,this[b].push(t),this[u]?this[E]&&this[d]()(new i("Aborted on iterator close()",{code:"LEVEL_ITERATOR_NOT_OPEN"})):this._close(this[g])),t[a]}_close(t){this.nextTick(t)}[g](){this[w]=!0,this.db.detachResource(this);const t=this[b];this[b]=[];for(const e of t)e()}async*[Symbol.asyncIterator](){try{let t;for(;void 0!==(t=await this.next());)yield t}finally{this[w]||await this.close()}}}class L extends U{constructor(t,e){super(t,e,!0),this[B]=!1!==e.keys,this[A]=!1!==e.values}[h](t,e,r){const n=this[d]();if(t)return n(t);try{e=this[B]&&void 0!==e?this[m].decode(e):void 0,r=this[A]&&void 0!==r?this[v].decode(r):void 0}catch(t){return n(new N("entry",t))}void 0===e&&void 0===r||this[S]++,n(null,e,r)}[l](t,e){const r=this[d]();if(t)return this[y](r,t);try{for(const t of e){const e=t[0],r=t[1];t[0]=this[B]&&void 0!==e?this[m].decode(e):void 0,t[1]=this[A]&&void 0!==r?this[v].decode(r):void 0}}catch(t){return this[y](r,new N("entries",t))}this[S]+=e.length,this[y](r,null,e)}end(t){return C||"undefined"==typeof console||(C=!0,console.warn(new i("The iterator.end() method was renamed to close() and end() is an alias that will be removed in a future version",{code:"LEVEL_LEGACY"}))),this.close(t)}}class N extends i{constructor(t,e){super(`Iterator could not decode ${t}`,{code:"LEVEL_DECODE_ERROR",cause:e})}}for(const t of["_ended property","_nexting property","_end method"])Object.defineProperty(L.prototype,t.split(" ")[0],{get(){throw new i(`The ${t} has been removed`,{code:"LEVEL_LEGACY"})},set(){throw new i(`The ${t} has been removed`,{code:"LEVEL_LEGACY"})}});L.keyEncoding=m,L.valueEncoding=v,e.AbstractIterator=L,e.AbstractKeyIterator=class extends U{constructor(t,e){super(t,e,!1)}[h](t,e){const r=this[d]();if(t)return r(t);try{e=void 0!==e?this[m].decode(e):void 0}catch(t){return r(new N("key",t))}void 0!==e&&this[S]++,r(null,e)}[l](t,e){const r=this[d]();if(t)return this[y](r,t);try{for(let t=0;t<e.length;t++){const r=e[t];e[t]=void 0!==r?this[m].decode(r):void 0}}catch(t){return this[y](r,new N("keys",t))}this[S]+=e.length,this[y](r,null,e)}},e.AbstractValueIterator=class extends U{constructor(t,e){super(t,e,!1)}[h](t,e){const r=this[d]();if(t)return r(t);try{e=void 0!==e?this[v].decode(e):void 0}catch(t){return r(new N("value",t))}void 0!==e&&this[S]++,r(null,e)}[l](t,e){const r=this[d]();if(t)return this[y](r,t);try{for(let t=0;t<e.length;t++){const r=e[t];e[t]=void 0!==r?this[v].decode(r):void 0}}catch(t){return this[y](r,new N("values",t))}this[S]+=e.length,this[y](r,null,e)}}},71:(t,e,r)=>{"use strict";const{supports:n}=r(675),{Transcoder:i}=r(499),{EventEmitter:o}=r(187),{fromCallback:s}=r(957),a=r(473),{AbstractIterator:c}=r(961),{DefaultKeyIterator:u,DefaultValueIterator:h}=r(429),{DeferredIterator:l,DeferredKeyIterator:f,DeferredValueIterator:d}=r(593),{DefaultChainedBatch:y}=r(765),{getCallback:p,getOptions:g}=r(520),w=r(56),b=Symbol("promise"),m=Symbol("landed"),v=Symbol("resources"),E=Symbol("closeResources"),x=Symbol("operations"),B=Symbol("undefer"),A=Symbol("deferOpen"),k=Symbol("options"),S=Symbol("status"),I=Symbol("defaultOptions"),T=Symbol("transcoder"),C=Symbol("keyEncoding"),U=Symbol("valueEncoding"),L=()=>{};class N extends o{constructor(t,e){if(super(),"object"!=typeof t||null===t)throw new TypeError("The first argument 'manifest' must be an object");e=g(e);const{keyEncoding:r,valueEncoding:o,passive:s,...a}=e;this[v]=new Set,this[x]=[],this[A]=!0,this[k]=a,this[S]="opening",this.supports=n(t,{status:!0,promises:!0,clear:!0,getMany:!0,deferredOpen:!0,snapshots:!1!==t.snapshots,permanence:!1!==t.permanence,keyIterator:!0,valueIterator:!0,iteratorNextv:!0,iteratorAll:!0,encodings:t.encodings||{},events:Object.assign({},t.events,{opening:!0,open:!0,closing:!0,closed:!0,put:!0,del:!0,batch:!0,clear:!0})}),this[T]=new i(R(this)),this[C]=this[T].encoding(r||"utf8"),this[U]=this[T].encoding(o||"utf8");for(const t of this[T].encodings())this.supports.encodings[t.commonName]||(this.supports.encodings[t.commonName]=!0);this[I]={empty:Object.freeze({}),entry:Object.freeze({keyEncoding:this[C].commonName,valueEncoding:this[U].commonName}),key:Object.freeze({keyEncoding:this[C].commonName})},this.nextTick((()=>{this[A]&&this.open({passive:!1},L)}))}get status(){return this[S]}keyEncoding(t){return this[T].encoding(null!=t?t:this[C])}valueEncoding(t){return this[T].encoding(null!=t?t:this[U])}open(t,e){e=p(t,e),e=s(e,b),(t={...this[k],...g(t)}).createIfMissing=!1!==t.createIfMissing,t.errorIfExists=!!t.errorIfExists;const r=t=>{"closing"===this[S]||"opening"===this[S]?this.once(m,t?()=>r(t):r):"open"!==this[S]?e(new a("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN",cause:t})):e()};return t.passive?"opening"===this[S]?this.once(m,r):this.nextTick(r):"closed"===this[S]||this[A]?(this[A]=!1,this[S]="opening",this.emit("opening"),this._open(t,(t=>{if(t)return this[S]="closed",this[E]((()=>{this.emit(m),r(t)})),void this[B]();this[S]="open",this[B](),this.emit(m),"open"===this[S]&&this.emit("open"),"open"===this[S]&&this.emit("ready"),r()}))):"open"===this[S]?this.nextTick(r):this.once(m,(()=>this.open(t,e))),e[b]}_open(t,e){this.nextTick(e)}close(t){t=s(t,b);const e=r=>{"opening"===this[S]||"closing"===this[S]?this.once(m,r?e(r):e):"closed"!==this[S]?t(new a("Database is not closed",{code:"LEVEL_DATABASE_NOT_CLOSED",cause:r})):t()};if("open"===this[S]){this[S]="closing",this.emit("closing");const t=t=>{this[S]="open",this[B](),this.emit(m),e(t)};this[E]((()=>{this._close((r=>{if(r)return t(r);this[S]="closed",this[B](),this.emit(m),"closed"===this[S]&&this.emit("closed"),e()}))}))}else"closed"===this[S]?this.nextTick(e):this.once(m,(()=>this.close(t)));return t[b]}[E](t){if(0===this[v].size)return this.nextTick(t);let e=this[v].size,r=!0;const n=()=>{0==--e&&(r?this.nextTick(t):t())};for(const t of this[v])t.close(n);r=!1,this[v].clear()}_close(t){this.nextTick(t)}get(t,e,r){if(r=p(e,r),r=s(r,b),e=g(e,this[I].entry),"opening"===this[S])return this.defer((()=>this.get(t,e,r))),r[b];if(_(this,r))return r[b];const n=this._checkKey(t);if(n)return this.nextTick(r,n),r[b];const i=this.keyEncoding(e.keyEncoding),o=this.valueEncoding(e.valueEncoding),c=i.format,u=o.format;return e.keyEncoding===c&&e.valueEncoding===u||(e=Object.assign({},e,{keyEncoding:c,valueEncoding:u})),this._get(this.prefixKey(i.encode(t),c),e,((t,e)=>{if(t)return("LEVEL_NOT_FOUND"===t.code||t.notFound||/NotFound/i.test(t))&&(t.code||(t.code="LEVEL_NOT_FOUND"),t.notFound||(t.notFound=!0),t.status||(t.status=404)),r(t);try{e=o.decode(e)}catch(t){return r(new a("Could not decode value",{code:"LEVEL_DECODE_ERROR",cause:t}))}r(null,e)})),r[b]}_get(t,e,r){this.nextTick(r,new Error("NotFound"))}getMany(t,e,r){if(r=p(e,r),r=s(r,b),e=g(e,this[I].entry),"opening"===this[S])return this.defer((()=>this.getMany(t,e,r))),r[b];if(_(this,r))return r[b];if(!Array.isArray(t))return this.nextTick(r,new TypeError("The first argument 'keys' must be an array")),r[b];if(0===t.length)return this.nextTick(r,null,[]),r[b];const n=this.keyEncoding(e.keyEncoding),i=this.valueEncoding(e.valueEncoding),o=n.format,c=i.format;e.keyEncoding===o&&e.valueEncoding===c||(e=Object.assign({},e,{keyEncoding:o,valueEncoding:c}));const u=new Array(t.length);for(let e=0;e<t.length;e++){const i=t[e],s=this._checkKey(i);if(s)return this.nextTick(r,s),r[b];u[e]=this.prefixKey(n.encode(i),o)}return this._getMany(u,e,((t,e)=>{if(t)return r(t);try{for(let t=0;t<e.length;t++)void 0!==e[t]&&(e[t]=i.decode(e[t]))}catch(t){return r(new a(`Could not decode one or more of ${e.length} value(s)`,{code:"LEVEL_DECODE_ERROR",cause:t}))}r(null,e)})),r[b]}_getMany(t,e,r){this.nextTick(r,null,new Array(t.length).fill(void 0))}put(t,e,r,n){if(n=p(r,n),n=s(n,b),r=g(r,this[I].entry),"opening"===this[S])return this.defer((()=>this.put(t,e,r,n))),n[b];if(_(this,n))return n[b];const i=this._checkKey(t)||this._checkValue(e);if(i)return this.nextTick(n,i),n[b];const o=this.keyEncoding(r.keyEncoding),a=this.valueEncoding(r.valueEncoding),c=o.format,u=a.format;r.keyEncoding===c&&r.valueEncoding===u||(r=Object.assign({},r,{keyEncoding:c,valueEncoding:u}));const h=this.prefixKey(o.encode(t),c),l=a.encode(e);return this._put(h,l,r,(r=>{if(r)return n(r);this.emit("put",t,e),n()})),n[b]}_put(t,e,r,n){this.nextTick(n)}del(t,e,r){if(r=p(e,r),r=s(r,b),e=g(e,this[I].key),"opening"===this[S])return this.defer((()=>this.del(t,e,r))),r[b];if(_(this,r))return r[b];const n=this._checkKey(t);if(n)return this.nextTick(r,n),r[b];const i=this.keyEncoding(e.keyEncoding),o=i.format;return e.keyEncoding!==o&&(e=Object.assign({},e,{keyEncoding:o})),this._del(this.prefixKey(i.encode(t),o),e,(e=>{if(e)return r(e);this.emit("del",t),r()})),r[b]}_del(t,e,r){this.nextTick(r)}batch(t,e,r){if(!arguments.length){if("opening"===this[S])return new y(this);if("open"!==this[S])throw new a("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN"});return this._chainedBatch()}if(r="function"==typeof t?t:p(e,r),r=s(r,b),e=g(e,this[I].empty),"opening"===this[S])return this.defer((()=>this.batch(t,e,r))),r[b];if(_(this,r))return r[b];if(!Array.isArray(t))return this.nextTick(r,new TypeError("The first argument 'operations' must be an array")),r[b];if(0===t.length)return this.nextTick(r),r[b];const n=new Array(t.length),{keyEncoding:i,valueEncoding:o,...c}=e;for(let e=0;e<t.length;e++){if("object"!=typeof t[e]||null===t[e])return this.nextTick(r,new TypeError("A batch operation must be an object")),r[b];const s=Object.assign({},t[e]);if("put"!==s.type&&"del"!==s.type)return this.nextTick(r,new TypeError("A batch operation must have a type property that is 'put' or 'del'")),r[b];const a=this._checkKey(s.key);if(a)return this.nextTick(r,a),r[b];const c=null!=s.sublevel?s.sublevel:this,u=c.keyEncoding(s.keyEncoding||i),h=u.format;if(s.key=c.prefixKey(u.encode(s.key),h),s.keyEncoding=h,"put"===s.type){const t=this._checkValue(s.value);if(t)return this.nextTick(r,t),r[b];const e=c.valueEncoding(s.valueEncoding||o);s.value=e.encode(s.value),s.valueEncoding=e.format}c!==this&&(s.sublevel=null),n[e]=s}return this._batch(n,c,(e=>{if(e)return r(e);this.emit("batch",t),r()})),r[b]}_batch(t,e,r){this.nextTick(r)}sublevel(t,e){return this._sublevel(t,O.defaults(e))}_sublevel(t,e){return new O(this,t,e)}prefixKey(t,e){return t}clear(t,e){if(e=p(t,e),e=s(e,b),t=g(t,this[I].empty),"opening"===this[S])return this.defer((()=>this.clear(t,e))),e[b];if(_(this,e))return e[b];const r=t,n=this.keyEncoding(t.keyEncoding);return(t=w(t,n)).keyEncoding=n.format,0===t.limit?this.nextTick(e):this._clear(t,(t=>{if(t)return e(t);this.emit("clear",r),e()})),e[b]}_clear(t,e){this.nextTick(e)}iterator(t){const e=this.keyEncoding(t&&t.keyEncoding),r=this.valueEncoding(t&&t.valueEncoding);if((t=w(t,e)).keys=!1!==t.keys,t.values=!1!==t.values,t[c.keyEncoding]=e,t[c.valueEncoding]=r,t.keyEncoding=e.format,t.valueEncoding=r.format,"opening"===this[S])return new l(this,t);if("open"!==this[S])throw new a("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN"});return this._iterator(t)}_iterator(t){return new c(this,t)}keys(t){const e=this.keyEncoding(t&&t.keyEncoding),r=this.valueEncoding(t&&t.valueEncoding);if((t=w(t,e))[c.keyEncoding]=e,t[c.valueEncoding]=r,t.keyEncoding=e.format,t.valueEncoding=r.format,"opening"===this[S])return new f(this,t);if("open"!==this[S])throw new a("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN"});return this._keys(t)}_keys(t){return new u(this,t)}values(t){const e=this.keyEncoding(t&&t.keyEncoding),r=this.valueEncoding(t&&t.valueEncoding);if((t=w(t,e))[c.keyEncoding]=e,t[c.valueEncoding]=r,t.keyEncoding=e.format,t.valueEncoding=r.format,"opening"===this[S])return new d(this,t);if("open"!==this[S])throw new a("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN"});return this._values(t)}_values(t){return new h(this,t)}defer(t){if("function"!=typeof t)throw new TypeError("The first argument must be a function");this[x].push(t)}[B](){if(0===this[x].length)return;const t=this[x];this[x]=[];for(const e of t)e()}attachResource(t){if("object"!=typeof t||null===t||"function"!=typeof t.close)throw new TypeError("The first argument must be a resource object");this[v].add(t)}detachResource(t){this[v].delete(t)}_chainedBatch(){return new y(this)}_checkKey(t){if(null==t)return new a("Key cannot be null or undefined",{code:"LEVEL_INVALID_KEY"})}_checkValue(t){if(null==t)return new a("Value cannot be null or undefined",{code:"LEVEL_INVALID_VALUE"})}}N.prototype.nextTick=r(909);const{AbstractSublevel:O}=r(650)({AbstractLevel:N});e.AbstractLevel=N,e.AbstractSublevel=O;const _=function(t,e){return"open"!==t[S]&&(t.nextTick(e,new a("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN"})),!0)},R=function(t){return Object.keys(t.supports.encodings).filter((e=>!!t.supports.encodings[e]))}},875:(t,e,r)=>{"use strict";e.AbstractLevel=r(71).AbstractLevel,e.AbstractSublevel=r(71).AbstractSublevel,e.AbstractIterator=r(961).AbstractIterator,e.AbstractKeyIterator=r(961).AbstractKeyIterator,e.AbstractValueIterator=r(961).AbstractValueIterator,e.AbstractChainedBatch=r(464).AbstractChainedBatch},970:(t,e,r)=>{"use strict";const{AbstractIterator:n,AbstractKeyIterator:i,AbstractValueIterator:o}=r(961),s=Symbol("unfix"),a=Symbol("iterator"),c=Symbol("handleOne"),u=Symbol("handleMany"),h=Symbol("callback");class l extends n{constructor(t,e,r,n){super(t,e),this[a]=r,this[s]=n,this[c]=this[c].bind(this),this[u]=this[u].bind(this),this[h]=null}[c](t,e,r){const n=this[h];if(t)return n(t);void 0!==e&&(e=this[s](e)),n(t,e,r)}[u](t,e){const r=this[h];if(t)return r(t);for(const t of e){const e=t[0];void 0!==e&&(t[0]=this[s](e))}r(t,e)}}class f extends i{constructor(t,e,r,n){super(t,e),this[a]=r,this[s]=n,this[c]=this[c].bind(this),this[u]=this[u].bind(this),this[h]=null}[c](t,e){const r=this[h];if(t)return r(t);void 0!==e&&(e=this[s](e)),r(t,e)}[u](t,e){const r=this[h];if(t)return r(t);for(let t=0;t<e.length;t++){const r=e[t];void 0!==r&&(e[t]=this[s](r))}r(t,e)}}class d extends o{constructor(t,e,r){super(t,e),this[a]=r}}for(const t of[l,f])t.prototype._next=function(t){this[h]=t,this[a].next(this[c])},t.prototype._nextv=function(t,e,r){this[h]=r,this[a].nextv(t,e,this[u])},t.prototype._all=function(t,e){this[h]=e,this[a].all(t,this[u])};for(const t of[d])t.prototype._next=function(t){this[a].next(t)},t.prototype._nextv=function(t,e,r){this[a].nextv(t,e,r)},t.prototype._all=function(t,e){this[a].all(t,e)};for(const t of[l,f,d])t.prototype._seek=function(t,e){this[a].seek(t,e)},t.prototype._close=function(t){this[a].close(t)};e.AbstractSublevelIterator=l,e.AbstractSublevelKeyIterator=f,e.AbstractSublevelValueIterator=d},650:(t,e,r)=>{"use strict";const n=r(473),{Buffer:i}=r(764)||{},{AbstractSublevelIterator:o,AbstractSublevelKeyIterator:s,AbstractSublevelValueIterator:a}=r(970),c=Symbol("prefix"),u=Symbol("upperBound"),h=Symbol("prefixRange"),l=Symbol("parent"),f=Symbol("unfix"),d=new TextEncoder,y={separator:"!"};t.exports=function({AbstractLevel:t}){class e extends t{static defaults(t){if("string"==typeof t)throw new n("The subleveldown string shorthand for { separator } has been removed",{code:"LEVEL_LEGACY"});if(t&&t.open)throw new n("The subleveldown open option has been removed",{code:"LEVEL_LEGACY"});return null==t?y:t.separator?t:{...t,separator:"!"}}constructor(t,r,i){const{separator:o,manifest:s,...a}=e.defaults(i);r=m(r,o);const h=o.charCodeAt(0)+1,y=t[l]||t;if(!d.encode(r).every((t=>t>h&&t<127)))throw new n(`Prefix must use bytes > ${h} < 127`,{code:"LEVEL_INVALID_PREFIX"});super(p(y,s),a);const g=(t.prefix||"")+o+r+o,v=g.slice(0,-1)+String.fromCharCode(h);this[l]=y,this[c]=new w(g),this[u]=new w(v),this[f]=new b,this.nextTick=y.nextTick}prefixKey(t,e){if("utf8"===e)return this[c].utf8+t;if(0===t.byteLength)return this[c][e];if("view"===e){const e=this[c].view,r=new Uint8Array(e.byteLength+t.byteLength);return r.set(e,0),r.set(t,e.byteLength),r}{const e=this[c].buffer;return i.concat([e,t],e.byteLength+t.byteLength)}}[h](t,e){void 0!==t.gte?t.gte=this.prefixKey(t.gte,e):void 0!==t.gt?t.gt=this.prefixKey(t.gt,e):t.gte=this[c][e],void 0!==t.lte?t.lte=this.prefixKey(t.lte,e):void 0!==t.lt?t.lt=this.prefixKey(t.lt,e):t.lte=this[u][e]}get prefix(){return this[c].utf8}get db(){return this[l]}_open(t,e){this[l].open({passive:!0},e)}_put(t,e,r,n){this[l].put(t,e,r,n)}_get(t,e,r){this[l].get(t,e,r)}_getMany(t,e,r){this[l].getMany(t,e,r)}_del(t,e,r){this[l].del(t,e,r)}_batch(t,e,r){this[l].batch(t,e,r)}_clear(t,e){this[h](t,t.keyEncoding),this[l].clear(t,e)}_iterator(t){this[h](t,t.keyEncoding);const e=this[l].iterator(t),r=this[f].get(this[c].utf8.length,t.keyEncoding);return new o(this,t,e,r)}_keys(t){this[h](t,t.keyEncoding);const e=this[l].keys(t),r=this[f].get(this[c].utf8.length,t.keyEncoding);return new s(this,t,e,r)}_values(t){this[h](t,t.keyEncoding);const e=this[l].values(t);return new a(this,t,e)}}return{AbstractSublevel:e}};const p=function(t,e){return{...t.supports,createIfMissing:!1,errorIfExists:!1,events:{},additionalMethods:{},...e,encodings:{utf8:g(t,"utf8"),buffer:g(t,"buffer"),view:g(t,"view")}}},g=function(t,e){return!!t.supports.encodings[e]&&t.keyEncoding(e).name===e};class w{constructor(t){this.utf8=t,this.view=d.encode(t),this.buffer=i?i.from(this.view.buffer,0,this.view.byteLength):{}}}class b{constructor(){this.cache=new Map}get(t,e){let r=this.cache.get(e);return void 0===r&&(r="view"===e?function(t,e){return e.subarray(t)}.bind(null,t):function(t,e){return e.slice(t)}.bind(null,t),this.cache.set(e,r)),r}}const m=function(t,e){let r=0,n=t.length;for(;r<n&&t[r]===e;)r++;for(;n>r&&t[n-1]===e;)n--;return t.slice(r,n)}},520:(t,e)=>{"use strict";e.getCallback=function(t,e){return"function"==typeof t?t:e},e.getOptions=function(t,e){return"object"==typeof t&&null!==t?t:void 0!==e?e:{}}},765:(t,e,r)=>{"use strict";const{AbstractChainedBatch:n}=r(464),i=r(473),o=Symbol("encoded");e.DefaultChainedBatch=class extends n{constructor(t){super(t),this[o]=[]}_put(t,e,r){this[o].push({...r,type:"put",key:t,value:e})}_del(t,e){this[o].push({...e,type:"del",key:t})}_clear(){this[o]=[]}_write(t,e){"opening"===this.db.status?this.db.defer((()=>this._write(t,e))):"open"===this.db.status?0===this[o].length?this.nextTick(e):this.db._batch(this[o],t,e):this.nextTick(e,new i("Batch is not open: cannot call write() after write() or close()",{code:"LEVEL_BATCH_NOT_OPEN"}))}}},429:(t,e,r)=>{"use strict";const{AbstractKeyIterator:n,AbstractValueIterator:i}=r(961),o=Symbol("iterator"),s=Symbol("callback"),a=Symbol("handleOne"),c=Symbol("handleMany");class u extends n{constructor(t,e){super(t,e),this[o]=t.iterator({...e,keys:!0,values:!1}),this[a]=this[a].bind(this),this[c]=this[c].bind(this)}}class h extends i{constructor(t,e){super(t,e),this[o]=t.iterator({...e,keys:!1,values:!0}),this[a]=this[a].bind(this),this[c]=this[c].bind(this)}}for(const t of[u,h]){const e=t===u,r=e?t=>t[0]:t=>t[1];t.prototype._next=function(t){this[s]=t,this[o].next(this[a])},t.prototype[a]=function(t,r,n){const i=this[s];t?i(t):i(null,e?r:n)},t.prototype._nextv=function(t,e,r){this[s]=r,this[o].nextv(t,e,this[c])},t.prototype._all=function(t,e){this[s]=e,this[o].all(t,this[c])},t.prototype[c]=function(t,e){const n=this[s];t?n(t):n(null,e.map(r))},t.prototype._seek=function(t,e){this[o].seek(t,e)},t.prototype._close=function(t){this[o].close(t)}}e.DefaultKeyIterator=u,e.DefaultValueIterator=h},593:(t,e,r)=>{"use strict";const{AbstractIterator:n,AbstractKeyIterator:i,AbstractValueIterator:o}=r(961),s=r(473),a=Symbol("nut"),c=Symbol("undefer"),u=Symbol("factory");class h extends n{constructor(t,e){super(t,e),this[a]=null,this[u]=()=>t.iterator(e),this.db.defer((()=>this[c]()))}}class l extends i{constructor(t,e){super(t,e),this[a]=null,this[u]=()=>t.keys(e),this.db.defer((()=>this[c]()))}}class f extends o{constructor(t,e){super(t,e),this[a]=null,this[u]=()=>t.values(e),this.db.defer((()=>this[c]()))}}for(const t of[h,l,f])t.prototype[c]=function(){"open"===this.db.status&&(this[a]=this[u]())},t.prototype._next=function(t){null!==this[a]?this[a].next(t):"opening"===this.db.status?this.db.defer((()=>this._next(t))):this.nextTick(t,new s("Iterator is not open: cannot call next() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"}))},t.prototype._nextv=function(t,e,r){null!==this[a]?this[a].nextv(t,e,r):"opening"===this.db.status?this.db.defer((()=>this._nextv(t,e,r))):this.nextTick(r,new s("Iterator is not open: cannot call nextv() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"}))},t.prototype._all=function(t,e){null!==this[a]?this[a].all(e):"opening"===this.db.status?this.db.defer((()=>this._all(t,e))):this.nextTick(e,new s("Iterator is not open: cannot call all() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"}))},t.prototype._seek=function(t,e){null!==this[a]?this[a]._seek(t,e):"opening"===this.db.status&&this.db.defer((()=>this._seek(t,e)))},t.prototype._close=function(t){null!==this[a]?this[a].close(t):"opening"===this.db.status?this.db.defer((()=>this._close(t))):this.nextTick(t)};e.DeferredIterator=h,e.DeferredKeyIterator=l,e.DeferredValueIterator=f},909:(t,e,r)=>{"use strict";const n=r(375);t.exports=function(t,...e){0===e.length?n(t):n((()=>t(...e)))}},56:(t,e,r)=>{"use strict";const n=r(473),i=Object.prototype.hasOwnProperty,o=new Set(["lt","lte","gt","gte"]);t.exports=function(t,e){const r={};for(const s in t)if(i.call(t,s)&&"keyEncoding"!==s&&"valueEncoding"!==s){if("start"===s||"end"===s)throw new n(`The legacy range option '${s}' has been removed`,{code:"LEVEL_LEGACY"});if("encoding"===s)throw new n("The levelup-style 'encoding' alias has been removed, use 'valueEncoding' instead",{code:"LEVEL_LEGACY"});o.has(s)?r[s]=e.encode(t[s]):r[s]=t[s]}return r.reverse=!!r.reverse,r.limit=Number.isInteger(r.limit)&&r.limit>=0?r.limit:-1,r}},742:(t,e)=>{"use strict";e.byteLength=function(t){var e=a(t),r=e[0],n=e[1];return 3*(r+n)/4-n},e.toByteArray=function(t){var e,r,o=a(t),s=o[0],c=o[1],u=new i(function(t,e,r){return 3*(e+r)/4-r}(0,s,c)),h=0,l=c>0?s-4:s;for(r=0;r<l;r+=4)e=n[t.charCodeAt(r)]<<18|n[t.charCodeAt(r+1)]<<12|n[t.charCodeAt(r+2)]<<6|n[t.charCodeAt(r+3)],u[h++]=e>>16&255,u[h++]=e>>8&255,u[h++]=255&e;return 2===c&&(e=n[t.charCodeAt(r)]<<2|n[t.charCodeAt(r+1)]>>4,u[h++]=255&e),1===c&&(e=n[t.charCodeAt(r)]<<10|n[t.charCodeAt(r+1)]<<4|n[t.charCodeAt(r+2)]>>2,u[h++]=e>>8&255,u[h++]=255&e),u},e.fromByteArray=function(t){for(var e,n=t.length,i=n%3,o=[],s=16383,a=0,u=n-i;a<u;a+=s)o.push(c(t,a,a+s>u?u:a+s));return 1===i?(e=t[n-1],o.push(r[e>>2]+r[e<<4&63]+"==")):2===i&&(e=(t[n-2]<<8)+t[n-1],o.push(r[e>>10]+r[e>>4&63]+r[e<<2&63]+"=")),o.join("")};for(var r=[],n=[],i="undefined"!=typeof Uint8Array?Uint8Array:Array,o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",s=0;s<64;++s)r[s]=o[s],n[o.charCodeAt(s)]=s;function a(t){var e=t.length;if(e%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=t.indexOf("=");return-1===r&&(r=e),[r,r===e?0:4-r%4]}function c(t,e,n){for(var i,o,s=[],a=e;a<n;a+=3)i=(t[a]<<16&16711680)+(t[a+1]<<8&65280)+(255&t[a+2]),s.push(r[(o=i)>>18&63]+r[o>>12&63]+r[o>>6&63]+r[63&o]);return s.join("")}n["-".charCodeAt(0)]=62,n["_".charCodeAt(0)]=63},708:(t,e,r)=>{"use strict";const{AbstractLevel:n}=r(875),i=r(473),o=r(967),{fromCallback:s}=r(957),{Iterator:a}=r(212),c=r(687),u=r(968),h=r(217),l="level-js-",f=Symbol("idb"),d=Symbol("namePrefix"),y=Symbol("location"),p=Symbol("version"),g=Symbol("store"),w=Symbol("onComplete"),b=Symbol("promise");class m extends n{constructor(t,e,r){if("function"==typeof e||"function"==typeof r)throw new i("The levelup-style callback argument has been removed",{code:"LEVEL_LEGACY"});const{prefix:n,version:o,...s}=e||{};if(super({encodings:{view:!0},snapshots:!1,createIfMissing:!1,errorIfExists:!1,seek:!0},s),"string"!=typeof t)throw new Error("constructor requires a location string argument");this[y]=t,this[d]=null==n?l:n,this[p]=parseInt(o||1,10),this[f]=null}get location(){return this[y]}get namePrefix(){return this[d]}get version(){return this[p]}get db(){return this[f]}get type(){return"browser-level"}_open(t,e){const r=indexedDB.open(this[d]+this[y],this[p]);r.onerror=function(){e(r.error||new Error("unknown error"))},r.onsuccess=()=>{this[f]=r.result,e()},r.onupgradeneeded=t=>{const e=t.target.result;e.objectStoreNames.contains(this[y])||e.createObjectStore(this[y])}}[g](t){return this[f].transaction([this[y]],t).objectStore(this[y])}[w](t,e){const r=t.transaction;r.onabort=function(){e(r.error||new Error("aborted by user"))},r.oncomplete=function(){e(null,t.result)}}_get(t,e,r){const n=this[g]("readonly");let o;try{o=n.get(t)}catch(t){return this.nextTick(r,t)}this[w](o,(function(t,e){return t?r(t):void 0===e?r(new i("Entry not found",{code:"LEVEL_NOT_FOUND"})):void r(null,c(e))}))}_getMany(t,e,r){const n=this[g]("readonly"),i=t.map((t=>e=>{let r;try{r=n.get(t)}catch(t){return e(t)}r.onsuccess=()=>{const t=r.result;e(null,void 0===t?t:c(t))},r.onerror=t=>{t.stopPropagation(),e(r.error)}}));o(i,16,r)}_del(t,e,r){const n=this[g]("readwrite");let i;try{i=n.delete(t)}catch(t){return this.nextTick(r,t)}this[w](i,r)}_put(t,e,r,n){const i=this[g]("readwrite");let o;try{o=i.put(e,t)}catch(t){return this.nextTick(n,t)}this[w](o,n)}_iterator(t){return new a(this,this[y],t)}_batch(t,e,r){const n=this[g]("readwrite"),i=n.transaction;let o,s=0;i.onabort=function(){r(o||i.error||new Error("aborted by user"))},i.oncomplete=function(){r()},function e(){const r=t[s++],a=r.key;let c;try{c="del"===r.type?n.delete(a):n.put(r.value,a)}catch(t){return o=t,void i.abort()}s<t.length?c.onsuccess=e:"function"==typeof i.commit&&i.commit()}()}_clear(t,e){let r,n;try{r=h(t)}catch(t){return this.nextTick(e)}if(t.limit>=0)return u(this,this[y],r,t,e);try{const t=this[g]("readwrite");n=r?t.delete(r):t.clear()}catch(t){return this.nextTick(e,t)}this[w](n,e)}_close(t){this[f].close(),this.nextTick(t)}}m.destroy=function(t,e,r){"function"==typeof e&&(r=e,e=l),r=s(r,b);const n=indexedDB.deleteDatabase(e+t);return n.onsuccess=function(){r()},n.onerror=function(t){r(t)},r[b]},e.BrowserLevel=m},212:(t,e,r)=>{"use strict";const{AbstractIterator:n}=r(875),i=r(217),o=r(687),s=Symbol("cache"),a=Symbol("finished"),c=Symbol("options"),u=Symbol("currentOptions"),h=Symbol("position"),l=Symbol("location"),f=Symbol("first"),d={};function y(t){"function"==typeof t.commit&&t.commit()}e.Iterator=class extends n{constructor(t,e,r){super(t,r),this[s]=[],this[a]=0===this.limit,this[c]=r,this[u]={...r},this[h]=void 0,this[l]=e,this[f]=!0}_nextv(t,e,r){if(this[f]=!1,this[a])return this.nextTick(r,null,[]);if(this[s].length>0)return t=Math.min(t,this[s].length),this.nextTick(r,null,this[s].splice(0,t));let n;void 0!==this[h]&&(this[c].reverse?(this[u].lt=this[h],this[u].lte=void 0):(this[u].gt=this[h],this[u].gte=void 0));try{n=i(this[u])}catch(t){return this[a]=!0,this.nextTick(r,null,[])}const d=this.db.db.transaction([this[l]],"readonly"),p=d.objectStore(this[l]),g=[];if(this[c].reverse)p[!this[c].values&&p.openKeyCursor?"openKeyCursor":"openCursor"](n,"prev").onsuccess=e=>{const r=e.target.result;if(r){const{key:e,value:n}=r;this[h]=e,g.push([this[c].keys&&void 0!==e?o(e):void 0,this[c].values&&void 0!==n?o(n):void 0]),g.length<t?r.continue():y(d)}else this[a]=!0};else{let e,r;const i=()=>{if(void 0===e||void 0===r)return;const n=Math.max(e.length,r.length);0===n||t===1/0?this[a]=!0:this[h]=e[n-1],g.length=n;for(let t=0;t<n;t++){const n=e[t],i=r[t];g[t]=[this[c].keys&&void 0!==n?o(n):void 0,this[c].values&&void 0!==i?o(i):void 0]}y(d)};this[c].keys||t<1/0?p.getAllKeys(n,t<1/0?t:void 0).onsuccess=t=>{e=t.target.result,i()}:(e=[],this.nextTick(i)),this[c].values?p.getAll(n,t<1/0?t:void 0).onsuccess=t=>{r=t.target.result,i()}:(r=[],this.nextTick(i))}d.onabort=()=>{r(d.error||new Error("aborted by user")),r=null},d.oncomplete=()=>{r(null,g),r=null}}_next(t){if(this[s].length>0){const[e,r]=this[s].shift();this.nextTick(t,null,e,r)}else if(this[a])this.nextTick(t);else{let e=Math.min(100,this.limit-this.count);this[f]&&(this[f]=!1,e=1),this._nextv(e,d,((e,r)=>{if(e)return t(e);this[s]=r,this._next(t)}))}}_all(t,e){this[f]=!1;const r=this[s].splice(0,this[s].length),n=this.limit-this.count-r.length;if(n<=0)return this.nextTick(e,null,r);this._nextv(n,d,((t,n)=>{if(t)return e(t);r.length>0&&(n=r.concat(n)),e(null,n)}))}_seek(t,e){let r;this[f]=!0,this[s]=[],this[a]=!1,this[h]=void 0,this[u]={...this[c]};try{r=i(this[c])}catch(t){return void(this[a]=!0)}null===r||r.includes(t)?this[c].reverse?this[u].lte=t:this[u].gte=t:this[a]=!0}}},968:t=>{"use strict";t.exports=function(t,e,r,n,i){if(0===n.limit)return t.nextTick(i);const o=t.db.transaction([e],"readwrite"),s=o.objectStore(e);let a=0;o.oncomplete=function(){i()},o.onabort=function(){i(o.error||new Error("aborted by user"))};const c=s.openKeyCursor?"openKeyCursor":"openCursor",u=n.reverse?"prev":"next";s[c](r,u).onsuccess=function(t){const e=t.target.result;e&&(s.delete(e.key).onsuccess=function(){(n.limit<=0||++a<n.limit)&&e.continue()})}}},687:t=>{"use strict";const e=new TextEncoder;t.exports=function(t){return t instanceof Uint8Array?t:t instanceof ArrayBuffer?new Uint8Array(t):e.encode(t)}},217:t=>{"use strict";t.exports=function(t){const e=void 0!==t.gte?t.gte:void 0!==t.gt?t.gt:void 0,r=void 0!==t.lte?t.lte:void 0!==t.lt?t.lt:void 0,n=void 0===t.gte,i=void 0===t.lte;return void 0!==e&&void 0!==r?IDBKeyRange.bound(e,r,n,i):void 0!==e?IDBKeyRange.lowerBound(e,n):void 0!==r?IDBKeyRange.upperBound(r,i):null}},764:(t,e,r)=>{"use strict";const n=r(742),i=r(645),o="function"==typeof Symbol&&"function"==typeof Symbol.for?Symbol.for("nodejs.util.inspect.custom"):null;e.Buffer=c,e.SlowBuffer=function(t){return+t!=t&&(t=0),c.alloc(+t)},e.INSPECT_MAX_BYTES=50;const s=2147483647;function a(t){if(t>s)throw new RangeError('The value "'+t+'" is invalid for option "size"');const e=new Uint8Array(t);return Object.setPrototypeOf(e,c.prototype),e}function c(t,e,r){if("number"==typeof t){if("string"==typeof e)throw new TypeError('The "string" argument must be of type string. Received type number');return l(t)}return u(t,e,r)}function u(t,e,r){if("string"==typeof t)return function(t,e){if("string"==typeof e&&""!==e||(e="utf8"),!c.isEncoding(e))throw new TypeError("Unknown encoding: "+e);const r=0|p(t,e);let n=a(r);const i=n.write(t,e);return i!==r&&(n=n.slice(0,i)),n}(t,e);if(ArrayBuffer.isView(t))return function(t){if(W(t,Uint8Array)){const e=new Uint8Array(t);return d(e.buffer,e.byteOffset,e.byteLength)}return f(t)}(t);if(null==t)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof t);if(W(t,ArrayBuffer)||t&&W(t.buffer,ArrayBuffer))return d(t,e,r);if("undefined"!=typeof SharedArrayBuffer&&(W(t,SharedArrayBuffer)||t&&W(t.buffer,SharedArrayBuffer)))return d(t,e,r);if("number"==typeof t)throw new TypeError('The "value" argument must not be of type number. Received type number');const n=t.valueOf&&t.valueOf();if(null!=n&&n!==t)return c.from(n,e,r);const i=function(t){if(c.isBuffer(t)){const e=0|y(t.length),r=a(e);return 0===r.length||t.copy(r,0,0,e),r}return void 0!==t.length?"number"!=typeof t.length||Z(t.length)?a(0):f(t):"Buffer"===t.type&&Array.isArray(t.data)?f(t.data):void 0}(t);if(i)return i;if("undefined"!=typeof Symbol&&null!=Symbol.toPrimitive&&"function"==typeof t[Symbol.toPrimitive])return c.from(t[Symbol.toPrimitive]("string"),e,r);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof t)}function h(t){if("number"!=typeof t)throw new TypeError('"size" argument must be of type number');if(t<0)throw new RangeError('The value "'+t+'" is invalid for option "size"')}function l(t){return h(t),a(t<0?0:0|y(t))}function f(t){const e=t.length<0?0:0|y(t.length),r=a(e);for(let n=0;n<e;n+=1)r[n]=255&t[n];return r}function d(t,e,r){if(e<0||t.byteLength<e)throw new RangeError('"offset" is outside of buffer bounds');if(t.byteLength<e+(r||0))throw new RangeError('"length" is outside of buffer bounds');let n;return n=void 0===e&&void 0===r?new Uint8Array(t):void 0===r?new Uint8Array(t,e):new Uint8Array(t,e,r),Object.setPrototypeOf(n,c.prototype),n}function y(t){if(t>=s)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+s.toString(16)+" bytes");return 0|t}function p(t,e){if(c.isBuffer(t))return t.length;if(ArrayBuffer.isView(t)||W(t,ArrayBuffer))return t.byteLength;if("string"!=typeof t)throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof t);const r=t.length,n=arguments.length>2&&!0===arguments[2];if(!n&&0===r)return 0;let i=!1;for(;;)switch(e){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":return K(t).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return G(t).length;default:if(i)return n?-1:K(t).length;e=(""+e).toLowerCase(),i=!0}}function g(t,e,r){let n=!1;if((void 0===e||e<0)&&(e=0),e>this.length)return"";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return"";if((r>>>=0)<=(e>>>=0))return"";for(t||(t="utf8");;)switch(t){case"hex":return U(this,e,r);case"utf8":case"utf-8":return S(this,e,r);case"ascii":return T(this,e,r);case"latin1":case"binary":return C(this,e,r);case"base64":return k(this,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return L(this,e,r);default:if(n)throw new TypeError("Unknown encoding: "+t);t=(t+"").toLowerCase(),n=!0}}function w(t,e,r){const n=t[e];t[e]=t[r],t[r]=n}function b(t,e,r,n,i){if(0===t.length)return-1;if("string"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),Z(r=+r)&&(r=i?0:t.length-1),r<0&&(r=t.length+r),r>=t.length){if(i)return-1;r=t.length-1}else if(r<0){if(!i)return-1;r=0}if("string"==typeof e&&(e=c.from(e,n)),c.isBuffer(e))return 0===e.length?-1:m(t,e,r,n,i);if("number"==typeof e)return e&=255,"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(t,e,r):Uint8Array.prototype.lastIndexOf.call(t,e,r):m(t,[e],r,n,i);throw new TypeError("val must be string, number or Buffer")}function m(t,e,r,n,i){let o,s=1,a=t.length,c=e.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(t.length<2||e.length<2)return-1;s=2,a/=2,c/=2,r/=2}function u(t,e){return 1===s?t[e]:t.readUInt16BE(e*s)}if(i){let n=-1;for(o=r;o<a;o++)if(u(t,o)===u(e,-1===n?0:o-n)){if(-1===n&&(n=o),o-n+1===c)return n*s}else-1!==n&&(o-=o-n),n=-1}else for(r+c>a&&(r=a-c),o=r;o>=0;o--){let r=!0;for(let n=0;n<c;n++)if(u(t,o+n)!==u(e,n)){r=!1;break}if(r)return o}return-1}function v(t,e,r,n){r=Number(r)||0;const i=t.length-r;n?(n=Number(n))>i&&(n=i):n=i;const o=e.length;let s;for(n>o/2&&(n=o/2),s=0;s<n;++s){const n=parseInt(e.substr(2*s,2),16);if(Z(n))return s;t[r+s]=n}return s}function E(t,e,r,n){return J(K(e,t.length-r),t,r,n)}function x(t,e,r,n){return J(function(t){const e=[];for(let r=0;r<t.length;++r)e.push(255&t.charCodeAt(r));return e}(e),t,r,n)}function B(t,e,r,n){return J(G(e),t,r,n)}function A(t,e,r,n){return J(function(t,e){let r,n,i;const o=[];for(let s=0;s<t.length&&!((e-=2)<0);++s)r=t.charCodeAt(s),n=r>>8,i=r%256,o.push(i),o.push(n);return o}(e,t.length-r),t,r,n)}function k(t,e,r){return 0===e&&r===t.length?n.fromByteArray(t):n.fromByteArray(t.slice(e,r))}function S(t,e,r){r=Math.min(t.length,r);const n=[];let i=e;for(;i<r;){const e=t[i];let o=null,s=e>239?4:e>223?3:e>191?2:1;if(i+s<=r){let r,n,a,c;switch(s){case 1:e<128&&(o=e);break;case 2:r=t[i+1],128==(192&r)&&(c=(31&e)<<6|63&r,c>127&&(o=c));break;case 3:r=t[i+1],n=t[i+2],128==(192&r)&&128==(192&n)&&(c=(15&e)<<12|(63&r)<<6|63&n,c>2047&&(c<55296||c>57343)&&(o=c));break;case 4:r=t[i+1],n=t[i+2],a=t[i+3],128==(192&r)&&128==(192&n)&&128==(192&a)&&(c=(15&e)<<18|(63&r)<<12|(63&n)<<6|63&a,c>65535&&c<1114112&&(o=c))}}null===o?(o=65533,s=1):o>65535&&(o-=65536,n.push(o>>>10&1023|55296),o=56320|1023&o),n.push(o),i+=s}return function(t){const e=t.length;if(e<=I)return String.fromCharCode.apply(String,t);let r="",n=0;for(;n<e;)r+=String.fromCharCode.apply(String,t.slice(n,n+=I));return r}(n)}e.kMaxLength=s,c.TYPED_ARRAY_SUPPORT=function(){try{const t=new Uint8Array(1),e={foo:function(){return 42}};return Object.setPrototypeOf(e,Uint8Array.prototype),Object.setPrototypeOf(t,e),42===t.foo()}catch(t){return!1}}(),c.TYPED_ARRAY_SUPPORT||"undefined"==typeof console||"function"!=typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(c.prototype,"parent",{enumerable:!0,get:function(){if(c.isBuffer(this))return this.buffer}}),Object.defineProperty(c.prototype,"offset",{enumerable:!0,get:function(){if(c.isBuffer(this))return this.byteOffset}}),c.poolSize=8192,c.from=function(t,e,r){return u(t,e,r)},Object.setPrototypeOf(c.prototype,Uint8Array.prototype),Object.setPrototypeOf(c,Uint8Array),c.alloc=function(t,e,r){return function(t,e,r){return h(t),t<=0?a(t):void 0!==e?"string"==typeof r?a(t).fill(e,r):a(t).fill(e):a(t)}(t,e,r)},c.allocUnsafe=function(t){return l(t)},c.allocUnsafeSlow=function(t){return l(t)},c.isBuffer=function(t){return null!=t&&!0===t._isBuffer&&t!==c.prototype},c.compare=function(t,e){if(W(t,Uint8Array)&&(t=c.from(t,t.offset,t.byteLength)),W(e,Uint8Array)&&(e=c.from(e,e.offset,e.byteLength)),!c.isBuffer(t)||!c.isBuffer(e))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(t===e)return 0;let r=t.length,n=e.length;for(let i=0,o=Math.min(r,n);i<o;++i)if(t[i]!==e[i]){r=t[i],n=e[i];break}return r<n?-1:n<r?1:0},c.isEncoding=function(t){switch(String(t).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},c.concat=function(t,e){if(!Array.isArray(t))throw new TypeError('"list" argument must be an Array of Buffers');if(0===t.length)return c.alloc(0);let r;if(void 0===e)for(e=0,r=0;r<t.length;++r)e+=t[r].length;const n=c.allocUnsafe(e);let i=0;for(r=0;r<t.length;++r){let e=t[r];if(W(e,Uint8Array))i+e.length>n.length?(c.isBuffer(e)||(e=c.from(e)),e.copy(n,i)):Uint8Array.prototype.set.call(n,e,i);else{if(!c.isBuffer(e))throw new TypeError('"list" argument must be an Array of Buffers');e.copy(n,i)}i+=e.length}return n},c.byteLength=p,c.prototype._isBuffer=!0,c.prototype.swap16=function(){const t=this.length;if(t%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let e=0;e<t;e+=2)w(this,e,e+1);return this},c.prototype.swap32=function(){const t=this.length;if(t%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let e=0;e<t;e+=4)w(this,e,e+3),w(this,e+1,e+2);return this},c.prototype.swap64=function(){const t=this.length;if(t%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let e=0;e<t;e+=8)w(this,e,e+7),w(this,e+1,e+6),w(this,e+2,e+5),w(this,e+3,e+4);return this},c.prototype.toString=function(){const t=this.length;return 0===t?"":0===arguments.length?S(this,0,t):g.apply(this,arguments)},c.prototype.toLocaleString=c.prototype.toString,c.prototype.equals=function(t){if(!c.isBuffer(t))throw new TypeError("Argument must be a Buffer");return this===t||0===c.compare(this,t)},c.prototype.inspect=function(){let t="";const r=e.INSPECT_MAX_BYTES;return t=this.toString("hex",0,r).replace(/(.{2})/g,"$1 ").trim(),this.length>r&&(t+=" ... "),"<Buffer "+t+">"},o&&(c.prototype[o]=c.prototype.inspect),c.prototype.compare=function(t,e,r,n,i){if(W(t,Uint8Array)&&(t=c.from(t,t.offset,t.byteLength)),!c.isBuffer(t))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof t);if(void 0===e&&(e=0),void 0===r&&(r=t?t.length:0),void 0===n&&(n=0),void 0===i&&(i=this.length),e<0||r>t.length||n<0||i>this.length)throw new RangeError("out of range index");if(n>=i&&e>=r)return 0;if(n>=i)return-1;if(e>=r)return 1;if(this===t)return 0;let o=(i>>>=0)-(n>>>=0),s=(r>>>=0)-(e>>>=0);const a=Math.min(o,s),u=this.slice(n,i),h=t.slice(e,r);for(let t=0;t<a;++t)if(u[t]!==h[t]){o=u[t],s=h[t];break}return o<s?-1:s<o?1:0},c.prototype.includes=function(t,e,r){return-1!==this.indexOf(t,e,r)},c.prototype.indexOf=function(t,e,r){return b(this,t,e,r,!0)},c.prototype.lastIndexOf=function(t,e,r){return b(this,t,e,r,!1)},c.prototype.write=function(t,e,r,n){if(void 0===e)n="utf8",r=this.length,e=0;else if(void 0===r&&"string"==typeof e)n=e,r=this.length,e=0;else{if(!isFinite(e))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");e>>>=0,isFinite(r)?(r>>>=0,void 0===n&&(n="utf8")):(n=r,r=void 0)}const i=this.length-e;if((void 0===r||r>i)&&(r=i),t.length>0&&(r<0||e<0)||e>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");let o=!1;for(;;)switch(n){case"hex":return v(this,t,e,r);case"utf8":case"utf-8":return E(this,t,e,r);case"ascii":case"latin1":case"binary":return x(this,t,e,r);case"base64":return B(this,t,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return A(this,t,e,r);default:if(o)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),o=!0}},c.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};const I=4096;function T(t,e,r){let n="";r=Math.min(t.length,r);for(let i=e;i<r;++i)n+=String.fromCharCode(127&t[i]);return n}function C(t,e,r){let n="";r=Math.min(t.length,r);for(let i=e;i<r;++i)n+=String.fromCharCode(t[i]);return n}function U(t,e,r){const n=t.length;(!e||e<0)&&(e=0),(!r||r<0||r>n)&&(r=n);let i="";for(let n=e;n<r;++n)i+=Y[t[n]];return i}function L(t,e,r){const n=t.slice(e,r);let i="";for(let t=0;t<n.length-1;t+=2)i+=String.fromCharCode(n[t]+256*n[t+1]);return i}function N(t,e,r){if(t%1!=0||t<0)throw new RangeError("offset is not uint");if(t+e>r)throw new RangeError("Trying to access beyond buffer length")}function O(t,e,r,n,i,o){if(!c.isBuffer(t))throw new TypeError('"buffer" argument must be a Buffer instance');if(e>i||e<o)throw new RangeError('"value" argument is out of bounds');if(r+n>t.length)throw new RangeError("Index out of range")}function _(t,e,r,n,i){F(e,n,i,t,r,7);let o=Number(e&BigInt(4294967295));t[r++]=o,o>>=8,t[r++]=o,o>>=8,t[r++]=o,o>>=8,t[r++]=o;let s=Number(e>>BigInt(32)&BigInt(4294967295));return t[r++]=s,s>>=8,t[r++]=s,s>>=8,t[r++]=s,s>>=8,t[r++]=s,r}function R(t,e,r,n,i){F(e,n,i,t,r,7);let o=Number(e&BigInt(4294967295));t[r+7]=o,o>>=8,t[r+6]=o,o>>=8,t[r+5]=o,o>>=8,t[r+4]=o;let s=Number(e>>BigInt(32)&BigInt(4294967295));return t[r+3]=s,s>>=8,t[r+2]=s,s>>=8,t[r+1]=s,s>>=8,t[r]=s,r+8}function D(t,e,r,n,i,o){if(r+n>t.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function V(t,e,r,n,o){return e=+e,r>>>=0,o||D(t,0,r,4),i.write(t,e,r,n,23,4),r+4}function M(t,e,r,n,o){return e=+e,r>>>=0,o||D(t,0,r,8),i.write(t,e,r,n,52,8),r+8}c.prototype.slice=function(t,e){const r=this.length;(t=~~t)<0?(t+=r)<0&&(t=0):t>r&&(t=r),(e=void 0===e?r:~~e)<0?(e+=r)<0&&(e=0):e>r&&(e=r),e<t&&(e=t);const n=this.subarray(t,e);return Object.setPrototypeOf(n,c.prototype),n},c.prototype.readUintLE=c.prototype.readUIntLE=function(t,e,r){t>>>=0,e>>>=0,r||N(t,e,this.length);let n=this[t],i=1,o=0;for(;++o<e&&(i*=256);)n+=this[t+o]*i;return n},c.prototype.readUintBE=c.prototype.readUIntBE=function(t,e,r){t>>>=0,e>>>=0,r||N(t,e,this.length);let n=this[t+--e],i=1;for(;e>0&&(i*=256);)n+=this[t+--e]*i;return n},c.prototype.readUint8=c.prototype.readUInt8=function(t,e){return t>>>=0,e||N(t,1,this.length),this[t]},c.prototype.readUint16LE=c.prototype.readUInt16LE=function(t,e){return t>>>=0,e||N(t,2,this.length),this[t]|this[t+1]<<8},c.prototype.readUint16BE=c.prototype.readUInt16BE=function(t,e){return t>>>=0,e||N(t,2,this.length),this[t]<<8|this[t+1]},c.prototype.readUint32LE=c.prototype.readUInt32LE=function(t,e){return t>>>=0,e||N(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},c.prototype.readUint32BE=c.prototype.readUInt32BE=function(t,e){return t>>>=0,e||N(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},c.prototype.readBigUInt64LE=Q((function(t){j(t>>>=0,"offset");const e=this[t],r=this[t+7];void 0!==e&&void 0!==r||z(t,this.length-8);const n=e+256*this[++t]+65536*this[++t]+this[++t]*2**24,i=this[++t]+256*this[++t]+65536*this[++t]+r*2**24;return BigInt(n)+(BigInt(i)<<BigInt(32))})),c.prototype.readBigUInt64BE=Q((function(t){j(t>>>=0,"offset");const e=this[t],r=this[t+7];void 0!==e&&void 0!==r||z(t,this.length-8);const n=e*2**24+65536*this[++t]+256*this[++t]+this[++t],i=this[++t]*2**24+65536*this[++t]+256*this[++t]+r;return(BigInt(n)<<BigInt(32))+BigInt(i)})),c.prototype.readIntLE=function(t,e,r){t>>>=0,e>>>=0,r||N(t,e,this.length);let n=this[t],i=1,o=0;for(;++o<e&&(i*=256);)n+=this[t+o]*i;return i*=128,n>=i&&(n-=Math.pow(2,8*e)),n},c.prototype.readIntBE=function(t,e,r){t>>>=0,e>>>=0,r||N(t,e,this.length);let n=e,i=1,o=this[t+--n];for(;n>0&&(i*=256);)o+=this[t+--n]*i;return i*=128,o>=i&&(o-=Math.pow(2,8*e)),o},c.prototype.readInt8=function(t,e){return t>>>=0,e||N(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},c.prototype.readInt16LE=function(t,e){t>>>=0,e||N(t,2,this.length);const r=this[t]|this[t+1]<<8;return 32768&r?4294901760|r:r},c.prototype.readInt16BE=function(t,e){t>>>=0,e||N(t,2,this.length);const r=this[t+1]|this[t]<<8;return 32768&r?4294901760|r:r},c.prototype.readInt32LE=function(t,e){return t>>>=0,e||N(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},c.prototype.readInt32BE=function(t,e){return t>>>=0,e||N(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},c.prototype.readBigInt64LE=Q((function(t){j(t>>>=0,"offset");const e=this[t],r=this[t+7];void 0!==e&&void 0!==r||z(t,this.length-8);const n=this[t+4]+256*this[t+5]+65536*this[t+6]+(r<<24);return(BigInt(n)<<BigInt(32))+BigInt(e+256*this[++t]+65536*this[++t]+this[++t]*2**24)})),c.prototype.readBigInt64BE=Q((function(t){j(t>>>=0,"offset");const e=this[t],r=this[t+7];void 0!==e&&void 0!==r||z(t,this.length-8);const n=(e<<24)+65536*this[++t]+256*this[++t]+this[++t];return(BigInt(n)<<BigInt(32))+BigInt(this[++t]*2**24+65536*this[++t]+256*this[++t]+r)})),c.prototype.readFloatLE=function(t,e){return t>>>=0,e||N(t,4,this.length),i.read(this,t,!0,23,4)},c.prototype.readFloatBE=function(t,e){return t>>>=0,e||N(t,4,this.length),i.read(this,t,!1,23,4)},c.prototype.readDoubleLE=function(t,e){return t>>>=0,e||N(t,8,this.length),i.read(this,t,!0,52,8)},c.prototype.readDoubleBE=function(t,e){return t>>>=0,e||N(t,8,this.length),i.read(this,t,!1,52,8)},c.prototype.writeUintLE=c.prototype.writeUIntLE=function(t,e,r,n){t=+t,e>>>=0,r>>>=0,n||O(this,t,e,r,Math.pow(2,8*r)-1,0);let i=1,o=0;for(this[e]=255&t;++o<r&&(i*=256);)this[e+o]=t/i&255;return e+r},c.prototype.writeUintBE=c.prototype.writeUIntBE=function(t,e,r,n){t=+t,e>>>=0,r>>>=0,n||O(this,t,e,r,Math.pow(2,8*r)-1,0);let i=r-1,o=1;for(this[e+i]=255&t;--i>=0&&(o*=256);)this[e+i]=t/o&255;return e+r},c.prototype.writeUint8=c.prototype.writeUInt8=function(t,e,r){return t=+t,e>>>=0,r||O(this,t,e,1,255,0),this[e]=255&t,e+1},c.prototype.writeUint16LE=c.prototype.writeUInt16LE=function(t,e,r){return t=+t,e>>>=0,r||O(this,t,e,2,65535,0),this[e]=255&t,this[e+1]=t>>>8,e+2},c.prototype.writeUint16BE=c.prototype.writeUInt16BE=function(t,e,r){return t=+t,e>>>=0,r||O(this,t,e,2,65535,0),this[e]=t>>>8,this[e+1]=255&t,e+2},c.prototype.writeUint32LE=c.prototype.writeUInt32LE=function(t,e,r){return t=+t,e>>>=0,r||O(this,t,e,4,4294967295,0),this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=255&t,e+4},c.prototype.writeUint32BE=c.prototype.writeUInt32BE=function(t,e,r){return t=+t,e>>>=0,r||O(this,t,e,4,4294967295,0),this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t,e+4},c.prototype.writeBigUInt64LE=Q((function(t,e=0){return _(this,t,e,BigInt(0),BigInt("0xffffffffffffffff"))})),c.prototype.writeBigUInt64BE=Q((function(t,e=0){return R(this,t,e,BigInt(0),BigInt("0xffffffffffffffff"))})),c.prototype.writeIntLE=function(t,e,r,n){if(t=+t,e>>>=0,!n){const n=Math.pow(2,8*r-1);O(this,t,e,r,n-1,-n)}let i=0,o=1,s=0;for(this[e]=255&t;++i<r&&(o*=256);)t<0&&0===s&&0!==this[e+i-1]&&(s=1),this[e+i]=(t/o>>0)-s&255;return e+r},c.prototype.writeIntBE=function(t,e,r,n){if(t=+t,e>>>=0,!n){const n=Math.pow(2,8*r-1);O(this,t,e,r,n-1,-n)}let i=r-1,o=1,s=0;for(this[e+i]=255&t;--i>=0&&(o*=256);)t<0&&0===s&&0!==this[e+i+1]&&(s=1),this[e+i]=(t/o>>0)-s&255;return e+r},c.prototype.writeInt8=function(t,e,r){return t=+t,e>>>=0,r||O(this,t,e,1,127,-128),t<0&&(t=255+t+1),this[e]=255&t,e+1},c.prototype.writeInt16LE=function(t,e,r){return t=+t,e>>>=0,r||O(this,t,e,2,32767,-32768),this[e]=255&t,this[e+1]=t>>>8,e+2},c.prototype.writeInt16BE=function(t,e,r){return t=+t,e>>>=0,r||O(this,t,e,2,32767,-32768),this[e]=t>>>8,this[e+1]=255&t,e+2},c.prototype.writeInt32LE=function(t,e,r){return t=+t,e>>>=0,r||O(this,t,e,4,2147483647,-2147483648),this[e]=255&t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24,e+4},c.prototype.writeInt32BE=function(t,e,r){return t=+t,e>>>=0,r||O(this,t,e,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t,e+4},c.prototype.writeBigInt64LE=Q((function(t,e=0){return _(this,t,e,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),c.prototype.writeBigInt64BE=Q((function(t,e=0){return R(this,t,e,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),c.prototype.writeFloatLE=function(t,e,r){return V(this,t,e,!0,r)},c.prototype.writeFloatBE=function(t,e,r){return V(this,t,e,!1,r)},c.prototype.writeDoubleLE=function(t,e,r){return M(this,t,e,!0,r)},c.prototype.writeDoubleBE=function(t,e,r){return M(this,t,e,!1,r)},c.prototype.copy=function(t,e,r,n){if(!c.isBuffer(t))throw new TypeError("argument should be a Buffer");if(r||(r=0),n||0===n||(n=this.length),e>=t.length&&(e=t.length),e||(e=0),n>0&&n<r&&(n=r),n===r)return 0;if(0===t.length||0===this.length)return 0;if(e<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),t.length-e<n-r&&(n=t.length-e+r);const i=n-r;return this===t&&"function"==typeof Uint8Array.prototype.copyWithin?this.copyWithin(e,r,n):Uint8Array.prototype.set.call(t,this.subarray(r,n),e),i},c.prototype.fill=function(t,e,r,n){if("string"==typeof t){if("string"==typeof e?(n=e,e=0,r=this.length):"string"==typeof r&&(n=r,r=this.length),void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!c.isEncoding(n))throw new TypeError("Unknown encoding: "+n);if(1===t.length){const e=t.charCodeAt(0);("utf8"===n&&e<128||"latin1"===n)&&(t=e)}}else"number"==typeof t?t&=255:"boolean"==typeof t&&(t=Number(t));if(e<0||this.length<e||this.length<r)throw new RangeError("Out of range index");if(r<=e)return this;let i;if(e>>>=0,r=void 0===r?this.length:r>>>0,t||(t=0),"number"==typeof t)for(i=e;i<r;++i)this[i]=t;else{const o=c.isBuffer(t)?t:c.from(t,n),s=o.length;if(0===s)throw new TypeError('The value "'+t+'" is invalid for argument "value"');for(i=0;i<r-e;++i)this[i+e]=o[i%s]}return this};const P={};function H(t,e,r){P[t]=class extends r{constructor(){super(),Object.defineProperty(this,"message",{value:e.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${t}]`,this.stack,delete this.name}get code(){return t}set code(t){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:t,writable:!0})}toString(){return`${this.name} [${t}]: ${this.message}`}}}function $(t){let e="",r=t.length;const n="-"===t[0]?1:0;for(;r>=n+4;r-=3)e=`_${t.slice(r-3,r)}${e}`;return`${t.slice(0,r)}${e}`}function F(t,e,r,n,i,o){if(t>r||t<e){const n="bigint"==typeof e?"n":"";let i;throw i=o>3?0===e||e===BigInt(0)?`>= 0${n} and < 2${n} ** ${8*(o+1)}${n}`:`>= -(2${n} ** ${8*(o+1)-1}${n}) and < 2 ** ${8*(o+1)-1}${n}`:`>= ${e}${n} and <= ${r}${n}`,new P.ERR_OUT_OF_RANGE("value",i,t)}!function(t,e,r){j(e,"offset"),void 0!==t[e]&&void 0!==t[e+r]||z(e,t.length-(r+1))}(n,i,o)}function j(t,e){if("number"!=typeof t)throw new P.ERR_INVALID_ARG_TYPE(e,"number",t)}function z(t,e,r){if(Math.floor(t)!==t)throw j(t,r),new P.ERR_OUT_OF_RANGE(r||"offset","an integer",t);if(e<0)throw new P.ERR_BUFFER_OUT_OF_BOUNDS;throw new P.ERR_OUT_OF_RANGE(r||"offset",`>= ${r?1:0} and <= ${e}`,t)}H("ERR_BUFFER_OUT_OF_BOUNDS",(function(t){return t?`${t} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"}),RangeError),H("ERR_INVALID_ARG_TYPE",(function(t,e){return`The "${t}" argument must be of type number. Received type ${typeof e}`}),TypeError),H("ERR_OUT_OF_RANGE",(function(t,e,r){let n=`The value of "${t}" is out of range.`,i=r;return Number.isInteger(r)&&Math.abs(r)>2**32?i=$(String(r)):"bigint"==typeof r&&(i=String(r),(r>BigInt(2)**BigInt(32)||r<-(BigInt(2)**BigInt(32)))&&(i=$(i)),i+="n"),n+=` It must be ${e}. Received ${i}`,n}),RangeError);const q=/[^+/0-9A-Za-z-_]/g;function K(t,e){let r;e=e||1/0;const n=t.length;let i=null;const o=[];for(let s=0;s<n;++s){if(r=t.charCodeAt(s),r>55295&&r<57344){if(!i){if(r>56319){(e-=3)>-1&&o.push(239,191,189);continue}if(s+1===n){(e-=3)>-1&&o.push(239,191,189);continue}i=r;continue}if(r<56320){(e-=3)>-1&&o.push(239,191,189),i=r;continue}r=65536+(i-55296<<10|r-56320)}else i&&(e-=3)>-1&&o.push(239,191,189);if(i=null,r<128){if((e-=1)<0)break;o.push(r)}else if(r<2048){if((e-=2)<0)break;o.push(r>>6|192,63&r|128)}else if(r<65536){if((e-=3)<0)break;o.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((e-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return o}function G(t){return n.toByteArray(function(t){if((t=(t=t.split("=")[0]).trim().replace(q,"")).length<2)return"";for(;t.length%4!=0;)t+="=";return t}(t))}function J(t,e,r,n){let i;for(i=0;i<n&&!(i+r>=e.length||i>=t.length);++i)e[i+r]=t[i];return i}function W(t,e){return t instanceof e||null!=t&&null!=t.constructor&&null!=t.constructor.name&&t.constructor.name===e.name}function Z(t){return t!=t}const Y=function(){const t="0123456789abcdef",e=new Array(256);for(let r=0;r<16;++r){const n=16*r;for(let i=0;i<16;++i)e[n+i]=t[r]+t[i]}return e}();function Q(t){return"undefined"==typeof BigInt?X:t}function X(){throw new Error("BigInt not supported")}},957:(t,e,r)=>{"use strict";var n=r(886);e.fromCallback=function(t,e){if(void 0===t){var r=new Promise((function(e,r){t=function(t,n){t?r(t):e(n)}}));t[void 0!==e?e:"promise"]=r}else if("function"!=typeof t)throw new TypeError("Callback must be a function");return t},e.fromPromise=function(t,e){if(void 0===e)return t;t.then((function(t){n((()=>e(null,t)))})).catch((function(t){n((()=>e(t)))}))}},886:t=>{t.exports="function"==typeof queueMicrotask?queueMicrotask:t=>Promise.resolve().then(t)},729:t=>{"use strict";var e=Object.prototype.hasOwnProperty,r="~";function n(){}function i(t,e,r){this.fn=t,this.context=e,this.once=r||!1}function o(t,e,n,o,s){if("function"!=typeof n)throw new TypeError("The listener must be a function");var a=new i(n,o||t,s),c=r?r+e:e;return t._events[c]?t._events[c].fn?t._events[c]=[t._events[c],a]:t._events[c].push(a):(t._events[c]=a,t._eventsCount++),t}function s(t,e){0==--t._eventsCount?t._events=new n:delete t._events[e]}function a(){this._events=new n,this._eventsCount=0}Object.create&&(n.prototype=Object.create(null),(new n).__proto__||(r=!1)),a.prototype.eventNames=function(){var t,n,i=[];if(0===this._eventsCount)return i;for(n in t=this._events)e.call(t,n)&&i.push(r?n.slice(1):n);return Object.getOwnPropertySymbols?i.concat(Object.getOwnPropertySymbols(t)):i},a.prototype.listeners=function(t){var e=r?r+t:t,n=this._events[e];if(!n)return[];if(n.fn)return[n.fn];for(var i=0,o=n.length,s=new Array(o);i<o;i++)s[i]=n[i].fn;return s},a.prototype.listenerCount=function(t){var e=r?r+t:t,n=this._events[e];return n?n.fn?1:n.length:0},a.prototype.emit=function(t,e,n,i,o,s){var a=r?r+t:t;if(!this._events[a])return!1;var c,u,h=this._events[a],l=arguments.length;if(h.fn){switch(h.once&&this.removeListener(t,h.fn,void 0,!0),l){case 1:return h.fn.call(h.context),!0;case 2:return h.fn.call(h.context,e),!0;case 3:return h.fn.call(h.context,e,n),!0;case 4:return h.fn.call(h.context,e,n,i),!0;case 5:return h.fn.call(h.context,e,n,i,o),!0;case 6:return h.fn.call(h.context,e,n,i,o,s),!0}for(u=1,c=new Array(l-1);u<l;u++)c[u-1]=arguments[u];h.fn.apply(h.context,c)}else{var f,d=h.length;for(u=0;u<d;u++)switch(h[u].once&&this.removeListener(t,h[u].fn,void 0,!0),l){case 1:h[u].fn.call(h[u].context);break;case 2:h[u].fn.call(h[u].context,e);break;case 3:h[u].fn.call(h[u].context,e,n);break;case 4:h[u].fn.call(h[u].context,e,n,i);break;default:if(!c)for(f=1,c=new Array(l-1);f<l;f++)c[f-1]=arguments[f];h[u].fn.apply(h[u].context,c)}}return!0},a.prototype.on=function(t,e,r){return o(this,t,e,r,!1)},a.prototype.once=function(t,e,r){return o(this,t,e,r,!0)},a.prototype.removeListener=function(t,e,n,i){var o=r?r+t:t;if(!this._events[o])return this;if(!e)return s(this,o),this;var a=this._events[o];if(a.fn)a.fn!==e||i&&!a.once||n&&a.context!==n||s(this,o);else{for(var c=0,u=[],h=a.length;c<h;c++)(a[c].fn!==e||i&&!a[c].once||n&&a[c].context!==n)&&u.push(a[c]);u.length?this._events[o]=1===u.length?u[0]:u:s(this,o)}return this},a.prototype.removeAllListeners=function(t){var e;return t?(e=r?r+t:t,this._events[e]&&s(this,e)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=r,a.EventEmitter=a,t.exports=a},187:t=>{"use strict";var e,r="object"==typeof Reflect?Reflect:null,n=r&&"function"==typeof r.apply?r.apply:function(t,e,r){return Function.prototype.apply.call(t,e,r)};e=r&&"function"==typeof r.ownKeys?r.ownKeys:Object.getOwnPropertySymbols?function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:function(t){return Object.getOwnPropertyNames(t)};var i=Number.isNaN||function(t){return t!=t};function o(){o.init.call(this)}t.exports=o,t.exports.once=function(t,e){return new Promise((function(r,n){function i(r){t.removeListener(e,o),n(r)}function o(){"function"==typeof t.removeListener&&t.removeListener("error",i),r([].slice.call(arguments))}p(t,e,o,{once:!0}),"error"!==e&&function(t,e,r){"function"==typeof t.on&&p(t,"error",e,{once:!0})}(t,i)}))},o.EventEmitter=o,o.prototype._events=void 0,o.prototype._eventsCount=0,o.prototype._maxListeners=void 0;var s=10;function a(t){if("function"!=typeof t)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof t)}function c(t){return void 0===t._maxListeners?o.defaultMaxListeners:t._maxListeners}function u(t,e,r,n){var i,o,s,u;if(a(r),void 0===(o=t._events)?(o=t._events=Object.create(null),t._eventsCount=0):(void 0!==o.newListener&&(t.emit("newListener",e,r.listener?r.listener:r),o=t._events),s=o[e]),void 0===s)s=o[e]=r,++t._eventsCount;else if("function"==typeof s?s=o[e]=n?[r,s]:[s,r]:n?s.unshift(r):s.push(r),(i=c(t))>0&&s.length>i&&!s.warned){s.warned=!0;var h=new Error("Possible EventEmitter memory leak detected. "+s.length+" "+String(e)+" listeners added. Use emitter.setMaxListeners() to increase limit");h.name="MaxListenersExceededWarning",h.emitter=t,h.type=e,h.count=s.length,u=h,console&&console.warn&&console.warn(u)}return t}function h(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function l(t,e,r){var n={fired:!1,wrapFn:void 0,target:t,type:e,listener:r},i=h.bind(n);return i.listener=r,n.wrapFn=i,i}function f(t,e,r){var n=t._events;if(void 0===n)return[];var i=n[e];return void 0===i?[]:"function"==typeof i?r?[i.listener||i]:[i]:r?function(t){for(var e=new Array(t.length),r=0;r<e.length;++r)e[r]=t[r].listener||t[r];return e}(i):y(i,i.length)}function d(t){var e=this._events;if(void 0!==e){var r=e[t];if("function"==typeof r)return 1;if(void 0!==r)return r.length}return 0}function y(t,e){for(var r=new Array(e),n=0;n<e;++n)r[n]=t[n];return r}function p(t,e,r,n){if("function"==typeof t.on)n.once?t.once(e,r):t.on(e,r);else{if("function"!=typeof t.addEventListener)throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof t);t.addEventListener(e,(function i(o){n.once&&t.removeEventListener(e,i),r(o)}))}}Object.defineProperty(o,"defaultMaxListeners",{enumerable:!0,get:function(){return s},set:function(t){if("number"!=typeof t||t<0||i(t))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+t+".");s=t}}),o.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},o.prototype.setMaxListeners=function(t){if("number"!=typeof t||t<0||i(t))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+t+".");return this._maxListeners=t,this},o.prototype.getMaxListeners=function(){return c(this)},o.prototype.emit=function(t){for(var e=[],r=1;r<arguments.length;r++)e.push(arguments[r]);var i="error"===t,o=this._events;if(void 0!==o)i=i&&void 0===o.error;else if(!i)return!1;if(i){var s;if(e.length>0&&(s=e[0]),s instanceof Error)throw s;var a=new Error("Unhandled error."+(s?" ("+s.message+")":""));throw a.context=s,a}var c=o[t];if(void 0===c)return!1;if("function"==typeof c)n(c,this,e);else{var u=c.length,h=y(c,u);for(r=0;r<u;++r)n(h[r],this,e)}return!0},o.prototype.addListener=function(t,e){return u(this,t,e,!1)},o.prototype.on=o.prototype.addListener,o.prototype.prependListener=function(t,e){return u(this,t,e,!0)},o.prototype.once=function(t,e){return a(e),this.on(t,l(this,t,e)),this},o.prototype.prependOnceListener=function(t,e){return a(e),this.prependListener(t,l(this,t,e)),this},o.prototype.removeListener=function(t,e){var r,n,i,o,s;if(a(e),void 0===(n=this._events))return this;if(void 0===(r=n[t]))return this;if(r===e||r.listener===e)0==--this._eventsCount?this._events=Object.create(null):(delete n[t],n.removeListener&&this.emit("removeListener",t,r.listener||e));else if("function"!=typeof r){for(i=-1,o=r.length-1;o>=0;o--)if(r[o]===e||r[o].listener===e){s=r[o].listener,i=o;break}if(i<0)return this;0===i?r.shift():function(t,e){for(;e+1<t.length;e++)t[e]=t[e+1];t.pop()}(r,i),1===r.length&&(n[t]=r[0]),void 0!==n.removeListener&&this.emit("removeListener",t,s||e)}return this},o.prototype.off=o.prototype.removeListener,o.prototype.removeAllListeners=function(t){var e,r,n;if(void 0===(r=this._events))return this;if(void 0===r.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==r[t]&&(0==--this._eventsCount?this._events=Object.create(null):delete r[t]),this;if(0===arguments.length){var i,o=Object.keys(r);for(n=0;n<o.length;++n)"removeListener"!==(i=o[n])&&this.removeAllListeners(i);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(e=r[t]))this.removeListener(t,e);else if(void 0!==e)for(n=e.length-1;n>=0;n--)this.removeListener(t,e[n]);return this},o.prototype.listeners=function(t){return f(this,t,!0)},o.prototype.rawListeners=function(t){return f(this,t,!1)},o.listenerCount=function(t,e){return"function"==typeof t.listenerCount?t.listenerCount(e):d.call(t,e)},o.prototype.listenerCount=d,o.prototype.eventNames=function(){return this._eventsCount>0?e(this._events):[]}},645:(t,e)=>{e.read=function(t,e,r,n,i){var o,s,a=8*i-n-1,c=(1<<a)-1,u=c>>1,h=-7,l=r?i-1:0,f=r?-1:1,d=t[e+l];for(l+=f,o=d&(1<<-h)-1,d>>=-h,h+=a;h>0;o=256*o+t[e+l],l+=f,h-=8);for(s=o&(1<<-h)-1,o>>=-h,h+=n;h>0;s=256*s+t[e+l],l+=f,h-=8);if(0===o)o=1-u;else{if(o===c)return s?NaN:1/0*(d?-1:1);s+=Math.pow(2,n),o-=u}return(d?-1:1)*s*Math.pow(2,o-n)},e.write=function(t,e,r,n,i,o){var s,a,c,u=8*o-i-1,h=(1<<u)-1,l=h>>1,f=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,d=n?0:o-1,y=n?1:-1,p=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(a=isNaN(e)?1:0,s=h):(s=Math.floor(Math.log(e)/Math.LN2),e*(c=Math.pow(2,-s))<1&&(s--,c*=2),(e+=s+l>=1?f/c:f*Math.pow(2,1-l))*c>=2&&(s++,c/=2),s+l>=h?(a=0,s=h):s+l>=1?(a=(e*c-1)*Math.pow(2,i),s+=l):(a=e*Math.pow(2,l-1)*Math.pow(2,i),s=0));i>=8;t[r+d]=255&a,d+=y,a/=256,i-=8);for(s=s<<i|a,u+=i;u>0;t[r+d]=255&s,d+=y,s/=256,u-=8);t[r+d-y]|=128*p}},717:t=>{"function"==typeof Object.create?t.exports=function(t,e){e&&(t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}))}:t.exports=function(t,e){if(e){t.super_=e;var r=function(){};r.prototype=e.prototype,t.prototype=new r,t.prototype.constructor=t}}},675:(t,e)=>{"use strict";e.supports=function(...t){const e=t.reduce(((t,e)=>Object.assign(t,e)),{});return Object.assign(e,{snapshots:e.snapshots||!1,permanence:e.permanence||!1,seek:e.seek||!1,clear:e.clear||!1,getMany:e.getMany||!1,keyIterator:e.keyIterator||!1,valueIterator:e.valueIterator||!1,iteratorNextv:e.iteratorNextv||!1,iteratorAll:e.iteratorAll||!1,status:e.status||!1,createIfMissing:e.createIfMissing||!1,errorIfExists:e.errorIfExists||!1,deferredOpen:e.deferredOpen||!1,promises:e.promises||!1,streams:e.streams||!1,encodings:Object.assign({},e.encodings),events:Object.assign({},e.events),additionalMethods:Object.assign({},e.additionalMethods)})}},499:(t,e,r)=>{"use strict";const n=r(473),i=r(2),{Encoding:o}=r(266),{BufferFormat:s,ViewFormat:a,UTF8Format:c}=r(376),u=Symbol("formats"),h=Symbol("encodings"),l=new Set(["buffer","view","utf8"]);e.Transcoder=class{constructor(t){if(!Array.isArray(t))throw new TypeError("The first argument 'formats' must be an array");if(!t.every((t=>l.has(t))))throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");this[h]=new Map,this[u]=new Set(t);for(const t in i)try{this.encoding(t)}catch(t){if("LEVEL_ENCODING_NOT_SUPPORTED"!==t.code)throw t}}encodings(){return Array.from(new Set(this[h].values()))}encoding(t){let e=this[h].get(t);if(void 0===e){if("string"==typeof t&&""!==t){if(e=d[t],!e)throw new n(`Encoding '${t}' is not found`,{code:"LEVEL_ENCODING_NOT_FOUND"})}else{if("object"!=typeof t||null===t)throw new TypeError("First argument 'encoding' must be a string or object");e=function(t){if(t instanceof o)return t;const e="type"in t&&"string"==typeof t.type?t.type:void 0,r=t.name||e||"anonymous-"+y++;switch(function(t){return"format"in t&&void 0!==t.format?t.format:"buffer"in t&&"boolean"==typeof t.buffer?t.buffer?"buffer":"utf8":"code"in t&&Number.isInteger(t.code)?"view":"buffer"}(t)){case"view":return new a({...t,name:r});case"utf8":return new c({...t,name:r});case"buffer":return new s({...t,name:r});default:throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'")}}(t)}const{name:r,format:i}=e;if(!this[u].has(i))if(this[u].has("view"))e=e.createViewTranscoder();else if(this[u].has("buffer"))e=e.createBufferTranscoder();else{if(!this[u].has("utf8"))throw new n(`Encoding '${r}' cannot be transcoded`,{code:"LEVEL_ENCODING_NOT_SUPPORTED"});e=e.createUTF8Transcoder()}for(const n of[t,r,e.name,e.commonName])this[h].set(n,e)}return e}};const f={binary:i.buffer,"utf-8":i.utf8},d={...i,...f};let y=0},266:(t,e,r)=>{"use strict";const n=r(473),i=new Set(["buffer","view","utf8"]);e.Encoding=class{constructor(t){if(this.encode=t.encode||this.encode,this.decode=t.decode||this.decode,this.name=t.name||this.name,this.format=t.format||this.format,"function"!=typeof this.encode)throw new TypeError("The 'encode' property must be a function");if("function"!=typeof this.decode)throw new TypeError("The 'decode' property must be a function");if(this.encode=this.encode.bind(this),this.decode=this.decode.bind(this),"string"!=typeof this.name||""===this.name)throw new TypeError("The 'name' property must be a string");if("string"!=typeof this.format||!i.has(this.format))throw new TypeError("The 'format' property must be one of 'buffer', 'view', 'utf8'");t.createViewTranscoder&&(this.createViewTranscoder=t.createViewTranscoder),t.createBufferTranscoder&&(this.createBufferTranscoder=t.createBufferTranscoder),t.createUTF8Transcoder&&(this.createUTF8Transcoder=t.createUTF8Transcoder)}get commonName(){return this.name.split("+")[0]}createBufferTranscoder(){throw new n(`Encoding '${this.name}' cannot be transcoded to 'buffer'`,{code:"LEVEL_ENCODING_NOT_SUPPORTED"})}createViewTranscoder(){throw new n(`Encoding '${this.name}' cannot be transcoded to 'view'`,{code:"LEVEL_ENCODING_NOT_SUPPORTED"})}createUTF8Transcoder(){throw new n(`Encoding '${this.name}' cannot be transcoded to 'utf8'`,{code:"LEVEL_ENCODING_NOT_SUPPORTED"})}}},2:(t,e,r)=>{"use strict";const{Buffer:n}=r(764)||{Buffer:{isBuffer:()=>!1}},{textEncoder:i,textDecoder:o}=r(850)(),{BufferFormat:s,ViewFormat:a,UTF8Format:c}=r(376),u=t=>t;e.utf8=new c({encode:function(t){return n.isBuffer(t)?t.toString("utf8"):ArrayBuffer.isView(t)?o.decode(t):String(t)},decode:u,name:"utf8",createViewTranscoder(){return new a({encode:function(t){return ArrayBuffer.isView(t)?t:i.encode(t)},decode:function(t){return o.decode(t)},name:`${this.name}+view`})},createBufferTranscoder(){return new s({encode:function(t){return n.isBuffer(t)?t:ArrayBuffer.isView(t)?n.from(t.buffer,t.byteOffset,t.byteLength):n.from(String(t),"utf8")},decode:function(t){return t.toString("utf8")},name:`${this.name}+buffer`})}}),e.json=new c({encode:JSON.stringify,decode:JSON.parse,name:"json"}),e.buffer=new s({encode:function(t){return n.isBuffer(t)?t:ArrayBuffer.isView(t)?n.from(t.buffer,t.byteOffset,t.byteLength):n.from(String(t),"utf8")},decode:u,name:"buffer",createViewTranscoder(){return new a({encode:function(t){return ArrayBuffer.isView(t)?t:n.from(String(t),"utf8")},decode:function(t){return n.from(t.buffer,t.byteOffset,t.byteLength)},name:`${this.name}+view`})}}),e.view=new a({encode:function(t){return ArrayBuffer.isView(t)?t:i.encode(t)},decode:u,name:"view",createBufferTranscoder(){return new s({encode:function(t){return n.isBuffer(t)?t:ArrayBuffer.isView(t)?n.from(t.buffer,t.byteOffset,t.byteLength):n.from(String(t),"utf8")},decode:u,name:`${this.name}+buffer`})}}),e.hex=new s({encode:function(t){return n.isBuffer(t)?t:n.from(String(t),"hex")},decode:function(t){return t.toString("hex")},name:"hex"}),e.base64=new s({encode:function(t){return n.isBuffer(t)?t:n.from(String(t),"base64")},decode:function(t){return t.toString("base64")},name:"base64"})},376:(t,e,r)=>{"use strict";const{Buffer:n}=r(764)||{},{Encoding:i}=r(266),o=r(850);class s extends i{constructor(t){super({...t,format:"buffer"})}createViewTranscoder(){return new a({encode:this.encode,decode:t=>this.decode(n.from(t.buffer,t.byteOffset,t.byteLength)),name:`${this.name}+view`})}createBufferTranscoder(){return this}}class a extends i{constructor(t){super({...t,format:"view"})}createBufferTranscoder(){return new s({encode:t=>{const e=this.encode(t);return n.from(e.buffer,e.byteOffset,e.byteLength)},decode:this.decode,name:`${this.name}+buffer`})}createViewTranscoder(){return this}}e.BufferFormat=s,e.ViewFormat=a,e.UTF8Format=class extends i{constructor(t){super({...t,format:"utf8"})}createBufferTranscoder(){return new s({encode:t=>n.from(this.encode(t),"utf8"),decode:t=>this.decode(t.toString("utf8")),name:`${this.name}+buffer`})}createViewTranscoder(){const{textEncoder:t,textDecoder:e}=o();return new a({encode:e=>t.encode(this.encode(e)),decode:t=>this.decode(e.decode(t)),name:`${this.name}+view`})}createUTF8Transcoder(){return this}}},850:t=>{"use strict";let e=null;t.exports=function(){return null===e&&(e={textEncoder:new TextEncoder,textDecoder:new TextDecoder}),e}},301:(t,e,r)=>{e.Level=r(708).BrowserLevel},117:(t,e,r)=>{var n=r(187),i=r(717);function o(t){if(!(this instanceof o))return new o(t);"number"==typeof t&&(t={max:t}),t||(t={}),n.EventEmitter.call(this),this.cache={},this.head=this.tail=null,this.length=0,this.max=t.max||1e3,this.maxAge=t.maxAge||0}t.exports=o,i(o,n.EventEmitter),Object.defineProperty(o.prototype,"keys",{get:function(){return Object.keys(this.cache)}}),o.prototype.clear=function(){this.cache={},this.head=this.tail=null,this.length=0},o.prototype.remove=function(t){if("string"!=typeof t&&(t=""+t),this.cache.hasOwnProperty(t)){var e=this.cache[t];return delete this.cache[t],this._unlink(t,e.prev,e.next),e.value}},o.prototype._unlink=function(t,e,r){this.length--,0===this.length?this.head=this.tail=null:this.head===t?(this.head=e,this.cache[this.head].next=null):this.tail===t?(this.tail=r,this.cache[this.tail].prev=null):(this.cache[e].next=r,this.cache[r].prev=e)},o.prototype.peek=function(t){if(this.cache.hasOwnProperty(t)){var e=this.cache[t];if(this._checkAge(t,e))return e.value}},o.prototype.set=function(t,e){var r;if("string"!=typeof t&&(t=""+t),this.cache.hasOwnProperty(t)){if((r=this.cache[t]).value=e,this.maxAge&&(r.modified=Date.now()),t===this.head)return e;this._unlink(t,r.prev,r.next)}else r={value:e,modified:0,next:null,prev:null},this.maxAge&&(r.modified=Date.now()),this.cache[t]=r,this.length===this.max&&this.evict();return this.length++,r.next=null,r.prev=this.head,this.head&&(this.cache[this.head].next=t),this.head=t,this.tail||(this.tail=t),e},o.prototype._checkAge=function(t,e){return!(this.maxAge&&Date.now()-e.modified>this.maxAge&&(this.remove(t),this.emit("evict",{key:t,value:e.value}),1))},o.prototype.get=function(t){if("string"!=typeof t&&(t=""+t),this.cache.hasOwnProperty(t)){var e=this.cache[t];if(this._checkAge(t,e))return this.head!==t&&(t===this.tail?(this.tail=e.next,this.cache[this.tail].prev=null):this.cache[e.prev].next=e.next,this.cache[e.next].prev=e.prev,this.cache[this.head].next=t,e.prev=this.head,e.next=null,this.head=t),e.value}},o.prototype.evict=function(){if(this.tail){var t=this.tail,e=this.remove(this.tail);this.emit("evict",{key:t,value:e})}}},473:t=>{"use strict";t.exports=class extends Error{constructor(t,e){super(t||""),"object"==typeof e&&null!==e&&(e.code&&(this.code=String(e.code)),e.expected&&(this.expected=!0),e.transient&&(this.transient=!0),e.cause&&(this.cause=e.cause)),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)}}},43:(t,e)=>{"use strict";class r{static isArrayBuffer(t){return"[object ArrayBuffer]"===Object.prototype.toString.call(t)}static toArrayBuffer(t){return this.isArrayBuffer(t)?t:t.byteLength===t.buffer.byteLength||0===t.byteOffset&&t.byteLength===t.buffer.byteLength?t.buffer:this.toUint8Array(t.buffer).slice(t.byteOffset,t.byteOffset+t.byteLength).buffer}static toUint8Array(t){return this.toView(t,Uint8Array)}static toView(t,e){if(t.constructor===e)return t;if(this.isArrayBuffer(t))return new e(t);if(this.isArrayBufferView(t))return new e(t.buffer,t.byteOffset,t.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(t){return this.isArrayBufferView(t)||this.isArrayBuffer(t)}static isArrayBufferView(t){return ArrayBuffer.isView(t)||t&&this.isArrayBuffer(t.buffer)}static isEqual(t,e){const n=r.toUint8Array(t),i=r.toUint8Array(e);if(n.length!==i.byteLength)return!1;for(let t=0;t<n.length;t++)if(n[t]!==i[t])return!1;return!0}static concat(...t){let e;e=!Array.isArray(t[0])||t[1]instanceof Function?Array.isArray(t[0])&&t[1]instanceof Function?t[0]:t[t.length-1]instanceof Function?t.slice(0,t.length-1):t:t[0];let r=0;for(const t of e)r+=t.byteLength;const n=new Uint8Array(r);let i=0;for(const t of e){const e=this.toUint8Array(t);n.set(e,i),i+=e.length}return t[t.length-1]instanceof Function?this.toView(n,t[t.length-1]):n.buffer}}const n="string",i=/^[0-9a-f]+$/i,o=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,s=/^[a-zA-Z0-9-_]+$/;class a{static fromString(t){const e=unescape(encodeURIComponent(t)),r=new Uint8Array(e.length);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return r.buffer}static toString(t){const e=r.toUint8Array(t);let n="";for(let t=0;t<e.length;t++)n+=String.fromCharCode(e[t]);return decodeURIComponent(escape(n))}}class c{static toString(t,e=!1){const n=r.toArrayBuffer(t),i=new DataView(n);let o="";for(let t=0;t<n.byteLength;t+=2){const r=i.getUint16(t,e);o+=String.fromCharCode(r)}return o}static fromString(t,e=!1){const r=new ArrayBuffer(2*t.length),n=new DataView(r);for(let r=0;r<t.length;r++)n.setUint16(2*r,t.charCodeAt(r),e);return r}}class u{static isHex(t){return typeof t===n&&i.test(t)}static isBase64(t){return typeof t===n&&o.test(t)}static isBase64Url(t){return typeof t===n&&s.test(t)}static ToString(t,e="utf8"){const n=r.toUint8Array(t);switch(e.toLowerCase()){case"utf8":return this.ToUtf8String(n);case"binary":return this.ToBinary(n);case"hex":return this.ToHex(n);case"base64":return this.ToBase64(n);case"base64url":return this.ToBase64Url(n);case"utf16le":return c.toString(n,!0);case"utf16":case"utf16be":return c.toString(n);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromString(t,e="utf8"){if(!t)return new ArrayBuffer(0);switch(e.toLowerCase()){case"utf8":return this.FromUtf8String(t);case"binary":return this.FromBinary(t);case"hex":return this.FromHex(t);case"base64":return this.FromBase64(t);case"base64url":return this.FromBase64Url(t);case"utf16le":return c.fromString(t,!0);case"utf16":case"utf16be":return c.fromString(t);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToBase64(t){const e=r.toUint8Array(t);if("undefined"!=typeof btoa){const t=this.ToString(e,"binary");return btoa(t)}return Buffer.from(e).toString("base64")}static FromBase64(t){const e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!u.isBase64(e))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return"undefined"!=typeof atob?this.FromBinary(atob(e)):new Uint8Array(Buffer.from(e,"base64")).buffer}static FromBase64Url(t){const e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!u.isBase64Url(e))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(e.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(t){return this.ToBase64(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(t,e=u.DEFAULT_UTF8_ENCODING){switch(e){case"ascii":return this.FromBinary(t);case"utf8":return a.fromString(t);case"utf16":case"utf16be":return c.fromString(t);case"utf16le":case"usc2":return c.fromString(t,!0);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToUtf8String(t,e=u.DEFAULT_UTF8_ENCODING){switch(e){case"ascii":return this.ToBinary(t);case"utf8":return a.toString(t);case"utf16":case"utf16be":return c.toString(t);case"utf16le":case"usc2":return c.toString(t,!0);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromBinary(t){const e=t.length,r=new Uint8Array(e);for(let n=0;n<e;n++)r[n]=t.charCodeAt(n);return r.buffer}static ToBinary(t){const e=r.toUint8Array(t);let n="";for(let t=0;t<e.length;t++)n+=String.fromCharCode(e[t]);return n}static ToHex(t){const e=r.toUint8Array(t);let n="";const i=e.length;for(let t=0;t<i;t++){const r=e[t];r<16&&(n+="0"),n+=r.toString(16)}return n}static FromHex(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!u.isHex(e))throw new TypeError("Argument 'hexString' is not HEX encoded");e.length%2&&(e=`0${e}`);const r=new Uint8Array(e.length/2);for(let t=0;t<e.length;t+=2){const n=e.slice(t,t+2);r[t/2]=parseInt(n,16)}return r.buffer}static ToUtf16String(t,e=!1){return c.toString(t,e)}static FromUtf16String(t,e=!1){return c.fromString(t,e)}static Base64Padding(t){const e=4-t.length%4;if(e<4)for(let r=0;r<e;r++)t+="=";return t}static formatString(t){return(null==t?void 0:t.replace(/[\n\r\t ]/g,""))||""}}u.DEFAULT_UTF8_ENCODING="utf8",e.vJ=r,e.ep=u},375:(t,e,r)=>{let n;t.exports="function"==typeof queueMicrotask?queueMicrotask.bind("undefined"!=typeof window?window:r.g):t=>(n||(n=Promise.resolve())).then(t).catch((t=>setTimeout((()=>{throw t}),0)))},916:(t,e,r)=>{"use strict";const n=r(807);class i{constructor(t,e,r){const i=this;this._started=n(),this._rescheduled=0,this._scheduled=e,this._args=r,this._triggered=!1,this._timerWrapper=()=>{i._rescheduled>0?(i._scheduled=i._rescheduled-(n()-i._started),i._schedule(i._scheduled)):(i._triggered=!0,t.apply(null,i._args))},this._timer=setTimeout(this._timerWrapper,e)}reschedule(t){t||(t=this._scheduled);const e=n();e+t-(this._started+this._scheduled)<0?(clearTimeout(this._timer),this._schedule(t)):this._triggered?this._schedule(t):(this._started=e,this._rescheduled=t)}_schedule(t){this._triggered=!1,this._started=n(),this._rescheduled=0,this._scheduled=t,this._timer=setTimeout(this._timerWrapper,t)}clear(){clearTimeout(this._timer)}}t.exports=function(){if("function"!=typeof arguments[0])throw new Error("callback needed");if("number"!=typeof arguments[1])throw new Error("timeout needed");let t;if(arguments.length>0){t=new Array(arguments.length-2);for(var e=0;e<t.length;e++)t[e]=arguments[e+2]}return new i(arguments[0],arguments[1],t)}},807:t=>{"use strict";t.exports=function(){return Date.now()}},967:(t,e,r)=>{t.exports=function(t,e,r){if("number"!=typeof e)throw new Error("second argument must be a Number");let i,o,s,a,c,u,h=!0;function l(t){function e(){r&&r(t,i),r=null}h?n(e):e()}function f(e,r,n){if(i[e]=n,r&&(c=!0),0==--s||r)l(r);else if(!c&&u<o){let e;a?(e=a[u],u+=1,t[e]((function(t,r){f(e,t,r)}))):(e=u,u+=1,t[e]((function(t,r){f(e,t,r)})))}}Array.isArray(t)?(i=[],s=o=t.length):(a=Object.keys(t),i={},s=o=a.length),u=e,s?a?a.some((function(r,n){return t[r]((function(t,e){f(r,t,e)})),n===e-1})):t.some((function(t,r){return t((function(t,e){f(r,t,e)})),r===e-1})):l(null),h=!1};const n=r(375)},715:(t,e,r)=>{"use strict";const{AbortController:n}=globalThis,i=r(916);class o extends n{constructor(t){super(),this._ms=t,this._timer=i((()=>this.abort()),t),Object.setPrototypeOf(this,o.prototype)}abort(){return this._timer.clear(),super.abort()}clear(){this._timer.clear()}reset(){this._timer.clear(),this._timer=i((()=>this.abort()),this._ms)}}t.exports={TimeoutController:o}}},e={};function r(n){var i=e[n];if(void 0!==i)return i.exports;var o=e[n]={exports:{}};return t[n](o,o.exports,r),o.exports}r.d=(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},r.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var n={};(()=>{"use strict";r.r(n),r.d(n,{ComposedStorage:()=>kn,Database:()=>Nn,DefaultAccessController:()=>Bn,Documents:()=>Dn,Entry:()=>fn,Events:()=>Pn,IPFSAccessController:()=>xf,IPFSBlockStorage:()=>Sn,Identities:()=>uf,KeyStore:()=>Jl,KeyValue:()=>Fn,KeyValueIndexed:()=>qn,LRUStorage:()=>Un,LevelStorage:()=>Tn,Log:()=>An,MemoryStorage:()=>dn,OrbitDBAccessController:()=>kf,PublicKeyIdentityProvider:()=>nf,createOrbitDB:()=>Cf,isIdentity:()=>tf,isValidAddress:()=>hf,parseAddress:()=>lf,useAccessController:()=>If,useDatabaseType:()=>Gn,useIdentityProvider:()=>af});var t={};r.r(t),r.d(t,{code:()=>en,decode:()=>nn,decodeOptions:()=>Xr,encode:()=>rn,encodeOptions:()=>Yr,name:()=>tn,toByteView:()=>Wr});var e={};r.r(e),r.d(e,{gk:()=>wo,dQ:()=>Uo,ci:()=>mo,bytesToNumberBE:()=>Ao,ty:()=>ko,eV:()=>Co,n$:()=>Oo,ql:()=>To,hexToBytes:()=>Bo,_t:()=>go,tL:()=>So,S5:()=>Io,FF:()=>Ro});var i={};r.r(i),r.d(i,{base10:()=>la});var o={};r.r(o),r.d(o,{base16:()=>fa,base16upper:()=>da});var s={};r.r(s),r.d(s,{base2:()=>ya});var a={};r.r(a),r.d(a,{base256emoji:()=>ba});var c={};r.r(c),r.d(c,{base32:()=>ma,base32hex:()=>Ba,base32hexpad:()=>ka,base32hexpadupper:()=>Sa,base32hexupper:()=>Aa,base32pad:()=>Ea,base32padupper:()=>xa,base32upper:()=>va,base32z:()=>Ia});var u={};r.r(u),r.d(u,{base36:()=>Ta,base36upper:()=>Ca});var h={};r.r(h),r.d(h,{base58btc:()=>Ua,base58flickr:()=>La});var l={};r.r(l),r.d(l,{base64:()=>Na,base64pad:()=>Oa,base64url:()=>_a,base64urlpad:()=>Ra});var f={};r.r(f),r.d(f,{base8:()=>Da});var d={};r.r(d),r.d(d,{identity:()=>Va});var y={};r.r(y),r.d(y,{code:()=>$a,decode:()=>ja,encode:()=>Fa,name:()=>Ha});var p={};r.r(p),r.d(p,{code:()=>qa,decode:()=>Ga,encode:()=>Ka,name:()=>za});var g={};r.r(g),r.d(g,{identity:()=>yc});var w={};r.r(w),r.d(w,{sha256:()=>bc,sha512:()=>mc});var b=r(187),m=r(729);class v extends Error{constructor(t){super(t),this.name="TimeoutError"}}class E extends Error{constructor(t){super(),this.name="AbortError",this.message=t}}const x=t=>void 0===globalThis.DOMException?new E(t):new DOMException(t),B=t=>{const e=void 0===t.reason?x("This operation was aborted."):t.reason;return e instanceof Error?e:x(e)};class A{#t=[];enqueue(t,e){const r={priority:(e={priority:0,...e}).priority,run:t};if(this.size&&this.#t[this.size-1].priority>=e.priority)return void this.#t.push(r);const n=function(t,e,r){let n=0,i=t.length;for(;i>0;){const r=Math.trunc(i/2);let s=n+r;o=t[s],e.priority-o.priority<=0?(n=++s,i-=r+1):i=r}var o;return n}(this.#t,r);this.#t.splice(n,0,r)}dequeue(){const t=this.#t.shift();return t?.run}filter(t){return this.#t.filter((e=>e.priority===t.priority)).map((t=>t.run))}get size(){return this.#t.length}}class k extends m{#e;#r;#n=0;#i;#o;#s=0;#a;#c;#t;#u;#h=0;#l;#f;#d;timeout;constructor(t){if(super(),!("number"==typeof(t={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:A,...t}).intervalCap&&t.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${t.intervalCap?.toString()??""}\` (${typeof t.intervalCap})`);if(void 0===t.interval||!(Number.isFinite(t.interval)&&t.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${t.interval?.toString()??""}\` (${typeof t.interval})`);this.#e=t.carryoverConcurrencyCount,this.#r=t.intervalCap===Number.POSITIVE_INFINITY||0===t.interval,this.#i=t.intervalCap,this.#o=t.interval,this.#t=new t.queueClass,this.#u=t.queueClass,this.concurrency=t.concurrency,this.timeout=t.timeout,this.#d=!0===t.throwOnTimeout,this.#f=!1===t.autoStart}get#y(){return this.#r||this.#n<this.#i}get#p(){return this.#h<this.#l}#g(){this.#h--,this.#w(),this.emit("next")}#b(){this.#m(),this.#v(),this.#c=void 0}get#E(){const t=Date.now();if(void 0===this.#a){const e=this.#s-t;if(!(e<0))return void 0===this.#c&&(this.#c=setTimeout((()=>{this.#b()}),e)),!0;this.#n=this.#e?this.#h:0}return!1}#w(){if(0===this.#t.size)return this.#a&&clearInterval(this.#a),this.#a=void 0,this.emit("empty"),0===this.#h&&this.emit("idle"),!1;if(!this.#f){const t=!this.#E;if(this.#y&&this.#p){const e=this.#t.dequeue();return!!e&&(this.emit("active"),e(),t&&this.#v(),!0)}}return!1}#v(){this.#r||void 0!==this.#a||(this.#a=setInterval((()=>{this.#m()}),this.#o),this.#s=Date.now()+this.#o)}#m(){0===this.#n&&0===this.#h&&this.#a&&(clearInterval(this.#a),this.#a=void 0),this.#n=this.#e?this.#h:0,this.#x()}#x(){for(;this.#w(););}get concurrency(){return this.#l}set concurrency(t){if(!("number"==typeof t&&t>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${t}\` (${typeof t})`);this.#l=t,this.#x()}async#B(t){return new Promise(((e,r)=>{t.addEventListener("abort",(()=>{r(t.reason)}),{once:!0})}))}async add(t,e={}){return e={timeout:this.timeout,throwOnTimeout:this.#d,...e},new Promise(((r,n)=>{this.#t.enqueue((async()=>{this.#h++,this.#n++;try{e.signal?.throwIfAborted();let n=t({signal:e.signal});e.timeout&&(n=function(t,e){const{milliseconds:r,fallback:n,message:i,customTimers:o={setTimeout,clearTimeout}}=e;let s;const a=new Promise(((a,c)=>{if("number"!=typeof r||1!==Math.sign(r))throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${r}\``);if(e.signal){const{signal:t}=e;t.aborted&&c(B(t)),t.addEventListener("abort",(()=>{c(B(t))}))}if(r===Number.POSITIVE_INFINITY)return void t.then(a,c);const u=new v;s=o.setTimeout.call(void 0,(()=>{if(n)try{a(n())}catch(t){c(t)}else"function"==typeof t.cancel&&t.cancel(),!1===i?a():i instanceof Error?c(i):(u.message=i??`Promise timed out after ${r} milliseconds`,c(u))}),r),(async()=>{try{a(await t)}catch(t){c(t)}})()})).finally((()=>{a.clear()}));return a.clear=()=>{o.clearTimeout.call(void 0,s),s=void 0},a}(Promise.resolve(n),{milliseconds:e.timeout})),e.signal&&(n=Promise.race([n,this.#B(e.signal)]));const i=await n;r(i),this.emit("completed",i)}catch(t){if(t instanceof v&&!e.throwOnTimeout)return void r();n(t),this.emit("error",t)}finally{this.#g()}}),e),this.emit("add"),this.#w()}))}async addAll(t,e){return Promise.all(t.map((async t=>this.add(t,e))))}start(){return this.#f?(this.#f=!1,this.#x(),this):this}pause(){this.#f=!0}clear(){this.#t=new this.#u}async onEmpty(){0!==this.#t.size&&await this.#A("empty")}async onSizeLessThan(t){this.#t.size<t||await this.#A("next",(()=>this.#t.size<t))}async onIdle(){0===this.#h&&0===this.#t.size||await this.#A("idle")}async#A(t,e){return new Promise((r=>{const n=()=>{e&&!e()||(this.off(t,n),r())};this.on(t,n)}))}get size(){return this.#t.size}sizeBy(t){return this.#t.filter(t).length}get pending(){return this.#h}get isPaused(){return this.#f}}function S(){const t={};return t.promise=new Promise(((e,r)=>{t.resolve=e,t.reject=r})),t}class I{buffer;mask;top;btm;next;constructor(t){if(!(t>0)||0!=(t-1&t))throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(t),this.mask=t-1,this.top=0,this.btm=0,this.next=null}push(t){return void 0===this.buffer[this.top]&&(this.buffer[this.top]=t,this.top=this.top+1&this.mask,!0)}shift(){const t=this.buffer[this.btm];if(void 0!==t)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,t}isEmpty(){return void 0===this.buffer[this.btm]}}class T{size;hwm;head;tail;constructor(t={}){this.hwm=t.splitLimit??16,this.head=new I(this.hwm),this.tail=this.head,this.size=0}calculateSize(t){return null!=t?.byteLength?t.byteLength:1}push(t){if(null!=t?.value&&(this.size+=this.calculateSize(t.value)),!this.head.push(t)){const e=this.head;this.head=e.next=new I(2*this.head.buffer.length),this.head.push(t)}}shift(){let t=this.tail.shift();if(void 0===t&&null!=this.tail.next){const e=this.tail.next;this.tail.next=null,this.tail=e,t=this.tail.shift()}return null!=t?.value&&(this.size-=this.calculateSize(t.value)),t}isEmpty(){return this.head.isEmpty()}}class C extends Error{type;code;constructor(t,e){super(t??"The operation was aborted"),this.type="aborted",this.code=e??"ABORT_ERR"}}function U(t={}){return function(t,e){let r,n,i,o=(e=e??{}).onEnd,s=new T,a=S();const c=t=>null!=n?n(t):(s.push(t),r),u=t=>{if(i)return r;if(!0!==e?.objectMode&&null==t?.byteLength)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return c({done:!1,value:t})},h=t=>i?r:(i=!0,null!=t?(t=>(s=new T,null!=n?n({error:t}):(s.push({error:t}),r)))(t):c({done:!0}));if(r={[Symbol.asyncIterator](){return this},next:async()=>{try{return s.isEmpty()?i?{done:!0}:await new Promise(((e,i)=>{n=o=>{n=null,s.push(o);try{e(t(s))}catch(t){i(t)}return r}})):t(s)}finally{s.isEmpty()&&queueMicrotask((()=>{a.resolve(),a=S()}))}},return:()=>(s=new T,h(),{done:!0}),throw:t=>(h(t),{done:!0}),push:u,end:h,get readableLength(){return s.size},onEmpty:async t=>{const e=t?.signal;if(e?.throwIfAborted(),s.isEmpty())return;let r,n;null!=e&&(r=new Promise(((t,r)=>{n=()=>{r(new C)},e.addEventListener("abort",n)})));try{await Promise.race([a.promise,r])}finally{null!=n&&null!=e&&e?.removeEventListener("abort",n)}}},null==o)return r;const l=r;return r={[Symbol.asyncIterator](){return this},next:()=>l.next(),throw:t=>(l.throw(t),null!=o&&(o(t),o=void 0),{done:!0}),return:()=>(l.return(),null!=o&&(o(),o=void 0),{done:!0}),push:u,end:t=>(l.end(t),null!=o&&(o(t),o=void 0),r),get readableLength(){return l.readableLength},onEmpty:t=>l.onEmpty(t)},r}((t=>{const e=t.shift();if(null==e)return{done:!0};if(null!=e.error)throw e.error;return{done:!0===e.done,value:e.value}}),t)}function L(t,...e){if(null==t)throw new Error("Empty pipeline");if(R(t)){const e=t;t=()=>e.source}else if(_(t)||O(t)){const e=t;t=()=>e}const r=[t,...e];if(r.length>1&&R(r[r.length-1])&&(r[r.length-1]=r[r.length-1].sink),r.length>2)for(let t=1;t<r.length-1;t++)R(r[t])&&(r[t]=D(r[t]));return N(...r)}const N=(...t)=>{let e;for(;t.length>0;)e=t.shift()(e);return e},O=t=>null!=t?.[Symbol.asyncIterator],_=t=>null!=t?.[Symbol.iterator],R=t=>null!=t&&null!=t.sink&&null!=t.source,D=t=>e=>{const r=t.sink(e);if(null!=r?.then){const e=U({objectMode:!0});let n;r.then((()=>{e.end()}),(t=>{e.end(t)}));const i=t.source;if(O(i))n=async function*(){yield*i,e.end()};else{if(!_(i))throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");n=function*(){yield*i,e.end()}}return function(...t){const e=[];for(const r of t)null==r[Symbol.asyncIterator]&&e.push(r);return e.length===t.length?function*(){for(const t of e)yield*t}():async function*(){const e=U({objectMode:!0});Promise.resolve().then((async()=>{try{await Promise.all(t.map((async t=>{for await(const r of t)e.push(r)}))),e.end()}catch(t){e.end(t)}})),yield*e}()}(e,n())}return t.source};var V=r(715);const M=(...t)=>t.join("/").replace(/((?<=\/)\/+)|(^\.\/)|((?<=\/)\.\/)/g,"")||".",P=M;var H=r(117);const $=(t,e)=>({id:t,time:e=e||0}),F=(new Uint8Array(0),t=>{if(t instanceof Uint8Array&&"Uint8Array"===t.constructor.name)return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")});const j=function(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var i=0;i<t.length;i++){var o=t.charAt(i),s=o.charCodeAt(0);if(255!==r[s])throw new TypeError(o+" is ambiguous");r[s]=i}var a=t.length,c=t.charAt(0),u=Math.log(a)/Math.log(256),h=Math.log(256)/Math.log(a);function l(t){if("string"!=typeof t)throw new TypeError("Expected String");if(0===t.length)return new Uint8Array;var e=0;if(" "!==t[e]){for(var n=0,i=0;t[e]===c;)n++,e++;for(var o=(t.length-e)*u+1>>>0,s=new Uint8Array(o);t[e];){var h=r[t.charCodeAt(e)];if(255===h)return;for(var l=0,f=o-1;(0!==h||l<i)&&-1!==f;f--,l++)h+=a*s[f]>>>0,s[f]=h%256>>>0,h=h/256>>>0;if(0!==h)throw new Error("Non-zero carry");i=l,e++}if(" "!==t[e]){for(var d=o-i;d!==o&&0===s[d];)d++;for(var y=new Uint8Array(n+(o-d)),p=n;d!==o;)y[p++]=s[d++];return y}}}return{encode:function(e){if(e instanceof Uint8Array||(ArrayBuffer.isView(e)?e=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):Array.isArray(e)&&(e=Uint8Array.from(e))),!(e instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===e.length)return"";for(var r=0,n=0,i=0,o=e.length;i!==o&&0===e[i];)i++,r++;for(var s=(o-i)*h+1>>>0,u=new Uint8Array(s);i!==o;){for(var l=e[i],f=0,d=s-1;(0!==l||f<n)&&-1!==d;d--,f++)l+=256*u[d]>>>0,u[d]=l%a>>>0,l=l/a>>>0;if(0!==l)throw new Error("Non-zero carry");n=f,i++}for(var y=s-n;y!==s&&0===u[y];)y++;for(var p=c.repeat(r);y<s;++y)p+=t.charAt(u[y]);return p},decodeUnsafe:l,decode:function(t){var r=l(t);if(r)return r;throw new Error(`Non-${e} character`)}}};class z{constructor(t,e,r){this.name=t,this.prefix=e,this.baseEncode=r}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}}class q{constructor(t,e,r){if(this.name=t,this.prefix=e,void 0===e.codePointAt(0))throw new Error("Invalid prefix character");this.prefixCodePoint=e.codePointAt(0),this.baseDecode=r}decode(t){if("string"==typeof t){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(t){return G(this,t)}}class K{constructor(t){this.decoders=t}or(t){return G(this,t)}decode(t){const e=t[0],r=this.decoders[e];if(r)return r.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const G=(t,e)=>new K({...t.decoders||{[t.prefix]:t},...e.decoders||{[e.prefix]:e}});class J{constructor(t,e,r,n){this.name=t,this.prefix=e,this.baseEncode=r,this.baseDecode=n,this.encoder=new z(t,e,r),this.decoder=new q(t,e,n)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}}const W=({name:t,prefix:e,encode:r,decode:n})=>new J(t,e,r,n),Z=({prefix:t,name:e,alphabet:r})=>{const{encode:n,decode:i}=j(r,e);return W({prefix:t,name:e,encode:n,decode:t=>F(i(t))})},Y=({name:t,prefix:e,bitsPerChar:r,alphabet:n})=>W({prefix:e,name:t,encode:t=>((t,e,r)=>{const n="="===e[e.length-1],i=(1<<r)-1;let o="",s=0,a=0;for(let n=0;n<t.length;++n)for(a=a<<8|t[n],s+=8;s>r;)s-=r,o+=e[i&a>>s];if(s&&(o+=e[i&a<<r-s]),n)for(;o.length*r&7;)o+="=";return o})(t,n,r),decode:e=>((t,e,r,n)=>{const i={};for(let t=0;t<e.length;++t)i[e[t]]=t;let o=t.length;for(;"="===t[o-1];)--o;const s=new Uint8Array(o*r/8|0);let a=0,c=0,u=0;for(let e=0;e<o;++e){const o=i[t[e]];if(void 0===o)throw new SyntaxError(`Non-${n} character`);c=c<<r|o,a+=r,a>=8&&(a-=8,s[u++]=255&c>>a)}if(a>=r||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return s})(e,n,r,t)}),Q=Y({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),X=(Y({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Y({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Y({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Y({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Y({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Y({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Y({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Y({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),Z({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}));Z({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var tt=128,et=-128,rt=Math.pow(2,31),nt=128,it=127,ot=Math.pow(2,7),st=Math.pow(2,14),at=Math.pow(2,21),ct=Math.pow(2,28),ut=Math.pow(2,35),ht=Math.pow(2,42),lt=Math.pow(2,49),ft=Math.pow(2,56),dt=Math.pow(2,63);const yt={encode:function t(e,r,n){r=r||[];for(var i=n=n||0;e>=rt;)r[n++]=255&e|tt,e/=128;for(;e&et;)r[n++]=255&e|tt,e>>>=7;return r[n]=0|e,t.bytes=n-i+1,r},decode:function t(e,r){var n,i=0,o=0,s=r=r||0,a=e.length;do{if(s>=a)throw t.bytes=0,new RangeError("Could not decode varint");n=e[s++],i+=o<28?(n&it)<<o:(n&it)*Math.pow(2,o),o+=7}while(n>=nt);return t.bytes=s-r,i},encodingLength:function(t){return t<ot?1:t<st?2:t<at?3:t<ct?4:t<ut?5:t<ht?6:t<lt?7:t<ft?8:t<dt?9:10}},pt=(t,e=0)=>[yt.decode(t,e),yt.decode.bytes],gt=(t,e,r=0)=>(yt.encode(t,e,r),e),wt=t=>yt.encodingLength(t),bt=(t,e)=>{const r=e.byteLength,n=wt(t),i=n+wt(r),o=new Uint8Array(i+r);return gt(t,o,0),gt(r,o,n),o.set(e,i),new mt(t,r,e,o)};class mt{constructor(t,e,r,n){this.code=t,this.size=e,this.digest=r,this.bytes=n}}const vt=(t,e)=>{const{bytes:r,version:n}=t;return 0===n?kt(r,xt(t),e||X.encoder):St(r,xt(t),e||Q.encoder)},Et=new WeakMap,xt=t=>{const e=Et.get(t);if(null==e){const e=new Map;return Et.set(t,e),e}return e};class Bt{constructor(t,e,r,n){this.code=e,this.version=t,this.multihash=r,this.bytes=n,this["/"]=n}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:t,multihash:e}=this;if(t!==It)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==Tt)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return Bt.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:t,digest:e}=this.multihash,r=bt(t,e);return Bt.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return Bt.equals(this,t)}static equals(t,e){const r=e;return r&&t.code===r.code&&t.version===r.version&&((t,e)=>{if(t===e)return!0;{const r=e;return t.code===r.code&&t.size===r.size&&r.bytes instanceof Uint8Array&&((t,e)=>{if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0})(t.bytes,r.bytes)}})(t.multihash,r.multihash)}toString(t){return vt(this,t)}toJSON(){return{"/":vt(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(null==t)return null;const e=t;if(e instanceof Bt)return e;if(null!=e["/"]&&e["/"]===e.bytes||e.asCID===e){const{version:t,code:r,multihash:n,bytes:i}=e;return new Bt(t,r,n,i||Ct(t,r,n.bytes))}if(!0===e[Ut]){const{version:t,multihash:r,code:n}=e,i=(t=>{const e=F(t),[r,n]=pt(e),[i,o]=pt(e.subarray(n)),s=e.subarray(n+o);if(s.byteLength!==i)throw new Error("Incorrect length");return new mt(r,i,s,e)})(r);return Bt.create(t,n,i)}return null}static create(t,e,r){if("number"!=typeof e)throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:if(e!==It)throw new Error(`Version 0 CID must use dag-pb (code: ${It}) block encoding`);return new Bt(t,e,r,r.bytes);case 1:{const n=Ct(t,e,r.bytes);return new Bt(t,e,r,n)}default:throw new Error("Invalid version")}}static createV0(t){return Bt.create(0,It,t)}static createV1(t,e){return Bt.create(1,t,e)}static decode(t){const[e,r]=Bt.decodeFirst(t);if(r.length)throw new Error("Incorrect length");return e}static decodeFirst(t){const e=Bt.inspectBytes(t),r=e.size-e.multihashSize,n=F(t.subarray(r,r+e.multihashSize));if(n.byteLength!==e.multihashSize)throw new Error("Incorrect length");const i=n.subarray(e.multihashSize-e.digestSize),o=new mt(e.multihashCode,e.digestSize,i,n);return[0===e.version?Bt.createV0(o):Bt.createV1(e.codec,o),t.subarray(e.size)]}static inspectBytes(t){let e=0;const r=()=>{const[r,n]=pt(t.subarray(e));return e+=n,r};let n=r(),i=It;if(18===n?(n=0,e=0):i=r(),0!==n&&1!==n)throw new RangeError(`Invalid CID version ${n}`);const o=e,s=r(),a=r(),c=e+a;return{version:n,codec:i,multihashCode:s,digestSize:a,multihashSize:c-o,size:c}}static parse(t,e){const[r,n]=At(t,e),i=Bt.decode(n);if(0===i.version&&"Q"!==t[0])throw Error("Version 0 CID string must not include multibase prefix");return xt(i).set(r,t),i}}const At=(t,e)=>{switch(t[0]){case"Q":{const r=e||X;return[X.prefix,r.decode(`${X.prefix}${t}`)]}case X.prefix:{const r=e||X;return[X.prefix,r.decode(t)]}case Q.prefix:{const r=e||Q;return[Q.prefix,r.decode(t)]}default:if(null==e)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[t[0],e.decode(t)]}},kt=(t,e,r)=>{const{prefix:n}=r;if(n!==X.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);const i=e.get(n);if(null==i){const i=r.encode(t).slice(1);return e.set(n,i),i}return i},St=(t,e,r)=>{const{prefix:n}=r,i=e.get(n);if(null==i){const i=r.encode(t);return e.set(n,i),i}return i},It=112,Tt=18,Ct=(t,e,r)=>{const n=wt(t),i=n+wt(e),o=new Uint8Array(i+r.byteLength);return gt(t,o,0),gt(e,o,n),o.set(r,i),o},Ut=Symbol.for("@ipld/js-cid/CID"),Lt=({name:t,code:e,encode:r})=>new Nt(t,e,r);class Nt{constructor(t,e,r){this.name=t,this.code=e,this.encode=r}digest(t){if(t instanceof Uint8Array){const e=this.encode(t);return e instanceof Uint8Array?bt(this.code,e):e.then((t=>bt(this.code,t)))}throw Error("Unknown type, must be binary type")}}function Ot({enumerable:t=!0,configurable:e=!1}={}){return{enumerable:t,configurable:e,writable:!1}}function*_t(t,e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))for(const[r,n]of e.entries()){const e=[...t,r],i=Bt.asCID(n);i?yield[e.join("/"),i]:"object"==typeof n&&(yield*Rt(n,e))}else{const r=Bt.asCID(e);r?yield[t.join("/"),r]:yield*Rt(e,t)}}function*Rt(t,e){if(null==t||t instanceof Uint8Array)return;const r=Bt.asCID(t);r&&(yield[e.join("/"),r]);for(const[r,n]of Object.entries(t)){const t=[...e,r];yield*_t(t,n)}}function*Dt(t,e){if(Array.isArray(e))for(const[r,n]of e.entries()){const e=[...t,r];yield e.join("/"),"object"!=typeof n||Bt.asCID(n)||(yield*Vt(n,e))}else yield*Vt(e,t)}function*Vt(t,e){if(null!=t&&"object"==typeof t)for(const[r,n]of Object.entries(t)){const t=[...e,r];yield t.join("/"),null==n||n instanceof Uint8Array||"object"!=typeof n||Bt.asCID(n)||(yield*Dt(t,n))}}class Mt{constructor({cid:t,bytes:e,value:r}){if(!t||!e||void 0===r)throw new Error("Missing required argument");this.cid=t,this.bytes=e,this.value=r,this.asBlock=this,Object.defineProperties(this,{cid:Ot(),bytes:Ot(),value:Ot(),asBlock:Ot()})}links(){return Rt(this.value,[])}tree(){return Vt(this.value,[])}get(t="/"){return function(t,e){let r=t;for(const[t,n]of e.entries()){if(r=r[n],null==r)throw new Error(`Object has no property at ${e.slice(0,t+1).map((t=>`[${JSON.stringify(t)}]`)).join("")}`);const i=Bt.asCID(r);if(i)return{value:i,remaining:e.slice(t+1).join("/")}}return{value:r}}(this.value,t.split("/").filter(Boolean))}}async function Pt({value:t,codec:e,hasher:r}){if(void 0===t)throw new Error('Missing required argument "value"');if(!e||!r)throw new Error("Missing required argument: codec or hasher");const n=e.encode(t),i=await r.digest(n),o=Bt.create(1,e.code,i);return new Mt({value:t,bytes:n,cid:o})}async function Ht({bytes:t,codec:e,hasher:r}){if(!t)throw new Error('Missing required argument "bytes"');if(!e||!r)throw new Error("Missing required argument: codec or hasher");const n=e.decode(t),i=await r.digest(t),o=Bt.create(1,e.code,i);return new Mt({value:n,bytes:t,cid:o})}const $t=["string","number","bigint","symbol"],Ft=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];class jt{constructor(t,e,r){this.major=t,this.majorEncoded=t<<5,this.name=e,this.terminal=r}toString(){return`Type[${this.major}].${this.name}`}compare(t){return this.major<t.major?-1:this.major>t.major?1:0}}jt.uint=new jt(0,"uint",!0),jt.negint=new jt(1,"negint",!0),jt.bytes=new jt(2,"bytes",!0),jt.string=new jt(3,"string",!0),jt.array=new jt(4,"array",!1),jt.map=new jt(5,"map",!1),jt.tag=new jt(6,"tag",!1),jt.float=new jt(7,"float",!0),jt.false=new jt(7,"false",!0),jt.true=new jt(7,"true",!0),jt.null=new jt(7,"null",!0),jt.undefined=new jt(7,"undefined",!0),jt.break=new jt(7,"break",!0);class zt{constructor(t,e,r){this.type=t,this.value=e,this.encodedLength=r,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}}const qt=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&"function"==typeof globalThis.Buffer.isBuffer,Kt=new TextDecoder,Gt=new TextEncoder;function Jt(t){return qt&&globalThis.Buffer.isBuffer(t)}function Wt(t){return t instanceof Uint8Array?Jt(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t:Uint8Array.from(t)}const Zt=qt?(t,e,r)=>r-e>64?globalThis.Buffer.from(t.subarray(e,r)).toString("utf8"):ne(t,e,r):(t,e,r)=>r-e>64?Kt.decode(t.subarray(e,r)):ne(t,e,r),Yt=qt?t=>t.length>64?globalThis.Buffer.from(t):re(t):t=>t.length>64?Gt.encode(t):re(t),Qt=t=>Uint8Array.from(t),Xt=qt?(t,e,r)=>Jt(t)?new Uint8Array(t.subarray(e,r)):t.slice(e,r):(t,e,r)=>t.slice(e,r),te=qt?(t,e)=>(t=t.map((t=>t instanceof Uint8Array?t:globalThis.Buffer.from(t))),Wt(globalThis.Buffer.concat(t,e))):(t,e)=>{const r=new Uint8Array(e);let n=0;for(let e of t)n+e.length>r.length&&(e=e.subarray(0,r.length-n)),r.set(e,n),n+=e.length;return r},ee=qt?t=>globalThis.Buffer.allocUnsafe(t):t=>new Uint8Array(t);function re(t){const e=[];let r=0;for(let n=0;n<t.length;n++){let i=t.charCodeAt(n);i<128?e[r++]=i:i<2048?(e[r++]=i>>6|192,e[r++]=63&i|128):55296==(64512&i)&&n+1<t.length&&56320==(64512&t.charCodeAt(n+1))?(i=65536+((1023&i)<<10)+(1023&t.charCodeAt(++n)),e[r++]=i>>18|240,e[r++]=i>>12&63|128,e[r++]=i>>6&63|128,e[r++]=63&i|128):(e[r++]=i>>12|224,e[r++]=i>>6&63|128,e[r++]=63&i|128)}return e}function ne(t,e,r){const n=[];for(;e<r;){const i=t[e];let o=null,s=i>239?4:i>223?3:i>191?2:1;if(e+s<=r){let r,n,a,c;switch(s){case 1:i<128&&(o=i);break;case 2:r=t[e+1],128==(192&r)&&(c=(31&i)<<6|63&r,c>127&&(o=c));break;case 3:r=t[e+1],n=t[e+2],128==(192&r)&&128==(192&n)&&(c=(15&i)<<12|(63&r)<<6|63&n,c>2047&&(c<55296||c>57343)&&(o=c));break;case 4:r=t[e+1],n=t[e+2],a=t[e+3],128==(192&r)&&128==(192&n)&&128==(192&a)&&(c=(15&i)<<18|(63&r)<<12|(63&n)<<6|63&a,c>65535&&c<1114112&&(o=c))}}null===o?(o=65533,s=1):o>65535&&(o-=65536,n.push(o>>>10&1023|55296),o=56320|1023&o),n.push(o),e+=s}return function(t){const e=t.length;if(e<=ie)return String.fromCharCode.apply(String,t);let r="",n=0;for(;n<e;)r+=String.fromCharCode.apply(String,t.slice(n,n+=ie));return r}(n)}const ie=4096;class oe{constructor(t=256){this.chunkSize=t,this.cursor=0,this.maxCursor=-1,this.chunks=[],this._initReuseChunk=null}reset(){this.cursor=0,this.maxCursor=-1,this.chunks.length&&(this.chunks=[]),null!==this._initReuseChunk&&(this.chunks.push(this._initReuseChunk),this.maxCursor=this._initReuseChunk.length-1)}push(t){let e=this.chunks[this.chunks.length-1];if(this.cursor+t.length<=this.maxCursor+1){const r=e.length-(this.maxCursor-this.cursor)-1;e.set(t,r)}else{if(e){const t=e.length-(this.maxCursor-this.cursor)-1;t<e.length&&(this.chunks[this.chunks.length-1]=e.subarray(0,t),this.maxCursor=this.cursor-1)}t.length<64&&t.length<this.chunkSize?(e=ee(this.chunkSize),this.chunks.push(e),this.maxCursor+=e.length,null===this._initReuseChunk&&(this._initReuseChunk=e),e.set(t,0)):(this.chunks.push(t),this.maxCursor+=t.length)}this.cursor+=t.length}toBytes(t=!1){let e;if(1===this.chunks.length){const r=this.chunks[0];t&&this.cursor>r.length/2?(e=this.cursor===r.length?r:r.subarray(0,this.cursor),this._initReuseChunk=null,this.chunks=[]):e=Xt(r,0,this.cursor)}else e=te(this.chunks,this.cursor);return t&&this.reset(),e}}const se="CBOR decode error:",ae="CBOR encode error:",ce=[];function ue(t,e,r){if(t.length-e<r)throw new Error(`${se} not enough data for type`)}ce[23]=1,ce[24]=2,ce[25]=3,ce[26]=5,ce[27]=9;const he=[24,256,65536,4294967296,BigInt("18446744073709551616")];function le(t,e,r){ue(t,e,1);const n=t[e];if(!0===r.strict&&n<he[0])throw new Error(`${se} integer encoded in more bytes than necessary (strict decode)`);return n}function fe(t,e,r){ue(t,e,2);const n=t[e]<<8|t[e+1];if(!0===r.strict&&n<he[1])throw new Error(`${se} integer encoded in more bytes than necessary (strict decode)`);return n}function de(t,e,r){ue(t,e,4);const n=16777216*t[e]+(t[e+1]<<16)+(t[e+2]<<8)+t[e+3];if(!0===r.strict&&n<he[2])throw new Error(`${se} integer encoded in more bytes than necessary (strict decode)`);return n}function ye(t,e,r){ue(t,e,8);const n=16777216*t[e]+(t[e+1]<<16)+(t[e+2]<<8)+t[e+3],i=16777216*t[e+4]+(t[e+5]<<16)+(t[e+6]<<8)+t[e+7],o=(BigInt(n)<<BigInt(32))+BigInt(i);if(!0===r.strict&&o<he[3])throw new Error(`${se} integer encoded in more bytes than necessary (strict decode)`);if(o<=Number.MAX_SAFE_INTEGER)return Number(o);if(!0===r.allowBigInt)return o;throw new Error(`${se} integers outside of the safe integer range are not supported`)}function pe(t,e){return ge(t,0,e.value)}function ge(t,e,r){if(r<he[0]){const n=Number(r);t.push([e|n])}else if(r<he[1]){const n=Number(r);t.push([24|e,n])}else if(r<he[2]){const n=Number(r);t.push([25|e,n>>>8,255&n])}else if(r<he[3]){const n=Number(r);t.push([26|e,n>>>24&255,n>>>16&255,n>>>8&255,255&n])}else{const n=BigInt(r);if(!(n<he[4]))throw new Error(`${se} encountered BigInt larger than allowable range`);{const r=[27|e,0,0,0,0,0,0,0];let i=Number(n&BigInt(4294967295)),o=Number(n>>BigInt(32)&BigInt(4294967295));r[8]=255&i,i>>=8,r[7]=255&i,i>>=8,r[6]=255&i,i>>=8,r[5]=255&i,r[4]=255&o,o>>=8,r[3]=255&o,o>>=8,r[2]=255&o,o>>=8,r[1]=255&o,t.push(r)}}}pe.encodedSize=function(t){return ge.encodedSize(t.value)},ge.encodedSize=function(t){return t<he[0]?1:t<he[1]?2:t<he[2]?3:t<he[3]?5:9},pe.compareTokens=function(t,e){return t.value<e.value?-1:t.value>e.value?1:0};const we=BigInt(-1),be=BigInt(1);function me(t,e){const r=e.value,n="bigint"==typeof r?r*we-be:-1*r-1;ge(t,e.type.majorEncoded,n)}function ve(t,e,r,n){ue(t,e,r+n);const i=Xt(t,e+r,e+r+n);return new zt(jt.bytes,i,r+n)}function Ee(t,e,r,n){return ve(t,e,1,r)}function xe(t){return void 0===t.encodedBytes&&(t.encodedBytes=t.type===jt.string?Yt(t.value):t.value),t.encodedBytes}function Be(t,e){const r=xe(e);ge(t,e.type.majorEncoded,r.length),t.push(r)}function Ae(t,e,r,n,i){const o=r+n;ue(t,e,o);const s=new zt(jt.string,Zt(t,e+r,e+o),o);return!0===i.retainStringBytes&&(s.byteValue=Xt(t,e+r,e+o)),s}function ke(t,e,r,n){return Ae(t,e,1,r,n)}me.encodedSize=function(t){const e=t.value,r="bigint"==typeof e?e*we-be:-1*e-1;return r<he[0]?1:r<he[1]?2:r<he[2]?3:r<he[3]?5:9},me.compareTokens=function(t,e){return t.value<e.value?1:t.value>e.value?-1:0},Be.encodedSize=function(t){const e=xe(t);return ge.encodedSize(e.length)+e.length},Be.compareTokens=function(t,e){return r=xe(t),n=xe(e),r.length<n.length?-1:r.length>n.length?1:function(t,e){if(Jt(t)&&Jt(e))return t.compare(e);for(let r=0;r<t.length;r++)if(t[r]!==e[r])return t[r]<e[r]?-1:1;return 0}(r,n);var r,n};const Se=Be;function Ie(t,e,r,n){return new zt(jt.array,n,r)}function Te(t,e,r,n){return Ie(0,0,1,r)}function Ce(t,e){ge(t,jt.array.majorEncoded,e.value)}function Ue(t,e,r,n){return new zt(jt.map,n,r)}function Le(t,e,r,n){return Ue(0,0,1,r)}function Ne(t,e){ge(t,jt.map.majorEncoded,e.value)}function Oe(t,e,r,n){return new zt(jt.tag,r,1)}function _e(t,e){ge(t,jt.tag.majorEncoded,e.value)}Ce.compareTokens=pe.compareTokens,Ce.encodedSize=function(t){return ge.encodedSize(t.value)},Ne.compareTokens=pe.compareTokens,Ne.encodedSize=function(t){return ge.encodedSize(t.value)},_e.compareTokens=pe.compareTokens,_e.encodedSize=function(t){return ge.encodedSize(t.value)};function Re(t,e,r){if(r){if(!1===r.allowNaN&&Number.isNaN(t))throw new Error(`${se} NaN values are not supported`);if(!1===r.allowInfinity&&(t===1/0||t===-1/0))throw new Error(`${se} Infinity values are not supported`)}return new zt(jt.float,t,e)}function De(t,e,r){const n=e.value;if(!1===n)t.push([20|jt.float.majorEncoded]);else if(!0===n)t.push([21|jt.float.majorEncoded]);else if(null===n)t.push([22|jt.float.majorEncoded]);else if(void 0===n)t.push([23|jt.float.majorEncoded]);else{let e,o=!1;r&&!0===r.float64||(He(n),e=$e(Pe,1),n===e||Number.isNaN(n)?(Pe[0]=249,t.push(Pe.slice(0,3)),o=!0):(Fe(n),e=je(Pe,1),n===e&&(Pe[0]=250,t.push(Pe.slice(0,5)),o=!0))),o||(i=n,Me.setFloat64(0,i,!1),e=ze(Pe,1),Pe[0]=251,t.push(Pe.slice(0,9)))}var i}De.encodedSize=function(t,e){const r=t.value;if(!1===r||!0===r||null==r)return 1;if(!e||!0!==e.float64){He(r);let t=$e(Pe,1);if(r===t||Number.isNaN(r))return 3;if(Fe(r),t=je(Pe,1),r===t)return 5}return 9};const Ve=new ArrayBuffer(9),Me=new DataView(Ve,1),Pe=new Uint8Array(Ve,0);function He(t){if(t===1/0)Me.setUint16(0,31744,!1);else if(t===-1/0)Me.setUint16(0,64512,!1);else if(Number.isNaN(t))Me.setUint16(0,32256,!1);else{Me.setFloat32(0,t);const e=Me.getUint32(0),r=(2139095040&e)>>23,n=8388607&e;if(255===r)Me.setUint16(0,31744,!1);else if(0===r)Me.setUint16(0,(2147483648&t)>>16|n>>13,!1);else{const t=r-127;t<-24?Me.setUint16(0,0):t<-14?Me.setUint16(0,(2147483648&e)>>16|1<<24+t,!1):Me.setUint16(0,(2147483648&e)>>16|t+15<<10|n>>13,!1)}}}function $e(t,e){if(t.length-e<2)throw new Error(`${se} not enough data for float16`);const r=(t[e]<<8)+t[e+1];if(31744===r)return 1/0;if(64512===r)return-1/0;if(32256===r)return NaN;const n=r>>10&31,i=1023&r;let o;return o=0===n?i*2**-24:31!==n?(i+1024)*2**(n-25):0===i?1/0:NaN,32768&r?-o:o}function Fe(t){Me.setFloat32(0,t,!1)}function je(t,e){if(t.length-e<4)throw new Error(`${se} not enough data for float32`);const r=(t.byteOffset||0)+e;return new DataView(t.buffer,r,4).getFloat32(0,!1)}function ze(t,e){if(t.length-e<8)throw new Error(`${se} not enough data for float64`);const r=(t.byteOffset||0)+e;return new DataView(t.buffer,r,8).getFloat64(0,!1)}function qe(t,e,r){throw new Error(`${se} encountered invalid minor (${r}) for major ${t[e]>>>5}`)}function Ke(t){return()=>{throw new Error(`${se} ${t}`)}}De.compareTokens=pe.compareTokens;const Ge=[];for(let t=0;t<=23;t++)Ge[t]=qe;Ge[24]=function(t,e,r,n){return new zt(jt.uint,le(t,e+1,n),2)},Ge[25]=function(t,e,r,n){return new zt(jt.uint,fe(t,e+1,n),3)},Ge[26]=function(t,e,r,n){return new zt(jt.uint,de(t,e+1,n),5)},Ge[27]=function(t,e,r,n){return new zt(jt.uint,ye(t,e+1,n),9)},Ge[28]=qe,Ge[29]=qe,Ge[30]=qe,Ge[31]=qe;for(let t=32;t<=55;t++)Ge[t]=qe;Ge[56]=function(t,e,r,n){return new zt(jt.negint,-1-le(t,e+1,n),2)},Ge[57]=function(t,e,r,n){return new zt(jt.negint,-1-fe(t,e+1,n),3)},Ge[58]=function(t,e,r,n){return new zt(jt.negint,-1-de(t,e+1,n),5)},Ge[59]=function(t,e,r,n){const i=ye(t,e+1,n);if("bigint"!=typeof i){const t=-1-i;if(t>=Number.MIN_SAFE_INTEGER)return new zt(jt.negint,t,9)}if(!0!==n.allowBigInt)throw new Error(`${se} integers outside of the safe integer range are not supported`);return new zt(jt.negint,we-BigInt(i),9)},Ge[60]=qe,Ge[61]=qe,Ge[62]=qe,Ge[63]=qe;for(let t=64;t<=87;t++)Ge[t]=Ee;Ge[88]=function(t,e,r,n){return ve(t,e,2,le(t,e+1,n))},Ge[89]=function(t,e,r,n){return ve(t,e,3,fe(t,e+1,n))},Ge[90]=function(t,e,r,n){return ve(t,e,5,de(t,e+1,n))},Ge[91]=function(t,e,r,n){const i=ye(t,e+1,n);if("bigint"==typeof i)throw new Error(`${se} 64-bit integer bytes lengths not supported`);return ve(t,e,9,i)},Ge[92]=qe,Ge[93]=qe,Ge[94]=qe,Ge[95]=Ke("indefinite length bytes/strings are not supported");for(let t=96;t<=119;t++)Ge[t]=ke;Ge[120]=function(t,e,r,n){return Ae(t,e,2,le(t,e+1,n),n)},Ge[121]=function(t,e,r,n){return Ae(t,e,3,fe(t,e+1,n),n)},Ge[122]=function(t,e,r,n){return Ae(t,e,5,de(t,e+1,n),n)},Ge[123]=function(t,e,r,n){const i=ye(t,e+1,n);if("bigint"==typeof i)throw new Error(`${se} 64-bit integer string lengths not supported`);return Ae(t,e,9,i,n)},Ge[124]=qe,Ge[125]=qe,Ge[126]=qe,Ge[127]=Ke("indefinite length bytes/strings are not supported");for(let t=128;t<=151;t++)Ge[t]=Te;Ge[152]=function(t,e,r,n){return Ie(0,0,2,le(t,e+1,n))},Ge[153]=function(t,e,r,n){return Ie(0,0,3,fe(t,e+1,n))},Ge[154]=function(t,e,r,n){return Ie(0,0,5,de(t,e+1,n))},Ge[155]=function(t,e,r,n){const i=ye(t,e+1,n);if("bigint"==typeof i)throw new Error(`${se} 64-bit integer array lengths not supported`);return Ie(0,0,9,i)},Ge[156]=qe,Ge[157]=qe,Ge[158]=qe,Ge[159]=function(t,e,r,n){if(!1===n.allowIndefinite)throw new Error(`${se} indefinite length items not allowed`);return Ie(0,0,1,1/0)};for(let t=160;t<=183;t++)Ge[t]=Le;Ge[184]=function(t,e,r,n){return Ue(0,0,2,le(t,e+1,n))},Ge[185]=function(t,e,r,n){return Ue(0,0,3,fe(t,e+1,n))},Ge[186]=function(t,e,r,n){return Ue(0,0,5,de(t,e+1,n))},Ge[187]=function(t,e,r,n){const i=ye(t,e+1,n);if("bigint"==typeof i)throw new Error(`${se} 64-bit integer map lengths not supported`);return Ue(0,0,9,i)},Ge[188]=qe,Ge[189]=qe,Ge[190]=qe,Ge[191]=function(t,e,r,n){if(!1===n.allowIndefinite)throw new Error(`${se} indefinite length items not allowed`);return Ue(0,0,1,1/0)};for(let t=192;t<=215;t++)Ge[t]=Oe;Ge[216]=function(t,e,r,n){return new zt(jt.tag,le(t,e+1,n),2)},Ge[217]=function(t,e,r,n){return new zt(jt.tag,fe(t,e+1,n),3)},Ge[218]=function(t,e,r,n){return new zt(jt.tag,de(t,e+1,n),5)},Ge[219]=function(t,e,r,n){return new zt(jt.tag,ye(t,e+1,n),9)},Ge[220]=qe,Ge[221]=qe,Ge[222]=qe,Ge[223]=qe;for(let t=224;t<=243;t++)Ge[t]=Ke("simple values are not supported");Ge[244]=qe,Ge[245]=qe,Ge[246]=qe,Ge[247]=function(t,e,r,n){if(!1===n.allowUndefined)throw new Error(`${se} undefined values are not supported`);return!0===n.coerceUndefinedToNull?new zt(jt.null,null,1):new zt(jt.undefined,void 0,1)},Ge[248]=Ke("simple values are not supported"),Ge[249]=function(t,e,r,n){return Re($e(t,e+1),3,n)},Ge[250]=function(t,e,r,n){return Re(je(t,e+1),5,n)},Ge[251]=function(t,e,r,n){return Re(ze(t,e+1),9,n)},Ge[252]=qe,Ge[253]=qe,Ge[254]=qe,Ge[255]=function(t,e,r,n){if(!1===n.allowIndefinite)throw new Error(`${se} indefinite length items not allowed`);return new zt(jt.break,void 0,1)};const Je=[];for(let t=0;t<24;t++)Je[t]=new zt(jt.uint,t,1);for(let t=-1;t>=-24;t--)Je[31-t]=new zt(jt.negint,t,1);Je[64]=new zt(jt.bytes,new Uint8Array(0),1),Je[96]=new zt(jt.string,"",1),Je[128]=new zt(jt.array,0,1),Je[160]=new zt(jt.map,0,1),Je[244]=new zt(jt.false,!1,1),Je[245]=new zt(jt.true,!0,1),Je[246]=new zt(jt.null,null,1);const We={float64:!1,mapSorter:function(t,e){const r=Array.isArray(t[0])?t[0][0]:t[0],n=Array.isArray(e[0])?e[0][0]:e[0];if(r.type!==n.type)return r.type.compare(n.type);const i=r.type.major,o=Ze[i].compareTokens(r,n);return 0===o&&console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone"),o},quickEncodeToken:function(t){switch(t.type){case jt.false:return Qt([244]);case jt.true:return Qt([245]);case jt.null:return Qt([246]);case jt.bytes:return t.value.length?void 0:Qt([64]);case jt.string:return""===t.value?Qt([96]):void 0;case jt.array:return 0===t.value?Qt([128]):void 0;case jt.map:return 0===t.value?Qt([160]):void 0;case jt.uint:return t.value<24?Qt([Number(t.value)]):void 0;case jt.negint:if(t.value>=-24)return Qt([31-Number(t.value)])}}},Ze=function(){const t=[];return t[jt.uint.major]=pe,t[jt.negint.major]=me,t[jt.bytes.major]=Be,t[jt.string.major]=Se,t[jt.array.major]=Ce,t[jt.map.major]=Ne,t[jt.tag.major]=_e,t[jt.float.major]=De,t}(),Ye=new oe;class Qe{constructor(t,e){this.obj=t,this.parent=e}includes(t){let e=this;do{if(e.obj===t)return!0}while(e=e.parent);return!1}static createCheck(t,e){if(t&&t.includes(e))throw new Error(`${ae} object contains circular references`);return new Qe(e,t)}}const Xe={null:new zt(jt.null,null),undefined:new zt(jt.undefined,void 0),true:new zt(jt.true,!0),false:new zt(jt.false,!1),emptyArray:new zt(jt.array,0),emptyMap:new zt(jt.map,0)},tr={number:(t,e,r,n)=>Number.isInteger(t)&&Number.isSafeInteger(t)?new zt(t>=0?jt.uint:jt.negint,t):new zt(jt.float,t),bigint:(t,e,r,n)=>t>=BigInt(0)?new zt(jt.uint,t):new zt(jt.negint,t),Uint8Array:(t,e,r,n)=>new zt(jt.bytes,t),string:(t,e,r,n)=>new zt(jt.string,t),boolean:(t,e,r,n)=>t?Xe.true:Xe.false,null:(t,e,r,n)=>Xe.null,undefined:(t,e,r,n)=>Xe.undefined,ArrayBuffer:(t,e,r,n)=>new zt(jt.bytes,new Uint8Array(t)),DataView:(t,e,r,n)=>new zt(jt.bytes,new Uint8Array(t.buffer,t.byteOffset,t.byteLength)),Array(t,e,r,n){if(!t.length)return!0===r.addBreakTokens?[Xe.emptyArray,new zt(jt.break)]:Xe.emptyArray;n=Qe.createCheck(n,t);const i=[];let o=0;for(const e of t)i[o++]=er(e,r,n);return r.addBreakTokens?[new zt(jt.array,t.length),i,new zt(jt.break)]:[new zt(jt.array,t.length),i]},Object(t,e,r,n){const i="Object"!==e,o=i?t.keys():Object.keys(t),s=i?t.size:o.length;if(!s)return!0===r.addBreakTokens?[Xe.emptyMap,new zt(jt.break)]:Xe.emptyMap;n=Qe.createCheck(n,t);const a=[];let c=0;for(const e of o)a[c++]=[er(e,r,n),er(i?t.get(e):t[e],r,n)];return function(t,e){e.mapSorter&&t.sort(e.mapSorter)}(a,r),r.addBreakTokens?[new zt(jt.map,s),a,new zt(jt.break)]:[new zt(jt.map,s),a]}};tr.Map=tr.Object,tr.Buffer=tr.Uint8Array;for(const t of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))tr[`${t}Array`]=tr.DataView;function er(t,e={},r){const n=function(t){if(null===t)return"null";if(void 0===t)return"undefined";if(!0===t||!1===t)return"boolean";const e=typeof t;if($t.includes(e))return e;if("function"===e)return"Function";if(Array.isArray(t))return"Array";if(function(t){return t&&t.constructor&&t.constructor.isBuffer&&t.constructor.isBuffer.call(null,t)}(t))return"Buffer";return function(t){const e=Object.prototype.toString.call(t).slice(8,-1);if(Ft.includes(e))return e}(t)||"Object"}(t),i=e&&e.typeEncoders&&e.typeEncoders[n]||tr[n];if("function"==typeof i){const o=i(t,n,e,r);if(null!=o)return o}const o=tr[n];if(!o)throw new Error(`${ae} unsupported type: ${n}`);return o(t,n,e,r)}function rr(t,e,r,n){if(Array.isArray(e))for(const i of e)rr(t,i,r,n);else r[e.type.major](t,e,n)}function nr(t,e,r){const n=er(t,r);if(!Array.isArray(n)&&r.quickEncodeToken){const t=r.quickEncodeToken(n);if(t)return t;const i=e[n.type.major];if(i.encodedSize){const t=i.encodedSize(n,r),e=new oe(t);if(i(e,n,r),1!==e.chunks.length)throw new Error(`Unexpected error: pre-calculated length for ${n} was wrong`);return Wt(e.chunks[0])}}return Ye.reset(),rr(Ye,n,e,r),Ye.toBytes(!0)}const ir={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0};class or{constructor(t,e={}){this._pos=0,this.data=t,this.options=e}pos(){return this._pos}done(){return this._pos>=this.data.length}next(){const t=this.data[this._pos];let e=Je[t];if(void 0===e){const r=Ge[t];if(!r)throw new Error(`${se} no decoder for major type ${t>>>5} (byte 0x${t.toString(16).padStart(2,"0")})`);const n=31&t;e=r(this.data,this._pos,n,this.options)}return this._pos+=e.encodedLength,e}}const sr=Symbol.for("DONE"),ar=Symbol.for("BREAK");function cr(t,e){if(t.done())return sr;const r=t.next();if(r.type===jt.break)return ar;if(r.type.terminal)return r.value;if(r.type===jt.array)return function(t,e,r){const n=[];for(let i=0;i<t.value;i++){const o=cr(e,r);if(o===ar){if(t.value===1/0)break;throw new Error(`${se} got unexpected break to lengthed array`)}if(o===sr)throw new Error(`${se} found array but not enough entries (got ${i}, expected ${t.value})`);n[i]=o}return n}(r,t,e);if(r.type===jt.map)return function(t,e,r){const n=!0===r.useMaps,i=n?void 0:{},o=n?new Map:void 0;for(let s=0;s<t.value;s++){const a=cr(e,r);if(a===ar){if(t.value===1/0)break;throw new Error(`${se} got unexpected break to lengthed map`)}if(a===sr)throw new Error(`${se} found map but not enough entries (got ${s} [no key], expected ${t.value})`);if(!0!==n&&"string"!=typeof a)throw new Error(`${se} non-string keys not supported (got ${typeof a})`);if(!0===r.rejectDuplicateMapKeys&&(n&&o.has(a)||!n&&a in i))throw new Error(`${se} found repeat map key "${a}"`);const c=cr(e,r);if(c===sr)throw new Error(`${se} found map but not enough entries (got ${s} [no value], expected ${t.value})`);n?o.set(a,c):i[a]=c}return n?o:i}(r,t,e);if(r.type===jt.tag){if(e.tags&&"function"==typeof e.tags[r.value]){const n=cr(t,e);return e.tags[r.value](n)}throw new Error(`${se} tag not supported (${r.value})`)}throw new Error("unsupported")}function ur(t,e){const[r,n]=function(t,e){if(!(t instanceof Uint8Array))throw new Error(`${se} data to decode must be a Uint8Array`);const r=(e=Object.assign({},ir,e)).tokenizer||new or(t,e),n=cr(r,e);if(n===sr)throw new Error(`${se} did not find any content to decode`);if(n===ar)throw new Error(`${se} got unexpected break`);return[n,t.subarray(r.pos())]}(t,e);if(n.length>0)throw new Error(`${se} too many terminals, data makes no sense`);return r}function hr(t){if(t instanceof Uint8Array&&"Uint8Array"===t.constructor.name)return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")}new Uint8Array(0);const lr=function(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var i=0;i<t.length;i++){var o=t.charAt(i),s=o.charCodeAt(0);if(255!==r[s])throw new TypeError(o+" is ambiguous");r[s]=i}var a=t.length,c=t.charAt(0),u=Math.log(a)/Math.log(256),h=Math.log(256)/Math.log(a);function l(t){if("string"!=typeof t)throw new TypeError("Expected String");if(0===t.length)return new Uint8Array;var e=0;if(" "!==t[e]){for(var n=0,i=0;t[e]===c;)n++,e++;for(var o=(t.length-e)*u+1>>>0,s=new Uint8Array(o);t[e];){var h=r[t.charCodeAt(e)];if(255===h)return;for(var l=0,f=o-1;(0!==h||l<i)&&-1!==f;f--,l++)h+=a*s[f]>>>0,s[f]=h%256>>>0,h=h/256>>>0;if(0!==h)throw new Error("Non-zero carry");i=l,e++}if(" "!==t[e]){for(var d=o-i;d!==o&&0===s[d];)d++;for(var y=new Uint8Array(n+(o-d)),p=n;d!==o;)y[p++]=s[d++];return y}}}return{encode:function(e){if(e instanceof Uint8Array||(ArrayBuffer.isView(e)?e=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):Array.isArray(e)&&(e=Uint8Array.from(e))),!(e instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===e.length)return"";for(var r=0,n=0,i=0,o=e.length;i!==o&&0===e[i];)i++,r++;for(var s=(o-i)*h+1>>>0,u=new Uint8Array(s);i!==o;){for(var l=e[i],f=0,d=s-1;(0!==l||f<n)&&-1!==d;d--,f++)l+=256*u[d]>>>0,u[d]=l%a>>>0,l=l/a>>>0;if(0!==l)throw new Error("Non-zero carry");n=f,i++}for(var y=s-n;y!==s&&0===u[y];)y++;for(var p=c.repeat(r);y<s;++y)p+=t.charAt(u[y]);return p},decodeUnsafe:l,decode:function(t){var r=l(t);if(r)return r;throw new Error(`Non-${e} character`)}}};class fr{name;prefix;baseEncode;constructor(t,e,r){this.name=t,this.prefix=e,this.baseEncode=r}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}}class dr{name;prefix;baseDecode;prefixCodePoint;constructor(t,e,r){if(this.name=t,this.prefix=e,void 0===e.codePointAt(0))throw new Error("Invalid prefix character");this.prefixCodePoint=e.codePointAt(0),this.baseDecode=r}decode(t){if("string"==typeof t){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(t){return pr(this,t)}}class yr{decoders;constructor(t){this.decoders=t}or(t){return pr(this,t)}decode(t){const e=t[0],r=this.decoders[e];if(null!=r)return r.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function pr(t,e){return new yr({...t.decoders??{[t.prefix]:t},...e.decoders??{[e.prefix]:e}})}class gr{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(t,e,r,n){this.name=t,this.prefix=e,this.baseEncode=r,this.baseDecode=n,this.encoder=new fr(t,e,r),this.decoder=new dr(t,e,n)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}}function wr({name:t,prefix:e,encode:r,decode:n}){return new gr(t,e,r,n)}function br({name:t,prefix:e,alphabet:r}){const{encode:n,decode:i}=lr(r,t);return wr({prefix:e,name:t,encode:n,decode:t=>hr(i(t))})}function mr({name:t,prefix:e,bitsPerChar:r,alphabet:n}){return wr({prefix:e,name:t,encode:t=>function(t,e,r){const n="="===e[e.length-1],i=(1<<r)-1;let o="",s=0,a=0;for(let n=0;n<t.length;++n)for(a=a<<8|t[n],s+=8;s>r;)s-=r,o+=e[i&a>>s];if(0!==s&&(o+=e[i&a<<r-s]),n)for(;0!=(o.length*r&7);)o+="=";return o}(t,n,r),decode:e=>function(t,e,r,n){const i={};for(let t=0;t<e.length;++t)i[e[t]]=t;let o=t.length;for(;"="===t[o-1];)--o;const s=new Uint8Array(o*r/8|0);let a=0,c=0,u=0;for(let e=0;e<o;++e){const o=i[t[e]];if(void 0===o)throw new SyntaxError(`Non-${n} character`);c=c<<r|o,a+=r,a>=8&&(a-=8,s[u++]=255&c>>a)}if(a>=r||0!=(255&c<<8-a))throw new SyntaxError("Unexpected end of data");return s}(e,n,r,t)})}const vr=mr({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Er=(mr({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),mr({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),mr({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),mr({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),mr({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),mr({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),mr({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),mr({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),br({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}));br({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var xr=128,Br=-128,Ar=Math.pow(2,31),kr=128,Sr=127,Ir=Math.pow(2,7),Tr=Math.pow(2,14),Cr=Math.pow(2,21),Ur=Math.pow(2,28),Lr=Math.pow(2,35),Nr=Math.pow(2,42),Or=Math.pow(2,49),_r=Math.pow(2,56),Rr=Math.pow(2,63);const Dr={encode:function t(e,r,n){r=r||[];for(var i=n=n||0;e>=Ar;)r[n++]=255&e|xr,e/=128;for(;e&Br;)r[n++]=255&e|xr,e>>>=7;return r[n]=0|e,t.bytes=n-i+1,r},decode:function t(e,r){var n,i=0,o=0,s=r=r||0,a=e.length;do{if(s>=a)throw t.bytes=0,new RangeError("Could not decode varint");n=e[s++],i+=o<28?(n&Sr)<<o:(n&Sr)*Math.pow(2,o),o+=7}while(n>=kr);return t.bytes=s-r,i},encodingLength:function(t){return t<Ir?1:t<Tr?2:t<Cr?3:t<Ur?4:t<Lr?5:t<Nr?6:t<Or?7:t<_r?8:t<Rr?9:10}};function Vr(t,e=0){return[Dr.decode(t,e),Dr.decode.bytes]}function Mr(t,e,r=0){return Dr.encode(t,e,r),e}function Pr(t){return Dr.encodingLength(t)}class Hr{code;size;digest;bytes;constructor(t,e,r,n){this.code=t,this.size=e,this.digest=r,this.bytes=n}}function $r(t,e){const{bytes:r,version:n}=t;return 0===n?function(t,e,r){const{prefix:n}=r;if(n!==Er.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);const i=e.get(n);if(null==i){const i=r.encode(t).slice(1);return e.set(n,i),i}return i}(r,jr(t),e??Er.encoder):function(t,e,r){const{prefix:n}=r,i=e.get(n);if(null==i){const i=r.encode(t);return e.set(n,i),i}return i}(r,jr(t),e??vr.encoder)}const Fr=new WeakMap;function jr(t){const e=Fr.get(t);if(null==e){const e=new Map;return Fr.set(t,e),e}return e}class zr{code;version;multihash;bytes;"/";constructor(t,e,r,n){this.code=e,this.version=t,this.multihash=r,this.bytes=n,this["/"]=n}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:t,multihash:e}=this;if(t!==qr)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==Kr)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return zr.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:t,digest:e}=this.multihash,r=function(t,e){const r=e.byteLength,n=Pr(t),i=n+Pr(r),o=new Uint8Array(i+r);return Mr(t,o,0),Mr(r,o,n),o.set(e,i),new Hr(t,r,e,o)}(t,e);return zr.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return zr.equals(this,t)}static equals(t,e){const r=e;return null!=r&&t.code===r.code&&t.version===r.version&&function(t,e){if(t===e)return!0;{const r=e;return t.code===r.code&&t.size===r.size&&r.bytes instanceof Uint8Array&&function(t,e){if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0}(t.bytes,r.bytes)}}(t.multihash,r.multihash)}toString(t){return $r(this,t)}toJSON(){return{"/":$r(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(null==t)return null;const e=t;if(e instanceof zr)return e;if(null!=e["/"]&&e["/"]===e.bytes||e.asCID===e){const{version:t,code:r,multihash:n,bytes:i}=e;return new zr(t,r,n,i??Gr(t,r,n.bytes))}if(!0===e[Jr]){const{version:t,multihash:r,code:n}=e,i=function(t){const e=hr(t),[r,n]=Vr(e),[i,o]=Vr(e.subarray(n)),s=e.subarray(n+o);if(s.byteLength!==i)throw new Error("Incorrect length");return new Hr(r,i,s,e)}(r);return zr.create(t,n,i)}return null}static create(t,e,r){if("number"!=typeof e)throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:if(e!==qr)throw new Error(`Version 0 CID must use dag-pb (code: ${qr}) block encoding`);return new zr(t,e,r,r.bytes);case 1:{const n=Gr(t,e,r.bytes);return new zr(t,e,r,n)}default:throw new Error("Invalid version")}}static createV0(t){return zr.create(0,qr,t)}static createV1(t,e){return zr.create(1,t,e)}static decode(t){const[e,r]=zr.decodeFirst(t);if(0!==r.length)throw new Error("Incorrect length");return e}static decodeFirst(t){const e=zr.inspectBytes(t),r=e.size-e.multihashSize,n=hr(t.subarray(r,r+e.multihashSize));if(n.byteLength!==e.multihashSize)throw new Error("Incorrect length");const i=n.subarray(e.multihashSize-e.digestSize),o=new Hr(e.multihashCode,e.digestSize,i,n);return[0===e.version?zr.createV0(o):zr.createV1(e.codec,o),t.subarray(e.size)]}static inspectBytes(t){let e=0;const r=()=>{const[r,n]=Vr(t.subarray(e));return e+=n,r};let n=r(),i=qr;if(18===n?(n=0,e=0):i=r(),0!==n&&1!==n)throw new RangeError(`Invalid CID version ${n}`);const o=e,s=r(),a=r(),c=e+a;return{version:n,codec:i,multihashCode:s,digestSize:a,multihashSize:c-o,size:c}}static parse(t,e){const[r,n]=function(t,e){switch(t[0]){case"Q":{const r=e??Er;return[Er.prefix,r.decode(`${Er.prefix}${t}`)]}case Er.prefix:{const r=e??Er;return[Er.prefix,r.decode(t)]}case vr.prefix:{const r=e??vr;return[vr.prefix,r.decode(t)]}default:if(null==e)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[t[0],e.decode(t)]}}(t,e),i=zr.decode(n);if(0===i.version&&"Q"!==t[0])throw Error("Version 0 CID string must not include multibase prefix");return jr(i).set(r,t),i}}const qr=112,Kr=18;function Gr(t,e,r){const n=Pr(t),i=n+Pr(e),o=new Uint8Array(i+r.byteLength);return Mr(t,o,0),Mr(e,o,n),o.set(r,i),o}const Jr=Symbol.for("@ipld/js-cid/CID");function Wr(t){return t instanceof ArrayBuffer?new Uint8Array(t,0,t.byteLength):t}const Zr={float64:!0,typeEncoders:{Object:function(t){if(t.asCID!==t&&t["/"]!==t.bytes)return null;const e=zr.asCID(t);if(!e)return null;const r=new Uint8Array(e.bytes.byteLength+1);return r.set(e.bytes,1),[new zt(jt.tag,42),new zt(jt.bytes,r)]},undefined:function(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")},number:function(t){if(Number.isNaN(t))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(t===1/0||t===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}}},Yr={...Zr,typeEncoders:{...Zr.typeEncoders}},Qr={allowIndefinite:!1,coerceUndefinedToNull:!0,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,rejectDuplicateMapKeys:!0,tags:[]};Qr.tags[42]=function(t){if(0!==t[0])throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");return zr.decode(t.subarray(1))};const Xr={...Qr,tags:Qr.tags.slice()},tn="dag-cbor",en=113,rn=t=>{return e=t,r=Zr,r=Object.assign({},We,r),nr(e,Ze,r);var e,r},nn=t=>ur(Wr(t),Qr),on=t=>async e=>new Uint8Array(await crypto.subtle.digest(t,e)),sn=Lt({name:"sha2-256",code:18,encode:on("SHA-256")}),an=(Lt({name:"sha2-512",code:19,encode:on("SHA-512")}),t),cn=sn,un=X,hn=t=>t&&void 0!==t.id&&void 0!==t.next&&void 0!==t.payload&&void 0!==t.v&&void 0!==t.clock&&void 0!==t.refs,ln=async t=>{const{cid:e,bytes:r}=await Pt({value:t,codec:an,hasher:cn}),n=e.toString(un),i=$(t.clock.id,t.clock.time);return{...t,clock:i,hash:n,bytes:r}},fn={create:async(t,e,r,n=null,i=[],o=[])=>{if(null==t)throw new Error("Identity is required, cannot create entry");if(null==e)throw new Error("Entry requires an id");if(null==r)throw new Error("Entry requires a payload");if(null==i||!Array.isArray(i))throw new Error("'next' argument is not an array");const s={id:e,payload:r,next:i,refs:o,clock:n=n||$(t.publicKey),v:2},{bytes:a}=await Pt({value:s,codec:an,hasher:cn}),c=await t.sign(t,a);return s.key=t.publicKey,s.identity=t.hash,s.sig=c,ln(s)},verify:async(t,e)=>{if(!t)throw new Error("Identities is required, cannot verify entry");if(!hn(e))throw new Error("Invalid Log entry");if(!e.key)throw new Error("Entry doesn't have a key");if(!e.sig)throw new Error("Entry doesn't have a signature");const r={id:e.id,payload:e.payload,next:e.next,refs:e.refs,clock:e.clock,v:e.v},{bytes:n}=await Pt({value:r,codec:an,hasher:cn});return t.verify(e.sig,e.key,n)},decode:async t=>{const{cid:e,value:r}=await Ht({bytes:t,codec:an,hasher:cn});return{...r,hash:e.toString(un),bytes:t}},encode:ln,isEntry:hn,isEqual:(t,e)=>t&&e&&t.hash===e.hash},dn=async()=>{let t={};const e=async(e,r)=>{t[e]=r};return{put:e,del:async e=>{delete t[e]},get:async e=>t[e],iterator:async function*(){for await(const[e,r]of Object.entries(t))yield[e,r]},merge:async t=>{if(t)for await(const[r,n]of t.iterator())e(r,n)},clear:async()=>{t={}},close:async()=>{}}},yn=dn,pn=t=>{t=new Set(t);const e={};for(const r of t)for(const t of r.next)e[t]=r.hash;const r=[];for(const n of t)e[n.hash]||r.push(n);return r};function gn(t,e,r){const n=((t,e)=>{const r=t.time-e.time;return 0===r&&t.id!==e.id?t.id<e.id?-1:1:r})(t.clock,e.clock);return 0===n?r(t,e):n}function wn(t,e,r){return t.clock.id===e.clock.id?r(t,e):t.clock.id<e.clock.id?-1:1}const bn={SortByClocks:gn,SortByClockId:wn,LastWriteWins:function(t,e){const r=(t,e)=>t,n=(t,e)=>wn(t,e,r);return((t,e)=>gn(t,e,n))(t,e)},NoZeroes:function(t){const e=`Your log's tiebreaker function, ${t.name}, has returned zero and therefore cannot be`;return(r,n)=>{const i=t(r,n);if(0===i)throw Error(e);return i}}},{LastWriteWins:mn,NoZeroes:vn}=bn,En=(t,e)=>Math.max(t,e.clock.time),xn=dn,Bn=async()=>({canAppend:async t=>!0}),An=async(t,{logId:e,logHeads:r,access:n,entryStorage:i,headsStorage:o,indexStorage:s,sortFn:a}={})=>{if(null==t)throw new Error("Identity is required");if(null!=r&&!Array.isArray(r))throw new Error("'logHeads' argument must be an array");const c=e||(new Date).getTime().toString();n=n||await Bn();const u=i||await xn(),h=s||await xn();o=o||await xn();const l=await(async({storage:t,heads:e})=>{t=t||await yn();const r=async e=>{e=pn(e);for(const r of e)await t.put(r.hash,r.bytes)},n=async e=>{await t.clear(),await r(e)},i=async function*(){const e=t.iterator();for await(const[,t]of e){const e=await fn.decode(t);yield e}},o=async()=>{const t=[];for await(const e of i())t.push(e);return t};return await r(e||[]),{put:r,set:n,add:async t=>{const e=await o();if(e.find((e=>fn.isEqual(e,t))))return;const r=pn([...e,t]);return await n(r),r},remove:async t=>{const e=(await o()).filter((e=>e.hash!==t));await n(e)},iterator:i,all:o,clear:async()=>{await t.clear()},close:async()=>{await t.close()}}})({storage:o,heads:r});a=vn(a||mn);const f=new k({concurrency:1}),d=new k({concurrency:1}),y=async()=>{const e=Math.max(0,(await p()).reduce(En,0));return $(t.publicKey,e)},p=async()=>(await l.all()).sort(a).reverse(),g=async()=>{const t=[];for await(const e of v())t.unshift(e);return t},w=async t=>{const e=await u.get(t);if(e)return await fn.decode(e)},b=async t=>null!=await h.get(t),m=async e=>d.add((async()=>{if(await b(e.hash))return!1;const r=async e=>{if(e.id!==c)throw new Error(`Entry's id (${e.id}) doesn't match the log's id (${c}).`);if(!await n.canAppend(e))throw new Error(`Could not append entry:\nKey "${e.identity}" is not allowed to write to the log`);if(!await fn.verify(t,e))throw new Error(`Could not validate signature for entry "${e.hash}"`)};await r(e);const i=(await p()).map((t=>t.hash)),o=new Set([e.hash]),s=new Set([...e.next,...e.refs]),a=new Set,f=async()=>{const t=Array.from(s.values()).filter(b).map(w),e=await Promise.all(t);for(const t of e){s.delete(t.hash),await r(t),o.add(t.hash);for(const e of[...t.next,...t.refs])await b(e)||o.has(e)?i.includes(e)&&a.add(e):s.add(e)}s.size>0&&await f()};await f();for(const t of o.values())await h.put(t,!0);for(const t of a.values())await l.remove(t);return await u.put(e.hash,e.bytes),await l.add(e),!0})),v=async function*(t,e){e=e||(()=>!1);let r=(t=t||await p()).sort(a);const n={};let i=[];const o={},s=t=>!(n[t]||o[t]);let c;for(;r.length>0;)if(r=r.sort(a),c=r.pop(),c){const{hash:t,next:a}=c;if(!n[t]){if(yield c,!0===await e(c))break;n[t]=!0,o[t]=!0,i=[...i,...a].filter(s);const u=t=>{if(!n[t]&&!o[t])return o[t]=!0,w(t)},h=await Promise.all(i.map(u));i=h.filter((t=>null!=t)).reduce(((t,e)=>Array.from(new Set([...t,...e.next]))),[]).filter(s),r=[...h,...r]}}};return{id:c,clock:y,heads:p,values:g,all:g,get:w,has:b,append:async(e,r={referencesCount:0})=>f.add((async()=>{const i=await p(),o=i.map((t=>t.hash)),s=await(async(t,e=0)=>{let r=[];const n=async t=>r.length>=e&&-1!==e;for await(const{hash:e}of v(t,n))r.push(e);return r=r.slice(t.length+1,e),r})(i,r.referencesCount+i.length),a=await fn.create(t,c,e,(t=>$(t.id,++t.time))(await y()),o,s);if(!await n.canAppend(a))throw new Error(`Could not append entry:\nKey "${t.hash}" is not allowed to write to the log`);return await l.set([a]),await u.put(a.hash,a.bytes),await h.put(a.hash,!0),a})),join:async t=>{if(!t)throw new Error("Log instance not defined");if(!(e=t)||void 0===e.id||void 0===e.clock||void 0===e.heads||void 0===e.values||void 0===e.access||void 0===e.identity||void 0===e.storage)throw new Error("Given argument is not an instance of Log");var e;u.merge&&await u.merge(t.storage);const r=await t.heads();for(const t of r)await m(t)},joinEntry:m,traverse:v,iterator:async function*({amount:t=-1,gt:e,gte:r,lt:n,lte:i}={}){if(0===t)return;if("string"==typeof i&&(i=[await w(i)]),"string"==typeof n){const t=await w(n);n=await Promise.all(t.next.map((t=>w(t))))}if(null!=n&&!Array.isArray(n))throw new Error("lt must be a string or an array of Entries");if(null!=i&&!Array.isArray(i))throw new Error("lte must be a string or an array of Entries");const o=(n||i||await p()).filter((t=>null!=t)),s=e||r?await w(e||r):null,a=s||-1===t?-1:t;let c=0;const u=s&&-1!==t&&!n&&!i,h=u?new H(t+2):null;let l=0;const f=v(o,(async t=>(c++,!!t&&(c>=a&&-1!==a||!(!s||!fn.isEqual(t,s))))));for await(const t of f){const r=n&&fn.isEqual(t,o),i=e&&fn.isEqual(t,s);r||i||(u?h.set(l++,t.hash):yield t)}if(u){const e=h.keys.length,r=e>t?e-t:0,n=h.keys.slice(r,e);for(const t of n){const e=h.get(t),r=await w(e);yield r}}},clear:async()=>{await h.clear(),await l.clear(),await u.clear()},close:async()=>{await h.close(),await l.close(),await u.close()},access:n,identity:t,storage:u}},kn=async(t,e)=>({put:async(r,n)=>{await t.put(r,n),await e.put(r,n)},get:async r=>{let n=await t.get(r);return n||(n=await e.get(r),n&&await t.put(r,n)),n},del:async r=>{await t.del(r),await e.del(r)},iterator:async function*({amount:r,reverse:n}={}){const i=[],o={amount:r||-1,reverse:n||!1};for(const r of[t,e])for await(const[t,e]of r.iterator(o))i[t]||(i[t]=!0,yield[t,e])},merge:async r=>{await t.merge(r),await e.merge(r),await r.merge(t),await r.merge(e)},clear:async()=>{await t.clear(),await e.clear()},close:async()=>{await t.close(),await e.close()}}),Sn=async({ipfs:t,pin:e,timeout:r}={})=>{if(!t)throw new Error("An instance of ipfs is required.");return{put:async(n,i)=>{const o=Bt.parse(n,X),{signal:s}=new V.TimeoutController(r||3e4);await t.blockstore.put(o,i,{signal:s}),e&&!await t.pins.isPinned(o)&&await function(t){if(null!=t[Symbol.asyncIterator])return(async()=>{for await(const e of t);})();for(const e of t);}(t.pins.add(o))},del:async t=>{},get:async e=>{const n=Bt.parse(e,X),{signal:i}=new V.TimeoutController(r||3e4),o=await t.blockstore.get(n,{signal:i});if(o)return o},iterator:async function*(){},merge:async t=>{},clear:async()=>{},close:async()=>{}}};var In=r(301);const Tn=async({path:t,valueEncoding:e}={})=>{t=t||"./level",e=e||"view";const r=new In.Level(t,{valueEncoding:e,passive:!0});return await r.open(),{put:async(t,e)=>{await r.put(t,e)},del:async t=>{await r.del(t)},get:async t=>{try{const e=await r.get(t);if(e)return e}catch(t){}},iterator:async function*({amount:t,reverse:e}={}){const n={limit:t||-1,reverse:e||!1};for await(const[t,e]of r.iterator(n))yield[t,e]},merge:async t=>{},clear:async()=>{await r.clear()},close:async()=>{await r.close()}}},Cn=1e6,Un=async({size:t}={})=>{let e=new H(t||Cn);return{put:async(t,r)=>{e.set(t,r)},del:async t=>{e.remove(t)},get:async t=>e.get(t),iterator:async function*(){for await(const t of e.keys){const r=e.get(t);yield[t,r]}},merge:async t=>{if(t)for await(const[r,n]of t.iterator())e.set(r,n)},clear:async()=>{e=new H(t||Cn)},close:async()=>{}}},Ln=1e3,Nn=async({ipfs:t,identity:e,address:r,name:n,access:i,directory:o,meta:s,headsStorage:a,entryStorage:c,indexStorage:u,referencesCount:h,syncAutomatically:l,onUpdate:f})=>{o=P(o||"./orbitdb",`./${r}/`),s=s||{},h=Number(h)>-1?h:16,c=c||await kn(await Un({size:Ln}),await Sn({ipfs:t,pin:!0})),a=a||await kn(await Un({size:Ln}),await Tn({path:P(o,"/log/_heads/")})),u=u||await kn(await Un({size:Ln}),await Tn({path:P(o,"/log/_index/")}));const d=await An(e,{logId:r,access:i,entryStorage:c,headsStorage:a,indexStorage:u}),y=new b.EventEmitter,p=new k({concurrency:1}),g=await(async({ipfs:t,log:e,events:r,onSynced:n,start:i,timeout:o})=>{if(!t)throw new Error("An instance of ipfs is required.");if(!e)throw new Error("An instance of log is required.");const s=t.libp2p,a=t.libp2p.services.pubsub,c=e.id,u=P("/orbitdb/heads/",c),h=new k({concurrency:1}),l=new Set;r=r||new b.EventEmitter,o=o||3e4;let f=!1;const d=t=>async function*(){const t=await e.heads();for await(const{bytes:e}of t)yield e}(),y=t=>async i=>{for await(const t of i){const e=t.subarray();e&&n&&await n(e)}f&&await(async t=>{const n=await e.heads();r.emit("join",t,n)})(t)},p=async({connection:t,stream:e})=>{const n=String(t.remotePeer);try{l.add(n),await L(e,y(n),d,e)}catch(t){l.delete(n),r.emit("error",t)}},g=async t=>{h.add((async()=>{const{peerId:e,subscriptions:n}=t.detail,i=String(e),a=n.find((t=>t.topic===c));if(a)if(a.subscribe){if(l.has(i))return;const t=new V.TimeoutController(o),{signal:n}=t;try{l.add(i);const t=await s.dialProtocol(e,u,{signal:n});await L(d,t,y(i))}catch(t){console.error(t),l.delete(i),"ERR_UNSUPPORTED_PROTOCOL"===t.code||r.emit("error",t)}finally{t&&t.clear()}}else l.delete(i),r.emit("leave",i)}))},w=async t=>{const{topic:e,data:i}=t.detail;e===c&&h.add((async()=>{try{i&&n&&await n(i)}catch(t){r.emit("error",t)}}))},m=async()=>{f||(await s.handle(u,p),a.addEventListener("subscription-change",g),a.addEventListener("message",w),await a.subscribe(c),f=!0)};return!1!==i&&await m(),{add:async t=>{f&&await a.publish(c,t.bytes)},stop:async()=>{f&&(f=!1,await h.onIdle(),a.removeEventListener("subscription-change",g),a.removeEventListener("message",w),await s.unhandle(u),await a.unsubscribe(c),l.clear())},start:m,events:r,peers:l}})({ipfs:t,log:d,events:y,onSynced:async t=>{await p.add((async()=>{const e=await fn.decode(t);e&&await d.joinEntry(e)&&(f&&await f(d,e),y.emit("update",e))}))},start:l});return{address:r,name:n,identity:e,meta:s,close:async()=>{await g.stop(),await p.onIdle(),await d.close(),i&&i.close&&await i.close(),y.emit("close")},drop:async()=>{await p.onIdle(),await d.clear(),i&&i.drop&&await i.drop(),y.emit("drop")},addOperation:async t=>{const e=await p.add((async()=>{const e=await d.append(t,{referencesCount:h});return await g.add(e),f&&await f(d,e),y.emit("update",e),e.hash}));return await p.onIdle(),e},log:d,sync:g,peers:g.peers,events:y,access:i}},On="documents",_n={indexBy:"_id"},Rn=({indexBy:t}=_n)=>async({ipfs:e,identity:r,address:n,name:i,access:o,directory:s,meta:a,headsStorage:c,entryStorage:u,indexStorage:h,referencesCount:l,syncAutomatically:f,onUpdate:d})=>{const y=await Nn({ipfs:e,identity:r,address:n,name:i,access:o,directory:s,meta:a,headsStorage:c,entryStorage:u,indexStorage:h,referencesCount:l,syncAutomatically:f}),{addOperation:p,log:g}=y,w=async t=>{for await(const e of b())if(t===e.key)return e},b=async function*({amount:t}={}){const e={};let r=0;for await(const n of g.iterator()){const{op:i,key:o,value:s}=n.payload;if("PUT"!==i||e[o])"DEL"!==i||e[o]||(e[o]=!0);else{e[o]=!0,r++;const t=n.hash;yield{hash:t,key:o,value:s}}if(r>=t)break}};return{...y,type:On,put:async e=>{const r=e[t];if(!r)throw new Error(`The provided document doesn't contain field '${t}'`);return p({op:"PUT",key:r,value:e})},del:async t=>{if(!await w(t))throw new Error(`No document with key '${t}' in the database`);return p({op:"DEL",key:t,value:null})},get:w,iterator:b,query:async t=>{const e=[];for await(const r of b())t(r.value)&&e.push(r.value);return e},indexBy:t,all:async()=>{const t=[];for await(const e of b())t.unshift(e);return t}}};Rn.type=On;const Dn=Rn,Vn="events",Mn=()=>async({ipfs:t,identity:e,address:r,name:n,access:i,directory:o,meta:s,headsStorage:a,entryStorage:c,indexStorage:u,referencesCount:h,syncAutomatically:l,onUpdate:f})=>{const d=await Nn({ipfs:t,identity:e,address:r,name:n,access:i,directory:o,meta:s,headsStorage:a,entryStorage:c,indexStorage:u,referencesCount:h,syncAutomatically:l,onUpdate:f}),{addOperation:y,log:p}=d,g=async function*({gt:t,gte:e,lt:r,lte:n,amount:i}={}){const o=p.iterator({gt:t,gte:e,lt:r,lte:n,amount:i});for await(const t of o){const e=t.hash,r=t.payload.value;yield{hash:e,value:r}}};return{...d,type:Vn,add:async t=>y({op:"ADD",key:null,value:t}),get:async t=>(await p.get(t)).payload.value,iterator:g,all:async()=>{const t=[];for await(const e of g())t.unshift(e);return t}}};Mn.type=Vn;const Pn=Mn,Hn="keyvalue",$n=()=>async({ipfs:t,identity:e,address:r,name:n,access:i,directory:o,meta:s,headsStorage:a,entryStorage:c,indexStorage:u,referencesCount:h,syncAutomatically:l,onUpdate:f})=>{const d=await Nn({ipfs:t,identity:e,address:r,name:n,access:i,directory:o,meta:s,headsStorage:a,entryStorage:c,indexStorage:u,referencesCount:h,syncAutomatically:l,onUpdate:f}),{addOperation:y,log:p}=d,g=async(t,e)=>y({op:"PUT",key:t,value:e}),w=async function*({amount:t}={}){const e={};let r=0;for await(const n of p.traverse()){const{op:i,key:o,value:s}=n.payload;if("PUT"!==i||e[o])"DEL"!==i||e[o]||(e[o]=!0);else{e[o]=!0,r++;const t=n.hash;yield{key:o,value:s,hash:t}}if(r>=t)break}};return{...d,type:Hn,put:g,set:g,del:async t=>y({op:"DEL",key:t,value:null}),get:async t=>{for await(const e of p.traverse()){const{op:r,key:n,value:i}=e.payload;if("PUT"===r&&n===t)return i;if("DEL"===r&&n===t)return}},iterator:w,all:async()=>{const t=[];for await(const e of w())t.unshift(e);return t}}};$n.type=Hn;const Fn=$n,jn="json",zn=()=>async({ipfs:t,identity:e,address:r,name:n,access:i,directory:o,meta:s,headsStorage:a,entryStorage:c,indexStorage:u,referencesCount:h,syncAutomatically:l,onUpdate:f})=>{o=P(o||"./orbitdb",`./${r}/_index/`);const d=await(({directory:t}={})=>async()=>{const e=await Tn({path:t,valueEncoding:jn}),r=await Tn({path:P(t,"/_indexedEntries/"),valueEncoding:jn});return{get:e.get,iterator:e.iterator,update:async(t,n)=>{const i=new Set,o=new Set,s=n.hash,a=async t=>!0===await r.get(t),c=async t=>!await a(t),u=async t=>{for await(const e of t.next)await c(e)&&o.add(e);return await a(s)&&0===o.size};for await(const n of t.traverse(null,u)){const{hash:t,payload:s}=n;if(await c(t)){const{op:a,key:c}=s;"PUT"!==a||i.has(c)?"DEL"!==a||i.has(c)||(i.add(c),await e.del(c),await r.put(t,!0)):(i.add(c),await e.put(c,n),await r.put(t,!0)),o.delete(t)}}},close:async()=>{await e.close(),await r.close()},drop:async()=>{await e.clear(),await r.clear()}}})({directory:o})(),y=await Fn()({ipfs:t,identity:e,address:r,name:n,access:i,directory:o,meta:s,headsStorage:a,entryStorage:c,indexStorage:u,referencesCount:h,syncAutomatically:l,onUpdate:d.update});return{...y,get:async t=>{const e=await d.get(t);if(e)return e.payload.value},iterator:async function*({amount:t}={}){const e=d.iterator({amount:t,reverse:!0});for await(const t of e){const e=t[1],{key:r,value:n}=e.payload,i=e.hash;yield{key:r,value:n,hash:i}}},close:async()=>{await y.close(),await d.close()},drop:async()=>{await y.drop(),await d.drop()}}};zn.type="keyvalue";const qn=zn,Kn={},Gn=t=>{if(!t.type)throw new Error("Database type does not contain required field 'type'.");Kn[t.type]=t};Gn(Pn),Gn(Dn),Gn(Fn);class Jn extends Error{static name="InvalidParametersError";constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}}class Wn extends Error{static name="InvalidPublicKeyError";constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}}class Zn extends Error{static name="InvalidPrivateKeyError";constructor(t="Invalid private key"){super(t),this.name="InvalidPrivateKeyError"}}class Yn extends Error{static name="UnsupportedKeyTypeError";constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}}function Qn(t){if(t instanceof Uint8Array&&"Uint8Array"===t.constructor.name)return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")}new Uint8Array(0);const Xn=function(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var i=0;i<t.length;i++){var o=t.charAt(i),s=o.charCodeAt(0);if(255!==r[s])throw new TypeError(o+" is ambiguous");r[s]=i}var a=t.length,c=t.charAt(0),u=Math.log(a)/Math.log(256),h=Math.log(256)/Math.log(a);function l(t){if("string"!=typeof t)throw new TypeError("Expected String");if(0===t.length)return new Uint8Array;var e=0;if(" "!==t[e]){for(var n=0,i=0;t[e]===c;)n++,e++;for(var o=(t.length-e)*u+1>>>0,s=new Uint8Array(o);t[e];){var h=r[t.charCodeAt(e)];if(255===h)return;for(var l=0,f=o-1;(0!==h||l<i)&&-1!==f;f--,l++)h+=a*s[f]>>>0,s[f]=h%256>>>0,h=h/256>>>0;if(0!==h)throw new Error("Non-zero carry");i=l,e++}if(" "!==t[e]){for(var d=o-i;d!==o&&0===s[d];)d++;for(var y=new Uint8Array(n+(o-d)),p=n;d!==o;)y[p++]=s[d++];return y}}}return{encode:function(e){if(e instanceof Uint8Array||(ArrayBuffer.isView(e)?e=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):Array.isArray(e)&&(e=Uint8Array.from(e))),!(e instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===e.length)return"";for(var r=0,n=0,i=0,o=e.length;i!==o&&0===e[i];)i++,r++;for(var s=(o-i)*h+1>>>0,u=new Uint8Array(s);i!==o;){for(var l=e[i],f=0,d=s-1;(0!==l||f<n)&&-1!==d;d--,f++)l+=256*u[d]>>>0,u[d]=l%a>>>0,l=l/a>>>0;if(0!==l)throw new Error("Non-zero carry");n=f,i++}for(var y=s-n;y!==s&&0===u[y];)y++;for(var p=c.repeat(r);y<s;++y)p+=t.charAt(u[y]);return p},decodeUnsafe:l,decode:function(t){var r=l(t);if(r)return r;throw new Error(`Non-${e} character`)}}};class ti{name;prefix;baseEncode;constructor(t,e,r){this.name=t,this.prefix=e,this.baseEncode=r}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}}class ei{name;prefix;baseDecode;prefixCodePoint;constructor(t,e,r){this.name=t,this.prefix=e;const n=e.codePointAt(0);if(void 0===n)throw new Error("Invalid prefix character");this.prefixCodePoint=n,this.baseDecode=r}decode(t){if("string"==typeof t){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(t){return ni(this,t)}}class ri{decoders;constructor(t){this.decoders=t}or(t){return ni(this,t)}decode(t){const e=t[0],r=this.decoders[e];if(null!=r)return r.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function ni(t,e){return new ri({...t.decoders??{[t.prefix]:t},...e.decoders??{[e.prefix]:e}})}class ii{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(t,e,r,n){this.name=t,this.prefix=e,this.baseEncode=r,this.baseDecode=n,this.encoder=new ti(t,e,r),this.decoder=new ei(t,e,n)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}}function oi({name:t,prefix:e,encode:r,decode:n}){return new ii(t,e,r,n)}function si({name:t,prefix:e,alphabet:r}){const{encode:n,decode:i}=Xn(r,t);return oi({prefix:e,name:t,encode:n,decode:t=>Qn(i(t))})}function ai({name:t,prefix:e,bitsPerChar:r,alphabet:n}){return oi({prefix:e,name:t,encode:t=>function(t,e,r){const n="="===e[e.length-1],i=(1<<r)-1;let o="",s=0,a=0;for(let n=0;n<t.length;++n)for(a=a<<8|t[n],s+=8;s>r;)s-=r,o+=e[i&a>>s];if(0!==s&&(o+=e[i&a<<r-s]),n)for(;0!=(o.length*r&7);)o+="=";return o}(t,n,r),decode:e=>function(t,e,r,n){const i={};for(let t=0;t<e.length;++t)i[e[t]]=t;let o=t.length;for(;"="===t[o-1];)--o;const s=new Uint8Array(o*r/8|0);let a=0,c=0,u=0;for(let e=0;e<o;++e){const o=i[t[e]];if(void 0===o)throw new SyntaxError(`Non-${n} character`);c=c<<r|o,a+=r,a>=8&&(a-=8,s[u++]=255&c>>a)}if(a>=r||0!=(255&c<<8-a))throw new SyntaxError("Unexpected end of data");return s}(e,n,r,t)})}const ci=si({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),ui=(si({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),ai({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5})),hi=(ai({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),ai({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),ai({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),ai({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),ai({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),ai({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),ai({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),ai({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),si({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}));si({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var li=128,fi=-128,di=Math.pow(2,31),yi=128,pi=127,gi=Math.pow(2,7),wi=Math.pow(2,14),bi=Math.pow(2,21),mi=Math.pow(2,28),vi=Math.pow(2,35),Ei=Math.pow(2,42),xi=Math.pow(2,49),Bi=Math.pow(2,56),Ai=Math.pow(2,63);const ki={encode:function t(e,r,n){r=r||[];for(var i=n=n||0;e>=di;)r[n++]=255&e|li,e/=128;for(;e&fi;)r[n++]=255&e|li,e>>>=7;return r[n]=0|e,t.bytes=n-i+1,r},decode:function t(e,r){var n,i=0,o=0,s=r=r||0,a=e.length;do{if(s>=a)throw t.bytes=0,new RangeError("Could not decode varint");n=e[s++],i+=o<28?(n&pi)<<o:(n&pi)*Math.pow(2,o),o+=7}while(n>=yi);return t.bytes=s-r,i},encodingLength:function(t){return t<gi?1:t<wi?2:t<bi?3:t<mi?4:t<vi?5:t<Ei?6:t<xi?7:t<Bi?8:t<Ai?9:10}};function Si(t,e=0){return[ki.decode(t,e),ki.decode.bytes]}function Ii(t,e,r=0){return ki.encode(t,e,r),e}function Ti(t){return ki.encodingLength(t)}function Ci(t,e){const r=e.byteLength,n=Ti(t),i=n+Ti(r),o=new Uint8Array(i+r);return Ii(t,o,0),Ii(r,o,n),o.set(e,i),new Ui(t,r,e,o)}class Ui{code;size;digest;bytes;constructor(t,e,r,n){this.code=t,this.size=e,this.digest=r,this.bytes=n}}function Li(t,e){const{bytes:r,version:n}=t;return 0===n?function(t,e,r){const{prefix:n}=r;if(n!==ci.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);const i=e.get(n);if(null==i){const i=r.encode(t).slice(1);return e.set(n,i),i}return i}(r,Oi(t),e??ci.encoder):function(t,e,r){const{prefix:n}=r,i=e.get(n);if(null==i){const i=r.encode(t);return e.set(n,i),i}return i}(r,Oi(t),e??ui.encoder)}const Ni=new WeakMap;function Oi(t){const e=Ni.get(t);if(null==e){const e=new Map;return Ni.set(t,e),e}return e}class _i{code;version;multihash;bytes;"/";constructor(t,e,r,n){this.code=e,this.version=t,this.multihash=r,this.bytes=n,this["/"]=n}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:t,multihash:e}=this;if(t!==Ri)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==Di)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return _i.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:t,digest:e}=this.multihash,r=Ci(t,e);return _i.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return _i.equals(this,t)}static equals(t,e){const r=e;return null!=r&&t.code===r.code&&t.version===r.version&&function(t,e){if(t===e)return!0;{const r=e;return t.code===r.code&&t.size===r.size&&r.bytes instanceof Uint8Array&&function(t,e){if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0}(t.bytes,r.bytes)}}(t.multihash,r.multihash)}toString(t){return Li(this,t)}toJSON(){return{"/":Li(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(null==t)return null;const e=t;if(e instanceof _i)return e;if(null!=e["/"]&&e["/"]===e.bytes||e.asCID===e){const{version:t,code:r,multihash:n,bytes:i}=e;return new _i(t,r,n,i??Vi(t,r,n.bytes))}if(!0===e[Mi]){const{version:t,multihash:r,code:n}=e,i=function(t){const e=Qn(t),[r,n]=Si(e),[i,o]=Si(e.subarray(n)),s=e.subarray(n+o);if(s.byteLength!==i)throw new Error("Incorrect length");return new Ui(r,i,s,e)}(r);return _i.create(t,n,i)}return null}static create(t,e,r){if("number"!=typeof e)throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:if(e!==Ri)throw new Error(`Version 0 CID must use dag-pb (code: ${Ri}) block encoding`);return new _i(t,e,r,r.bytes);case 1:{const n=Vi(t,e,r.bytes);return new _i(t,e,r,n)}default:throw new Error("Invalid version")}}static createV0(t){return _i.create(0,Ri,t)}static createV1(t,e){return _i.create(1,t,e)}static decode(t){const[e,r]=_i.decodeFirst(t);if(0!==r.length)throw new Error("Incorrect length");return e}static decodeFirst(t){const e=_i.inspectBytes(t),r=e.size-e.multihashSize,n=Qn(t.subarray(r,r+e.multihashSize));if(n.byteLength!==e.multihashSize)throw new Error("Incorrect length");const i=n.subarray(e.multihashSize-e.digestSize),o=new Ui(e.multihashCode,e.digestSize,i,n);return[0===e.version?_i.createV0(o):_i.createV1(e.codec,o),t.subarray(e.size)]}static inspectBytes(t){let e=0;const r=()=>{const[r,n]=Si(t.subarray(e));return e+=n,r};let n=r(),i=Ri;if(18===n?(n=0,e=0):i=r(),0!==n&&1!==n)throw new RangeError(`Invalid CID version ${n}`);const o=e,s=r(),a=r(),c=e+a;return{version:n,codec:i,multihashCode:s,digestSize:a,multihashSize:c-o,size:c}}static parse(t,e){const[r,n]=function(t,e){switch(t[0]){case"Q":{const r=e??ci;return[ci.prefix,r.decode(`${ci.prefix}${t}`)]}case ci.prefix:{const r=e??ci;return[ci.prefix,r.decode(t)]}case ui.prefix:{const r=e??ui;return[ui.prefix,r.decode(t)]}case hi.prefix:{const r=e??hi;return[hi.prefix,r.decode(t)]}default:if(null==e)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[t[0],e.decode(t)]}}(t,e),i=_i.decode(n);if(0===i.version&&"Q"!==t[0])throw Error("Version 0 CID string must not include multibase prefix");return Oi(i).set(r,t),i}}const Ri=112,Di=18;function Vi(t,e,r){const n=Ti(t),i=n+Ti(e),o=new Uint8Array(i+r.byteLength);return Ii(t,o,0),Ii(e,o,n),o.set(r,i),o}const Mi=Symbol.for("@ipld/js-cid/CID"),Pi=Qn,Hi=function(t){return Ci(0,Pi(t))};function $i(t,e){if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0}function Fi(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`positive integer expected, not ${t}`)}function ji(t,...e){if(!((r=t)instanceof Uint8Array||null!=r&&"object"==typeof r&&"Uint8Array"===r.constructor.name))throw new Error("Uint8Array expected");var r;if(e.length>0&&!e.includes(t.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${t.length}`)}function zi(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}const qi="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0,Ki=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),Gi=(t,e)=>t<<32-e|t>>>e;function Ji(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}function Wi(t){return"string"==typeof t&&(t=Ji(t)),ji(t),t}function Zi(...t){let e=0;for(let r=0;r<t.length;r++){const n=t[r];ji(n),e+=n.length}const r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const i=t[e];r.set(i,n),n+=i.length}return r}new Uint8Array(new Uint32Array([287454020]).buffer)[0];class Yi{clone(){return this._cloneInto()}}function Qi(t){const e=e=>t().update(Wi(e)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}function Xi(t=32){if(qi&&"function"==typeof qi.getRandomValues)return qi.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}const to=(t,e,r)=>t&e^t&r^e&r;class eo extends Yi{constructor(t,e,r,n){super(),this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=Ki(this.buffer)}update(t){zi(this);const{view:e,buffer:r,blockLen:n}=this,i=(t=Wi(t)).length;for(let o=0;o<i;){const s=Math.min(n-this.pos,i-o);if(s!==n)r.set(t.subarray(o,o+s),this.pos),this.pos+=s,o+=s,this.pos===n&&(this.process(e,0),this.pos=0);else{const e=Ki(t);for(;n<=i-o;o+=n)this.process(e,o)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){zi(this),function(t,e){ji(t);const r=e.outputLen;if(t.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:n,isLE:i}=this;let{pos:o}=this;e[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>n-o&&(this.process(r,0),o=0);for(let t=o;t<n;t++)e[t]=0;!function(t,e,r,n){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,r,n);const i=BigInt(32),o=BigInt(4294967295),s=Number(r>>i&o),a=Number(r&o),c=n?4:0,u=n?0:4;t.setUint32(e+c,s,n),t.setUint32(e+u,a,n)}(r,n-8,BigInt(8*this.length),i),this.process(r,0);const s=Ki(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const c=a/4,u=this.get();if(c>u.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<c;t++)s.setUint32(4*t,u[t],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:n,finished:i,destroyed:o,pos:s}=this;return t.length=n,t.pos=s,t.finished=i,t.destroyed=o,n%e&&t.buffer.set(r),t}}const ro=BigInt(2**32-1),no=BigInt(32);function io(t,e=!1){return e?{h:Number(t&ro),l:Number(t>>no&ro)}:{h:0|Number(t>>no&ro),l:0|Number(t&ro)}}const oo={fromBig:io,split:function(t,e=!1){let r=new Uint32Array(t.length),n=new Uint32Array(t.length);for(let i=0;i<t.length;i++){const{h:o,l:s}=io(t[i],e);[r[i],n[i]]=[o,s]}return[r,n]},toBig:(t,e)=>BigInt(t>>>0)<<no|BigInt(e>>>0),shrSH:(t,e,r)=>t>>>r,shrSL:(t,e,r)=>t<<32-r|e>>>r,rotrSH:(t,e,r)=>t>>>r|e<<32-r,rotrSL:(t,e,r)=>t<<32-r|e>>>r,rotrBH:(t,e,r)=>t<<64-r|e>>>r-32,rotrBL:(t,e,r)=>t>>>r-32|e<<64-r,rotr32H:(t,e)=>e,rotr32L:(t,e)=>t,rotlSH:(t,e,r)=>t<<r|e>>>32-r,rotlSL:(t,e,r)=>e<<r|t>>>32-r,rotlBH:(t,e,r)=>e<<r-32|t>>>64-r,rotlBL:(t,e,r)=>t<<r-32|e>>>64-r,add:function(t,e,r,n){const i=(e>>>0)+(n>>>0);return{h:t+r+(i/2**32|0)|0,l:0|i}},add3L:(t,e,r)=>(t>>>0)+(e>>>0)+(r>>>0),add3H:(t,e,r,n)=>e+r+n+(t/2**32|0)|0,add4L:(t,e,r,n)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0),add4H:(t,e,r,n,i)=>e+r+n+i+(t/2**32|0)|0,add5H:(t,e,r,n,i,o)=>e+r+n+i+o+(t/2**32|0)|0,add5L:(t,e,r,n,i)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0)+(i>>>0)},so=oo,[ao,co]=(()=>so.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((t=>BigInt(t)))))(),uo=new Uint32Array(80),ho=new Uint32Array(80);class lo extends eo{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:t,Al:e,Bh:r,Bl:n,Ch:i,Cl:o,Dh:s,Dl:a,Eh:c,El:u,Fh:h,Fl:l,Gh:f,Gl:d,Hh:y,Hl:p}=this;return[t,e,r,n,i,o,s,a,c,u,h,l,f,d,y,p]}set(t,e,r,n,i,o,s,a,c,u,h,l,f,d,y,p){this.Ah=0|t,this.Al=0|e,this.Bh=0|r,this.Bl=0|n,this.Ch=0|i,this.Cl=0|o,this.Dh=0|s,this.Dl=0|a,this.Eh=0|c,this.El=0|u,this.Fh=0|h,this.Fl=0|l,this.Gh=0|f,this.Gl=0|d,this.Hh=0|y,this.Hl=0|p}process(t,e){for(let r=0;r<16;r++,e+=4)uo[r]=t.getUint32(e),ho[r]=t.getUint32(e+=4);for(let t=16;t<80;t++){const e=0|uo[t-15],r=0|ho[t-15],n=so.rotrSH(e,r,1)^so.rotrSH(e,r,8)^so.shrSH(e,r,7),i=so.rotrSL(e,r,1)^so.rotrSL(e,r,8)^so.shrSL(e,r,7),o=0|uo[t-2],s=0|ho[t-2],a=so.rotrSH(o,s,19)^so.rotrBH(o,s,61)^so.shrSH(o,s,6),c=so.rotrSL(o,s,19)^so.rotrBL(o,s,61)^so.shrSL(o,s,6),u=so.add4L(i,c,ho[t-7],ho[t-16]),h=so.add4H(u,n,a,uo[t-7],uo[t-16]);uo[t]=0|h,ho[t]=0|u}let{Ah:r,Al:n,Bh:i,Bl:o,Ch:s,Cl:a,Dh:c,Dl:u,Eh:h,El:l,Fh:f,Fl:d,Gh:y,Gl:p,Hh:g,Hl:w}=this;for(let t=0;t<80;t++){const e=so.rotrSH(h,l,14)^so.rotrSH(h,l,18)^so.rotrBH(h,l,41),b=so.rotrSL(h,l,14)^so.rotrSL(h,l,18)^so.rotrBL(h,l,41),m=h&f^~h&y,v=l&d^~l&p,E=so.add5L(w,b,v,co[t],ho[t]),x=so.add5H(E,g,e,m,ao[t],uo[t]),B=0|E,A=so.rotrSH(r,n,28)^so.rotrBH(r,n,34)^so.rotrBH(r,n,39),k=so.rotrSL(r,n,28)^so.rotrBL(r,n,34)^so.rotrBL(r,n,39),S=r&i^r&s^i&s,I=n&o^n&a^o&a;g=0|y,w=0|p,y=0|f,p=0|d,f=0|h,d=0|l,({h,l}=so.add(0|c,0|u,0|x,0|B)),c=0|s,u=0|a,s=0|i,a=0|o,i=0|r,o=0|n;const T=so.add3L(B,k,I);r=so.add3H(T,x,A,S),n=0|T}({h:r,l:n}=so.add(0|this.Ah,0|this.Al,0|r,0|n)),({h:i,l:o}=so.add(0|this.Bh,0|this.Bl,0|i,0|o)),({h:s,l:a}=so.add(0|this.Ch,0|this.Cl,0|s,0|a)),({h:c,l:u}=so.add(0|this.Dh,0|this.Dl,0|c,0|u)),({h,l}=so.add(0|this.Eh,0|this.El,0|h,0|l)),({h:f,l:d}=so.add(0|this.Fh,0|this.Fl,0|f,0|d)),({h:y,l:p}=so.add(0|this.Gh,0|this.Gl,0|y,0|p)),({h:g,l:w}=so.add(0|this.Hh,0|this.Hl,0|g,0|w)),this.set(r,n,i,o,s,a,c,u,h,l,f,d,y,p,g,w)}roundClean(){uo.fill(0),ho.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const fo=Qi((()=>new lo)),yo=(BigInt(0),BigInt(1)),po=BigInt(2);function go(t){return t instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name}function wo(t){if(!go(t))throw new Error("Uint8Array expected")}const bo=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function mo(t){wo(t);let e="";for(let r=0;r<t.length;r++)e+=bo[t[r]];return e}function vo(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":`0x${t}`)}const Eo={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function xo(t){return t>=Eo._0&&t<=Eo._9?t-Eo._0:t>=Eo._A&&t<=Eo._F?t-(Eo._A-10):t>=Eo._a&&t<=Eo._f?t-(Eo._a-10):void 0}function Bo(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length,r=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(r);for(let e=0,i=0;e<r;e++,i+=2){const r=xo(t.charCodeAt(i)),o=xo(t.charCodeAt(i+1));if(void 0===r||void 0===o){const e=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+i)}n[e]=16*r+o}return n}function Ao(t){return vo(mo(t))}function ko(t){return wo(t),vo(mo(Uint8Array.from(t).reverse()))}function So(t,e){return Bo(t.toString(16).padStart(2*e,"0"))}function Io(t,e){return So(t,e).reverse()}function To(t,e,r){let n;if("string"==typeof e)try{n=Bo(e)}catch(r){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${r}`)}else{if(!go(e))throw new Error(`${t} must be hex string or Uint8Array`);n=Uint8Array.from(e)}const i=n.length;if("number"==typeof r&&i!==r)throw new Error(`${t} expected ${r} bytes, got ${i}`);return n}function Co(...t){let e=0;for(let r=0;r<t.length;r++){const n=t[r];wo(n),e+=n.length}const r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const i=t[e];r.set(i,n),n+=i.length}return r}const Uo=t=>(po<<BigInt(t-1))-yo,Lo=t=>new Uint8Array(t),No=t=>Uint8Array.from(t);function Oo(t,e,r){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");let n=Lo(t),i=Lo(t),o=0;const s=()=>{n.fill(1),i.fill(0),o=0},a=(...t)=>r(i,n,...t),c=(t=Lo())=>{i=a(No([0]),t),n=a(),0!==t.length&&(i=a(No([1]),t),n=a())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const r=[];for(;t<e;){n=a();const e=n.slice();r.push(e),t+=n.length}return Co(...r)};return(t,e)=>{let r;for(s(),c(t);!(r=e(u()));)c();return s(),r}}const _o={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||go(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function Ro(t,e,r={}){const n=(e,r,n)=>{const i=_o[r];if("function"!=typeof i)throw new Error(`Invalid validator "${r}", expected function`);const o=t[e];if(!(n&&void 0===o||i(o,t)))throw new Error(`Invalid param ${String(e)}=${o} (${typeof o}), expected ${r}`)};for(const[t,r]of Object.entries(e))n(t,r,!1);for(const[t,e]of Object.entries(r))n(t,e,!0);return t}const Do=BigInt(0),Vo=BigInt(1),Mo=BigInt(2),Po=BigInt(3),Ho=BigInt(4),$o=BigInt(5),Fo=BigInt(8);function jo(t,e){const r=t%e;return r>=Do?r:e+r}function zo(t,e,r){if(r<=Do||e<Do)throw new Error("Expected power/modulo > 0");if(r===Vo)return Do;let n=Vo;for(;e>Do;)e&Vo&&(n=n*t%r),t=t*t%r,e>>=Vo;return n}function qo(t,e,r){let n=t;for(;e-- >Do;)n*=n,n%=r;return n}function Ko(t,e){if(t===Do||e<=Do)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let r=jo(t,e),n=e,i=Do,o=Vo,s=Vo,a=Do;for(;r!==Do;){const t=n/r,e=n%r,c=i-s*t,u=o-a*t;n=r,r=e,i=s,o=a,s=c,a=u}if(n!==Vo)throw new Error("invert: does not exist");return jo(i,e)}BigInt(9),BigInt(16);const Go=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Jo(t,e){const r=void 0!==e?e:t.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function Wo(t,e,r=!1,n={}){if(t<=Do)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:i,nByteLength:o}=Jo(t,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const s=function(t){if(t%Ho===Po){const e=(t+Vo)/Ho;return function(t,r){const n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw new Error("Cannot find square root");return n}}if(t%Fo===$o){const e=(t-$o)/Fo;return function(t,r){const n=t.mul(r,Mo),i=t.pow(n,e),o=t.mul(r,i),s=t.mul(t.mul(o,Mo),i),a=t.mul(o,t.sub(s,t.ONE));if(!t.eql(t.sqr(a),r))throw new Error("Cannot find square root");return a}}return function(t){const e=(t-Vo)/Mo;let r,n,i;for(r=t-Vo,n=0;r%Mo===Do;r/=Mo,n++);for(i=Mo;i<t&&zo(i,e,t)!==t-Vo;i++);if(1===n){const e=(t+Vo)/Ho;return function(t,r){const n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw new Error("Cannot find square root");return n}}const o=(r+Vo)/Mo;return function(t,s){if(t.pow(s,e)===t.neg(t.ONE))throw new Error("Cannot find square root");let a=n,c=t.pow(t.mul(t.ONE,i),r),u=t.pow(s,o),h=t.pow(s,r);for(;!t.eql(h,t.ONE);){if(t.eql(h,t.ZERO))return t.ZERO;let e=1;for(let r=t.sqr(h);e<a&&!t.eql(r,t.ONE);e++)r=t.sqr(r);const r=t.pow(c,Vo<<BigInt(a-e-1));c=t.sqr(r),u=t.mul(u,r),h=t.mul(h,c),a=e}return u}}(t)}(t),a=Object.freeze({ORDER:t,BITS:i,BYTES:o,MASK:Uo(i),ZERO:Do,ONE:Vo,create:e=>jo(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("Invalid field element: expected bigint, got "+typeof e);return Do<=e&&e<t},is0:t=>t===Do,isOdd:t=>(t&Vo)===Vo,neg:e=>jo(-e,t),eql:(t,e)=>t===e,sqr:e=>jo(e*e,t),add:(e,r)=>jo(e+r,t),sub:(e,r)=>jo(e-r,t),mul:(e,r)=>jo(e*r,t),pow:(t,e)=>function(t,e,r){if(r<Do)throw new Error("Expected power > 0");if(r===Do)return t.ONE;if(r===Vo)return e;let n=t.ONE,i=e;for(;r>Do;)r&Vo&&(n=t.mul(n,i)),i=t.sqr(i),r>>=Vo;return n}(a,t,e),div:(e,r)=>jo(e*Ko(r,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>Ko(e,t),sqrt:n.sqrt||(t=>s(a,t)),invertBatch:t=>function(t,e){const r=new Array(e.length),n=e.reduce(((e,n,i)=>t.is0(n)?e:(r[i]=e,t.mul(e,n))),t.ONE),i=t.inv(n);return e.reduceRight(((e,n,i)=>t.is0(n)?e:(r[i]=t.mul(e,r[i]),t.mul(e,n))),i),r}(a,t),cmov:(t,e,r)=>r?e:t,toBytes:t=>r?Io(t,o):So(t,o),fromBytes:t=>{if(t.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${t.length}`);return r?ko(t):Ao(t)}});return Object.freeze(a)}function Zo(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function Yo(t){const e=Zo(t);return e+Math.ceil(e/2)}const Qo=BigInt(0),Xo=BigInt(1);function ts(t,e){const r=(t,e)=>{const r=e.negate();return t?r:e},n=t=>({windows:Math.ceil(e/t)+1,windowSize:2**(t-1)});return{constTimeNegate:r,unsafeLadder(e,r){let n=t.ZERO,i=e;for(;r>Qo;)r&Xo&&(n=n.add(i)),i=i.double(),r>>=Xo;return n},precomputeWindow(t,e){const{windows:r,windowSize:i}=n(e),o=[];let s=t,a=s;for(let t=0;t<r;t++){a=s,o.push(a);for(let t=1;t<i;t++)a=a.add(s),o.push(a);s=a.double()}return o},wNAF(e,i,o){const{windows:s,windowSize:a}=n(e);let c=t.ZERO,u=t.BASE;const h=BigInt(2**e-1),l=2**e,f=BigInt(e);for(let t=0;t<s;t++){const e=t*a;let n=Number(o&h);o>>=f,n>a&&(n-=l,o+=Xo);const s=e,d=e+Math.abs(n)-1,y=t%2!=0,p=n<0;0===n?u=u.add(r(y,i[s])):c=c.add(r(p,i[d]))}return{p:c,f:u}},wNAFCached(t,e,r,n){const i=t._WINDOW_SIZE||1;let o=e.get(t);return o||(o=this.precomputeWindow(t,i),1!==i&&e.set(t,n(o))),this.wNAF(i,o,r)}}}function es(t){return Ro(t.Fp,Go.reduce(((t,e)=>(t[e]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),Ro(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Jo(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}const rs=BigInt(0),ns=BigInt(1),is=BigInt(2),os=BigInt(8),ss={zip215:!0};function as(t){const e=function(t){const e=es(t);return Ro(t,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}(t),{Fp:r,n,prehash:i,hash:o,randomBytes:s,nByteLength:a,h:c}=e,u=is<<BigInt(8*a)-ns,h=r.create,l=e.uvRatio||((t,e)=>{try{return{isValid:!0,value:r.sqrt(t*r.inv(e))}}catch(t){return{isValid:!1,value:rs}}}),f=e.adjustScalarBytes||(t=>t),d=e.domain||((t,e,r)=>{if(e.length||r)throw new Error("Contexts/pre-hash are not supported");return t}),y=t=>"bigint"==typeof t&&rs<t,p=(t,e)=>y(t)&&y(e)&&t<e,g=t=>t===rs||p(t,u);function w(t,e){if(p(t,e))return t;throw new Error(`Expected valid scalar < ${e}, got ${typeof t} ${t}`)}function b(t){return t===rs?t:w(t,n)}const m=new Map;function v(t){if(!(t instanceof E))throw new Error("ExtendedPoint expected")}class E{constructor(t,e,r,n){if(this.ex=t,this.ey=e,this.ez=r,this.et=n,!g(t))throw new Error("x required");if(!g(e))throw new Error("y required");if(!g(r))throw new Error("z required");if(!g(n))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(t){if(t instanceof E)throw new Error("extended point not allowed");const{x:e,y:r}=t||{};if(!g(e)||!g(r))throw new Error("invalid affine point");return new E(e,r,ns,h(e*r))}static normalizeZ(t){const e=r.invertBatch(t.map((t=>t.ez)));return t.map(((t,r)=>t.toAffine(e[r]))).map(E.fromAffine)}_setWindowSize(t){this._WINDOW_SIZE=t,m.delete(this)}assertValidity(){const{a:t,d:r}=e;if(this.is0())throw new Error("bad point: ZERO");const{ex:n,ey:i,ez:o,et:s}=this,a=h(n*n),c=h(i*i),u=h(o*o),l=h(u*u),f=h(a*t);if(h(u*h(f+c))!==h(l+h(r*h(a*c))))throw new Error("bad point: equation left != right (1)");if(h(n*i)!==h(o*s))throw new Error("bad point: equation left != right (2)")}equals(t){v(t);const{ex:e,ey:r,ez:n}=this,{ex:i,ey:o,ez:s}=t,a=h(e*s),c=h(i*n),u=h(r*s),l=h(o*n);return a===c&&u===l}is0(){return this.equals(E.ZERO)}negate(){return new E(h(-this.ex),this.ey,this.ez,h(-this.et))}double(){const{a:t}=e,{ex:r,ey:n,ez:i}=this,o=h(r*r),s=h(n*n),a=h(is*h(i*i)),c=h(t*o),u=r+n,l=h(h(u*u)-o-s),f=c+s,d=f-a,y=c-s,p=h(l*d),g=h(f*y),w=h(l*y),b=h(d*f);return new E(p,g,b,w)}add(t){v(t);const{a:r,d:n}=e,{ex:i,ey:o,ez:s,et:a}=this,{ex:c,ey:u,ez:l,et:f}=t;if(r===BigInt(-1)){const t=h((o-i)*(u+c)),e=h((o+i)*(u-c)),r=h(e-t);if(r===rs)return this.double();const n=h(s*is*f),d=h(a*is*l),y=d+n,p=e+t,g=d-n,w=h(y*r),b=h(p*g),m=h(y*g),v=h(r*p);return new E(w,b,v,m)}const d=h(i*c),y=h(o*u),p=h(a*n*f),g=h(s*l),w=h((i+o)*(c+u)-d-y),b=g-p,m=g+p,x=h(y-r*d),B=h(w*b),A=h(m*x),k=h(w*x),S=h(b*m);return new E(B,A,S,k)}subtract(t){return this.add(t.negate())}wNAF(t){return A.wNAFCached(this,m,t,E.normalizeZ)}multiply(t){const{p:e,f:r}=this.wNAF(w(t,n));return E.normalizeZ([e,r])[0]}multiplyUnsafe(t){let e=b(t);return e===rs?B:this.equals(B)||e===ns?this:this.equals(x)?this.wNAF(e).p:A.unsafeLadder(this,e)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return A.unsafeLadder(this,n).is0()}toAffine(t){const{ex:e,ey:n,ez:i}=this,o=this.is0();null==t&&(t=o?os:r.inv(i));const s=h(e*t),a=h(n*t),c=h(i*t);if(o)return{x:rs,y:ns};if(c!==ns)throw new Error("invZ was invalid");return{x:s,y:a}}clearCofactor(){const{h:t}=e;return t===ns?this:this.multiplyUnsafe(t)}static fromHex(t,n=!1){const{d:i,a:o}=e,s=r.BYTES,a=(t=To("pointHex",t,s)).slice(),c=t[s-1];a[s-1]=-129&c;const f=ko(a);f===rs||w(f,n?u:r.ORDER);const d=h(f*f),y=h(d-ns),p=h(i*d-o);let{isValid:g,value:b}=l(y,p);if(!g)throw new Error("Point.fromHex: invalid y coordinate");const m=(b&ns)===ns,v=0!=(128&c);if(!n&&b===rs&&v)throw new Error("Point.fromHex: x=0 and x_0=1");return v!==m&&(b=h(-b)),E.fromAffine({x:b,y:f})}static fromPrivateKey(t){return I(t).point}toRawBytes(){const{x:t,y:e}=this.toAffine(),n=Io(e,r.BYTES);return n[n.length-1]|=t&ns?128:0,n}toHex(){return mo(this.toRawBytes())}}E.BASE=new E(e.Gx,e.Gy,ns,h(e.Gx*e.Gy)),E.ZERO=new E(rs,ns,ns,rs);const{BASE:x,ZERO:B}=E,A=ts(E,8*a);function k(t){return jo(t,n)}function S(t){return k(ko(t))}function I(t){const e=a;t=To("private key",t,e);const r=To("hashed private key",o(t),2*e),n=f(r.slice(0,e)),i=r.slice(e,2*e),s=S(n),c=x.multiply(s),u=c.toRawBytes();return{head:n,prefix:i,scalar:s,point:c,pointBytes:u}}function T(t=new Uint8Array,...e){const r=Co(...e);return S(o(d(r,To("context",t),!!i)))}const C=ss;return x._setWindowSize(8),{CURVE:e,getPublicKey:function(t){return I(t).pointBytes},sign:function(t,e,n={}){t=To("message",t),i&&(t=i(t));const{prefix:o,scalar:s,pointBytes:c}=I(e),u=T(n.context,o,t),h=x.multiply(u).toRawBytes(),l=k(u+T(n.context,h,c,t)*s);return b(l),To("result",Co(h,Io(l,r.BYTES)),2*a)},verify:function(t,e,n,o=C){const{context:s,zip215:a}=o,c=r.BYTES;t=To("signature",t,2*c),e=To("message",e),i&&(e=i(e));const u=ko(t.slice(c,2*c));let h,l,f;try{h=E.fromHex(n,a),l=E.fromHex(t.slice(0,c),a),f=x.multiplyUnsafe(u)}catch(t){return!1}if(!a&&h.isSmallOrder())return!1;const d=T(s,l.toRawBytes(),h.toRawBytes(),e);return l.add(h.multiplyUnsafe(d)).subtract(f).clearCofactor().equals(E.ZERO)},ExtendedPoint:E,utils:{getExtendedPublicKey:I,randomPrivateKey:()=>s(r.BYTES),precompute:(t=8,e=E.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)}}}const cs=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),us=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),hs=(BigInt(0),BigInt(1)),ls=BigInt(2),fs=BigInt(5),ds=BigInt(10),ys=BigInt(20),ps=BigInt(40),gs=BigInt(80);const ws=Wo(cs,void 0,!0),bs={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:ws,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:fo,randomBytes:Xi,adjustScalarBytes:function(t){return t[0]&=248,t[31]&=127,t[31]|=64,t},uvRatio:function(t,e){const r=cs,n=jo(e*e*e,r),i=jo(n*n*e,r);let o=jo(t*n*function(t){const e=cs,r=t*t%e*t%e,n=qo(r,ls,e)*r%e,i=qo(n,hs,e)*t%e,o=qo(i,fs,e)*i%e,s=qo(o,ds,e)*o%e,a=qo(s,ys,e)*s%e,c=qo(a,ps,e)*a%e,u=qo(c,gs,e)*c%e,h=qo(u,gs,e)*c%e,l=qo(h,ds,e)*o%e;return{pow_p_5_8:qo(l,ls,e)*t%e,b2:r}}(t*i).pow_p_5_8,r);const s=jo(e*o*o,r),a=o,c=jo(o*us,r),u=s===t,h=s===jo(-t,r),l=s===jo(-t*us,r);return u&&(o=a),(h||l)&&(o=c),(jo(o,r)&Vo)===Vo&&(o=jo(-o,r)),{isValid:u||h,value:o}}},ms=as(bs);const vs=(ws.ORDER+BigInt(3))/BigInt(8);ws.pow(ls,vs),ws.sqrt(ws.neg(ws.ONE)),ws.ORDER,BigInt(5),BigInt(8),BigInt(486662),function(t,e){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const r=t.sqrt(e);t.isOdd(r)&&t.neg(r)}(ws,ws.neg(BigInt(486664))),BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");const Es=64,xs=32;function Bs(t,e){const r=new Uint8Array(Es);for(let n=0;n<xs;n++)r[n]=t[n],r[xs+n]=e[n];return r}class As{type="Ed25519";raw;constructor(t){this.raw=Ss(t,32)}toMultihash(){return Hi(jl(this))}toCID(){return _i.createV1(114,this.toMultihash())}toString(){return ci.encode(this.toMultihash().bytes).substring(1)}equals(t){return null!=t&&t.raw instanceof Uint8Array&&$i(this.raw,t.raw)}verify(t,e){return function(t,e,r){return ms.verify(e,r instanceof Uint8Array?r:r.subarray(),t)}(this.raw,e,t)}}class ks{type="Ed25519";raw;publicKey;constructor(t,e){this.raw=Ss(t,Es),this.publicKey=new As(e)}equals(t){return null!=t&&t.raw instanceof Uint8Array&&$i(this.raw,t.raw)}sign(t){return function(t,e){const r=t.subarray(0,xs);return ms.sign(e instanceof Uint8Array?e:e.subarray(),r)}(this.raw,t)}}function Ss(t,e){if((t=Uint8Array.from(t??[])).length!==e)throw new Jn(`Key must be a Uint8Array of length ${e}, got ${t.length}`);return t}const Is=Math.pow(2,7),Ts=Math.pow(2,14),Cs=Math.pow(2,21),Us=Math.pow(2,28),Ls=Math.pow(2,35),Ns=Math.pow(2,42),Os=Math.pow(2,49),_s=128,Rs=127;function Ds(t){if(t<Is)return 1;if(t<Ts)return 2;if(t<Cs)return 3;if(t<Us)return 4;if(t<Ls)return 5;if(t<Ns)return 6;if(t<Os)return 7;if(null!=Number.MAX_SAFE_INTEGER&&t>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function Vs(t,e,r=0){switch(Ds(t)){case 8:e[r++]=255&t|_s,t/=128;case 7:e[r++]=255&t|_s,t/=128;case 6:e[r++]=255&t|_s,t/=128;case 5:e[r++]=255&t|_s,t/=128;case 4:e[r++]=255&t|_s,t>>>=7;case 3:e[r++]=255&t|_s,t>>>=7;case 2:e[r++]=255&t|_s,t>>>=7;case 1:e[r++]=255&t,t>>>=7;break;default:throw new Error("unreachable")}return e}const Ms=new Float32Array([-0]),Ps=new Uint8Array(Ms.buffer);function Hs(t,e,r){Ms[0]=t,e[r]=Ps[0],e[r+1]=Ps[1],e[r+2]=Ps[2],e[r+3]=Ps[3]}const $s=new Float64Array([-0]),Fs=new Uint8Array($s.buffer);function js(t,e,r){$s[0]=t,e[r]=Fs[0],e[r+1]=Fs[1],e[r+2]=Fs[2],e[r+3]=Fs[3],e[r+4]=Fs[4],e[r+5]=Fs[5],e[r+6]=Fs[6],e[r+7]=Fs[7]}const zs=BigInt(Number.MAX_SAFE_INTEGER),qs=BigInt(Number.MIN_SAFE_INTEGER);class Ks{lo;hi;constructor(t,e){this.lo=0|t,this.hi=0|e}toNumber(t=!1){if(!t&&this.hi>>>31>0){const t=1+~this.lo>>>0;let e=~this.hi>>>0;return 0===t&&(e=e+1>>>0),-(t+4294967296*e)}return this.lo+4294967296*this.hi}toBigInt(t=!1){if(t)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31!=0){const t=1+~this.lo>>>0;let e=~this.hi>>>0;return 0===t&&(e=e+1>>>0),-(BigInt(t)+(BigInt(e)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(t=!1){return this.toBigInt(t).toString()}zzEncode(){const t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this}zzDecode(){const t=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this}length(){const t=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,r=this.hi>>>24;return 0===r?0===e?t<16384?t<128?1:2:t<2097152?3:4:e<16384?e<128?5:6:e<2097152?7:8:r<128?9:10}static fromBigInt(t){if(0n===t)return Gs;if(t<zs&&t>qs)return this.fromNumber(Number(t));const e=t<0n;e&&(t=-t);let r=t>>32n,n=t-(r<<32n);return e&&(r=0n|~r,n=0n|~n,++n>Js&&(n=0n,++r>Js&&(r=0n))),new Ks(Number(n),Number(r))}static fromNumber(t){if(0===t)return Gs;const e=t<0;e&&(t=-t);let r=t>>>0,n=(t-r)/4294967296>>>0;return e&&(n=~n>>>0,r=~r>>>0,++r>4294967295&&(r=0,++n>4294967295&&(n=0))),new Ks(r,n)}static from(t){return"number"==typeof t?Ks.fromNumber(t):"bigint"==typeof t?Ks.fromBigInt(t):"string"==typeof t?Ks.fromBigInt(BigInt(t)):null!=t.low||null!=t.high?new Ks(t.low>>>0,t.high>>>0):Gs}}const Gs=new Ks(0,0);Gs.toBigInt=function(){return 0n},Gs.zzEncode=Gs.zzDecode=function(){return this},Gs.length=function(){return 1};const Js=4294967296n;function Ws(t,e,r){const n=r;let i,o;for(let n=0;n<t.length;++n)i=t.charCodeAt(n),i<128?e[r++]=i:i<2048?(e[r++]=i>>6|192,e[r++]=63&i|128):55296==(64512&i)&&56320==(64512&(o=t.charCodeAt(n+1)))?(i=65536+((1023&i)<<10)+(1023&o),++n,e[r++]=i>>18|240,e[r++]=i>>12&63|128,e[r++]=i>>6&63|128,e[r++]=63&i|128):(e[r++]=i>>12|224,e[r++]=i>>6&63|128,e[r++]=63&i|128);return r-n}function Zs(t,e){return RangeError(`index out of range: ${t.pos} + ${e??1} > ${t.len}`)}function Ys(t,e){return(t[e-4]|t[e-3]<<8|t[e-2]<<16|t[e-1]<<24)>>>0}class Qs{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(t){this.buf=t,this.pos=0,this.len=t.length}uint32(){let t=4294967295;if(t=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128)return t;if(t=(t|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)return t;if(t=(t|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)return t;if(t=(t|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)return t;if(t=(t|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128)return t;if((this.pos+=5)>this.len)throw this.pos=this.len,Zs(this,10);return t}int32(){return 0|this.uint32()}sint32(){const t=this.uint32();return t>>>1^-(1&t)|0}bool(){return 0!==this.uint32()}fixed32(){if(this.pos+4>this.len)throw Zs(this,4);return Ys(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw Zs(this,4);return 0|Ys(this.buf,this.pos+=4)}float(){if(this.pos+4>this.len)throw Zs(this,4);const t=function(t,e){return Ps[0]=t[e],Ps[1]=t[e+1],Ps[2]=t[e+2],Ps[3]=t[e+3],Ms[0]}(this.buf,this.pos);return this.pos+=4,t}double(){if(this.pos+8>this.len)throw Zs(this,4);const t=function(t,e){return Fs[0]=t[e],Fs[1]=t[e+1],Fs[2]=t[e+2],Fs[3]=t[e+3],Fs[4]=t[e+4],Fs[5]=t[e+5],Fs[6]=t[e+6],Fs[7]=t[e+7],$s[0]}(this.buf,this.pos);return this.pos+=8,t}bytes(){const t=this.uint32(),e=this.pos,r=this.pos+t;if(r>this.len)throw Zs(this,t);return this.pos+=t,e===r?new Uint8Array(0):this.buf.subarray(e,r)}string(){const t=this.bytes();return function(t,e,r){if(r-e<1)return"";let n;const i=[];let o,s=0;for(;e<r;)o=t[e++],o<128?i[s++]=o:o>191&&o<224?i[s++]=(31&o)<<6|63&t[e++]:o>239&&o<365?(o=((7&o)<<18|(63&t[e++])<<12|(63&t[e++])<<6|63&t[e++])-65536,i[s++]=55296+(o>>10),i[s++]=56320+(1023&o)):i[s++]=(15&o)<<12|(63&t[e++])<<6|63&t[e++],s>8191&&((n??(n=[])).push(String.fromCharCode.apply(String,i)),s=0);return null!=n?(s>0&&n.push(String.fromCharCode.apply(String,i.slice(0,s))),n.join("")):String.fromCharCode.apply(String,i.slice(0,s))}(t,0,t.length)}skip(t){if("number"==typeof t){if(this.pos+t>this.len)throw Zs(this,t);this.pos+=t}else do{if(this.pos>=this.len)throw Zs(this)}while(0!=(128&this.buf[this.pos++]));return this}skipType(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(t=7&this.uint32());)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${t} at offset ${this.pos}`)}return this}readLongVarint(){const t=new Ks(0,0);let e=0;if(!(this.len-this.pos>4)){for(;e<3;++e){if(this.pos>=this.len)throw Zs(this);if(t.lo=(t.lo|(127&this.buf[this.pos])<<7*e)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(127&this.buf[this.pos++])<<7*e)>>>0,t}for(;e<4;++e)if(t.lo=(t.lo|(127&this.buf[this.pos])<<7*e)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(127&this.buf[this.pos])<<28)>>>0,t.hi=(t.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return t;if(e=0,this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(127&this.buf[this.pos])<<7*e+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw Zs(this);if(t.hi=(t.hi|(127&this.buf[this.pos])<<7*e+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw Zs(this,8);const t=Ys(this.buf,this.pos+=4),e=Ys(this.buf,this.pos+=4);return new Ks(t,e)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const t=function(t,e){let r=t[e],n=0;if(n+=r&Rs,r<_s)return n;if(r=t[e+1],n+=(r&Rs)<<7,r<_s)return n;if(r=t[e+2],n+=(r&Rs)<<14,r<_s)return n;if(r=t[e+3],n+=(r&Rs)<<21,r<_s)return n;if(r=t[e+4],n+=(r&Rs)*Us,r<_s)return n;if(r=t[e+5],n+=(r&Rs)*Ls,r<_s)return n;if(r=t[e+6],n+=(r&Rs)*Ns,r<_s)return n;if(r=t[e+7],n+=(r&Rs)*Os,r<_s)return n;throw new RangeError("Could not decode varint")}(this.buf,this.pos);return this.pos+=Ds(t),t}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function Xs(t,e,r){const n=function(t){return new Qs(t instanceof Uint8Array?t:t.subarray())}(t);return e.decode(n,void 0,r)}function ta(t=0){return new Uint8Array(t)}function ea(t){if(t instanceof Uint8Array&&"Uint8Array"===t.constructor.name)return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")}new Uint8Array(0);const ra=function(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var i=0;i<t.length;i++){var o=t.charAt(i),s=o.charCodeAt(0);if(255!==r[s])throw new TypeError(o+" is ambiguous");r[s]=i}var a=t.length,c=t.charAt(0),u=Math.log(a)/Math.log(256),h=Math.log(256)/Math.log(a);function l(t){if("string"!=typeof t)throw new TypeError("Expected String");if(0===t.length)return new Uint8Array;var e=0;if(" "!==t[e]){for(var n=0,i=0;t[e]===c;)n++,e++;for(var o=(t.length-e)*u+1>>>0,s=new Uint8Array(o);t[e];){var h=r[t.charCodeAt(e)];if(255===h)return;for(var l=0,f=o-1;(0!==h||l<i)&&-1!==f;f--,l++)h+=a*s[f]>>>0,s[f]=h%256>>>0,h=h/256>>>0;if(0!==h)throw new Error("Non-zero carry");i=l,e++}if(" "!==t[e]){for(var d=o-i;d!==o&&0===s[d];)d++;for(var y=new Uint8Array(n+(o-d)),p=n;d!==o;)y[p++]=s[d++];return y}}}return{encode:function(e){if(e instanceof Uint8Array||(ArrayBuffer.isView(e)?e=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):Array.isArray(e)&&(e=Uint8Array.from(e))),!(e instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===e.length)return"";for(var r=0,n=0,i=0,o=e.length;i!==o&&0===e[i];)i++,r++;for(var s=(o-i)*h+1>>>0,u=new Uint8Array(s);i!==o;){for(var l=e[i],f=0,d=s-1;(0!==l||f<n)&&-1!==d;d--,f++)l+=256*u[d]>>>0,u[d]=l%a>>>0,l=l/a>>>0;if(0!==l)throw new Error("Non-zero carry");n=f,i++}for(var y=s-n;y!==s&&0===u[y];)y++;for(var p=c.repeat(r);y<s;++y)p+=t.charAt(u[y]);return p},decodeUnsafe:l,decode:function(t){var r=l(t);if(r)return r;throw new Error(`Non-${e} character`)}}};class na{name;prefix;baseEncode;constructor(t,e,r){this.name=t,this.prefix=e,this.baseEncode=r}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}}class ia{name;prefix;baseDecode;prefixCodePoint;constructor(t,e,r){if(this.name=t,this.prefix=e,void 0===e.codePointAt(0))throw new Error("Invalid prefix character");this.prefixCodePoint=e.codePointAt(0),this.baseDecode=r}decode(t){if("string"==typeof t){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(t){return sa(this,t)}}class oa{decoders;constructor(t){this.decoders=t}or(t){return sa(this,t)}decode(t){const e=t[0],r=this.decoders[e];if(null!=r)return r.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function sa(t,e){return new oa({...t.decoders??{[t.prefix]:t},...e.decoders??{[e.prefix]:e}})}class aa{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(t,e,r,n){this.name=t,this.prefix=e,this.baseEncode=r,this.baseDecode=n,this.encoder=new na(t,e,r),this.decoder=new ia(t,e,n)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}}function ca({name:t,prefix:e,encode:r,decode:n}){return new aa(t,e,r,n)}function ua({name:t,prefix:e,alphabet:r}){const{encode:n,decode:i}=ra(r,t);return ca({prefix:e,name:t,encode:n,decode:t=>ea(i(t))})}function ha({name:t,prefix:e,bitsPerChar:r,alphabet:n}){return ca({prefix:e,name:t,encode:t=>function(t,e,r){const n="="===e[e.length-1],i=(1<<r)-1;let o="",s=0,a=0;for(let n=0;n<t.length;++n)for(a=a<<8|t[n],s+=8;s>r;)s-=r,o+=e[i&a>>s];if(0!==s&&(o+=e[i&a<<r-s]),n)for(;0!=(o.length*r&7);)o+="=";return o}(t,n,r),decode:e=>function(t,e,r,n){const i={};for(let t=0;t<e.length;++t)i[e[t]]=t;let o=t.length;for(;"="===t[o-1];)--o;const s=new Uint8Array(o*r/8|0);let a=0,c=0,u=0;for(let e=0;e<o;++e){const o=i[t[e]];if(void 0===o)throw new SyntaxError(`Non-${n} character`);c=c<<r|o,a+=r,a>=8&&(a-=8,s[u++]=255&c>>a)}if(a>=r||0!=(255&c<<8-a))throw new SyntaxError("Unexpected end of data");return s}(e,n,r,t)})}const la=ua({prefix:"9",name:"base10",alphabet:"0123456789"}),fa=ha({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),da=ha({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),ya=ha({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),pa=Array.from(""),ga=pa.reduce(((t,e,r)=>(t[r]=e,t)),[]),wa=pa.reduce(((t,e,r)=>(t[e.codePointAt(0)]=r,t)),[]),ba=ca({prefix:"",name:"base256emoji",encode:function(t){return t.reduce(((t,e)=>t+ga[e]),"")},decode:function(t){const e=[];for(const r of t){const t=wa[r.codePointAt(0)];if(void 0===t)throw new Error(`Non-base256emoji character: ${r}`);e.push(t)}return new Uint8Array(e)}}),ma=ha({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),va=ha({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Ea=ha({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),xa=ha({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Ba=ha({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Aa=ha({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),ka=ha({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Sa=ha({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Ia=ha({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),Ta=ua({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Ca=ua({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),Ua=ua({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),La=ua({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),Na=ha({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Oa=ha({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),_a=ha({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Ra=ha({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),Da=ha({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),Va=ca({prefix:"\0",name:"identity",encode:t=>{return e=t,(new TextDecoder).decode(e);var e},decode:t=>function(t){return(new TextEncoder).encode(t)}(t)}),Ma=new TextEncoder,Pa=new TextDecoder,Ha="json",$a=512;function Fa(t){return Ma.encode(JSON.stringify(t))}function ja(t){return JSON.parse(Pa.decode(t))}const za="raw",qa=85;function Ka(t){return ea(t)}function Ga(t){return ea(t)}var Ja=128,Wa=-128,Za=Math.pow(2,31),Ya=128,Qa=127,Xa=Math.pow(2,7),tc=Math.pow(2,14),ec=Math.pow(2,21),rc=Math.pow(2,28),nc=Math.pow(2,35),ic=Math.pow(2,42),oc=Math.pow(2,49),sc=Math.pow(2,56),ac=Math.pow(2,63);const cc={encode:function t(e,r,n){r=r||[];for(var i=n=n||0;e>=Za;)r[n++]=255&e|Ja,e/=128;for(;e&Wa;)r[n++]=255&e|Ja,e>>>=7;return r[n]=0|e,t.bytes=n-i+1,r},decode:function t(e,r){var n,i=0,o=0,s=r=r||0,a=e.length;do{if(s>=a)throw t.bytes=0,new RangeError("Could not decode varint");n=e[s++],i+=o<28?(n&Qa)<<o:(n&Qa)*Math.pow(2,o),o+=7}while(n>=Ya);return t.bytes=s-r,i},encodingLength:function(t){return t<Xa?1:t<tc?2:t<ec?3:t<rc?4:t<nc?5:t<ic?6:t<oc?7:t<sc?8:t<ac?9:10}};function uc(t,e,r=0){return cc.encode(t,e,r),e}function hc(t){return cc.encodingLength(t)}function lc(t,e){const r=e.byteLength,n=hc(t),i=n+hc(r),o=new Uint8Array(i+r);return uc(t,o,0),uc(r,o,n),o.set(e,i),new fc(t,r,e,o)}class fc{code;size;digest;bytes;constructor(t,e,r,n){this.code=t,this.size=e,this.digest=r,this.bytes=n}}const dc=ea,yc={code:0,name:"identity",encode:dc,digest:function(t){return lc(0,dc(t))}};function pc({name:t,code:e,encode:r}){return new gc(t,e,r)}class gc{name;code;encode;constructor(t,e,r){this.name=t,this.code=e,this.encode=r}digest(t){if(t instanceof Uint8Array){const e=this.encode(t);return e instanceof Uint8Array?lc(this.code,e):e.then((t=>lc(this.code,t)))}throw Error("Unknown type, must be binary type")}}function wc(t){return async e=>new Uint8Array(await crypto.subtle.digest(t,e))}const bc=pc({name:"sha2-256",code:18,encode:wc("SHA-256")}),mc=pc({name:"sha2-512",code:19,encode:wc("SHA-512")});new WeakMap,Symbol.toStringTag,Symbol.for("nodejs.util.inspect.custom"),Symbol.for("@ipld/js-cid/CID");const vc={...d,...s,...f,...i,...o,...c,...u,...h,...l,...a};function Ec(t,e,r,n){return{name:t,prefix:e,encoder:{name:t,prefix:e,encode:r},decoder:{decode:n}}}const xc=Ec("utf8","u",(t=>"u"+new TextDecoder("utf8").decode(t)),(t=>(new TextEncoder).encode(t.substring(1)))),Bc=Ec("ascii","a",(t=>{let e="a";for(let r=0;r<t.length;r++)e+=String.fromCharCode(t[r]);return e}),(t=>{const e=ta((t=t.substring(1)).length);for(let r=0;r<t.length;r++)e[r]=t.charCodeAt(r);return e})),Ac={utf8:xc,"utf-8":xc,hex:vc.base16,latin1:Bc,ascii:Bc,binary:Bc,...vc};function kc(t,e="utf8"){const r=Ac[e];if(null==r)throw new Error(`Unsupported encoding "${e}"`);return r.decoder.decode(`${r.prefix}${t}`)}class Sc{fn;len;next;val;constructor(t,e,r){this.fn=t,this.len=e,this.next=void 0,this.val=r}}function Ic(){}class Tc{head;tail;len;next;constructor(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}}const Cc=function(t){const e=8192;let r,n=e;return function(t){if(t<1||t>4096)return ta(t);n+t>e&&(r=ta(e),n=0);const i=r.subarray(n,n+=t);return 0!=(7&n)&&(n=1+(7|n)),i}}();class Uc{len;head;tail;states;constructor(){this.len=0,this.head=new Sc(Ic,0,0),this.tail=this.head,this.states=null}_push(t,e,r){return this.tail=this.tail.next=new Sc(t,e,r),this.len+=e,this}uint32(t){return this.len+=(this.tail=this.tail.next=new Oc((t>>>=0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this}int32(t){return t<0?this._push(_c,10,Ks.fromNumber(t)):this.uint32(t)}sint32(t){return this.uint32((t<<1^t>>31)>>>0)}uint64(t){const e=Ks.fromBigInt(t);return this._push(_c,e.length(),e)}uint64Number(t){return this._push(Vs,Ds(t),t)}uint64String(t){return this.uint64(BigInt(t))}int64(t){return this.uint64(t)}int64Number(t){return this.uint64Number(t)}int64String(t){return this.uint64String(t)}sint64(t){const e=Ks.fromBigInt(t).zzEncode();return this._push(_c,e.length(),e)}sint64Number(t){const e=Ks.fromNumber(t).zzEncode();return this._push(_c,e.length(),e)}sint64String(t){return this.sint64(BigInt(t))}bool(t){return this._push(Lc,1,t?1:0)}fixed32(t){return this._push(Rc,4,t>>>0)}sfixed32(t){return this.fixed32(t)}fixed64(t){const e=Ks.fromBigInt(t);return this._push(Rc,4,e.lo)._push(Rc,4,e.hi)}fixed64Number(t){const e=Ks.fromNumber(t);return this._push(Rc,4,e.lo)._push(Rc,4,e.hi)}fixed64String(t){return this.fixed64(BigInt(t))}sfixed64(t){return this.fixed64(t)}sfixed64Number(t){return this.fixed64Number(t)}sfixed64String(t){return this.fixed64String(t)}float(t){return this._push(Hs,4,t)}double(t){return this._push(js,8,t)}bytes(t){const e=t.length>>>0;return 0===e?this._push(Lc,1,0):this.uint32(e)._push(Dc,e,t)}string(t){const e=function(t){let e=0,r=0;for(let n=0;n<t.length;++n)r=t.charCodeAt(n),r<128?e+=1:r<2048?e+=2:55296==(64512&r)&&56320==(64512&t.charCodeAt(n+1))?(++n,e+=4):e+=3;return e}(t);return 0!==e?this.uint32(e)._push(Ws,e,t):this._push(Lc,1,0)}fork(){return this.states=new Tc(this),this.head=this.tail=new Sc(Ic,0,0),this.len=0,this}reset(){return null!=this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Sc(Ic,0,0),this.len=0),this}ldelim(){const t=this.head,e=this.tail,r=this.len;return this.reset().uint32(r),0!==r&&(this.tail.next=t.next,this.tail=e,this.len+=r),this}finish(){let t=this.head.next;const e=(r=this.len,null!=globalThis.Buffer?ta(r):Cc(r));var r;let n=0;for(;null!=t;)t.fn(t.val,e,n),n+=t.len,t=t.next;return e}}function Lc(t,e,r){e[r]=255&t}function Nc(t,e,r){for(;t>127;)e[r++]=127&t|128,t>>>=7;e[r]=t}class Oc extends Sc{next;constructor(t,e){super(Nc,t,e),this.next=void 0}}function _c(t,e,r){for(;0!==t.hi;)e[r++]=127&t.lo|128,t.lo=(t.lo>>>7|t.hi<<25)>>>0,t.hi>>>=7;for(;t.lo>127;)e[r++]=127&t.lo|128,t.lo=t.lo>>>7;e[r++]=t.lo}function Rc(t,e,r){e[r]=255&t,e[r+1]=t>>>8&255,e[r+2]=t>>>16&255,e[r+3]=t>>>24}function Dc(t,e,r){e.set(t,r)}function Vc(t,e,r){e.set(t,r)}function Mc(t,e,r){t.length<40?Ws(t,e,r):null!=e.utf8Write?e.utf8Write(t,r):e.set(kc(t),r)}function Pc(t,e){const r=new Uc;return e.encode(t,r,{lengthDelimited:!1}),r.finish()}var Hc,$c,Fc,jc,zc;function qc(t,e,r,n){return{name:t,type:e,encode:r,decode:n}}function Kc(t,e){return qc("message",Hc.LENGTH_DELIMITED,t,e)}null!=globalThis.Buffer&&(Uc.prototype.bytes=function(t){const e=t.length>>>0;return this.uint32(e),e>0&&this._push(Vc,e,t),this},Uc.prototype.string=function(t){const e=globalThis.Buffer.byteLength(t);return this.uint32(e),e>0&&this._push(Mc,e,t),this}),function(t){t[t.VARINT=0]="VARINT",t[t.BIT64=1]="BIT64",t[t.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",t[t.START_GROUP=3]="START_GROUP",t[t.END_GROUP=4]="END_GROUP",t[t.BIT32=5]="BIT32"}(Hc||(Hc={})),function(t){t.RSA="RSA",t.Ed25519="Ed25519",t.secp256k1="secp256k1"}($c||($c={})),function(t){t[t.RSA=0]="RSA",t[t.Ed25519=1]="Ed25519",t[t.secp256k1=2]="secp256k1"}(Fc||(Fc={})),function(t){t.codec=()=>function(t){function e(e){if(null==t[e.toString()])throw new Error("Invalid enum value");return t[e]}return qc("enum",Hc.VARINT,(function(t,r){const n=e(t);r.int32(n)}),(function(t){return e(t.int32())}))}(Fc)}($c||($c={})),function(t){let e;t.codec=()=>(null==e&&(e=Kc(((t,e,r={})=>{!1!==r.lengthDelimited&&e.fork(),null!=t.Type&&(e.uint32(8),$c.codec().encode(t.Type,e)),null!=t.Data&&(e.uint32(18),e.bytes(t.Data)),!1!==r.lengthDelimited&&e.ldelim()}),((t,e,r={})=>{const n={},i=null==e?t.len:t.pos+e;for(;t.pos<i;){const e=t.uint32();switch(e>>>3){case 1:n.Type=$c.codec().decode(t);break;case 2:n.Data=t.bytes();break;default:t.skipType(7&e)}}return n}))),e),t.encode=e=>Pc(e,t.codec()),t.decode=(e,r)=>Xs(e,t.codec(),r)}(jc||(jc={})),function(t){let e;t.codec=()=>(null==e&&(e=Kc(((t,e,r={})=>{!1!==r.lengthDelimited&&e.fork(),null!=t.Type&&(e.uint32(8),$c.codec().encode(t.Type,e)),null!=t.Data&&(e.uint32(18),e.bytes(t.Data)),!1!==r.lengthDelimited&&e.ldelim()}),((t,e,r={})=>{const n={},i=null==e?t.len:t.pos+e;for(;t.pos<i;){const e=t.uint32();switch(e>>>3){case 1:n.Type=$c.codec().decode(t);break;case 2:n.Data=t.bytes();break;default:t.skipType(7&e)}}return n}))),e),t.encode=e=>Pc(e,t.codec()),t.decode=(e,r)=>Xs(e,t.codec(),r)}(zc||(zc={}));const Gc=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Jc=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Wc=new Uint32Array(64);class Zc extends eo{constructor(){super(64,32,8,!1),this.A=0|Jc[0],this.B=0|Jc[1],this.C=0|Jc[2],this.D=0|Jc[3],this.E=0|Jc[4],this.F=0|Jc[5],this.G=0|Jc[6],this.H=0|Jc[7]}get(){const{A:t,B:e,C:r,D:n,E:i,F:o,G:s,H:a}=this;return[t,e,r,n,i,o,s,a]}set(t,e,r,n,i,o,s,a){this.A=0|t,this.B=0|e,this.C=0|r,this.D=0|n,this.E=0|i,this.F=0|o,this.G=0|s,this.H=0|a}process(t,e){for(let r=0;r<16;r++,e+=4)Wc[r]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=Wc[t-15],r=Wc[t-2],n=Gi(e,7)^Gi(e,18)^e>>>3,i=Gi(r,17)^Gi(r,19)^r>>>10;Wc[t]=i+Wc[t-7]+n+Wc[t-16]|0}let{A:r,B:n,C:i,D:o,E:s,F:a,G:c,H:u}=this;for(let t=0;t<64;t++){const e=u+(Gi(s,6)^Gi(s,11)^Gi(s,25))+((h=s)&a^~h&c)+Gc[t]+Wc[t]|0,l=(Gi(r,2)^Gi(r,13)^Gi(r,22))+to(r,n,i)|0;u=c,c=a,a=s,s=o+e|0,o=i,i=n,n=r,r=e+l|0}var h;r=r+this.A|0,n=n+this.B|0,i=i+this.C|0,o=o+this.D|0,s=s+this.E|0,a=a+this.F|0,c=c+this.G|0,u=u+this.H|0,this.set(r,n,i,o,s,a,c,u)}roundClean(){Wc.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Yc=Qi((()=>new Zc));var Qc=r(43);function Xc(t,e){let r=0;if(1===t.length)return t[0];for(let n=t.length-1;n>=0;n--)r+=t[t.length-1-n]*Math.pow(2,e*n);return r}function tu(t,e,r=-1){const n=r;let i=t,o=0,s=Math.pow(2,e);for(let r=1;r<8;r++){if(t<s){let t;if(n<0)t=new ArrayBuffer(r),o=r;else{if(n<r)return new ArrayBuffer(0);t=new ArrayBuffer(n),o=n}const s=new Uint8Array(t);for(let t=r-1;t>=0;t--){const r=Math.pow(2,t*e);s[o-t-1]=Math.floor(i/r),i-=s[o-t-1]*r}return t}s*=Math.pow(2,e)}return new ArrayBuffer(0)}function eu(...t){let e=0,r=0;for(const r of t)e+=r.length;const n=new ArrayBuffer(e),i=new Uint8Array(n);for(const e of t)i.set(e,r),r+=e.length;return i}function ru(){const t=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const e=255===t[0]&&128&t[1],r=0===t[0]&&0==(128&t[1]);(e||r)&&this.warnings.push("Needlessly long format")}const e=new ArrayBuffer(this.valueHex.byteLength),r=new Uint8Array(e);for(let t=0;t<this.valueHex.byteLength;t++)r[t]=0;r[0]=128&t[0];const n=Xc(r,8),i=new ArrayBuffer(this.valueHex.byteLength),o=new Uint8Array(i);for(let e=0;e<this.valueHex.byteLength;e++)o[e]=t[e];return o[0]&=127,Xc(o,8)-n}function nu(t,e){const r=t.toString(10);if(e<r.length)return"";const n=e-r.length,i=new Array(n);for(let t=0;t<n;t++)i[t]="0";return i.join("").concat(r)}function iu(){if("undefined"==typeof BigInt)throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function ou(t){let e=0,r=0;for(let r=0;r<t.length;r++)e+=t[r].byteLength;const n=new Uint8Array(e);for(let e=0;e<t.length;e++){const i=t[e];n.set(new Uint8Array(i),r),r+=i.byteLength}return n.buffer}function su(t,e,r,n){return e instanceof Uint8Array?e.byteLength?r<0?(t.error="Wrong parameter: inputOffset less than zero",!1):n<0?(t.error="Wrong parameter: inputLength less than zero",!1):!(e.byteLength-r-n<0&&(t.error="End of input reached before message was fully decoded (inconsistent offset and length values)",1)):(t.error="Wrong parameter: inputBuffer has zero length",!1):(t.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}Math.log(2);class au{constructor(){this.items=[]}write(t){this.items.push(t)}final(){return ou(this.items)}}const cu=[new Uint8Array([1])],uu="0123456789",hu="",lu=new ArrayBuffer(0),fu=new Uint8Array(0),du="EndOfContent",yu="OCTET STRING",pu="BIT STRING";function gu(t){var e;return(e=class extends t{constructor(...t){var e;super(...t);const r=t[0]||{};this.isHexOnly=null!==(e=r.isHexOnly)&&void 0!==e&&e,this.valueHexView=r.valueHex?Qc.vJ.toUint8Array(r.valueHex):fu}get valueHex(){return this.valueHexView.slice().buffer}set valueHex(t){this.valueHexView=new Uint8Array(t)}fromBER(t,e,r){const n=t instanceof ArrayBuffer?new Uint8Array(t):t;if(!su(this,n,e,r))return-1;const i=e+r;return this.valueHexView=n.subarray(e,i),this.valueHexView.length?(this.blockLength=r,i):(this.warnings.push("Zero buffer length"),e)}toBER(t=!1){return this.isHexOnly?t?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",lu)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:Qc.ep.ToHex(this.valueHexView)}}}).NAME="hexBlock",e}class wu{constructor({blockLength:t=0,error:e="",warnings:r=[],valueBeforeDecode:n=fu}={}){this.blockLength=t,this.error=e,this.warnings=r,this.valueBeforeDecodeView=Qc.vJ.toUint8Array(n)}static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(t){this.valueBeforeDecodeView=new Uint8Array(t)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:Qc.ep.ToHex(this.valueBeforeDecodeView)}}}wu.NAME="baseBlock";class bu extends wu{fromBER(t,e,r){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(t,e){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}}bu.NAME="valueBlock";class mu extends(gu(wu)){constructor({idBlock:t={}}={}){var e,r,n,i;super(),t?(this.isHexOnly=null!==(e=t.isHexOnly)&&void 0!==e&&e,this.valueHexView=t.valueHex?Qc.vJ.toUint8Array(t.valueHex):fu,this.tagClass=null!==(r=t.tagClass)&&void 0!==r?r:-1,this.tagNumber=null!==(n=t.tagNumber)&&void 0!==n?n:-1,this.isConstructed=null!==(i=t.isConstructed)&&void 0!==i&&i):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(t=!1){let e=0;switch(this.tagClass){case 1:e|=0;break;case 2:e|=64;break;case 3:e|=128;break;case 4:e|=192;break;default:return this.error="Unknown tag class",lu}if(this.isConstructed&&(e|=32),this.tagNumber<31&&!this.isHexOnly){const r=new Uint8Array(1);if(!t){let t=this.tagNumber;t&=31,e|=t,r[0]=e}return r.buffer}if(!this.isHexOnly){const r=tu(this.tagNumber,7),n=new Uint8Array(r),i=r.byteLength,o=new Uint8Array(i+1);if(o[0]=31|e,!t){for(let t=0;t<i-1;t++)o[t+1]=128|n[t];o[i]=n[i-1]}return o.buffer}const r=new Uint8Array(this.valueHexView.byteLength+1);if(r[0]=31|e,!t){const t=this.valueHexView;for(let e=0;e<t.length-1;e++)r[e+1]=128|t[e];r[this.valueHexView.byteLength]=t[t.length-1]}return r.buffer}fromBER(t,e,r){const n=Qc.vJ.toUint8Array(t);if(!su(this,n,e,r))return-1;const i=n.subarray(e,e+r);if(0===i.length)return this.error="Zero buffer length",-1;switch(192&i[0]){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=32==(32&i[0]),this.isHexOnly=!1;const o=31&i[0];if(31!==o)this.tagNumber=o,this.blockLength=1;else{let t=1,e=this.valueHexView=new Uint8Array(255),r=255;for(;128&i[t];){if(e[t-1]=127&i[t],t++,t>=i.length)return this.error="End of input reached before message was fully decoded",-1;if(t===r){r+=255;const t=new Uint8Array(r);for(let r=0;r<e.length;r++)t[r]=e[r];e=this.valueHexView=new Uint8Array(r)}}this.blockLength=t+1,e[t-1]=127&i[t];const n=new Uint8Array(t);for(let r=0;r<t;r++)n[r]=e[r];e=this.valueHexView=new Uint8Array(t),e.set(n),this.blockLength<=9?this.tagNumber=Xc(e,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return e+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}}mu.NAME="identificationBlock";class vu extends wu{constructor({lenBlock:t={}}={}){var e,r,n;super(),this.isIndefiniteForm=null!==(e=t.isIndefiniteForm)&&void 0!==e&&e,this.longFormUsed=null!==(r=t.longFormUsed)&&void 0!==r&&r,this.length=null!==(n=t.length)&&void 0!==n?n:0}fromBER(t,e,r){const n=Qc.vJ.toUint8Array(t);if(!su(this,n,e,r))return-1;const i=n.subarray(e,e+r);if(0===i.length)return this.error="Zero buffer length",-1;if(255===i[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===i[0],this.isIndefiniteForm)return this.blockLength=1,e+this.blockLength;if(this.longFormUsed=!!(128&i[0]),!1===this.longFormUsed)return this.length=i[0],this.blockLength=1,e+this.blockLength;const o=127&i[0];if(o>8)return this.error="Too big integer",-1;if(o+1>i.length)return this.error="End of input reached before message was fully decoded",-1;const s=e+1,a=n.subarray(s,s+o);return 0===a[o-1]&&this.warnings.push("Needlessly long encoded length"),this.length=Xc(a,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=o+1,e+this.blockLength}toBER(t=!1){let e,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return e=new ArrayBuffer(1),!1===t&&(r=new Uint8Array(e),r[0]=128),e;if(this.longFormUsed){const n=tu(this.length,8);if(n.byteLength>127)return this.error="Too big length",lu;if(e=new ArrayBuffer(n.byteLength+1),t)return e;const i=new Uint8Array(n);r=new Uint8Array(e),r[0]=128|n.byteLength;for(let t=0;t<n.byteLength;t++)r[t+1]=i[t];return e}return e=new ArrayBuffer(1),!1===t&&(r=new Uint8Array(e),r[0]=this.length),e}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}}vu.NAME="lengthBlock";const Eu={};class xu extends wu{constructor({name:t="",optional:e=!1,primitiveSchema:r,...n}={},i){super(n),this.name=t,this.optional=e,r&&(this.primitiveSchema=r),this.idBlock=new mu(n),this.lenBlock=new vu(n),this.valueBlock=i?new i(n):new bu(n)}fromBER(t,e,r){const n=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),n)}toBER(t,e){const r=e||new au;e||Bu(this);const n=this.idBlock.toBER(t);if(r.write(n),this.lenBlock.isIndefiniteForm)r.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(t,r),r.write(new ArrayBuffer(2));else{const e=this.valueBlock.toBER(t);this.lenBlock.length=e.byteLength;const n=this.lenBlock.toBER(t);r.write(n),r.write(e)}return e?lu:r.final()}toJSON(){const t={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(t.primitiveSchema=this.primitiveSchema.toJSON()),t}toString(t="ascii"){return"ascii"===t?this.onAsciiEncoding():Qc.ep.ToHex(this.toBER())}onAsciiEncoding(){return`${this.constructor.NAME} : ${Qc.ep.ToHex(this.valueBlock.valueBeforeDecodeView)}`}isEqual(t){return this===t||t instanceof this.constructor&&function(t,e){if(t.byteLength!==e.byteLength)return!1;const r=new Uint8Array(t),n=new Uint8Array(e);for(let t=0;t<r.length;t++)if(r[t]!==n[t])return!1;return!0}(this.toBER(),t.toBER())}}function Bu(t){if(t instanceof Eu.Constructed)for(const e of t.valueBlock.value)Bu(e)&&(t.lenBlock.isIndefiniteForm=!0);return!!t.lenBlock.isIndefiniteForm}xu.NAME="BaseBlock";class Au extends xu{constructor({value:t="",...e}={},r){super(e,r),t&&this.fromString(t)}getValue(){return this.valueBlock.value}setValue(t){this.valueBlock.value=t}fromBER(t,e,r){const n=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),n)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}}Au.NAME="BaseStringBlock";class ku extends(gu(bu)){constructor({isHexOnly:t=!0,...e}={}){super(e),this.isHexOnly=t}}var Su,Iu,Tu,Cu,Uu,Lu,Nu,Ou,_u,Ru,Du,Vu,Mu,Pu,Hu,$u,Fu,ju,zu,qu,Ku,Gu,Ju,Wu,Zu,Yu,Qu,Xu,th,eh,rh,nh,ih;ku.NAME="PrimitiveValueBlock";class oh extends xu{constructor(t={}){super(t,ku),this.idBlock.isConstructed=!1}}function sh(t,e=0,r=t.length){const n=e;let i=new xu({},bu);const o=new wu;if(!su(o,t,e,r))return i.error=o.error,{offset:-1,result:i};if(!t.subarray(e,e+r).length)return i.error="Zero buffer length",{offset:-1,result:i};let s=i.idBlock.fromBER(t,e,r);if(i.idBlock.warnings.length&&i.warnings.concat(i.idBlock.warnings),-1===s)return i.error=i.idBlock.error,{offset:-1,result:i};if(e=s,r-=i.idBlock.blockLength,s=i.lenBlock.fromBER(t,e,r),i.lenBlock.warnings.length&&i.warnings.concat(i.lenBlock.warnings),-1===s)return i.error=i.lenBlock.error,{offset:-1,result:i};if(e=s,r-=i.lenBlock.blockLength,!i.idBlock.isConstructed&&i.lenBlock.isIndefiniteForm)return i.error="Indefinite length form used for primitive encoding form",{offset:-1,result:i};let a=xu;if(1===i.idBlock.tagClass){if(i.idBlock.tagNumber>=37&&!1===i.idBlock.isHexOnly)return i.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:i};switch(i.idBlock.tagNumber){case 0:if(i.idBlock.isConstructed&&i.lenBlock.length>0)return i.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:i};a=Eu.EndOfContent;break;case 1:a=Eu.Boolean;break;case 2:a=Eu.Integer;break;case 3:a=Eu.BitString;break;case 4:a=Eu.OctetString;break;case 5:a=Eu.Null;break;case 6:a=Eu.ObjectIdentifier;break;case 10:a=Eu.Enumerated;break;case 12:a=Eu.Utf8String;break;case 13:a=Eu.RelativeObjectIdentifier;break;case 14:a=Eu.TIME;break;case 15:return i.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:i};case 16:a=Eu.Sequence;break;case 17:a=Eu.Set;break;case 18:a=Eu.NumericString;break;case 19:a=Eu.PrintableString;break;case 20:a=Eu.TeletexString;break;case 21:a=Eu.VideotexString;break;case 22:a=Eu.IA5String;break;case 23:a=Eu.UTCTime;break;case 24:a=Eu.GeneralizedTime;break;case 25:a=Eu.GraphicString;break;case 26:a=Eu.VisibleString;break;case 27:a=Eu.GeneralString;break;case 28:a=Eu.UniversalString;break;case 29:a=Eu.CharacterString;break;case 30:a=Eu.BmpString;break;case 31:a=Eu.DATE;break;case 32:a=Eu.TimeOfDay;break;case 33:a=Eu.DateTime;break;case 34:a=Eu.Duration;break;default:{const t=i.idBlock.isConstructed?new Eu.Constructed:new Eu.Primitive;t.idBlock=i.idBlock,t.lenBlock=i.lenBlock,t.warnings=i.warnings,i=t}}}else a=i.idBlock.isConstructed?Eu.Constructed:Eu.Primitive;return i=function(t,e){if(t instanceof e)return t;const r=new e;return r.idBlock=t.idBlock,r.lenBlock=t.lenBlock,r.warnings=t.warnings,r.valueBeforeDecodeView=t.valueBeforeDecodeView,r}(i,a),s=i.fromBER(t,e,i.lenBlock.isIndefiniteForm?r:i.lenBlock.length),i.valueBeforeDecodeView=t.subarray(n,n+i.blockLength),{offset:s,result:i}}function ah(t){if(!t.byteLength){const t=new xu({},bu);return t.error="Input buffer has zero length",{offset:-1,result:t}}return sh(Qc.vJ.toUint8Array(t).slice(),0,t.byteLength)}Su=oh,Eu.Primitive=Su,oh.NAME="PRIMITIVE";class ch extends bu{constructor({value:t=[],isIndefiniteForm:e=!1,...r}={}){super(r),this.value=t,this.isIndefiniteForm=e}fromBER(t,e,r){const n=Qc.vJ.toUint8Array(t);if(!su(this,n,e,r))return-1;if(this.valueBeforeDecodeView=n.subarray(e,e+r),0===this.valueBeforeDecodeView.length)return this.warnings.push("Zero buffer length"),e;let i=e;for(;(this.isIndefiniteForm?1:r)>0;){const t=sh(n,i,r);if(-1===t.offset)return this.error=t.result.error,this.warnings.concat(t.result.warnings),-1;if(i=t.offset,this.blockLength+=t.result.blockLength,r-=t.result.blockLength,this.value.push(t.result),this.isIndefiniteForm&&t.result.constructor.NAME===du)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===du?this.value.pop():this.warnings.push("No EndOfContent block encoded")),i}toBER(t,e){const r=e||new au;for(let e=0;e<this.value.length;e++)this.value[e].toBER(t,r);return e?lu:r.final()}toJSON(){const t={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(const e of this.value)t.value.push(e.toJSON());return t}}ch.NAME="ConstructedValueBlock";class uh extends xu{constructor(t={}){super(t,ch),this.idBlock.isConstructed=!0}fromBER(t,e,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const n=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),n)}onAsciiEncoding(){const t=[];for(const e of this.valueBlock.value)t.push(e.toString("ascii").split("\n").map((t=>`  ${t}`)).join("\n"));const e=3===this.idBlock.tagClass?`[${this.idBlock.tagNumber}]`:this.constructor.NAME;return t.length?`${e} :\n${t.join("\n")}`:`${e} :`}}Iu=uh,Eu.Constructed=Iu,uh.NAME="CONSTRUCTED";class hh extends bu{fromBER(t,e,r){return e}toBER(t){return lu}}hh.override="EndOfContentValueBlock";class lh extends xu{constructor(t={}){super(t,hh),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}}Tu=lh,Eu.EndOfContent=Tu,lh.NAME=du;class fh extends xu{constructor(t={}){super(t,bu),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}fromBER(t,e,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,e+r>t.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):e+r}toBER(t,e){const r=new ArrayBuffer(2);if(!t){const t=new Uint8Array(r);t[0]=5,t[1]=0}return e&&e.write(r),r}onAsciiEncoding(){return`${this.constructor.NAME}`}}Cu=fh,Eu.Null=Cu,fh.NAME="NULL";class dh extends(gu(bu)){constructor({value:t,...e}={}){super(e),e.valueHex?this.valueHexView=Qc.vJ.toUint8Array(e.valueHex):this.valueHexView=new Uint8Array(1),t&&(this.value=t)}get value(){for(const t of this.valueHexView)if(t>0)return!0;return!1}set value(t){this.valueHexView[0]=t?255:0}fromBER(t,e,r){const n=Qc.vJ.toUint8Array(t);return su(this,n,e,r)?(this.valueHexView=n.subarray(e,e+r),r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,ru.call(this),this.blockLength=r,e+r):-1}toBER(){return this.valueHexView.slice()}toJSON(){return{...super.toJSON(),value:this.value}}}dh.NAME="BooleanValueBlock";class yh extends xu{constructor(t={}){super(t,dh),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}getValue(){return this.valueBlock.value}setValue(t){this.valueBlock.value=t}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.getValue}`}}Uu=yh,Eu.Boolean=Uu,yh.NAME="BOOLEAN";class ph extends(gu(ch)){constructor({isConstructed:t=!1,...e}={}){super(e),this.isConstructed=t}fromBER(t,e,r){let n=0;if(this.isConstructed){if(this.isHexOnly=!1,n=ch.prototype.fromBER.call(this,t,e,r),-1===n)return n;for(let t=0;t<this.value.length;t++){const e=this.value[t].constructor.NAME;if(e===du){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(e!==yu)return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,n=super.fromBER(t,e,r),this.blockLength=r;return n}toBER(t,e){return this.isConstructed?ch.prototype.toBER.call(this,t,e):t?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),isConstructed:this.isConstructed}}}ph.NAME="OctetStringValueBlock";class gh extends xu{constructor({idBlock:t={},lenBlock:e={},...r}={}){var n,i;null!==(n=r.isConstructed)&&void 0!==n||(r.isConstructed=!!(null===(i=r.value)||void 0===i?void 0:i.length)),super({idBlock:{isConstructed:r.isConstructed,...t},lenBlock:{...e,isIndefiniteForm:!!r.isIndefiniteForm},...r},ph),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(t,e,r){if(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===r)return 0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),e;if(!this.valueBlock.isConstructed){const n=(t instanceof ArrayBuffer?new Uint8Array(t):t).subarray(e,e+r);try{if(n.byteLength){const t=sh(n,0,n.byteLength);-1!==t.offset&&t.offset===r&&(this.valueBlock.value=[t.result])}}catch(t){}}return super.fromBER(t,e,r)}onAsciiEncoding(){return this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length?uh.prototype.onAsciiEncoding.call(this):`${this.constructor.NAME} : ${Qc.ep.ToHex(this.valueBlock.valueHexView)}`}getValue(){if(!this.idBlock.isConstructed)return this.valueBlock.valueHexView.slice().buffer;const t=[];for(const e of this.valueBlock.value)e instanceof gh&&t.push(e.valueBlock.valueHexView);return Qc.vJ.concat(t)}}Lu=gh,Eu.OctetString=Lu,gh.NAME=yu;class wh extends(gu(ch)){constructor({unusedBits:t=0,isConstructed:e=!1,...r}={}){super(r),this.unusedBits=t,this.isConstructed=e,this.blockLength=this.valueHexView.byteLength}fromBER(t,e,r){if(!r)return e;let n=-1;if(this.isConstructed){if(n=ch.prototype.fromBER.call(this,t,e,r),-1===n)return n;for(const t of this.value){const e=t.constructor.NAME;if(e===du){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(e!==pu)return this.error="BIT STRING may consists of BIT STRINGs only",-1;const r=t.valueBlock;if(this.unusedBits>0&&r.unusedBits>0)return this.error='Using of "unused bits" inside constructive BIT STRING allowed for least one only',-1;this.unusedBits=r.unusedBits}return n}const i=Qc.vJ.toUint8Array(t);if(!su(this,i,e,r))return-1;const o=i.subarray(e,e+r);if(this.unusedBits=o[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;if(!this.unusedBits){const t=o.subarray(1);try{if(t.byteLength){const e=sh(t,0,t.byteLength);-1!==e.offset&&e.offset===r-1&&(this.value=[e.result])}}catch(t){}}return this.valueHexView=o.subarray(1),this.blockLength=o.length,e+r}toBER(t,e){if(this.isConstructed)return ch.prototype.toBER.call(this,t,e);if(t)return new ArrayBuffer(this.valueHexView.byteLength+1);if(!this.valueHexView.byteLength)return lu;const r=new Uint8Array(this.valueHexView.length+1);return r[0]=this.unusedBits,r.set(this.valueHexView,1),r.buffer}toJSON(){return{...super.toJSON(),unusedBits:this.unusedBits,isConstructed:this.isConstructed}}}wh.NAME="BitStringValueBlock";class bh extends xu{constructor({idBlock:t={},lenBlock:e={},...r}={}){var n,i;null!==(n=r.isConstructed)&&void 0!==n||(r.isConstructed=!!(null===(i=r.value)||void 0===i?void 0:i.length)),super({idBlock:{isConstructed:r.isConstructed,...t},lenBlock:{...e,isIndefiniteForm:!!r.isIndefiniteForm},...r},wh),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}fromBER(t,e,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(t,e,r)}onAsciiEncoding(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return uh.prototype.onAsciiEncoding.call(this);{const t=[],e=this.valueBlock.valueHexView;for(const r of e)t.push(r.toString(2).padStart(8,"0"));const r=t.join("");return`${this.constructor.NAME} : ${r.substring(0,r.length-this.valueBlock.unusedBits)}`}}}function mh(t,e){const r=new Uint8Array([0]),n=new Uint8Array(t),i=new Uint8Array(e);let o=n.slice(0);const s=o.length-1,a=i.slice(0),c=a.length-1;let u=0,h=0;for(let t=c<s?s:c;t>=0;t--,h++)u=1==h<a.length?o[s-h]+a[c-h]+r[0]:o[s-h]+r[0],r[0]=u/10,1==h>=o.length?o=eu(new Uint8Array([u%10]),o):o[s-h]=u%10;return r[0]>0&&(o=eu(r,o)),o}function vh(t){if(t>=cu.length)for(let e=cu.length;e<=t;e++){const t=new Uint8Array([0]);let r=cu[e-1].slice(0);for(let e=r.length-1;e>=0;e--){const n=new Uint8Array([(r[e]<<1)+t[0]]);t[0]=n[0]/10,r[e]=n[0]%10}t[0]>0&&(r=eu(t,r)),cu.push(r)}return cu[t]}function Eh(t,e){let r=0;const n=new Uint8Array(t),i=new Uint8Array(e),o=n.slice(0),s=o.length-1,a=i.slice(0),c=a.length-1;let u,h=0;for(let t=c;t>=0;t--,h++)u=o[s-h]-a[c-h]-r,1==u<0?(r=1,o[s-h]=u+10):(r=0,o[s-h]=u);if(r>0)for(let t=s-c+1;t>=0;t--,h++){if(u=o[s-h]-r,!(u<0)){r=0,o[s-h]=u;break}r=1,o[s-h]=u+10}return o.slice()}Nu=bh,Eu.BitString=Nu,bh.NAME=pu;class xh extends(gu(bu)){constructor({value:t,...e}={}){super(e),this._valueDec=0,e.valueHex&&this.setValueHex(),void 0!==t&&(this.valueDec=t)}setValueHex(){this.valueHexView.length>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,this.valueHexView.length>0&&(this._valueDec=ru.call(this)))}set valueDec(t){this._valueDec=t,this.isHexOnly=!1,this.valueHexView=new Uint8Array(function(t){const e=t<0?-1*t:t;let r=128;for(let n=1;n<8;n++){if(e<=r){if(t<0){const t=tu(r-e,8,n);return new Uint8Array(t)[0]|=128,t}let i=tu(e,8,n),o=new Uint8Array(i);if(128&o[0]){const t=i.slice(0),e=new Uint8Array(t);i=new ArrayBuffer(i.byteLength+1),o=new Uint8Array(i);for(let r=0;r<t.byteLength;r++)o[r+1]=e[r];o[0]=0}return i}r*=Math.pow(2,8)}return new ArrayBuffer(0)}(t))}get valueDec(){return this._valueDec}fromDER(t,e,r,n=0){const i=this.fromBER(t,e,r);if(-1===i)return i;const o=this.valueHexView;return 0===o[0]&&0!=(128&o[1])?this.valueHexView=o.subarray(1):0!==n&&o.length<n&&(n-o.length>1&&(n=o.length+1),this.valueHexView=o.subarray(n-o.length)),i}toDER(t=!1){const e=this.valueHexView;switch(!0){case 0!=(128&e[0]):{const t=new Uint8Array(this.valueHexView.length+1);t[0]=0,t.set(e,1),this.valueHexView=t}break;case 0===e[0]&&0==(128&e[1]):this.valueHexView=this.valueHexView.subarray(1)}return this.toBER(t)}fromBER(t,e,r){const n=super.fromBER(t,e,r);return-1===n||this.setValueHex(),n}toBER(t){return t?new ArrayBuffer(this.valueHexView.length):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}toString(){const t=8*this.valueHexView.length-1;let e,r=new Uint8Array(8*this.valueHexView.length/3),n=0;const i=this.valueHexView;let o="",s=!1;for(let s=i.byteLength-1;s>=0;s--){e=i[s];for(let i=0;i<8;i++)1==(1&e)&&(n===t?(r=Eh(vh(n),r),o="-"):r=mh(r,vh(n))),n++,e>>=1}for(let t=0;t<r.length;t++)r[t]&&(s=!0),s&&(o+=uu.charAt(r[t]));return!1===s&&(o+=uu.charAt(0)),o}}Ou=xh,xh.NAME="IntegerValueBlock",Object.defineProperty(Ou.prototype,"valueHex",{set:function(t){this.valueHexView=new Uint8Array(t),this.setValueHex()},get:function(){return this.valueHexView.slice().buffer}});class Bh extends xu{constructor(t={}){super(t,xh),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}toBigInt(){return iu(),BigInt(this.valueBlock.toString())}static fromBigInt(t){iu();const e=BigInt(t),r=new au,n=e.toString(16).replace(/^-/,""),i=new Uint8Array(Qc.ep.FromHex(n));if(e<0){const t=new Uint8Array(i.length+(128&i[0]?1:0));t[0]|=128;const n=BigInt(`0x${Qc.ep.ToHex(t)}`)+e,o=Qc.vJ.toUint8Array(Qc.ep.FromHex(n.toString(16)));o[0]|=128,r.write(o)}else 128&i[0]&&r.write(new Uint8Array([0])),r.write(i);return new Bh({valueHex:r.final()})}convertToDER(){const t=new Bh({valueHex:this.valueBlock.valueHexView});return t.valueBlock.toDER(),t}convertFromDER(){return new Bh({valueHex:0===this.valueBlock.valueHexView[0]?this.valueBlock.valueHexView.subarray(1):this.valueBlock.valueHexView})}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()}`}}_u=Bh,Eu.Integer=_u,Bh.NAME="INTEGER";class Ah extends Bh{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}}Ru=Ah,Eu.Enumerated=Ru,Ah.NAME="ENUMERATED";class kh extends(gu(bu)){constructor({valueDec:t=-1,isFirstSid:e=!1,...r}={}){super(r),this.valueDec=t,this.isFirstSid=e}fromBER(t,e,r){if(!r)return e;const n=Qc.vJ.toUint8Array(t);if(!su(this,n,e,r))return-1;const i=n.subarray(e,e+r);this.valueHexView=new Uint8Array(r);for(let t=0;t<r&&(this.valueHexView[t]=127&i[t],this.blockLength++,0!=(128&i[t]));t++);const o=new Uint8Array(this.blockLength);for(let t=0;t<this.blockLength;t++)o[t]=this.valueHexView[t];return this.valueHexView=o,0!=(128&i[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===this.valueHexView[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=Xc(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),e+this.blockLength)}set valueBigInt(t){iu();let e=BigInt(t).toString(2);for(;e.length%7;)e="0"+e;const r=new Uint8Array(e.length/7);for(let t=0;t<r.length;t++)r[t]=parseInt(e.slice(7*t,7*t+7),2)+(t+1<r.length?128:0);this.fromBER(r.buffer,0,r.length)}toBER(t){if(this.isHexOnly){if(t)return new ArrayBuffer(this.valueHexView.byteLength);const e=this.valueHexView,r=new Uint8Array(this.blockLength);for(let t=0;t<this.blockLength-1;t++)r[t]=128|e[t];return r[this.blockLength-1]=e[this.blockLength-1],r.buffer}const e=tu(this.valueDec,7);if(0===e.byteLength)return this.error="Error during encoding SID value",lu;const r=new Uint8Array(e.byteLength);if(!t){const t=new Uint8Array(e),n=e.byteLength-1;for(let e=0;e<n;e++)r[e]=128|t[e];r[n]=t[n]}return r}toString(){let t="";if(this.isHexOnly)t=Qc.ep.ToHex(this.valueHexView);else if(this.isFirstSid){let e=this.valueDec;this.valueDec<=39?t="0.":this.valueDec<=79?(t="1.",e-=40):(t="2.",e-=80),t+=e.toString()}else t=this.valueDec.toString();return t}toJSON(){return{...super.toJSON(),valueDec:this.valueDec,isFirstSid:this.isFirstSid}}}kh.NAME="sidBlock";class Sh extends bu{constructor({value:t="",...e}={}){super(e),this.value=[],t&&this.fromString(t)}fromBER(t,e,r){let n=e;for(;r>0;){const e=new kh;if(n=e.fromBER(t,n,r),-1===n)return this.blockLength=0,this.error=e.error,n;0===this.value.length&&(e.isFirstSid=!0),this.blockLength+=e.blockLength,r-=e.blockLength,this.value.push(e)}return n}toBER(t){const e=[];for(let r=0;r<this.value.length;r++){const n=this.value[r].toBER(t);if(0===n.byteLength)return this.error=this.value[r].error,lu;e.push(n)}return ou(e)}fromString(t){this.value=[];let e=0,r=0,n="",i=!1;do{if(r=t.indexOf(".",e),n=-1===r?t.substring(e):t.substring(e,r),e=r+1,i){const t=this.value[0];let e=0;switch(t.valueDec){case 0:break;case 1:e=40;break;case 2:e=80;break;default:return void(this.value=[])}const r=parseInt(n,10);if(isNaN(r))return;t.valueDec=r+e,i=!1}else{const t=new kh;if(n>Number.MAX_SAFE_INTEGER){iu();const e=BigInt(n);t.valueBigInt=e}else if(t.valueDec=parseInt(n,10),isNaN(t.valueDec))return;this.value.length||(t.isFirstSid=!0,i=!0),this.value.push(t)}}while(-1!==r)}toString(){let t="",e=!1;for(let r=0;r<this.value.length;r++){e=this.value[r].isHexOnly;let n=this.value[r].toString();0!==r&&(t=`${t}.`),e?(n=`{${n}}`,this.value[r].isFirstSid?t=`2.{${n} - 80}`:t+=n):t+=n}return t}toJSON(){const t={...super.toJSON(),value:this.toString(),sidArray:[]};for(let e=0;e<this.value.length;e++)t.sidArray.push(this.value[e].toJSON());return t}}Sh.NAME="ObjectIdentifierValueBlock";class Ih extends xu{constructor(t={}){super(t,Sh),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}getValue(){return this.valueBlock.toString()}setValue(t){this.valueBlock.fromString(t)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}Du=Ih,Eu.ObjectIdentifier=Du,Ih.NAME="OBJECT IDENTIFIER";class Th extends(gu(wu)){constructor({valueDec:t=0,...e}={}){super(e),this.valueDec=t}fromBER(t,e,r){if(0===r)return e;const n=Qc.vJ.toUint8Array(t);if(!su(this,n,e,r))return-1;const i=n.subarray(e,e+r);this.valueHexView=new Uint8Array(r);for(let t=0;t<r&&(this.valueHexView[t]=127&i[t],this.blockLength++,0!=(128&i[t]));t++);const o=new Uint8Array(this.blockLength);for(let t=0;t<this.blockLength;t++)o[t]=this.valueHexView[t];return this.valueHexView=o,0!=(128&i[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===this.valueHexView[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=Xc(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),e+this.blockLength)}toBER(t){if(this.isHexOnly){if(t)return new ArrayBuffer(this.valueHexView.byteLength);const e=this.valueHexView,r=new Uint8Array(this.blockLength);for(let t=0;t<this.blockLength-1;t++)r[t]=128|e[t];return r[this.blockLength-1]=e[this.blockLength-1],r.buffer}const e=tu(this.valueDec,7);if(0===e.byteLength)return this.error="Error during encoding SID value",lu;const r=new Uint8Array(e.byteLength);if(!t){const t=new Uint8Array(e),n=e.byteLength-1;for(let e=0;e<n;e++)r[e]=128|t[e];r[n]=t[n]}return r.buffer}toString(){let t="";return t=this.isHexOnly?Qc.ep.ToHex(this.valueHexView):this.valueDec.toString(),t}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}}Th.NAME="relativeSidBlock";class Ch extends bu{constructor({value:t="",...e}={}){super(e),this.value=[],t&&this.fromString(t)}fromBER(t,e,r){let n=e;for(;r>0;){const e=new Th;if(n=e.fromBER(t,n,r),-1===n)return this.blockLength=0,this.error=e.error,n;this.blockLength+=e.blockLength,r-=e.blockLength,this.value.push(e)}return n}toBER(t,e){const r=[];for(let e=0;e<this.value.length;e++){const n=this.value[e].toBER(t);if(0===n.byteLength)return this.error=this.value[e].error,lu;r.push(n)}return ou(r)}fromString(t){this.value=[];let e=0,r=0,n="";do{r=t.indexOf(".",e),n=-1===r?t.substring(e):t.substring(e,r),e=r+1;const i=new Th;if(i.valueDec=parseInt(n,10),isNaN(i.valueDec))return!0;this.value.push(i)}while(-1!==r);return!0}toString(){let t="",e=!1;for(let r=0;r<this.value.length;r++){e=this.value[r].isHexOnly;let n=this.value[r].toString();0!==r&&(t=`${t}.`),e?(n=`{${n}}`,t+=n):t+=n}return t}toJSON(){const t={...super.toJSON(),value:this.toString(),sidArray:[]};for(let e=0;e<this.value.length;e++)t.sidArray.push(this.value[e].toJSON());return t}}Ch.NAME="RelativeObjectIdentifierValueBlock";class Uh extends xu{constructor(t={}){super(t,Ch),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}getValue(){return this.valueBlock.toString()}setValue(t){this.valueBlock.fromString(t)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}Vu=Uh,Eu.RelativeObjectIdentifier=Vu,Uh.NAME="RelativeObjectIdentifier";class Lh extends uh{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}}Mu=Lh,Eu.Sequence=Mu,Lh.NAME="SEQUENCE";class Nh extends uh{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}}Pu=Nh,Eu.Set=Pu,Nh.NAME="SET";class Oh extends(gu(bu)){constructor({...t}={}){super(t),this.isHexOnly=!0,this.value=hu}toJSON(){return{...super.toJSON(),value:this.value}}}Oh.NAME="StringValueBlock";class _h extends Oh{}_h.NAME="SimpleStringValueBlock";class Rh extends Au{constructor({...t}={}){super(t,_h)}fromBuffer(t){this.valueBlock.value=String.fromCharCode.apply(null,Qc.vJ.toUint8Array(t))}fromString(t){const e=t.length,r=this.valueBlock.valueHexView=new Uint8Array(e);for(let n=0;n<e;n++)r[n]=t.charCodeAt(n);this.valueBlock.value=t}}Rh.NAME="SIMPLE STRING";class Dh extends Rh{fromBuffer(t){this.valueBlock.valueHexView=Qc.vJ.toUint8Array(t);try{this.valueBlock.value=Qc.ep.ToUtf8String(t)}catch(e){this.warnings.push(`Error during "decodeURIComponent": ${e}, using raw string`),this.valueBlock.value=Qc.ep.ToBinary(t)}}fromString(t){this.valueBlock.valueHexView=new Uint8Array(Qc.ep.FromUtf8String(t)),this.valueBlock.value=t}}Dh.NAME="Utf8StringValueBlock";class Vh extends Dh{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}}Hu=Vh,Eu.Utf8String=Hu,Vh.NAME="UTF8String";class Mh extends Rh{fromBuffer(t){this.valueBlock.value=Qc.ep.ToUtf16String(t),this.valueBlock.valueHexView=Qc.vJ.toUint8Array(t)}fromString(t){this.valueBlock.value=t,this.valueBlock.valueHexView=new Uint8Array(Qc.ep.FromUtf16String(t))}}Mh.NAME="BmpStringValueBlock";class Ph extends Mh{constructor({...t}={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}}$u=Ph,Eu.BmpString=$u,Ph.NAME="BMPString";class Hh extends Rh{fromBuffer(t){const e=ArrayBuffer.isView(t)?t.slice().buffer:t.slice(0),r=new Uint8Array(e);for(let t=0;t<r.length;t+=4)r[t]=r[t+3],r[t+1]=r[t+2],r[t+2]=0,r[t+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(e))}fromString(t){const e=t.length,r=this.valueBlock.valueHexView=new Uint8Array(4*e);for(let n=0;n<e;n++){const e=tu(t.charCodeAt(n),8),i=new Uint8Array(e);if(i.length>4)continue;const o=4-i.length;for(let t=i.length-1;t>=0;t--)r[4*n+t+o]=i[t]}this.valueBlock.value=t}}Hh.NAME="UniversalStringValueBlock";class $h extends Hh{constructor({...t}={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}}Fu=$h,Eu.UniversalString=Fu,$h.NAME="UniversalString";class Fh extends Rh{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}}ju=Fh,Eu.NumericString=ju,Fh.NAME="NumericString";class jh extends Rh{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}}zu=jh,Eu.PrintableString=zu,jh.NAME="PrintableString";class zh extends Rh{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}}qu=zh,Eu.TeletexString=qu,zh.NAME="TeletexString";class qh extends Rh{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}}Ku=qh,Eu.VideotexString=Ku,qh.NAME="VideotexString";class Kh extends Rh{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}}Gu=Kh,Eu.IA5String=Gu,Kh.NAME="IA5String";class Gh extends Rh{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}}Ju=Gh,Eu.GraphicString=Ju,Gh.NAME="GraphicString";class Jh extends Rh{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}}Wu=Jh,Eu.VisibleString=Wu,Jh.NAME="VisibleString";class Wh extends Rh{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}}Zu=Wh,Eu.GeneralString=Zu,Wh.NAME="GeneralString";class Zh extends Rh{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}}Yu=Zh,Eu.CharacterString=Yu,Zh.NAME="CharacterString";class Yh extends Jh{constructor({value:t,valueDate:e,...r}={}){if(super(r),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,t){this.fromString(t),this.valueBlock.valueHexView=new Uint8Array(t.length);for(let e=0;e<t.length;e++)this.valueBlock.valueHexView[e]=t.charCodeAt(e)}e&&(this.fromDate(e),this.valueBlock.valueHexView=new Uint8Array(this.toBuffer())),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBuffer(t){this.fromString(String.fromCharCode.apply(null,Qc.vJ.toUint8Array(t)))}toBuffer(){const t=this.toString(),e=new ArrayBuffer(t.length),r=new Uint8Array(e);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);return e}fromDate(t){this.year=t.getUTCFullYear(),this.month=t.getUTCMonth()+1,this.day=t.getUTCDate(),this.hour=t.getUTCHours(),this.minute=t.getUTCMinutes(),this.second=t.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(t){const e=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi.exec(t);if(null===e)return void(this.error="Wrong input string for conversion");const r=parseInt(e[1],10);this.year=r>=50?1900+r:2e3+r,this.month=parseInt(e[2],10),this.day=parseInt(e[3],10),this.hour=parseInt(e[4],10),this.minute=parseInt(e[5],10),this.second=parseInt(e[6],10)}toString(t="iso"){if("iso"===t){const t=new Array(7);return t[0]=nu(this.year<2e3?this.year-1900:this.year-2e3,2),t[1]=nu(this.month,2),t[2]=nu(this.day,2),t[3]=nu(this.hour,2),t[4]=nu(this.minute,2),t[5]=nu(this.second,2),t[6]="Z",t.join("")}return super.toString(t)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.toDate().toISOString()}`}toJSON(){return{...super.toJSON(),year:this.year,month:this.month,day:this.day,hour:this.hour,minute:this.minute,second:this.second}}}Qu=Yh,Eu.UTCTime=Qu,Yh.NAME="UTCTime";class Qh extends Yh{constructor(t={}){var e;super(t),null!==(e=this.millisecond)&&void 0!==e||(this.millisecond=0),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromDate(t){super.fromDate(t),this.millisecond=t.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(t){let e,r=!1,n="",i="",o=0,s=0,a=0;if("Z"===t[t.length-1])n=t.substring(0,t.length-1),r=!0;else{const e=new Number(t[t.length-1]);if(isNaN(e.valueOf()))throw new Error("Wrong input string for conversion");n=t}if(r){if(-1!==n.indexOf("+"))throw new Error("Wrong input string for conversion");if(-1!==n.indexOf("-"))throw new Error("Wrong input string for conversion")}else{let t=1,e=n.indexOf("+"),r="";if(-1===e&&(e=n.indexOf("-"),t=-1),-1!==e){if(r=n.substring(e+1),n=n.substring(0,e),2!==r.length&&4!==r.length)throw new Error("Wrong input string for conversion");let i=parseInt(r.substring(0,2),10);if(isNaN(i.valueOf()))throw new Error("Wrong input string for conversion");if(s=t*i,4===r.length){if(i=parseInt(r.substring(2,4),10),isNaN(i.valueOf()))throw new Error("Wrong input string for conversion");a=t*i}}}let c=n.indexOf(".");if(-1===c&&(c=n.indexOf(",")),-1!==c){const t=new Number(`0${n.substring(c)}`);if(isNaN(t.valueOf()))throw new Error("Wrong input string for conversion");o=t.valueOf(),i=n.substring(0,c)}else i=n;switch(!0){case 8===i.length:if(e=/(\d{4})(\d{2})(\d{2})/gi,-1!==c)throw new Error("Wrong input string for conversion");break;case 10===i.length:if(e=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==c){let t=60*o;this.minute=Math.floor(t),t=60*(t-this.minute),this.second=Math.floor(t),t=1e3*(t-this.second),this.millisecond=Math.floor(t)}break;case 12===i.length:if(e=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==c){let t=60*o;this.second=Math.floor(t),t=1e3*(t-this.second),this.millisecond=Math.floor(t)}break;case 14===i.length:if(e=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==c){const t=1e3*o;this.millisecond=Math.floor(t)}break;default:throw new Error("Wrong input string for conversion")}const u=e.exec(i);if(null===u)throw new Error("Wrong input string for conversion");for(let t=1;t<u.length;t++)switch(t){case 1:this.year=parseInt(u[t],10);break;case 2:this.month=parseInt(u[t],10);break;case 3:this.day=parseInt(u[t],10);break;case 4:this.hour=parseInt(u[t],10)+s;break;case 5:this.minute=parseInt(u[t],10)+a;break;case 6:this.second=parseInt(u[t],10);break;default:throw new Error("Wrong input string for conversion")}if(!1===r){const t=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=t.getUTCFullYear(),this.month=t.getUTCMonth(),this.day=t.getUTCDay(),this.hour=t.getUTCHours(),this.minute=t.getUTCMinutes(),this.second=t.getUTCSeconds(),this.millisecond=t.getUTCMilliseconds()}}toString(t="iso"){if("iso"===t){const t=[];return t.push(nu(this.year,4)),t.push(nu(this.month,2)),t.push(nu(this.day,2)),t.push(nu(this.hour,2)),t.push(nu(this.minute,2)),t.push(nu(this.second,2)),0!==this.millisecond&&(t.push("."),t.push(nu(this.millisecond,3))),t.push("Z"),t.join("")}return super.toString(t)}toJSON(){return{...super.toJSON(),millisecond:this.millisecond}}}Xu=Qh,Eu.GeneralizedTime=Xu,Qh.NAME="GeneralizedTime";class Xh extends Vh{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}}th=Xh,Eu.DATE=th,Xh.NAME="DATE";class tl extends Vh{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}}eh=tl,Eu.TimeOfDay=eh,tl.NAME="TimeOfDay";class el extends Vh{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}}rh=el,Eu.DateTime=rh,el.NAME="DateTime";class rl extends Vh{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}}nh=rl,Eu.Duration=nh,rl.NAME="Duration";class nl extends Vh{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}}function il(t,e="utf8"){const r=Ac[e];if(null==r)throw new Error(`Unsupported encoding "${e}"`);return r.encoder.encode(t).substring(1)}ih=nl,Eu.TIME=ih,nl.NAME="TIME";class ol extends Error{constructor(t="An error occurred while signing a message"){super(t),this.name="SigningError"}}class sl extends Error{constructor(t="An error occurred while verifying a message"){super(t),this.name="VerificationError"}}class al extends Error{constructor(t="Missing Web Crypto API"){super(t),this.name="WebCryptoMissingError"}}const cl={get(t=globalThis){const e=t.crypto;if(null==e?.subtle)throw new al("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return e}};function ul(t){if("RSA"!==t.kty)throw new Jn("invalid key type");if(null==t.n)throw new Jn("invalid key modulus");return 8*kc(t.n,"base64url").length}class hl{type="RSA";_key;_raw;_multihash;constructor(t,e){this._key=t,this._multihash=e}get raw(){return null==this._raw&&(this._raw=yl(this._key)),this._raw}toMultihash(){return this._multihash}toCID(){return _i.createV1(114,this._multihash)}toString(){return ci.encode(this.toMultihash().bytes).substring(1)}equals(t){return null!=t&&t.raw instanceof Uint8Array&&$i(this.raw,t.raw)}verify(t,e){return async function(t,e,r){const n=await cl.get().subtle.importKey("jwk",t,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);return cl.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},n,e,r instanceof Uint8Array?r:r.subarray())}(this._key,e,t)}}class ll{type="RSA";_key;_raw;publicKey;constructor(t,e){this._key=t,this.publicKey=e}get raw(){return null==this._raw&&(this._raw=function(t){if(null==t.n||null==t.e||null==t.d||null==t.p||null==t.q||null==t.dp||null==t.dq||null==t.qi)throw new Jn("JWK was missing components");const e=new Lh({value:[new Bh({value:0}),Bh.fromBigInt(gl(kc(t.n,"base64url"))),Bh.fromBigInt(gl(kc(t.e,"base64url"))),Bh.fromBigInt(gl(kc(t.d,"base64url"))),Bh.fromBigInt(gl(kc(t.p,"base64url"))),Bh.fromBigInt(gl(kc(t.q,"base64url"))),Bh.fromBigInt(gl(kc(t.dp,"base64url"))),Bh.fromBigInt(gl(kc(t.dq,"base64url"))),Bh.fromBigInt(gl(kc(t.qi,"base64url")))]}).toBER();return new Uint8Array(e,0,e.byteLength)}(this._key)),this._raw}equals(t){return null!=t&&t.raw instanceof Uint8Array&&$i(this.raw,t.raw)}sign(t){return async function(t,e){const r=await cl.get().subtle.importKey("jwk",t,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["sign"]),n=await cl.get().subtle.sign({name:"RSASSA-PKCS1-v1_5"},r,e instanceof Uint8Array?e:e.subarray());return new Uint8Array(n,0,n.byteLength)}(this._key,t)}}const fl=8192,dl=18;function yl(t){if(null==t.n||null==t.e)throw new Jn("JWK was missing components");const e=new Lh({value:[new Lh({value:[new Ih({value:"1.2.840.113549.1.1.1"}),new fh]}),new bh({valueHex:new Lh({value:[Bh.fromBigInt(gl(kc(t.n,"base64url"))),Bh.fromBigInt(gl(kc(t.e,"base64url")))]}).toBER()})]}).toBER();return new Uint8Array(e,0,e.byteLength)}function pl(t){let e=t.valueBlock.valueHexView;for(;0===e[0];)e=e.subarray(1);return il(e,"base64url")}function gl(t){const e=[];return t.forEach((function(t){let r=t.toString(16);r.length%2>0&&(r=`0${r}`),e.push(r)})),BigInt("0x"+e.join(""))}class wl extends Yi{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,function(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");Fi(t.outputLen),Fi(t.blockLen)}(t);const r=Wi(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,i=new Uint8Array(n);i.set(r.length>n?t.create().update(r).digest():r);for(let t=0;t<i.length;t++)i[t]^=54;this.iHash.update(i),this.oHash=t.create();for(let t=0;t<i.length;t++)i[t]^=106;this.oHash.update(i),i.fill(0)}update(t){return zi(this),this.iHash.update(t),this}digestInto(t){zi(this),ji(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:n,destroyed:i,blockLen:o,outputLen:s}=this;return t.finished=n,t.destroyed=i,t.blockLen=o,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const bl=(t,e,r)=>new wl(t,e).update(r).digest();bl.create=(t,e)=>new wl(t,e);const{bytesToNumberBE:ml,hexToBytes:vl}=e,El={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(t){const{Err:e}=El;if(t.length<2||2!==t[0])throw new e("Invalid signature integer tag");const r=t[1],n=t.subarray(2,r+2);if(!r||n.length!==r)throw new e("Invalid signature integer: wrong length");if(128&n[0])throw new e("Invalid signature integer: negative");if(0===n[0]&&!(128&n[1]))throw new e("Invalid signature integer: unnecessary leading zero");return{d:ml(n),l:t.subarray(r+2)}},toSig(t){const{Err:e}=El,r="string"==typeof t?vl(t):t;wo(r);let n=r.length;if(n<2||48!=r[0])throw new e("Invalid signature tag");if(r[1]!==n-2)throw new e("Invalid signature: incorrect length");const{d:i,l:o}=El._parseInt(r.subarray(2)),{d:s,l:a}=El._parseInt(o);if(a.length)throw new e("Invalid signature: left bytes after parsing");return{r:i,s}},hexFromSig(t){const e=t=>8&Number.parseInt(t[0],16)?"00"+t:t,r=t=>{const e=t.toString(16);return 1&e.length?`0${e}`:e},n=e(r(t.s)),i=e(r(t.r)),o=n.length/2,s=i.length/2,a=r(o),c=r(s);return`30${r(s+o+4)}02${c}${i}02${a}${n}`}},xl=BigInt(0),Bl=BigInt(1),Al=(BigInt(2),BigInt(3));function kl(t){const e=function(t){const e=es(t);return Ro(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:r,n}=e,i=r.BYTES+1,o=2*r.BYTES+1;function s(t){return jo(t,n)}function a(t){return Ko(t,n)}const{ProjectivePoint:c,normPrivateKeyToScalar:u,weierstrassEquation:h,isWithinCurveOrder:l}=function(t){const e=function(t){const e=es(t);Ro(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:n,a:i}=e;if(r){if(!n.eql(i,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:r}=e,n=e.toBytes||((t,e,n)=>{const i=e.toAffine();return Co(Uint8Array.from([4]),r.toBytes(i.x),r.toBytes(i.y))}),i=e.fromBytes||(t=>{const e=t.subarray(1);return{x:r.fromBytes(e.subarray(0,r.BYTES)),y:r.fromBytes(e.subarray(r.BYTES,2*r.BYTES))}});function o(t){const{a:n,b:i}=e,o=r.sqr(t),s=r.mul(o,t);return r.add(r.add(s,r.mul(t,n)),i)}if(!r.eql(r.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function s(t){return"bigint"==typeof t&&xl<t&&t<e.n}function a(t){if(!s(t))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(t){const{allowedPrivateKeyLengths:r,nByteLength:n,wrapPrivateKey:i,n:o}=e;if(r&&"bigint"!=typeof t){if(go(t)&&(t=mo(t)),"string"!=typeof t||!r.includes(t.length))throw new Error("Invalid key");t=t.padStart(2*n,"0")}let s;try{s="bigint"==typeof t?t:Ao(To("private key",t,n))}catch(e){throw new Error(`private key must be ${n} bytes, hex or bigint, not ${typeof t}`)}return i&&(s=jo(s,o)),a(s),s}const u=new Map;function h(t){if(!(t instanceof l))throw new Error("ProjectivePoint expected")}class l{constructor(t,e,n){if(this.px=t,this.py=e,this.pz=n,null==t||!r.isValid(t))throw new Error("x required");if(null==e||!r.isValid(e))throw new Error("y required");if(null==n||!r.isValid(n))throw new Error("z required")}static fromAffine(t){const{x:e,y:n}=t||{};if(!t||!r.isValid(e)||!r.isValid(n))throw new Error("invalid affine point");if(t instanceof l)throw new Error("projective point not allowed");const i=t=>r.eql(t,r.ZERO);return i(e)&&i(n)?l.ZERO:new l(e,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=r.invertBatch(t.map((t=>t.pz)));return t.map(((t,r)=>t.toAffine(e[r]))).map(l.fromAffine)}static fromHex(t){const e=l.fromAffine(i(To("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return l.BASE.multiply(c(t))}_setWindowSize(t){this._WINDOW_SIZE=t,u.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!r.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:t,y:n}=this.toAffine();if(!r.isValid(t)||!r.isValid(n))throw new Error("bad point: x or y not FE");const i=r.sqr(n),s=o(t);if(!r.eql(i,s))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:t}=this.toAffine();if(r.isOdd)return!r.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){h(t);const{px:e,py:n,pz:i}=this,{px:o,py:s,pz:a}=t,c=r.eql(r.mul(e,a),r.mul(o,i)),u=r.eql(r.mul(n,a),r.mul(s,i));return c&&u}negate(){return new l(this.px,r.neg(this.py),this.pz)}double(){const{a:t,b:n}=e,i=r.mul(n,Al),{px:o,py:s,pz:a}=this;let c=r.ZERO,u=r.ZERO,h=r.ZERO,f=r.mul(o,o),d=r.mul(s,s),y=r.mul(a,a),p=r.mul(o,s);return p=r.add(p,p),h=r.mul(o,a),h=r.add(h,h),c=r.mul(t,h),u=r.mul(i,y),u=r.add(c,u),c=r.sub(d,u),u=r.add(d,u),u=r.mul(c,u),c=r.mul(p,c),h=r.mul(i,h),y=r.mul(t,y),p=r.sub(f,y),p=r.mul(t,p),p=r.add(p,h),h=r.add(f,f),f=r.add(h,f),f=r.add(f,y),f=r.mul(f,p),u=r.add(u,f),y=r.mul(s,a),y=r.add(y,y),f=r.mul(y,p),c=r.sub(c,f),h=r.mul(y,d),h=r.add(h,h),h=r.add(h,h),new l(c,u,h)}add(t){h(t);const{px:n,py:i,pz:o}=this,{px:s,py:a,pz:c}=t;let u=r.ZERO,f=r.ZERO,d=r.ZERO;const y=e.a,p=r.mul(e.b,Al);let g=r.mul(n,s),w=r.mul(i,a),b=r.mul(o,c),m=r.add(n,i),v=r.add(s,a);m=r.mul(m,v),v=r.add(g,w),m=r.sub(m,v),v=r.add(n,o);let E=r.add(s,c);return v=r.mul(v,E),E=r.add(g,b),v=r.sub(v,E),E=r.add(i,o),u=r.add(a,c),E=r.mul(E,u),u=r.add(w,b),E=r.sub(E,u),d=r.mul(y,v),u=r.mul(p,b),d=r.add(u,d),u=r.sub(w,d),d=r.add(w,d),f=r.mul(u,d),w=r.add(g,g),w=r.add(w,g),b=r.mul(y,b),v=r.mul(p,v),w=r.add(w,b),b=r.sub(g,b),b=r.mul(y,b),v=r.add(v,b),g=r.mul(w,v),f=r.add(f,g),g=r.mul(E,v),u=r.mul(m,u),u=r.sub(u,g),g=r.mul(m,w),d=r.mul(E,d),d=r.add(d,g),new l(u,f,d)}subtract(t){return this.add(t.negate())}is0(){return this.equals(l.ZERO)}wNAF(t){return d.wNAFCached(this,u,t,(t=>{const e=r.invertBatch(t.map((t=>t.pz)));return t.map(((t,r)=>t.toAffine(e[r]))).map(l.fromAffine)}))}multiplyUnsafe(t){const n=l.ZERO;if(t===xl)return n;if(a(t),t===Bl)return this;const{endo:i}=e;if(!i)return d.unsafeLadder(this,t);let{k1neg:o,k1:s,k2neg:c,k2:u}=i.splitScalar(t),h=n,f=n,y=this;for(;s>xl||u>xl;)s&Bl&&(h=h.add(y)),u&Bl&&(f=f.add(y)),y=y.double(),s>>=Bl,u>>=Bl;return o&&(h=h.negate()),c&&(f=f.negate()),f=new l(r.mul(f.px,i.beta),f.py,f.pz),h.add(f)}multiply(t){a(t);let n,i,o=t;const{endo:s}=e;if(s){const{k1neg:t,k1:e,k2neg:a,k2:c}=s.splitScalar(o);let{p:u,f:h}=this.wNAF(e),{p:f,f:y}=this.wNAF(c);u=d.constTimeNegate(t,u),f=d.constTimeNegate(a,f),f=new l(r.mul(f.px,s.beta),f.py,f.pz),n=u.add(f),i=h.add(y)}else{const{p:t,f:e}=this.wNAF(o);n=t,i=e}return l.normalizeZ([n,i])[0]}multiplyAndAddUnsafe(t,e,r){const n=l.BASE,i=(t,e)=>e!==xl&&e!==Bl&&t.equals(n)?t.multiply(e):t.multiplyUnsafe(e),o=i(this,e).add(i(t,r));return o.is0()?void 0:o}toAffine(t){const{px:e,py:n,pz:i}=this,o=this.is0();null==t&&(t=o?r.ONE:r.inv(i));const s=r.mul(e,t),a=r.mul(n,t),c=r.mul(i,t);if(o)return{x:r.ZERO,y:r.ZERO};if(!r.eql(c,r.ONE))throw new Error("invZ was invalid");return{x:s,y:a}}isTorsionFree(){const{h:t,isTorsionFree:r}=e;if(t===Bl)return!0;if(r)return r(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:r}=e;return t===Bl?this:r?r(l,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return this.assertValidity(),n(l,this,t)}toHex(t=!0){return mo(this.toRawBytes(t))}}l.BASE=new l(e.Gx,e.Gy,r.ONE),l.ZERO=new l(r.ZERO,r.ONE,r.ZERO);const f=e.nBitLength,d=ts(l,e.endo?Math.ceil(f/2):f);return{CURVE:e,ProjectivePoint:l,normPrivateKeyToScalar:c,weierstrassEquation:o,isWithinCurveOrder:s}}({...e,toBytes(t,e,n){const i=e.toAffine(),o=r.toBytes(i.x),s=Co;return n?s(Uint8Array.from([e.hasEvenY()?2:3]),o):s(Uint8Array.from([4]),o,r.toBytes(i.y))},fromBytes(t){const e=t.length,n=t[0],s=t.subarray(1);if(e!==i||2!==n&&3!==n){if(e===o&&4===n)return{x:r.fromBytes(s.subarray(0,r.BYTES)),y:r.fromBytes(s.subarray(r.BYTES,2*r.BYTES))};throw new Error(`Point of length ${e} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`)}{const t=Ao(s);if(!(xl<(a=t)&&a<r.ORDER))throw new Error("Point is not on curve");const e=h(t);let i;try{i=r.sqrt(e)}catch(t){const e=t instanceof Error?": "+t.message:"";throw new Error("Point is not on curve"+e)}return 1==(1&n)!=((i&Bl)===Bl)&&(i=r.neg(i)),{x:t,y:i}}var a}}),f=t=>mo(So(t,e.nByteLength));function d(t){return t>n>>Bl}const y=(t,e,r)=>Ao(t.slice(e,r));class p{constructor(t,e,r){this.r=t,this.s=e,this.recovery=r,this.assertValidity()}static fromCompact(t){const r=e.nByteLength;return t=To("compactSignature",t,2*r),new p(y(t,0,r),y(t,r,2*r))}static fromDER(t){const{r:e,s:r}=El.toSig(To("DER",t));return new p(e,r)}assertValidity(){if(!l(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!l(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(t){return new p(this.r,this.s,t)}recoverPublicKey(t){const{r:n,s:i,recovery:o}=this,u=m(To("msgHash",t));if(null==o||![0,1,2,3].includes(o))throw new Error("recovery id invalid");const h=2===o||3===o?n+e.n:n;if(h>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const l=0==(1&o)?"02":"03",d=c.fromHex(l+f(h)),y=a(h),p=s(-u*y),g=s(i*y),w=c.BASE.multiplyAndAddUnsafe(d,p,g);if(!w)throw new Error("point at infinify");return w.assertValidity(),w}hasHighS(){return d(this.s)}normalizeS(){return this.hasHighS()?new p(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return Bo(this.toDERHex())}toDERHex(){return El.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Bo(this.toCompactHex())}toCompactHex(){return f(this.r)+f(this.s)}}const g={isValidPrivateKey(t){try{return u(t),!0}catch(t){return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const t=Yo(e.n);return function(t,e,r=!1){const n=t.length,i=Zo(e),o=Yo(e);if(n<16||n<o||n>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${n}`);const s=jo(r?Ao(t):ko(t),e-Vo)+Vo;return r?Io(s,i):So(s,i)}(e.randomBytes(t),e.n)},precompute:(t=8,e=c.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function w(t){const e=go(t),r="string"==typeof t,n=(e||r)&&t.length;return e?n===i||n===o:r?n===2*i||n===2*o:t instanceof c}const b=e.bits2int||function(t){const r=Ao(t),n=8*t.length-e.nBitLength;return n>0?r>>BigInt(n):r},m=e.bits2int_modN||function(t){return s(b(t))},v=Uo(e.nBitLength);function E(t){if("bigint"!=typeof t)throw new Error("bigint expected");if(!(xl<=t&&t<v))throw new Error(`bigint expected < 2^${e.nBitLength}`);return So(t,e.nByteLength)}const x={lowS:e.lowS,prehash:!1},B={lowS:e.lowS,prehash:!1};return c.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function(t,e=!0){return c.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,r=!0){if(w(t))throw new Error("first arg must be private key");if(!w(e))throw new Error("second arg must be public key");return c.fromHex(e).multiply(u(t)).toRawBytes(r)},sign:function(t,n,i=x){const{seed:o,k2sig:h}=function(t,n,i=x){if(["recovered","canonical"].some((t=>t in i)))throw new Error("sign() legacy options not supported");const{hash:o,randomBytes:h}=e;let{lowS:f,prehash:y,extraEntropy:g}=i;null==f&&(f=!0),t=To("msgHash",t),y&&(t=To("prehashed msgHash",o(t)));const w=m(t),v=u(n),B=[E(v),E(w)];if(null!=g&&!1!==g){const t=!0===g?h(r.BYTES):g;B.push(To("extraEntropy",t))}const A=Co(...B),k=w;return{seed:A,k2sig:function(t){const e=b(t);if(!l(e))return;const r=a(e),n=c.BASE.multiply(e).toAffine(),i=s(n.x);if(i===xl)return;const o=s(r*s(k+i*v));if(o===xl)return;let u=(n.x===i?0:2)|Number(n.y&Bl),h=o;return f&&d(o)&&(h=function(t){return d(t)?s(-t):t}(o),u^=1),new p(i,h,u)}}}(t,n,i),f=e;return Oo(f.hash.outputLen,f.nByteLength,f.hmac)(o,h)},verify:function(t,r,n,i=B){const o=t;if(r=To("msgHash",r),n=To("publicKey",n),"strict"in i)throw new Error("options.strict was renamed to lowS");const{lowS:u,prehash:h}=i;let l,f;try{if("string"==typeof o||go(o))try{l=p.fromDER(o)}catch(t){if(!(t instanceof El.Err))throw t;l=p.fromCompact(o)}else{if("object"!=typeof o||"bigint"!=typeof o.r||"bigint"!=typeof o.s)throw new Error("PARSE");{const{r:t,s:e}=o;l=new p(t,e)}}f=c.fromHex(n)}catch(t){if("PARSE"===t.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(u&&l.hasHighS())return!1;h&&(r=e.hash(r));const{r:d,s:y}=l,g=m(r),w=a(y),b=s(g*w),v=s(d*w),E=c.BASE.multiplyAndAddUnsafe(f,b,v)?.toAffine();return!!E&&s(E.x)===d},ProjectivePoint:c,Signature:p,utils:g}}function Sl(t){return{hash:t,hmac:(e,...r)=>bl(t,e,Zi(...r)),randomBytes:Xi}}BigInt(4);const Il=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Tl=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Cl=BigInt(1),Ul=BigInt(2),Ll=(t,e)=>(t+e/Ul)/e;const Nl=Wo(Il,void 0,void 0,{sqrt:function(t){const e=Il,r=BigInt(3),n=BigInt(6),i=BigInt(11),o=BigInt(22),s=BigInt(23),a=BigInt(44),c=BigInt(88),u=t*t*t%e,h=u*u*t%e,l=qo(h,r,e)*h%e,f=qo(l,r,e)*h%e,d=qo(f,Ul,e)*u%e,y=qo(d,i,e)*d%e,p=qo(y,o,e)*y%e,g=qo(p,a,e)*p%e,w=qo(g,c,e)*g%e,b=qo(w,a,e)*p%e,m=qo(b,r,e)*h%e,v=qo(m,s,e)*y%e,E=qo(v,n,e)*u%e,x=qo(E,Ul,e);if(!Nl.eql(Nl.sqr(x),t))throw new Error("Cannot find square root");return x}}),Ol=function(t,e){const r=e=>kl({...t,...Sl(e)});return Object.freeze({...r(e),create:r})}({a:BigInt(0),b:BigInt(7),Fp:Nl,n:Tl,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=Tl,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Cl*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=r,s=BigInt("0x100000000000000000000000000000000"),a=Ll(o*t,e),c=Ll(-n*t,e);let u=jo(t-a*r-c*i,e),h=jo(-a*n-c*o,e);const l=u>s,f=h>s;if(l&&(u=e-u),f&&(h=e-h),u>s||h>s)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:l,k1:u,k2neg:f,k2:h}}}},Yc);function _l({name:t,code:e,encode:r}){return new Rl(t,e,r)}BigInt(0),Ol.ProjectivePoint;class Rl{name;code;encode;constructor(t,e,r){this.name=t,this.code=e,this.encode=r}digest(t){if(t instanceof Uint8Array){const e=this.encode(t);return e instanceof Uint8Array?Ci(this.code,e):e.then((t=>Ci(this.code,t)))}throw Error("Unknown type, must be binary type")}}function Dl(t){return async e=>new Uint8Array(await crypto.subtle.digest(t,e))}const Vl=_l({name:"sha2-256",code:18,encode:Dl("SHA-256")});function Ml(t){return null!=t&&"function"==typeof t.then&&"function"==typeof t.catch&&"function"==typeof t.finally}_l({name:"sha2-512",code:19,encode:Dl("SHA-512")});class Pl{type="secp256k1";raw;_key;constructor(t){this._key=function(t){try{return Ol.ProjectivePoint.fromHex(t),t}catch(t){throw new Wn(String(t))}}(t),this.raw=function(t){return Ol.ProjectivePoint.fromHex(t).toRawBytes(!0)}(this._key)}toMultihash(){return Hi(jl(this))}toCID(){return _i.createV1(114,this.toMultihash())}toString(){return ci.encode(this.toMultihash().bytes).substring(1)}equals(t){return null!=t&&t.raw instanceof Uint8Array&&$i(this.raw,t.raw)}verify(t,e){return function(t,e,r){const n=Vl.digest(r instanceof Uint8Array?r:r.subarray());if(Ml(n))return n.then((({digest:r})=>Ol.verify(e,r,t))).catch((t=>{throw new sl(String(t))}));try{return Ol.verify(e,n.digest,t)}catch(t){throw new sl(String(t))}}(this._key,e,t)}}class Hl{type="secp256k1";raw;publicKey;constructor(t,e){this.raw=function(t){try{return Ol.getPublicKey(t,!0),t}catch(t){throw new Zn(String(t))}}(t),this.publicKey=new Pl(e??function(t){try{return Ol.getPublicKey(t,!0)}catch(t){throw new Zn(String(t))}}(t))}equals(t){return null!=t&&t.raw instanceof Uint8Array&&$i(this.raw,t.raw)}sign(t){return function(t,e){const r=Vl.digest(e instanceof Uint8Array?e:e.subarray());if(Ml(r))return r.then((({digest:e})=>Ol.sign(e,t).toDERRawBytes())).catch((t=>{throw new ol(String(t))}));try{return Ol.sign(r.digest,t).toDERRawBytes()}catch(t){throw new ol(String(t))}}(this.raw,t)}}async function $l(t,e){if("Ed25519"===t)return async function(){const{privateKey:t,publicKey:e}=function(){const t=ms.utils.randomPrivateKey(),e=ms.getPublicKey(t);return{privateKey:Bs(t,e),publicKey:e}}();return new ks(t,e)}();if("secp256k1"===t)return async function(){const t=Ol.utils.randomPrivateKey();return new Hl(t)}();if("RSA"===t)return async function(t){if(t>fl)throw new Jn("Key size is too large");const e=await async function(t){const e=await cl.get().subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:t,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),r=await async function(t){if(null==t.privateKey||null==t.publicKey)throw new Jn("Private and public key are required");return Promise.all([cl.get().subtle.exportKey("jwk",t.privateKey),cl.get().subtle.exportKey("jwk",t.publicKey)])}(e);return{privateKey:r[0],publicKey:r[1]}}(t),r=Yc(jc.encode({Type:$c.RSA,Data:yl(e.publicKey)})),n=Ci(dl,r);return new ll(e.privateKey,new hl(e.publicKey,n))}(e??2048);throw new Yn}function Fl(t){return 32===t.byteLength?function(t){return t=Ss(t,32),new As(t)}(t):33===t.byteLength?function(t){return new Pl(t)}(t):function(t){const e=function(t){const{result:e}=ah(t),r=e.valueBlock.value[1].valueBlock.value[0].valueBlock.value;return{kty:"RSA",n:pl(r[0]),e:pl(r[1])}}(t);if(ul(e)>fl)throw new Wn("Key size is too large");const r=Yc(jc.encode({Type:$c.RSA,Data:t})),n=Ci(dl,r);return new hl(e,n)}(t)}function jl(t){return jc.encode({Type:$c[t.type],Data:t.raw})}function zl(t){return 64===t.byteLength?function(t){if(t.length>Es){const e=(t=Ss(t,Es+32)).subarray(0,Es),r=t.subarray(Es,t.length);return new ks(e,r)}const e=(t=Ss(t,Es)).subarray(0,Es),r=t.subarray(32);return new ks(e,r)}(t):32===t.byteLength?function(t){return new Hl(t)}(t):function(t){const e=function(t){const{result:e}=ah(t),r=e.valueBlock.value;return{n:pl(r[1]),e:pl(r[2]),d:pl(r[3]),p:pl(r[4]),q:pl(r[5]),dp:pl(r[6]),dq:pl(r[7]),qi:pl(r[8]),kty:"RSA",alg:"RS256"}}(t);return function(t){if(ul(t)>fl)throw new Jn("Key size is too large");const e=function(t){if(null==t)throw new Jn("Missing key parameter");return{privateKey:t,publicKey:{kty:t.kty,n:t.n,e:t.e}}}(t),r=Yc(jc.encode({Type:$c.RSA,Data:yl(e.publicKey)})),n=Ci(dl,r);return new ll(e.privateKey,new hl(e.publicKey,n))}(e)}(t)}const ql=async(t,e)=>{if(!t)throw new Error("No signing key given");if(!e)throw new Error("Given input data was undefined");return e instanceof Uint8Array||(e="string"==typeof e?kc(e):new Uint8Array(e)),il(await t.sign(e),"base16")},Kl=Un({size:1e3}),Gl=async(t,e,r)=>{const n=await Kl,i=await n.get(t);let o=!1;if(i){const t=(t,e)=>e instanceof Uint8Array?0===function(t,e){for(let r=0;r<t.byteLength;r++){if(t[r]<e[r])return-1;if(t[r]>e[r])return 1}return t.byteLength>e.byteLength?1:t.byteLength<e.byteLength?-1:0}(t,e):t.toString()===e.toString();o=i.publicKey===e&&t(i.data,r)}else{const i=await(async(t,e,r)=>{if(!t)throw new Error("No signature given");if(!e)throw new Error("Given publicKey was undefined");if(!r)throw new Error("Given input data was undefined");r instanceof Uint8Array||(r="string"==typeof r?kc(r):new Uint8Array(r));let n=!1;try{const a=Fl(kc(e,"base16"));n=await(i=a,o=r,s=kc(t,"base16"),i.verify(o,s))}catch(t){}var i,o,s;return Promise.resolve(n)})(t,e,r);o=i,i&&await n.put(t,{publicKey:e,data:r})}return o},Jl=async({storage:t,path:e}={})=>{t=t||await kn(await Un({size:1e3}),await Tn({path:e||"./keystore"}));const r=await Un({size:1e3}),n=async(e,n)=>{const{privateKey:i}=n;await t.put("private_"+e,i);const o=zl(i);await r.put(e,o)};return{clear:async()=>{await t.clear(),await r.clear()},close:async()=>{await t.close(),await r.close()},hasKey:async e=>{if(!e)throw new Error("id needed to check a key");let n=!1,i=await r.get(e);if(i)n=!0;else try{i=await t.get("private_"+e),n=null!=i}catch(t){console.error("Error: ENOENT: no such file or directory")}return n},addKey:n,createKey:async t=>{if(!t)throw new Error("id needed to create a key");const e=await $l("secp256k1"),r={publicKey:e.publicKey.raw,privateKey:e.raw};return await n(t,r),e},getKey:async e=>{if(!e)throw new Error("id needed to get a key");let n=await r.get(e);if(!n){let i;try{i=await t.get("private_"+e)}catch(t){}if(!i)return;n=zl(i),await r.put(e,n)}return n},getPublic:(t,e={})=>{const r=e.format||"hex";if(-1===["hex","buffer"].indexOf(r))throw new Error("Supported formats are `hex` and `buffer`");const n=t.publicKey.raw;return"buffer"===r?n:il(n,"base16")}}},Wl=t,Zl=sn,Yl=X,Ql=async({id:t,publicKey:e,signatures:r,type:n,sign:i,verify:o}={})=>{if(!t)throw new Error("Identity id is required");if(!e)throw new Error("Invalid public key");if(!r)throw new Error("Signatures object is required");if(!r.id)throw new Error("Signature of id is required");if(!r.publicKey)throw new Error("Signature of publicKey+id is required");if(!n)throw new Error("Identity type is required");const s={id:t,publicKey:e,signatures:r=Object.assign({},r),type:n,sign:i,verify:o},{hash:a,bytes:c}=await Xl(s);return s.hash=a,s.bytes=c,s},Xl=async t=>{const{id:e,publicKey:r,signatures:n,type:i}=t,o={id:e,publicKey:r,signatures:n,type:i},{cid:s,bytes:a}=await Pt({value:o,codec:Wl,hasher:Zl});return{hash:s.toString(Yl),bytes:Uint8Array.from(a)}},tf=t=>Boolean(t.id&&t.hash&&t.bytes&&t.publicKey&&t.signatures&&t.signatures.id&&t.signatures.publicKey&&t.type),ef="publickey",rf=({keystore:t})=>async()=>{if(!t)throw new Error("PublicKeyIdentityProvider requires a keystore parameter");return{type:ef,getId:async({id:e}={})=>{if(!e)throw new Error("id is required");return il((await t.getKey(e)||await t.createKey(e)).publicKey.raw,"base16")},signIdentity:async(e,{id:r}={})=>{if(!r)throw new Error("id is required");const n=await t.getKey(r);if(!n)throw new Error(`Signing key for '${r}' not found`);return ql(n,e)}}};rf.verifyIdentity=async t=>{const{id:e,publicKey:r,signatures:n}=t;return Gl(n.publicKey,e,r+n.id)},rf.type=ef;const nf=rf,of={},sf=t=>{if(!(t=>Object.keys(of).includes(t))(t))throw new Error(`IdentityProvider type '${t}' is not supported`);return of[t]},af=t=>{if(!t.type||"string"!=typeof t.type)throw new Error("Given IdentityProvider doesn't have a field 'type'.");if(!t.verifyIdentity)throw new Error("Given IdentityProvider doesn't have a function 'verifyIdentity'.");of[t.type]=t};af(nf);const cf=P("./orbitdb","identities"),uf=async({keystore:t,path:e,storage:r,ipfs:n}={})=>{t=t||await Jl({path:e||cf}),r||(r=n?await kn(await Un({size:1e3}),await Sn({ipfs:n,pin:!0})):await dn());const i=await Un({size:1e3}),o=async(e,r)=>{const n=await t.getKey(e.id);if(!n)throw new Error("Private signing key not found from KeyStore");return await ql(n,r)},s=async(t,e,r)=>await Gl(t,e,r);return{createIdentity:async(e={})=>{e.keystore=t;const n=sf("publickey"),i=e.provider||n({keystore:t}),a=await i();if(!sf(a.type))throw new Error("Identity provider is unknown. Use useIdentityProvider(provider) to register the identity provider");const c=await a.getId(e),u=await t.getKey(c)||await t.createKey(c),h=t.getPublic(u),l=await ql(u,c),f={id:l,publicKey:await a.signIdentity(h+l,e)},d=await Ql({id:c,publicKey:h,signatures:f,type:a.type,sign:o,verify:s});return await r.put(d.hash,d.bytes),d},verifyIdentity:async t=>{if(!tf(t))return!1;const{id:e,publicKey:r,signatures:n}=t;if(!await s(n.id,r,e))return!1;const o=await i.get(n.id);if(o)return c=o,(a=t).id===c.id&&a.hash===c.hash&&a.type===c.type&&a.publicKey===c.publicKey&&a.signatures.id===c.signatures.id&&a.signatures.publicKey===c.signatures.publicKey;var a,c;const u=sf(t.type),h=await u.verifyIdentity(t);return h&&await i.put(n.id,t),h},getIdentity:async t=>{const e=await r.get(t);if(e)return(async t=>{const{value:e}=await Ht({bytes:t,codec:Wl,hasher:Zl});return Ql({...e})})(e)},sign:o,verify:s,keystore:t}},hf=t=>{if(!(t=t.toString()).startsWith("/orbitdb")&&!t.startsWith("\\orbitdb"))return!1;let e;t=(t=(t=(t=t.replaceAll("/orbitdb/","")).replaceAll("\\orbitdb\\","")).replaceAll("/","")).replaceAll("\\","");try{e=Bt.parse(t,X)}catch(t){return!1}return void 0!==e},lf=t=>{if(!t)throw new Error(`Not a valid OrbitDB address: ${t}`);if(!hf(t))throw new Error(`Not a valid OrbitDB address: ${t}`);return ff(t)},ff=t=>{if(t&&"orbitdb"===t.protocol&&t.hash)return t;const e="orbitdb",r=t.replace("/orbitdb/","").replace("\\orbitdb\\","");return{protocol:e,hash:r,address:t,toString:()=>M("/",e,r)}},df=t,yf=sn,pf=X,gf=async(t=32)=>{let e="",r=0;for(;r<t;)e+="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".charAt(Math.floor(62*Math.random())),r+=1;return e},wf=t,bf=sn,mf=X,vf="ipfs",Ef=({write:t,storage:e}={})=>async({orbitdb:r,identities:n,address:i})=>{if(e=e||await kn(await Un({size:1e3}),await Sn({ipfs:r.ipfs,pin:!0})),t=t||[r.identity.id],i){const r=await e.get(i.replaceAll("/ipfs/","")),{value:n}=await Ht({bytes:r,codec:wf,hasher:bf});t=n.write}else i=await(async({storage:t,type:e,params:r})=>{const n={type:e,...r},{cid:i,bytes:o}=await Pt({value:n,codec:wf,hasher:bf}),s=i.toString(mf);return await t.put(s,o),s})({storage:e,type:vf,params:{write:t}}),i=P("/",vf,i);return{type:vf,address:i,write:t,canAppend:async e=>{const r=await n.getIdentity(e.identity);if(!r)return!1;const{id:i}=r;return!(!t.includes(i)&&!t.includes("*"))&&await n.verifyIdentity(r)}}};Ef.type=vf;const xf=Ef,Bf="orbitdb",Af=({write:t}={})=>async({orbitdb:e,identities:r,address:n,name:i})=>{n=n||i||await gf(64),t=t||[e.identity.id];const o=await e.open(n,{type:"keyvalue",AccessController:xf({write:t})});n=o.address;const s=async()=>{const t=[];for await(const e of o.iterator())t[e.key]=e.value;return Object.entries({...t,admin:new Set([...t.admin||[],...o.access.write])}).forEach((e=>{const r=e[0];t[r]=new Set([...t[r]||[],...e[1]])})),t},a=async t=>(await s())[t]||new Set([]),c=async(t,e)=>{const r=new Set(await a(t));return r.has(e)||r.has("*")};return{type:Bf,address:n,write:t,canAppend:async t=>{const e=await r.getIdentity(t.identity);if(!e)return!1;const{id:n}=e;return!(!await c("write",n)&&!await c("admin",n))&&await r.verifyIdentity(e)},capabilities:s,get:a,grant:async(t,e)=>{const r=new Set([...await o.get(t)||[],e]);await o.put(t,Array.from(r.values()))},revoke:async(t,e)=>{const r=new Set(await o.get(t)||[]);r.delete(e),r.size>0?await o.put(t,Array.from(r.values())):await o.del(t)},close:async()=>{await o.close()},drop:async()=>{await o.drop()},events:o.events}};Af.type=Bf;const kf=Af,Sf={},If=t=>{if(!t.type)throw new Error("AccessController does not contain required field 'type'.");Sf[t.type]=t};If(xf),If(kf);const Tf=xf,Cf=async({ipfs:t,id:e,identity:r,identities:n,directory:i}={})=>{if(null==t)throw new Error("IPFS instance is a required argument.");e=e||await gf();const o=t.libp2p.peerId;let s;i=i||"./orbitdb",n?s=n.keystore:(s=await Jl({path:P(i,"./keystore")}),n=await uf({ipfs:t,keystore:s})),r?r.provider&&(r=await n.createIdentity({...r})):r=await n.createIdentity({id:e});const a=await(async({ipfs:t,storage:e}={})=>(e=e||await kn(await Un({size:1e5}),await Sn({ipfs:t,pin:!0})),{get:async t=>{const r=await e.get(t),{value:n}=await Ht({bytes:r,codec:df,hasher:yf});return n&&await e.put(t,r),n},create:async({name:t,type:r,accessController:n,meta:i})=>{if(!t)throw new Error("name is required");if(!r)throw new Error("type is required");if(!n)throw new Error("accessController is required");const o=Object.assign({name:t,type:r,accessController:n},void 0!==i?{meta:i}:{}),{cid:s,bytes:a}=await Pt({value:o,codec:df,hasher:yf}),c=s.toString(pf);return await e.put(c,a),{hash:c,manifest:o}},close:async()=>{await e.close()}}))({ipfs:t});let c={};const u=async(e,{type:o,meta:s,sync:l,Database:f,AccessController:d,headsStorage:y,entryStorage:p,indexStorage:g,referencesCount:w}={})=>{let b,m,v;if(c[e])return c[e];if(hf(e)){const i=ff(e);m=await a.get(i.hash),d=(t=>{if(!Sf[t])throw new Error(`AccessController type '${t}' is not supported`);return Sf[t]})(m.accessController.split("/",2).pop())(),v=await d({orbitdb:{open:u,identity:r,ipfs:t},identities:n,address:m.accessController}),b=m.name,o=o||m.type,s=m.meta}else{o=o||"events",d=d||Tf(),v=await d({orbitdb:{open:u,identity:r,ipfs:t},identities:n,name:e});const i=await a.create({name:e,type:o,accessController:v.address,meta:s});if(m=i.manifest,e=ff(i.hash),b=m.name,s=m.meta,c[e])return c[e]}if(f=f||(t=>{if(!t)throw new Error("Type not specified");if(!Kn[t])throw new Error(`Unsupported database type: '${t}'`);return Kn[t]})(o)(),!f)throw new Error(`Unsupported database type: '${o}'`);e=e.toString();const E=await f({ipfs:t,identity:r,address:e,name:b,access:v,directory:i,meta:s,syncAutomatically:l,headsStorage:y,entryStorage:p,indexStorage:g,referencesCount:w});return E.events.on("close",h(e)),c[e]=E,E},h=t=>()=>{delete c[t]};return{id:e,open:u,stop:async()=>{for(const t of Object.values(c))await t.close();s&&await s.close(),a&&await a.close(),c={}},ipfs:t,directory:i,keystore:s,identities:n,identity:r,peerId:o}}})(),OrbitDB=n})();
./node_modules/@orbitdb/core/dist/orbitdb.js:20523: * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
./node_modules/@orbitdb/core/dist/orbitdb.js:20526:    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues === 'function') {
./node_modules/@orbitdb/core/dist/orbitdb.js:20527:        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues(new Uint8Array(bytesLength));
./node_modules/@orbitdb/core/dist/orbitdb.js:20529:    throw new Error('crypto.getRandomValues must be defined');
./node_modules/@orbitdb/core/dist/orbitdb.js.map:1:{"version":3,"file":"../dist/orbitdb.js","mappings":";;;;;;;;;;;AAAY;;AAEZ,QAAQ,eAAe,EAAE,mBAAO,CAAC,kDAAU;AAC3C,oBAAoB,mBAAO,CAAC,0DAAc;AAC1C,QAAQ,0BAA0B,EAAE,mBAAO,CAAC,iEAAc;;AAE1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6FAA6F,KAAK;AAClG;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,sCAAsC;;AAEnE;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,+BAA+B;;AAE5D;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B;;;;;;;;;;;;ACpLhB;;AAEZ,QAAQ,eAAe,EAAE,mBAAO,CAAC,kDAAU;AAC3C,oBAAoB,mBAAO,CAAC,0DAAc;AAC1C,QAAQ,0BAA0B,EAAE,mBAAO,CAAC,iEAAc;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,KAAK;AAClG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,aAAa,6BAA6B,GAAG,qBAAqB,sBAAsB,GAAG;AAC3F,aAAa,6BAA6B,GAAG,qBAAqB,sBAAsB;AACxF,GAAG;AACH;;AAEA;AACA;AACA;;AAEA,wBAAwB;AACxB,2BAA2B;AAC3B,6BAA6B;;;;;;;;;;;;ACzejB;;AAEZ,QAAQ,WAAW,EAAE,mBAAO,CAAC,8DAAgB;AAC7C,QAAQ,aAAa,EAAE,mBAAO,CAAC,kEAAkB;AACjD,QAAQ,eAAe,EAAE,mBAAO,CAAC,+CAAQ;AACzC,QAAQ,eAAe,EAAE,mBAAO,CAAC,kDAAU;AAC3C,oBAAoB,mBAAO,CAAC,0DAAc;AAC1C,QAAQ,mBAAmB,EAAE,mBAAO,CAAC,+EAAqB;AAC1D,QAAQ,2CAA2C,EAAE,mBAAO,CAAC,2FAA2B;AACxF,QAAQ,+DAA+D,EAAE,mBAAO,CAAC,uFAAyB;AAC1G,QAAQ,sBAAsB,EAAE,mBAAO,CAAC,+FAA6B;AACrE,QAAQ,0BAA0B,EAAE,mBAAO,CAAC,iEAAc;AAC1D,qBAAqB,mBAAO,CAAC,+EAAqB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY,kDAAkD;;AAE9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC;AACzC,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB;;AAEhB;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT,OAAO;AACP,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,aAAa,oDAAoD;AACjG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,aAAa,oDAAoD;AACjG;;AAEA;;AAEA,oBAAoB,iBAAiB;AACrC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA,QAAQ;AACR,2EAA2E,eAAe;AAC1F;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,aAAa,oDAAoD;AACjG;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gCAAgC,aAAa,wBAAwB;AACrE;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,YAAY,iDAAiD;;AAE7D,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;;AAEA,iCAAiC;;AAEjC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,mBAAO,CAAC,+EAAiB;;AAE5D,QAAQ,mBAAmB,EAAE,mBAAO,CAAC,uFAAyB,IAAI,eAAe;;AAEjF,qBAAqB;AACrB,wBAAwB;;AAExB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACjzBY;;AAEZ,oIAAiE;AACjE,0IAAuE;AACvE,gJAA0E;AAC1E,sJAAgF;AAChF,0JAAoF;AACpF,kKAAuF;;;;;;;;;;;;ACP3E;;AAEZ,QAAQ,+DAA+D,EAAE,mBAAO,CAAC,gFAAsB;;AAEvG;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,iBAAiB;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gCAAgC;AAChC,mCAAmC;AACnC,qCAAqC;;;;;;;;;;;;AC3HzB;;AAEZ,oBAAoB,mBAAO,CAAC,0DAAc;AAC1C,QAAQ,SAAS,EAAE,mBAAO,CAAC,8CAAQ;AACnC;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,qGAA8B;;AAE1C;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;;AAEnB;AACA,6BAA6B,eAAe;AAC5C;AACA;AACA;AACA;AACA,uEAAuE,YAAY;AACnF;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,QAAQ;AACR,iBAAiB;AACjB,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,kCAAkC;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yDAAyD,UAAU,IAAI,IAAI;AAC3E;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;;AAEd;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;ACjQY;;AAEZ,mBAAmB;AACnB;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AChBY;;AAEZ,QAAQ,uBAAuB,EAAE,mBAAO,CAAC,0FAA2B;AACpE,oBAAoB,mBAAO,CAAC,0DAAc;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,qCAAqC;AAC/D;;AAEA;AACA,0BAA0B,8BAA8B;AACxD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,2BAA2B;;;;;;;;;;;;ACxCf;;AAEZ,QAAQ,6CAA6C,EAAE,mBAAO,CAAC,gFAAsB;;AAErF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC,uCAAuC;AAC3E;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC,uCAAuC;AAC3E;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B,4BAA4B;;;;;;;;;;;;ACvEhB;;AAEZ,QAAQ,+DAA+D,EAAE,mBAAO,CAAC,gFAAsB;AACvG,oBAAoB,mBAAO,CAAC,0DAAc;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA,wBAAwB;AACxB,2BAA2B;AAC3B,6BAA6B;;;;;;;;;;;;AC3GjB;;AAEZ,uBAAuB,mBAAO,CAAC,gEAAiB;;AAEhD;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;;;;;;;;;;;ACVY;;AAEZ,oBAAoB,mBAAO,CAAC,0DAAc;AAC1C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wDAAwD,EAAE;AAC1D;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;;AAEuC;AACJ;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,4DAA+B;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8CAAiB;AAC/C;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,kBAAkB,wFAAwF,IAAI;AAC9G;AACA;AACA;AACA,qCAAqC,4DAA+B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8CAAiB;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,YAAY,IAAI,IAAI;AACtC;AACA;AACA;AACA;AACA,mDAAmD,4DAA+B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAkB;AACjD;AACA;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAA+B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+BAA+B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA,iCAAiC,iDAAoB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,aAAa,IAAI,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAA+B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB,wEAAwE,IAAI;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAAiB;AAChC;AACA;AACA,kBAAkB,uBAAuB,IAAI,8CAAiB,8CAA8C;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kDAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,sCAAsC,IAAI;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB,KAAK,sBAAsB;AACpE;AACA;AACA;;AAEA;AACA,kBAAkB,kCAAkC,IAAI;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4DAA+B;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sDAAsD,IAAI;AAC5E;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAA+B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,EAAE;AAC5E;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA,iBAAiB,WAAW,KAAK,kBAAkB;AACnD,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA,kBAAkB,uBAAuB,IAAI;AAC7C;AACA;AACA,gCAAgC,4DAA+B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAA+B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB,IAAI,cAAc;AAC3D;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA,kBAAkB,uCAAuC,IAAI;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,YAAY,eAAe,kBAAkB,IAAI;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB,IAAI,8CAAiB,qCAAqC;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4DAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA,kBAAkB,uDAAuD,IAAI;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAA+B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,YAAY,eAAe,kBAAkB,IAAI;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB,IAAI,kEAAkE;AACnH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mDAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mDAAsB;AAC9C;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA,yBAAyB,mDAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,QAAQ;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB,IAAI;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iDAAoB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iDAAoB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,iBAAiB;AAC1E;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC;;AAED;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8CAAiB;AACrD;AACA;AACA;AACA,yCAAyC,8CAAiB,cAAc;AACxE;AACA,2BAA2B,4DAA+B,cAAc,8CAAiB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sCAAsC,wCAAwC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB,uBAAuB,IAAI,2BAA2B;AACxE;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA,kBAAkB,mDAAmD,IAAI;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAA+B;AACzD;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA,2BAA2B,+CAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,sCAAsC,IAAI;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA,2BAA2B,EAAE,QAAQ;AACrC;AACA,iCAAiC,EAAE,QAAQ,KAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB,IAAI,sCAAsC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA,kBAAkB,8BAA8B,IAAI;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAA+B;AACzD;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA,2BAA2B,+CAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,sCAAsC,IAAI;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA,2BAA2B,EAAE,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB,IAAI,sCAAsC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA,kBAAkB,gBAAgB,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,gBAAgB,IAAI;AACtC;AACA;AACA;AACA,gEAAgE,4DAA+B;AAC/F;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,4DAA+B;AACtE;AACA,oCAAoC,8CAAiB;AACrD;AACA;AACA,qEAAqE,GAAG;AACxE,oCAAoC,8CAAiB;AACrD;AACA;AACA;AACA,sDAAsD,8CAAiB;AACvE;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,gCAAgC,8CAAiB;AACjD,uCAAuC,4DAA+B;AACtE;AACA;AACA;AACA,sDAAsD,8CAAiB;AACvE;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,gBAAgB,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC,4BAA4B,+CAAkB;AAC9C;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,gBAAgB,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,kBAAkB,kCAAkC,IAAI;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,4DAA+B;AACvF;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAiB;AAC9C,6BAA6B,8CAAiB;AAC9C,6BAA6B,8CAAiB;AAC9C,6BAA6B,8CAAiB;AAC9C,6BAA6B,8CAAiB;AAC9C,6BAA6B,8CAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB,IAAI,4BAA4B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,4CAA4C;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,EAAE,KAAK,EAAE,KAAK,EAAE;AAC9C;AACA;AACA;AACA;AACA,8BAA8B,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAiB;AAC9C,6BAA6B,8CAAiB;AAC9C,6BAA6B,8CAAiB;AAC9C,6BAA6B,8CAAiB;AAC9C,6BAA6B,8CAAiB;AAC9C,6BAA6B,8CAAiB;AAC9C;AACA;AACA,iCAAiC,8CAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA,kBAAkB,yCAAyC,IAAI;AAC/D;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,4BAA4B,IAAI;AAClD;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,kDAAkD,IAAI;AACxE;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,oBAAoB,IAAI;AAC1C,wBAAwB,4DAA+B;AACvD;AACA;AACA;AACA;AACA;AACA,wBAAwB,4DAA+B;AACvD;AACA;AACA;AACA,wBAAwB,4DAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yCAAyC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,8BAA8B,4DAA+B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgiB;;;;;;;;;;;;ACvjGphB;;AAEZ,kBAAkB;AAClB,mBAAmB;AACnB,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,UAAU;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACrJA;;AAEY;;AAEZ,QAAQ,gBAAgB,EAAE,mBAAO,CAAC,8DAAgB;AAClD,oBAAoB,mBAAO,CAAC,0DAAc;AAC1C,iBAAiB,mBAAO,CAAC,sEAAoB;AAC7C,QAAQ,eAAe,EAAE,mBAAO,CAAC,kDAAU;AAC3C,QAAQ,WAAW,EAAE,mBAAO,CAAC,4DAAY;AACzC,oBAAoB,mBAAO,CAAC,4EAAoB;AAChD,cAAc,mBAAO,CAAC,gEAAc;AACpC,uBAAuB,mBAAO,CAAC,wEAAkB;;AAEjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,YAAY,8BAA8B;;AAE1C;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB;;;;;;;;;;;;AClSR;;AAEZ,QAAQ,mBAAmB,EAAE,mBAAO,CAAC,8DAAgB;AACrD,uBAAuB,mBAAO,CAAC,wEAAkB;AACjD,oBAAoB,mBAAO,CAAC,4EAAoB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA,wBAAwB,YAAY;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,aAAa;AAC/B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;;AAE9B;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7OY;;AAEZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClCY;;AAEZ;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;;;;;;;;;;;;ACbA;;AAEY;;AAEZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ,eAAe,mBAAO,CAAC,oDAAW;AAClC,gBAAgB,mBAAO,CAAC,gDAAS;AACjC;AACA;AACA;AACA;;AAEA,cAAc;AACd,kBAAkB;AAClB,yBAAyB;;AAEzB;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;;AAEA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,eAAe;AACxC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,yBAAyB,QAAQ;AACjC;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,qBAAqB,WAAW,GAAG,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,gBAAgB,WAAW,GAAG,IAAI,KAAK,aAAa;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;;AAEA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,KAAK,mDAAmD,cAAc;AACzF,GAAG;AACH;AACA;AACA,+BAA+B,IAAI;AACnC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,MAAM,aAAa,SAAS;AACtD;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,SAAS,gBAAgB;AACzB,cAAc,oBAAoB,EAAE,IAAI;AACxC;AACA,YAAY,gBAAgB,EAAE,IAAI;AAClC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,GAAG,SAAS,GAAG,KAAK,qBAAqB,EAAE,EAAE;AACpE,QAAQ;AACR,yBAAyB,GAAG,KAAK,yBAAyB,EAAE,EAAE;AAC9D,mBAAmB,yBAAyB,EAAE,EAAE;AAChD;AACA,MAAM;AACN,oBAAoB,IAAI,EAAE,GAAG,SAAS,IAAI,EAAE,EAAE;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,cAAc,SAAS,OAAO;AACxE;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACzjEY;;AAEZ,eAAe,mBAAO,CAAC,iEAAa;;AAEpC,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB;;AAEA;AACA,2BAA2B,qCAAqC;AAChE,4BAA4B,+BAA+B;AAC3D;;;;;;;;;;;AC3BA;;;;;;;;;;;;ACAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,iBAAiB;AAC5B,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0DAA0D,OAAO;AACjE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA,gBAAgB,YAAY;AAC5B;;AAEA;AACA,4DAA4D;AAC5D,gEAAgE;AAChE,oEAAoE;AACpE,wEAAwE;AACxE;AACA,2DAA2D,SAAS;AACpE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,WAAW,SAAS;AACpB,aAAa,cAAc;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,4DAA4D,YAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,aAAa,cAAc;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,IAA6B;AACjC;AACA;;;;;;;;;;;;AC/UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,sBAAsB;AACxC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA,SAAS,yBAAyB;AAClC;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8DAA8D,YAAY;AAC1E;AACA,8DAA8D,YAAY;AAC1E;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,qCAAqC,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;;;;;;;;;;;AChfA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS,WAAW;;AAEpB;AACA;AACA;AACA,SAAS,WAAW;;AAEpB;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA,SAAS,WAAW;;AAEpB;AACA;AACA,SAAS,UAAU;;AAEnB;AACA;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1BY;;AAEZ,gBAAgB;AAChB,yEAAyE;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,4BAA4B;AAC5B,uCAAuC;AACvC,GAAG;AACH;;;;;;;;;;;;ACzBY;;AAEZ,oBAAoB,mBAAO,CAAC,0DAAc;AAC1C,kBAAkB,mBAAO,CAAC,yEAAiB;AAC3C,QAAQ,WAAW,EAAE,mBAAO,CAAC,uEAAgB;AAC7C,QAAQ,uCAAuC,EAAE,mBAAO,CAAC,qEAAe;;AAExE;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,+BAA+B;AAC5C;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA,eAAe,mEAAmE;AAClF;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA,aAAa,qCAAqC;AAClD,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;AACA,WAAW;AACX;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;AAEA,cAAc,eAAe;;AAE7B;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV,6CAA6C,KAAK;AAClD;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA,WAAW,8BAA8B;AACzC,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yDAAyD,iBAAiB;;AAE1E;AACA,yCAAyC,kBAAkB;AAC3D,yCAAyC,kBAAkB;AAC3D,6CAA6C,kBAAkB;AAC/D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,8BAA8B;AACzC,aAAa;AACb;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,aAAa,0DAA0D;AACvE;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC7JY;;AAEZ,oBAAoB,mBAAO,CAAC,0DAAc;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6BAA6B;AAC1C;AACA;AACA,eAAe,wBAAwB;AACvC;;AAEA,eAAe,yBAAyB;AACxC;;AAEA,eAAe,QAAQ;AACvB;;AAEA,eAAe,QAAQ;AACvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,QAAQ;AAC9B;;AAEA,eAAe,wBAAwB;AACvC;AACA,uCAAuC,UAAU;AACjD;AACA,KAAK;AACL;;AAEA,eAAe,sBAAsB;AACrC;AACA,uCAAuC,UAAU;AACjD;AACA,KAAK;AACL;;AAEA,eAAe,sBAAsB;AACrC;AACA,uCAAuC,UAAU;AACjD;AACA,KAAK;AACL;AACA;;AAEA,gBAAgB;;AAEhB;AACA,aAAa,kDAAkD;AAC/D;AACA;;AAEA;AACA,aAAa,4CAA4C;AACzD;AACA;;AAEA;AACA,aAAa,0CAA0C;AACvD;AACA;;AAEA;AACA,aAAa,0CAA0C;AACvD;AACA;;;;;;;;;;;;ACxGY;;AAEZ,QAAQ,SAAS,EAAE,mBAAO,CAAC,8CAAQ,OAAO,UAAU;AACpD,QAAQ,2BAA2B,EAAE,mBAAO,CAAC,uEAAc;AAC3D,QAAQ,uCAAuC,EAAE,mBAAO,CAAC,iEAAW;;AAEpE,WAAW,gBAAgB;AAC3B;;AAEA;AACA,UAAU;AACV;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,eAAe,UAAU;AACzB,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,eAAe,UAAU;AACzB,KAAK;AACL;AACA,CAAC;;AAED;AACA,UAAU;AACV;AACA,YAAY;AACZ;AACA;AACA;AACA,CAAC;;AAED;AACA,UAAU;AACV;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,eAAe,UAAU;AACzB,KAAK;AACL;AACA,CAAC;;AAED;AACA,UAAU;AACV;AACA,YAAY;AACZ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,eAAe,UAAU;AACzB,KAAK;AACL;AACA,CAAC;;AAED;AACA,UAAU;AACV;AACA,WAAW;AACX;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA,UAAU;AACV;AACA,cAAc;AACd;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,CAAC;;;;;;;;;;;;ACtIW;;AAEZ,QAAQ,SAAS,EAAE,mBAAO,CAAC,8CAAQ;AACnC,QAAQ,WAAW,EAAE,mBAAO,CAAC,mEAAY;AACzC,kBAAkB,mBAAO,CAAC,uEAAc;;AAExC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa,8CAA8C;AAC3D;AACA;AACA,YAAY,8BAA8B;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa,kDAAkD;AAC/D;AACA;AACA,YAAY,4BAA4B;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,eAAe,UAAU;AACzB,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa,8CAA8C;AAC3D;AACA;AACA,YAAY,4BAA4B;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,KAAK;AACL;;AAEA;AACA;AACA,YAAY,2BAA2B;;AAEvC;AACA;AACA;AACA,eAAe,UAAU;AACzB,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;AACpB,kBAAkB;AAClB,kBAAkB;;AAElB;AACA,aAAa,kDAAkD;AAC/D;AACA;;;;;;;;;;;;AC9GY;;AAEZ,aAAa,oDAAoD,OAAO;AACxE;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;AClBA,8GAAqD;;;;;;;;;;;ACArD,aAAa,mBAAO,CAAC,+CAAQ;AAC7B,eAAe,mBAAO,CAAC,6DAAU;;AAEjC;;AAEA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qBAAqB;AACrB,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ,eAAe;AACf;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;;;;;;;;;;;;AChJY;;AAEZ;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,yEAAyE;AACxF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,EAAE,mBAAmB,EAAE,iBAAiB,EAAE;AAClF;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,IAAI;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,IAAI;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,SAAS;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,SAAS;AACtE;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B,eAAe;AACf,cAAc;AACd,eAAe;AACf,eAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9Yf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sBAAsB,EAAE,sBAAsB;AAC3E;AACA;AACA;AACA,iCAAiC,sBAAsB,EAAE,sBAAsB,EAAE,sBAAsB;AACvG;AACA;AACA,iCAAiC,sBAAsB,EAAE,sBAAsB,EAAE,sBAAsB,EAAE,sBAAsB;AAC/H;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB,EAAE,sBAAsB,EAAE,sBAAsB,EAAE,sBAAsB;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2R;;;;;;;;;;;AClV3R;AACA;;AAEA;AACA,iEAAiE,qBAAM;AACvE;AACA;AACA;AACA,qCAAqC,WAAW;;;;;;;;;;;;ACRpC;;AAEZ,gBAAgB,mBAAO,CAAC,sDAAQ;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC/EY;;AAEZ;AACA;AACA;;;;;;;;;;;ACJA;AACA;;AAEA,uBAAuB,mBAAO,CAAC,gEAAiB;;AAEhD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,4CAA4C,wBAAwB;AACpE,QAAQ;AACR;AACA;AACA,4CAA4C,wBAAwB;AACpE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,0CAA0C,wBAAwB;AAClE;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA,oCAAoC,sBAAsB;AAC1D;AACA;AACA,KAAK;AACL;;AAEA;AACA;;;;;;;;;;;;ACrEY;;AAEZ,QAAQ,kBAAkB;;AAE1B;AACA,gBAAgB,mBAAO,CAAC,kDAAS;;AAEjC;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC9CqC;AACG;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY,EAAE,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,qBAAqB,IAAI,WAAW,6CAA6C,YAAY;AAC9J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,sBAAsB,8BAA8B,4BAA4B;AAClJ;AACA;AACA;AACO;AACP;AACA;AACA,+BAA+B,qBAAqB;AACpD,gCAAgC,uBAAuB;AACvD,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gBAAgB,8BAA8B;AACrD;AACA;AACO,iBAAiB,wBAAwB;AAChD,YAAY,iBAAiB,EAAE,6DAAK;AACpC;AACA;AACA;AACA;AACA,0BAA0B,iDAAM;AAChC,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,oBAAoB;AACpB,qBAAqB;AACrB,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA,yCAAyC,MAAM;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,oBAAoB;AACpB,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mBAAmB,qCAAqC;AAC/D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACzMoC;AAC7B,eAAe,iDAAO;AAC7B;AACA;AACA;AACA;AACA,CAAC;AACM,oBAAoB,iDAAO;AAClC;AACA;AACA;AACA;AACA,CAAC;AACM,kBAAkB,iDAAO;AAChC;AACA;AACA;AACA;AACA,CAAC;AACM,uBAAuB,iDAAO;AACrC;AACA;AACA;AACA;AACA,CAAC;AACM,kBAAkB,iDAAO;AAChC;AACA;AACA;AACA;AACA,CAAC;AACM,uBAAuB,iDAAO;AACrC;AACA;AACA;AACA;AACA,CAAC;AACM,qBAAqB,iDAAO;AACnC;AACA;AACA;AACA;AACA,CAAC;AACM,0BAA0B,iDAAO;AACxC;AACA;AACA;AACA;AACA,CAAC;AACM,gBAAgB,iDAAO;AAC9B;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;ACvDkC;AAC3B,kBAAkB,+CAAK;AAC9B;AACA;AACA;AACA,CAAC;AACM,qBAAqB,+CAAK;AACjC;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;;;;;ACXO;AACA;AACP;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACxC2C;AACG;AACV;AACS;AACP;AACtC;AACoC;AAC7B;AACP,YAAY,iBAAiB;AAC7B;AACA;AACA,8DAA8D,uDAAS;AACvE;AACA,+DAA+D,oDAAM;AACrE;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC,kCAAkC,qDAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qDAAa;AACzB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kCAAkC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C,2BAA2B,qDAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,YAAY;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAM;AACrC;AACA;AACA;AACA;AACA,2BAA2B,qDAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8CAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,QAAQ;AAChE;AACA;AACA,sCAAsC;AACtC,mCAAmC;AACnC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uDAAS;AAC7C;AACA,gBAAgB,uDAAS;AACzB,kCAAkC,uDAAS,QAAQ,EAAE,OAAO;AAC5D;AACA;AACA,aAAa,uDAAS;AACtB,oCAAoC,uDAAS;AAC7C,oBAAoB,uDAAS;AAC7B;AACA,aAAa,oDAAM;AACnB,oCAAoC,oDAAM;AAC1C,oBAAoB,oDAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,mBAAmB,uDAAS;AAC5B,kDAAkD,WAAW;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sDAAqB;AAC5C,oCAAoC,sDAAqB;AACzD;AACA,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrX2D;AACpB;AACvC;AACA;AACA;AACO;AACP;AACA,uBAAuB,sDAAqB;AAC5C,sCAAsC,sDAAqB;AAC3D;AACA,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,iDAAM;AACxB,+BAA+B,8CAAa;AAC5C,iCAAiC,8CAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3DA;AACA;AACU;AACV;;;;;;;;;;;;;;;;;;ACHwC;AACjC;AACP,iBAAiB,yDAAM;AACvB,kBAAkB,yDAAM;AACxB;AACO;AACP,IAAI,yDAAM;AACV;AACA;AACO;AACP,WAAW,yDAAM;AACjB;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,kDAAkD;AAClD;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6CAA6C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6CAA6C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,+BAA+B,EAAC;AAC/C;;;;;;;;;;;;;;;ACzKA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,YAAY,EAAC;AAC5B;;;;;;;;;;;;;;;;;;;;;;;AC7E8B;AACQ;;AAEtC;AACA;;AAEA;AACA;AACA,aAAa,qDAAqD;AAClE;;AAEA;AACA;AACA,aAAa,4DAA4D;AACzE;;AAEA;AACA;AACA,WAAW,kCAAkC;AAC7C,aAAa;AACb;AACO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAc,iDAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAW,CAAC,uCAAU;AAC9B,QAAQ,wCAAW,CAAC,uCAAU;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA,kDAAkD;AAClD;AACA,SAAS,iDAAG;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8BAA8B;AAC3C;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACA;;AAEP;AACA;AACA,WAAW,GAAG;AACd,aAAa;AACb;AACO,yBAAyB,yCAAY;;AAE5C;AACA;AACA,WAAW,kCAAkC;AAC7C,aAAa;AACb;AACO,yBAAyB,yCAAY;;;;;;;;;;;;;;;;;;AClJ5C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3B8C;AACX;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAS,qBAAqB,cAAc;AAClE;AACA;AACO;AACP;AACA,sBAAsB,2DAAS;AAC/B;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT,gBAAgB,mDAAO;AACvB;AACA;AACA;;;;;;;;;;;;;;;ACxBA,iEAAe;AACf;AACA;AACA;AACA,CAAC,EAAC;AACF;;;;;;;;;;;;;;;;;;;;;ACL2D;AACK;AACA;AACO;AACrB;AACD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kBAAkB,qEAAsB,mBAAmB,MAAM,YAAY,MAAM;AACnF;AACA,uBAAuB,2DAAS;AAChC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,+BAA+B,2DAAS;AACxC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,0BAA0B,2DAAS;AACnC;AACA;AACA,SAAS;AACT,6BAA6B,2DAAS;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B,2DAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qEAAsB;AACxC;AACA;AACA,kBAAkB,qEAAsB,mBAAmB,QAAQ,YAAY,MAAM;AACrF;AACA;AACA,WAAW,0DAAgB;AAC3B;AACA,QAAQ,2DAAiB;AACzB,QAAQ,2DAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qEAAsB,mBAAmB,MAAM,YAAY,MAAM;AACnF;AACA;AACA,SAAS,0DAAgB;AACzB,kBAAkB,qEAAsB;AACxC;AACA;AACA;AACA;AACA,WAAW,+DAAkB;AAC7B,WAAW,+DAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA,OAAO,+DAAkB;AACzB,CAAC;AACD;;;;;;;;;;;;;;;;;;;;;;;;AC1FsD;AACf;AACK;AACY;AACQ;AACd;AACJ;AACT;AAC9B;AACP;AACA;AACA;AACA,mBAAmB,2DAAgB,MAAM,sDAAsB;AAC/D;AACA;AACA,eAAe,kEAAQ,QAAQ,8DAAmB;AAClD;AACA;AACA,eAAe,iDAAG;AAClB;AACA;AACA,eAAe,gEAAS;AACxB;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAgB;AAC/B;AACA;AACA,eAAe,oDAAoB;AACnC;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAgB,MAAM,uDAAuB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAgB;AAC/B;AACA;AACA,eAAe,kDAAkB;AACjC;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACrDsD;AACtD;AACA,oCAAoC;AACpC;AACqD;AACE;AAChD;AACP;AACA,0BAA0B,0DAAE;AAC5B,sBAAsB,0DAAE;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAE;AACxB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,WAAW,0DAAE;AACb;AACO;AACP,WAAW,0DAAE;AACb;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACnD2D;AAC2D;AACjF;AAC9B;AACP;AACA,uBAAuB,uDAAuB;AAC9C,wCAAwC,uDAAuB,GAAG,sDAAsB;AACxF,kDAAkD,uDAAuB;AACzE,8CAA8C,uDAAuB;AACrE,mBAAmB,0DAAsB;AACzC;AACA,oCAAoC,uDAAuB;AAC3D,8CAA8C,uDAAuB;AACrE,0CAA0C,sDAAsB;AAChE,eAAe,0DAAsB;AACrC;AACO;AACP,oCAAoC,sDAAsB;AAC1D,eAAe,yDAAqB;AACpC;AACO;AACP,YAAY,wBAAwB,EAAE,kDAAkB;AACxD,eAAe,0DAAsB;AACrC;AACO;AACP,YAAY,wBAAwB,EAAE,0DAA0B;AAChE,eAAe,0DAAsB;AACrC;AACO;AACP;AACA;AACA,kBAAkB,qEAAsB,uCAAuC,OAAO,QAAQ,WAAW;AACzG;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4D;AACuF;AACnH;AAC8D;AAC6B;AAChE;AACT;AAC3C;AACP;AACA,eAAe,yEAAsB;AACrC;AACA;AACA,eAAe,6EAAwB;AACvC;AACA;AACA,eAAe,iEAAkB;AACjC;AACA,cAAc,sEAAuB;AACrC;AACO;AACP;AACA,kBAAkB,sEAAuB;AACzC;AACA,WAAW,iFAA8B;AACzC;AACA;AACA;AACA;AACO;AACP,YAAY,aAAa,EAAE,+CAAY;AACvC;AACA;AACA,aAAa,6CAAU;AACvB,mBAAmB,iEAAkB;AACrC,aAAa,6CAAU;AACvB,mBAAmB,4EAAyB;AAC5C,aAAa,6CAAU;AACvB,mBAAmB,gFAA2B;AAC9C;AACA,sBAAsB,sEAAuB;AAC7C;AACA;AACA;AACA;AACA;AACO;AACP;AACA,eAAe,4EAAyB;AACxC;AACA;AACA,eAAe,gFAA2B;AAC1C;AACA;AACA,eAAe,iEAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,aAAa,EAAE,+CAAY;AACvC;AACA;AACA,aAAa,6CAAU;AACvB,mBAAmB,4EAAyB;AAC5C,aAAa,6CAAU;AACvB,mBAAmB,gFAA2B;AAC9C;AACA,sBAAsB,sEAAuB;AAC7C;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,+CAAY;AACvB,cAAc,6CAAU;AACxB;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP,oBAAoB,gDAAa;AACjC;AACA;AACA,aAAa,6CAAU;AACvB,mBAAmB,mEAAoB;AACvC,aAAa,6CAAU;AACvB,mBAAmB,6EAA0B;AAC7C,aAAa,6CAAU;AACvB,mBAAmB,iFAA4B;AAC/C;AACA,sBAAsB,sEAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,eAAe,6EAA0B;AACzC;AACA;AACA,eAAe,iFAA4B;AAC3C;AACA;AACA,eAAe,mEAAoB;AACnC;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,gDAAa;AACxB,cAAc,6CAAU;AACxB;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;ACvI2D;AACK;AACa;AACpC;AACzC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kBAAkB,qEAAsB;AACxC;AACA;AACA,kBAAkB,qEAAsB;AACxC;AACA;AACA,kBAAkB,qEAAsB;AACxC;AACA;AACA;AACA;AACA;AACA,iBAAiB,mEAAoB;AACrC;AACA,oBAAoB,kDAAW;AAC/B;AACA;AACA;AACA;AACA,iCAAiC,0DAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0DAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACqF;AAC9E;AACP;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA,eAAe,4DAAW;AAC1B;AACA,CAAC,0BAA0B;AACpB;AACP;AACA;AACA;AACA;AACA,qBAAqB,wDAAO,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4BAA4B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,8DAAa;AAC5B;AACA;AACA,eAAe,8DAAa;AAC5B;AACA,CAAC,8BAA8B;AACxB;AACP;AACA;AACA;AACA;AACA,qBAAqB,wDAAO,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4BAA4B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,8DAAa;AAC5B;AACA;AACA,eAAe,8DAAa;AAC5B;AACA,CAAC,gCAAgC;AACjC;;;;;;;;;;;;;;;;;;;;;;;;;AC/H2D;AACkB;AAC7B;AACC;AACb;AACnB;AACV;AACP,uBAAuB,2DAAS;AAChC;AACA;AACA;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AAC0C;AACnC;AACP,6BAA6B,2DAAS;AACtC;AACA,gBAAgB;AAChB,KAAK;AACL,sBAAsB,2DAAS,qBAAqB,2BAA2B;AAC/E;AACA;AACO;AACP,4BAA4B,2DAAS;AACrC;AACA,gBAAgB;AAChB,KAAK;AACL,WAAW,2DAAS,uBAAuB,2BAA2B;AACtE;AACA;AACA;AACA,kBAAkB,qEAAsB;AACxC;AACA;AACA,QAAQ,2DAAS;AACjB,QAAQ,2DAAS;AACjB;AACA;AACO;AACP;AACA,kBAAkB,qEAAsB;AACxC;AACA;AACA,kBAAkB,qEAAsB;AACxC;AACA,kBAAkB,mEAAoB;AACtC;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACtDsD;AACf;AACK;AACoB;AACD;AACxD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gDAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iDAAG;AAClB;AACA;AACA,eAAe,gEAAS;AACxB;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAgB;AAC/B;AACA;AACA,eAAe,wDAAa;AAC5B;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAgB;AAC/B;AACA;AACA,eAAe,sDAAW;AAC1B;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChEkF;AACpC;AACb;AACmB;AACyB;AACN;AACtC;AACiE;AAC1C;AACjD;AACP;AACA;AACA;AACA;AACO;AACP,YAAY,SAAS,EAAE,2CAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kBAAkB,qEAAsB;AACxC;AACA,qBAAqB,4CAAe;AACpC;AACA,gBAAgB,2CAAc,GAAG,UAAU;AAC3C,YAAY,2CAAc,oBAAoB,mEAAoB;AAClE,YAAY,2CAAc,oBAAoB,mEAAoB;AAClE,YAAY,2CAAc,oBAAoB,mEAAoB;AAClE,YAAY,2CAAc,oBAAoB,mEAAoB;AAClE,YAAY,2CAAc,oBAAoB,mEAAoB;AAClE,YAAY,2CAAc,oBAAoB,mEAAoB;AAClE,YAAY,2CAAc,oBAAoB,mEAAoB;AAClE,YAAY,2CAAc,oBAAoB,mEAAoB;AAClE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,SAAS,EAAE,2CAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kBAAkB,qEAAsB;AACxC;AACA,qBAAqB,4CAAe;AACpC;AACA,gBAAgB,4CAAe;AAC/B;AACA;AACA,wBAAwB,oDAAuB;AAC/C;AACA,qBAAqB;AACrB,wBAAwB,wCAAW;AACnC;AACA,aAAa;AACb;AACA;AACA,gBAAgB,6CAAgB;AAChC,8BAA8B,4CAAe;AAC7C;AACA,wBAAwB,2CAAc,oBAAoB,mEAAoB;AAC9E,wBAAwB,2CAAc,oBAAoB,mEAAoB;AAC9E;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,+DAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,EAAE;AACtB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,QAAQ,qDAAU;AAClB,kBAAkB,oEAAqB;AACvC;AACA,iBAAiB,4DAAM,CAAC,+CAAY;AACpC,cAAc,6CAAU;AACxB;AACA,KAAK;AACL,mBAAmB,kEAAM;AACzB,eAAe,iDAAiB;AAChC;AACO;AACP,QAAQ,qDAAU;AAClB,kBAAkB,qEAAsB;AACxC;AACA;AACA,iBAAiB,4DAAM,CAAC,+CAAY;AACpC,cAAc,6CAAU;AACxB;AACA,KAAK;AACL,mBAAmB,kEAAM;AACzB,eAAe,kDAAkB,sBAAsB,iDAAiB;AACxE;AACO;AACP;AACA,kBAAkB,qEAAsB;AACxC;AACA,uBAAuB,yDAAc;AACrC,iBAAiB,4DAAM,CAAC,+CAAY;AACpC,cAAc,6CAAU;AACxB;AACA,KAAK;AACL,mBAAmB,kEAAM;AACzB,eAAe,kDAAkB,sBAAsB,iDAAiB;AACxE;AACA;AACA;AACA;AACO;AACP;AACA,kBAAkB,qEAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxL4D;AACV;AACgB;AACxB;AAC1C;AACA;AACA;AACO;AACP,cAAc,4DAAM;AACpB,QAAQ,mDAAS;AACjB,yBAAyB,QAAQ,KAAK,8DAAI;AAC1C;AACA,sBAAsB,oDAAY;AAClC,SAAS;AACT;AACA;AACA,eAAe,8DAAI;AACnB;AACA;AACA,kBAAkB,oDAAY;AAC9B;AACA;AACA;AACA;AACA;AACO;AACP,cAAc,4DAAM;AACpB,QAAQ,mDAAS;AACjB,yBAAyB,QAAQ,KAAK,8DAAI;AAC1C;AACA,sBAAsB,yDAAiB;AACvC,SAAS;AACT;AACA;AACA,eAAe,8DAAI;AACnB;AACA;AACA,kBAAkB,yDAAiB;AACnC;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACxCsD;AACf;AACiB;AACQ;AACd;AAC0F;AACpF;AACjD;AACP;AACA;AACA;AACA;AACA,oBAAoB,qEAA0B;AAC9C,mBAAmB,qEAA0B;AAC7C;AACA;AACA,eAAe,kEAAQ,QAAQ,8DAAmB;AAClD;AACA;AACA,eAAe,iDAAG;AAClB;AACA;AACA,eAAe,gEAAS;AACxB;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAgB;AAC/B;AACA;AACA,eAAe,wDAAa;AAC5B;AACA;AACO;AACP;AACA;AACA;AACA;AACA,mBAAmB,sEAA2B;AAC9C,6DAA6D,oEAAyB;AACtF;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAgB;AAC/B;AACA;AACA,eAAe,sDAAW;AAC1B;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpDkF;AACtB;AACoE;AAChI;AACuD;AAChD;AACP,eAAe,8DAAwB;AACvC;AACO;AACP,eAAe,6DAAuB;AACtC;AACO;AACP;AACA,eAAe,8DAAwB;AACvC;AACO;AACP,kBAAkB,8DAAI;AACtB;AACA;AACO;AACP,kBAAkB,8DAAI;AACtB;AACA;AACO;AACP;AACA,QAAQ,8DAAI;AACZ;AACA;AACA;AACA,kBAAkB,qEAAsB;AACxC;AACA;AACO;AACP;AACA,QAAQ,8DAAI;AACZ;AACA;AACA;AACA,kBAAkB,oEAAqB;AACvC;AACA;AACO;AACP;AACA,eAAe,8DAAI;AACnB;AACA;AACA,kBAAkB,qEAAsB;AACxC;AACA;AACO;AACP,WAAW,8DAAI;AACf;AACA;;;;;;;;;;;;;;;;;ACpD2D;AACA;AAC3D;AACA;AACA;AACe;AACf;AACA,kBAAkB,qEAAsB;AACxC;AACA,WAAW,gEAAK;AAChB;AACA;;;;;;;;;;;;;;;;;;ACXgE;AACa;AACtE;AACP,cAAc,mEAAoB;AAClC;AACA;AACA;AACA,cAAc,0DAAgB;AAC9B;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnBuC;AACvC,iEAAe,qDAAS,EAAC;AACzB;;;;;;;;;;;;;;;;ACFA;AACqD;AACrD;AACA;AACA,iEAAe;AACf;AACA;AACA;AACA,sBAAsB,6DAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF;;;;;;;;;;;;;;;;;;;;;ACjBqC;AACG;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY,EAAE,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,qBAAqB,IAAI,WAAW,6CAA6C,YAAY;AAC9J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,sBAAsB,8BAA8B,4BAA4B;AAClJ;AACA;AACA;AACO;AACP;AACA;AACA,+BAA+B,qBAAqB;AACpD,gCAAgC,uBAAuB;AACvD,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gBAAgB,8BAA8B;AACrD;AACA;AACO,iBAAiB,wBAAwB;AAChD,YAAY,iBAAiB,EAAE,6DAAK;AACpC;AACA;AACA;AACA;AACA,0BAA0B,iDAAM;AAChC,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,oBAAoB;AACpB,qBAAqB;AACrB,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA,yCAAyC,MAAM;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,oBAAoB;AACpB,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mBAAmB,qCAAqC;AAC/D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC1MoC;AAC7B,eAAe,iDAAO;AAC7B;AACA;AACA;AACA;AACA,CAAC;AACM,oBAAoB,iDAAO;AAClC;AACA;AACA;AACA;AACA,CAAC;AACM,kBAAkB,iDAAO;AAChC;AACA;AACA;AACA;AACA,CAAC;AACM,uBAAuB,iDAAO;AACrC;AACA;AACA;AACA;AACA,CAAC;AACM,kBAAkB,iDAAO;AAChC;AACA;AACA;AACA;AACA,CAAC;AACM,uBAAuB,iDAAO;AACrC;AACA;AACA;AACA;AACA,CAAC;AACM,qBAAqB,iDAAO;AACnC;AACA;AACA;AACA;AACA,CAAC;AACM,0BAA0B,iDAAO;AACxC;AACA;AACA;AACA;AACA,CAAC;AACM,gBAAgB,iDAAO;AAC9B;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;ACvDkC;AAC3B,eAAe,+CAAK;AAC3B;AACA;AACA;AACA,CAAC;AACM,oBAAoB,+CAAK;AAChC;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;ACXkC;AAC3B,kBAAkB,+CAAK;AAC9B;AACA;AACA;AACA,CAAC;AACM,qBAAqB,+CAAK;AACjC;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;;;;;ACXO;AACA;AACP;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACxC2C;AACA;AACG;AACV;AACS;AACP;AACtC;AACoC;AAC7B;AACP,YAAY,iBAAiB;AAC7B;AACA;AACA,8DAA8D,uDAAS;AACvE;AACA,+DAA+D,oDAAM;AACrE;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC,kCAAkC,qDAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qDAAa;AACzB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kCAAkC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C,2BAA2B,qDAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,YAAY;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAM;AACrC;AACA;AACA;AACA;AACA,2BAA2B,qDAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8CAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,QAAQ;AAChE;AACA;AACA,sCAAsC;AACtC,mCAAmC;AACnC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uDAAS;AAC7C;AACA,gBAAgB,uDAAS;AACzB,kCAAkC,uDAAS,QAAQ,EAAE,OAAO;AAC5D;AACA;AACA,aAAa,uDAAS;AACtB,oCAAoC,uDAAS;AAC7C,oBAAoB,uDAAS;AAC7B;AACA,aAAa,oDAAM;AACnB,oCAAoC,oDAAM;AAC1C,oBAAoB,oDAAM;AAC1B;AACA,aAAa,oDAAM;AACnB,oCAAoC,oDAAM;AAC1C,oBAAoB,oDAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,mBAAmB,uDAAS;AAC5B,kDAAkD,WAAW;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sDAAqB;AAC5C,oCAAoC,sDAAqB;AACzD;AACA,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC1X2D;AACpB;AACvC;AACA;AACA;AACO;AACP;AACA,uBAAuB,sDAAqB;AAC5C,sCAAsC,sDAAqB;AAC3D;AACA,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,iDAAM;AACxB,+BAA+B,8CAAa;AAC5C,iCAAiC,8CAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;ACjEsC;AAC/B,gBAAgB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8CAAa;AAC/B;AACA,wCAAwC,8CAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/BqC;AACC;AACtC;AACA;AACA,eAAe,6CAAM;AACrB;AACA,WAAW,8CAAa;AACxB;AACO,mBAAmB;AAC1B;;;;;;;;;;;;;;;;;ACTA;AACmC;AACnC;AACA;AACA;AACO,eAAe,gDAAI;AAC1B;AACA;AACA;AACA,CAAC;AACM,eAAe,gDAAI;AAC1B;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;ACfA;AACA;AACU;AACV;;;;;;;;;;;;;;;;;;ACHwC;AACjC;AACP,iBAAiB,yDAAM;AACvB,kBAAkB,yDAAM;AACxB;AACO;AACP,IAAI,yDAAM;AACV;AACA;AACO;AACP,WAAW,yDAAM;AACjB;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,kDAAkD;AAClD;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6CAA6C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6CAA6C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,+BAA+B,EAAC;AAC/C;;;;;;;;;;;;;;;ACzKA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,YAAY,EAAC;AAC5B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClTA;AAC0C;AACqB;AACP;AACxD;AACO;AACP;AACA;AACA,gCAAgC,wDAAI,YAAY,gEAAW;AAC3D,mBAAmB;AACnB;AACA;AACO;AACP,6BAA6B,qEAAW,GAAG,+BAA+B;AAC1E,2BAA2B,4BAA4B;AACvD;AACA;;;;;;;;;;;;;;;;;;AChBA;AACA;AACsD;AACV;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,yCAAyC;AACzC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP,IAAI,0DAAa;AACjB,IAAI,yDAAc;AAClB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW,oDAAO;AAClB;AACA,aAAa,mBAAmB;AAChC,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;AC3JA;AACA;AACmC;AACF;AACQ;AACQ;AACjD;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB,wDAAa;AAC9B,IAAI,qDAAiB;AACrB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2BAA2B,SAAS;AACpC;AACA;AACO;AACP;AACA,YAAY,4FAA4F;AACxG;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA,SAAS;AACT,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA,SAAS,GAAG;AACZ,2DAA2D;AAC3D,mEAAmE;AACnE,+DAA+D;AAC/D;AACA;AACA;AACA;AACA,mDAAmD,IAAI,QAAQ,UAAU,EAAE,EAAE;AAC7E;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,oDAAoD;AACpD;AACA;AACA,oBAAoB,6BAA6B;AACjD,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;AACpC,sCAAsC;AACtC,sCAAsC;AACtC,oDAAoD;AACpD,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB,oBAAoB,yBAAyB;AAC7C,qCAAqC;AACrC,qCAAqC;AACrC,iDAAiD;AACjD,mCAAmC;AACnC;AACA,uDAAuD;AACvD,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;AAC7B,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,oBAAoB,iCAAiC;AACrD,oBAAoB,iCAAiC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,qCAAqC;AACrC,yCAAyC;AACzC,qCAAqC;AACrC,2DAA2D;AAC3D,6BAA6B;AAC7B,6BAA6B;AAC7B,uCAAuC;AACvC,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,kBAAkB,sDAAW,wBAAwB;AACrD,wCAAwC;AACxC,2CAA2C;AAC3C,gDAAgD;AAChD,sBAAsB,sDAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,gDAAgD;AAChD;AACA;AACA;AACA,oCAAoC;AACpC,sCAAsC;AACtC,wCAAwC;AACxC,kBAAkB,oBAAoB,iBAAiB;AACvD;AACA;AACA,8CAA8C;AAC9C,2DAA2D;AAC3D;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,sCAAsC,MAAM;AAC5C;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,0BAA0B,sDAAkB,eAAe;AAC3D,2DAA2D;AAC3D,0BAA0B;AAC1B;AACA;AACA,mBAAmB,iDAAa,qBAAqB;AACrD;AACA;AACA;AACA,gDAAgD;AAChD,YAAY,mBAAmB;AAC/B,iBAAiB,+CAAI;AACrB;AACA,eAAe,gDAAG;AAClB;AACA;AACA;AACA,oBAAoB,sDAAkB;AACtC;AACA;AACA;AACA;AACA,cAAc,sDAAW;AACzB;AACA;AACA,uBAAuB,sDAAW;AAClC,8DAA8D;AAC9D,mDAAmD;AACnD,sCAAsC;AACtC,0CAA0C;AAC1C,+CAA+C;AAC/C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kDAAc;AAClC,yCAAyC,sDAAW;AACpD;AACA;AACA,4CAA4C;AAC5C,cAAc,sDAAW;AACzB;AACA,gCAAgC;AAChC,gBAAgB,6BAA6B;AAC7C,oEAAoE;AACpE,8CAA8C;AAC9C,2EAA2E;AAC3E,wCAAwC;AACxC,sBAAsB;AACtB,oBAAoB,kDAAc,IAAI,sDAAkB;AACxD,eAAe,sDAAW,kCAAkC;AAC5D;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC,8BAA8B;AAC9B,cAAc,sDAAW,6BAA6B;AACtD,cAAc,sDAAW;AACzB;AACA,gCAAgC;AAChC,kBAAkB,sDAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACxamC;AAC4D;AAC/F;AACA,cAAc,sDAAe;AAC7B;AACA;AACA;AACA,iDAAiD,OAAO,SAAS,OAAO;AACxE;AACA,6BAA6B,QAAQ;AACrC,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,iDAAM;AACV,IAAI,iDAAM;AACV;AACA;AACA;AACA,gBAAgB,sDAAW,CAAC,sDAAW;AACvC,YAAY,8CAA8C;AAC1D;AACA;AACA;AACA,sBAAsB,sDAAW;AACjC;AACA,4CAA4C;AAC5C;AACA,kBAAkB,sDAAW;AAC7B,aAAa,sDAAW;AACxB,oBAAoB,UAAU;AAC9B;AACA,iBAAiB,sDAAW;AAC5B;AACA,gCAAgC,sDAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,iDAAM;AACV,IAAI,iDAAM;AACV;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,SAAS,sDAAW;AACpD;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6EAA6E;AACjG;AACA;AACO;AACP,IAAI,yDAAc;AAClB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,mCAAmC;AAC/C,IAAI,iDAAM;AACV;AACA,2CAA2C,sDAAW;AACtD;AACA,0CAA0C;AAC1C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,mBAAmB,gDAAG;AACtB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,mCAAmC;AACnC,iDAAiD;AACjD,iBAAiB;AACjB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kCAAkC;AAChF;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8CAA8C,wCAAwC;AACtF;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjKA;AACA;AACuI;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qEAAqE,QAAQ,MAAM,OAAO;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA,kBAAkB,2CAA2C;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,mCAAmC;AACnC,8BAA8B;AAC9B;AACA;AACA,gCAAgC;AAChC;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA,iCAAiC;AACjC;AACA;AACA,4DAA4D;AAC5D,4BAA4B;AAC5B,+BAA+B;AAC/B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,kDAAkD;AAClD,kDAAkD;AAClD,kDAAkD;AAClD;AACA,kDAAkD;AAClD,kDAAkD;AAClD,kDAAkD;AAClD,kDAAkD;AAClD,sDAAsD;AACtD,sDAAsD;AACtD,0CAA0C;AAC1C,0CAA0C;AAC1C,sDAAsD;AACtD,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,WAAW,yDAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACO;AACP,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,sDAAsD;AAC7D;AACA,yDAAyD,MAAM;AAC/D,YAAY,uCAAuC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kDAAO;AACrB;AACA;AACA;AACA;AACA;AACA,+EAA+E,WAAW;AAC1F,8CAA8C;AAC9C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0DAAe,eAAe,0DAAe;AAC/E;AACA;AACA,0DAA0D,MAAM,QAAQ,aAAa;AACrF,0BAA0B,0DAAe,UAAU,0DAAe;AAClE,SAAS;AACT,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,sDAAW;AACtB;AACA;AACA;AACA,yDAAyD,OAAO,4BAA4B,QAAQ;AACpG,uBAAuB,0DAAe,SAAS,0DAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO,4BAA4B,IAAI;AAC3E,uBAAuB,0DAAe,QAAQ,0DAAe;AAC7D;AACA;AACA,kBAAkB,0DAAe,sBAAsB,0DAAe;AACtE;AACA;;;;;;;;;;;;;;;;;AC/ZA;AACwC;AACmD;AAC3F;AACA;AACA;AACA,IAAI,yDAAc;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACO;AACP;AACA,YAAY,IAAI;AAChB,wBAAwB,gDAAG;AAC3B;AACA;AACA;AACA;AACA,mDAAmD,gDAAG;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,UAAU;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAe;AAC9B;AACA;AACA;AACA;AACA,kBAAkB,sDAAW;AAC7B;AACA,0BAA0B;AAC1B,eAAe,0DAAe;AAC9B;AACA;AACA,sBAAsB,sDAAW;AACjC;AACA;AACA,wCAAwC,iBAAiB,KAAK,UAAU,aAAa,IAAI;AACzF,eAAe,0DAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8DAA8D;AAC/E;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,2CAA2C,aAAa;AACxD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACO;AACP;AACA,gCAAgC,IAAI;AACpC;AACO;AACP;AACA;AACA;AACA,0CAA0C,IAAI;AAC9C;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO,iCAAiC,IAAI,YAAY,EAAE;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA,2BAA2B,OAAO,WAAW,gBAAgB,aAAa,IAAI;AAC9E;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,4DAA4D,WAAW;AACvE,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACO;AACP;AACA,4CAA4C;AAC5C,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,mCAAmC;AACnC,iBAAiB;AACjB;AACA;AACA,mCAAmC;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AACnD,8DAA8D;AACrE;AACA;AACA;AACA,kDAAkD,KAAK;AACvD;AACA;AACA;AACA;AACA,6CAA6C,kBAAkB,GAAG,KAAK,GAAG,WAAW,cAAc,KAAK;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW,WAAW,YAAY,IAAI;AACpD,kCAAkC,oBAAoB,IAAI,aAAa,GAAG;AAC1E;AACA,kCAAkC,UAAU,IAAI,SAAS;AACzD,kCAAkC,oBAAoB,IAAI,SAAS;AACnE,kCAAkC,2BAA2B;AAC7D,kCAAkC,wBAAwB;AAC1D;;;;;;;;;;;;;;;;;;;;;;AChSA;AACA;AACoC;AACH;AACQ;AACQ;AACjD;AACA,iBAAiB,wDAAa;AAC9B,IAAI,qDAAiB;AACrB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA,QAAQ,wCAAwC,EAAE,sCAAE;AAC7C;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0CAA0C;AAC3D,KAAK;AACL;AACA;AACA,gBAAgB,SAAS;AACzB;AACA,QAAQ,6CAAS;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC,gBAAgB,sBAAsB;AACtC;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wCAAwC,IAAI;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB,IAAI,GAAG,EAAE,EAAE,IAAI,GAAG,EAAE,EAAE;AAC3D,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,KAAK,SAAS;AAC1B;AACA;AACA;AACA,mBAAmB,kDAAc;AACjC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,8BAA8B;AAC9B,kCAAkC;AAClC,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAoE;AACpF;AACA,gBAAgB,8CAAU;AAC1B,sBAAsB,iDAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAkB,CAAC,sDAAW;AACpD;AACA;AACA,mDAAmD,aAAa,4BAA4B,WAAW;AACvG;AACA;AACA,kBAAkB,4CAAO,UAAU;AACnC,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,sDAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,oCAAoC;AACpC,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,oBAAoB,yBAAyB;AAC7C,0DAA0D;AAC1D,qCAAqC;AACrC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C,oBAAoB,yBAAyB;AAC7C,0DAA0D;AAC1D;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,oBAAoB,OAAO;AAC3B;AACA,wBAAwB,uBAAuB;AAC/C,sBAAsB,iBAAiB;AACvC,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,oBAAoB,6BAA6B;AACjD;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,oBAAoB,6BAA6B;AACjD;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAa;AAChC;AACA;AACA;AACA;AACA;AACA,iBAAiB,+CAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wDAAa;AAC9B,IAAI,qDAAiB;AACrB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,2BAA2B,qBAAqB;AAChD;AACO;AACP;AACA,YAAY,qBAAqB;AACjC,wCAAwC;AACxC,8CAA8C;AAC9C;AACA,4CAA4C;AAC5C;AACA;AACA,eAAe,4CAAO;AACtB;AACA;AACA,eAAe,+CAAU;AACzB;AACA,YAAY,2FAA2F;AACvG;AACA;AACA;AACA;AACA,wBAAwB,kDAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAkB;AAC5C;AACA;AACA,mDAAmD;AACnD;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,mDAAmD,KAAK,wBAAwB,eAAe,sBAAsB,iBAAiB;AACtI;AACA,SAAS;AACT,KAAK;AACL,mCAAmC,iDAAa,CAAC,sDAAkB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sDAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sDAAW;AAC7B;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO,YAAY,sDAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C,oCAAoC,sDAAW,uBAAuB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,sCAAsC;AACtC,qCAAqC;AACrC,kEAAkE;AAClE;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAa;AAChC;AACA;AACA,oCAAoC,sBAAsB;AAC1D;AACA;AACA;AACA,mBAAmB,iDAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yDAAoB;AAC/C,mBAAmB,uDAAkB;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,uCAAuC;AACvC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8CAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,wBAAwB,sDAAkB,SAAS;AACnD,+DAA+D;AAC/D;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,uBAAuB,8CAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,iBAAiB;AACpE;AACA,eAAe,sDAAkB;AACjC;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC,cAAc,mCAAmC,QAAQ;AACzD;AACA,yBAAyB;AACzB,kBAAkB,sDAAW;AAC7B;AACA,sBAAsB,sDAAW;AACjC;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA,kEAAkE;AAClE,0BAA0B,sDAAW,sBAAsB;AAC3D;AACA,qBAAqB,kDAAc,eAAe;AAClD,yBAAyB;AACzB;AACA;AACA;AACA,wCAAwC;AACxC;AACA,wBAAwB;AACxB,gCAAgC;AAChC,yDAAyD;AACzD,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,oEAAoE;AACpE;AACA;AACA,uCAAuC;AACvC,+BAA+B;AAC/B;AACA,sDAAsD;AACtD;AACA,iBAAiB;AACjB;AACA,6BAA6B;AAC7B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc,mCAAmC;AACjE;AACA,qBAAqB,qDAAiB;AACtC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sDAAW;AAC7B,oBAAoB,sDAAW;AAC/B;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA,0CAA0C,8CAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,0CAA0C;AAC1C,4BAA4B;AAC5B,iCAAiC;AACjC,iCAAiC;AACjC,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA,kBAAkB;AAClB,2DAA2D;AAC3D;AACA;AACA;AACA,uCAAuC;AACvC,iCAAiC;AACjC,iCAAiC;AACjC,6BAA6B;AAC7B,8BAA8B;AAC9B,4CAA4C;AAC5C;AACA,sBAAsB;AACtB,iCAAiC;AACjC,+BAA+B;AAC/B,8BAA8B;AAC9B,kCAAkC;AAClC,+BAA+B;AAC/B,gCAAgC;AAChC,8BAA8B;AAC9B,8BAA8B;AAC9B,oCAAoC;AACpC,+BAA+B;AAC/B,wCAAwC;AACxC,+BAA+B;AAC/B,gCAAgC;AAChC,uCAAuC;AACvC,uCAAuC;AACvC;AACA,yBAAyB,SAAS;AAClC,+BAA+B;AAC/B,sCAAsC;AACtC,yCAAyC;AACzC,6CAA6C;AAC7C,oCAAoC;AACpC,oCAAoC;AACpC,qCAAqC;AACrC,yCAAyC;AACzC,0CAA0C;AAC1C;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2CAA2C;AAC3C,uCAAuC;AACvC;AACA,iCAAiC;AACjC,sCAAsC;AACtC,oCAAoC;AACpC,sCAAsC;AACtC,kCAAkC;AAClC,uCAAuC;AACvC,+CAA+C,kBAAkB;AACjE,yCAAyC;AACzC,2CAA2C;AAC3C,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,sDAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,mCAAmC;AACnC,2BAA2B;AAC3B,gCAAgC;AAChC,mCAAmC;AACnC,mCAAmC;AACnC,mEAAmE;AACnE,mCAAmC;AACnC,2BAA2B;AAC3B,2BAA2B;AAC3B,mCAAmC;AACnC,gCAAgC;AAChC,gCAAgC;AAChC,gCAAgC;AAChC,mCAAmC;AACnC,gCAAgC;AAChC,8BAA8B;AAC9B,gBAAgB,iBAAiB,uBAAuB;AACxD,4BAA4B;AAC5B,8BAA8B;AAC9B,sCAAsC;AACtC,wCAAwC;AACxC,gDAAgD;AAChD,uCAAuC;AACvC,4BAA4B;AAC5B,iBAAiB;AACjB;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACriCA;AAC8C;AAC8B;AACrB;AACD;AAC6B;AAC0B;AAC9B;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,gBAAgB,0DAAI,wBAAwB;AAC5C,gBAAgB,0DAAI,uBAAuB;AAC3C,iBAAiB,0DAAI;AACrB,iBAAiB,0DAAI;AACrB,iBAAiB,0DAAI;AACrB,iBAAiB,0DAAI;AACrB,kBAAkB,0DAAI;AACtB,kBAAkB,0DAAI;AACtB,kBAAkB,0DAAI;AACtB,uBAAuB,0DAAI;AAC3B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,sBAAsB;AACtB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAG,gBAAgB;AAClC,eAAe,yDAAG,kBAAkB;AACpC;AACA;AACA,YAAY,yDAAG,mBAAmB;AAClC,gBAAgB,yDAAG,gBAAgB;AACnC,qBAAqB;AACrB,kBAAkB,yDAAG,0BAA0B;AAC/C,gCAAgC;AAChC,6BAA6B,yDAAG,SAAS;AACzC,2BAA2B,yDAAG,2BAA2B;AACzD;AACA;AACA;AACA,mBAAmB;AACnB,QAAQ,kEAAY;AACpB,YAAY,yDAAG;AACf,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2DAAK;AAChB;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAM;AAChB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,oEAAc;AACrD;AACA;AACA;AACA,WAAW,gEAAW,CAAC,gEAAW;AAClC;AACO,mCAAmC,oEAAc;AACxD;AACA;AACA,CAAC;AACM,kCAAkC,oEAAc;AACvD;AACA;AACA,aAAa,wDAAM;AACnB,CAAC;AACM,sCAAsC,mEAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC,eAAe,yDAAG,CAAC,0DAAI;AACvB,KAAK;AACL;AACA,eAAe;AACf,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,IAAI;AAChB;AACA;AACA;AACO,oDAAoD;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,sCAAsC;AACtC,yCAAyC;AACzC,oDAAoD;AACpD;AACA;AACA;AACA,yBAAyB;AACzB,4BAA4B;AAC5B,kCAAkC;AAClC,8BAA8B;AAC9B,0BAA0B;AAC1B,+BAA+B;AAC/B,mCAAmC;AACnC,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,2BAA2B;AAC3B,uBAAuB;AACvB,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,oCAAoC;AACpC,4BAA4B;AAC5B,oCAAoC;AACpC,uBAAuB;AACvB,4BAA4B;AAC5B,+BAA+B;AAC/B,oCAAoC;AACpC,gCAAgC;AAChC,8BAA8B;AAC9B,gCAAgC;AAChC,oCAAoC;AACpC,gCAAgC;AAChC,uBAAuB;AACvB,4BAA4B;AAC5B,+BAA+B;AAC/B,oCAAoC;AACpC,sBAAsB;AACtB,4BAA4B;AAC5B,+BAA+B;AAC/B,oCAAoC;AACpC,iCAAiC;AACjC,0BAA0B;AAC1B,0CAA0C;AAC1C,aAAa,sCAAsC;AACnD;AACA,wBAAwB,gEAAU,8BAA8B;AAChE;AACA,YAAY,qBAAqB,yCAAyC;AAC1E;AACA,+BAA+B;AAC/B,sCAAsC;AACtC,+BAA+B;AAC/B,+BAA+B;AAC/B,+BAA+B;AAC/B,8BAA8B;AAC9B,kCAAkC;AAClC,kCAAkC;AAClC,iCAAiC;AACjC,iCAAiC;AACjC,iCAAiC;AACjC,0CAA0C;AAC1C,aAAa,gDAAgD;AAC7D;AACA,mCAAmC,wEAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAM;AAChB,CAAC;AACM;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,mEAAe;AAC7E;AACA;AACA;AACA,YAAY,IAAI;AAChB;AACA;AACA,sCAAsC;AACtC,gDAAgD;AAChD,wBAAwB;AACxB,6CAA6C;AAC7C,UAAU,gCAAgC,kBAAkB;AAC5D,0BAA0B;AAC1B,SAAS,kEAAY;AACrB;AACA;AACA,gBAAgB;AAChB;AACA,eAAe;AACf,wDAAwD;AACxD;AACA,iCAAiC;AACjC,4CAA4C;AAC5C,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+DAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+DAAW;AACzB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8DAAU,CAAC,mEAAe,iBAAiB,kEAAY;AACpE;AACA;AACA,sCAAsC;AACtC,sCAAsC;AACtC;AACA;AACA,4CAA4C;AAC5C,gBAAgB,oBAAoB,6BAA6B;AACjE,gCAAgC;AAChC,oCAAoC;AACpC,mCAAmC;AACnC,YAAY,kEAAY;AACxB,yBAAyB;AACzB,gCAAgC;AAChC,8BAA8B;AAC9B,wBAAwB,kEAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6BAA6B;AAC3C;AACA;AACA,iDAAiD;AACjD,+BAA+B;AAC/B;AACA;AACA,gBAAgB,iBAAiB,8BAA8B;AAC/D,sCAAsC;AACtC,sCAAsC;AACtC,uCAAuC;AACvC,eAAe;AACf,YAAY,kEAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,YAAY,kEAAY;AACxB,yBAAyB;AACzB,kCAAkC;AAClC,YAAY,kEAAY;AACxB;AACA,eAAe,mEAAe,SAAS;AACvC;AACA;AACA,eAAe,8DAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACO;AACP;AACA,wCAAwC,gEAAW;AACnD,0BAA0B,8EAAkB,eAAe,wDAAM;AACjE;AACA;AACA;AACO,iDAAiD;AACxD;;;;;;;;;;;;;;;;;;;;;;;;;ACtbA;AAC8C;AACI;AACO;AACO;AACiC;AAC1B;AACtB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,kCAAkC;AAClC,gBAAgB,0DAAI;AACpB,gBAAgB,0DAAI;AACpB,iBAAiB,0DAAI;AACrB,iBAAiB,0DAAI;AACrB,iBAAiB,0DAAI;AACrB,iBAAiB,0DAAI;AACrB,kBAAkB,0DAAI;AACtB,kBAAkB,0DAAI;AACtB,kBAAkB,0DAAI;AACtB,gBAAgB,0DAAI;AACpB,gBAAgB,0DAAI;AACpB,iBAAiB,0DAAI;AACrB;AACA;AACA;AACA;AACA,WAAW,2DAAK,qCAAqC,eAAe;AAC7D,kBAAkB,6DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA,qBAAqB,yDAAG;AACxB,qBAAqB,yDAAG;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT,KAAK;AACL,CAAC,EAAE,wDAAM;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAM;AAC3B,eAAe,+DAAW;AAC1B;AACA;AACA,WAAW,4DAAM,CAAC,+DAAW;AAC7B;AACA;AACA;AACA,wBAAwB,mEAAe;AACvC,oBAAoB,yDAAG;AACvB,oBAAoB,yDAAG;AACvB;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,sCAAsC,aAAa;AACnD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,wCAAwC;AACxC,wBAAwB;AACxB;AACA,sBAAsB;AACtB,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mEAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA,oDAAoD,gEAAW;AAC/D,cAAc,+DAAW;AACzB,YAAY,uBAAuB,mCAAmC;AACtE,cAAc,+DAAW,0BAA0B;AACnD,2BAA2B,mEAAe,iCAAiC;AAC3E,wDAAwD;AACxD,oBAAoB,mEAAe,SAAS;AAC5C;AACA,mDAAmD;AACnD,YAAY,uBAAuB,2BAA2B;AAC9D,oCAAoC;AACpC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+DAAW;AAC3B,cAAc,+DAAW;AACzB,gBAAgB,+DAAW;AAC3B;AACA,yBAAyB,mEAAe,QAAQ,wBAAwB;AACxE,kBAAkB,mEAAe,uBAAuB,2BAA2B;AACnF;AACA;AACA,kBAAkB,mEAAe,wBAAwB,4BAA4B;AACrF;AACA;AACA,8DAA8D;AAC9D,2CAA2C;AAC3C;AACA,0BAA0B;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,uBAAuB;AACvB;AACA,WAAW;AACX,KAAK;AACL,CAAC;AACD,sCAAsC,sEAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,6EAAmB;AACzD;AACA;AACA;AACA,CAAC;AACD,mCAAmC,wEAAY;AAC/C,YAAY,OAAO;AACnB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAM;AAChB,CAAC;AACM;AACA;AACP;;;;;;;;;;;;;;;;;;;;;;AC7PA;AACA;AACA,0DAA0D,EAAE;AAC5D;AACA;AACA;AACA,iDAAiD,EAAE;AACnD;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,QAAQ,kBAAkB,SAAS;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,IAAI;AACrF;AACA;AACqD;AACrD,iBAAiB;AACjB,iEAAe,MAAM,EAAC;AACtB;;;;;;;;;;;;;;;;;;;ACzC8C;AACS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACO;AACP;AACA;AACA;AACA;AACO,qBAAqB,2CAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qDAAU;AAC9B;AACA;AACA,QAAQ,kDAAM;AACd,gBAAgB,yBAAyB;AACzC,eAAe,kDAAO;AACtB;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA,iCAAiC,qDAAU;AAC3C,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAM;AACd,QAAQ,kDAAM;AACd;AACA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qDAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAqD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzHA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiL;AACjL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,GAAG,EAAC;AACnB;;;;;;;;;;;;;;;AC7DO;AACP;;;;;;;;;;;;;;;;;;ACDgG;AACrD;AAC3C;AACO,mBAAmB,2CAAI;AAC9B;AACA;AACA;AACA;AACA,QAAQ,gDAAU;AAClB,oBAAoB,kDAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAY;AACpB;AACA;AACA;AACA;AACA,QAAQ,kDAAY;AACpB,QAAQ,iDAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE,gBAAgB,yDAAyD;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;AC5E4C;AACO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0CAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA,uBAAuB,+CAAI,WAAW,+CAAI;AAC1C,uBAAuB,+CAAI,WAAW,+CAAI;AAC1C;AACA;AACA;AACA,cAAc,yBAAyB;AACvC,wBAAwB,QAAQ;AAChC,2BAA2B,+CAAI,SAAS,+CAAI,UAAU,+CAAI;AAC1D,qCAAqC,2CAAG;AACxC,2BAA2B,+CAAI,SAAS,+CAAI,UAAU,+CAAI;AAC1D,iCAAiC,2CAAG;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,0DAAe;AAC9C,+BAA+B,0DAAe;AACrD;;;;;;;;;;;;;;;;;;;;;;AC1HkC;AACN;AACiB;AAC7C;AACA;AACA,sDAAsD,qDAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qBAAqB,0CAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAiE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA,wBAAwB,sDAAU,kBAAkB,sDAAU,kBAAkB,qDAAS;AACzF,wBAAwB,sDAAU,kBAAkB,sDAAU,kBAAkB,qDAAS;AACzF;AACA;AACA;AACA,wBAAwB,sDAAU,iBAAiB,sDAAU,iBAAiB,qDAAS;AACvF,wBAAwB,sDAAU,iBAAiB,sDAAU,iBAAiB,qDAAS;AACvF;AACA,yBAAyB,qDAAS;AAClC,yBAAyB,qDAAS;AAClC;AACA;AACA;AACA,cAAc,iEAAiE;AAC/E;AACA,wBAAwB,QAAQ;AAChC;AACA,4BAA4B,sDAAU,eAAe,sDAAU,eAAe,sDAAU;AACxF,4BAA4B,sDAAU,eAAe,sDAAU,eAAe,sDAAU;AACxF;AACA;AACA;AACA;AACA;AACA,yBAAyB,qDAAS;AAClC,wBAAwB,qDAAS;AACjC;AACA;AACA,4BAA4B,sDAAU,eAAe,sDAAU,eAAe,sDAAU;AACxF,4BAA4B,sDAAU,eAAe,sDAAU,eAAe,sDAAU;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe,EAAE,mDAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qDAAS;AACjC,iBAAiB,qDAAS;AAC1B;AACA;AACA;AACA,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,0DAAe;AAC9C,mCAAmC,0DAAe;AAClD,mCAAmC,0DAAe;AAClD,+BAA+B,0DAAe;AACrD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtOA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACC;AAC/C,YAAY,UAAU;AACtB;AACO;AACP;AACA;AACA;AACA;AACO;AACA;AACP;AACO;AACP;AACO;AACP;AACO;AACA;AACP;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACO;AACP,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA,2CAA2C,aAAa;AACxD;AACA;AACA;AACO;AACP,IAAI,iDAAM;AACV;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACO;AACP;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,4DAA4D,WAAW;AACvE,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI,iDAAM;AACV;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,mBAAmB;AACvC;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB;AACT;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,QAAQ,wDAAM,WAAW,wDAAM;AAC/B,eAAe,wDAAM;AACrB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC1LwC;AACwC;AACpC;;AAE5C;AACA;AACA,aAAa,kCAAkC;AAC/C;AACA,aAAa,2CAA2C;AACxD,aAAa,qCAAqC;AAClD,aAAa,qCAAqC;AAClD;;AAUC;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrBD;;AAEwC;AACuB;;AAExD;;AAEP;AACA,aAAa,sBAAsB;AACnC,aAAa,sCAAsC;AACnD;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,EAAE,6DAAgB;AAClB;AACA;AACA,uBAAuB,uDAAe,EAAE;AACxC;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,EAAE,4DAAgB;AAClB;AACA;AACA,uBAAuB,uDAAe,EAAE;AACxC;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,EAAE,4DAAgB;AAClB;AACA;AACA,uBAAuB,uDAAe,EAAE;AACxC;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP;AACA,EAAE,4DAAgB;AAClB;AACA;AACA;AACA;AACA,uBAAuB,uDAAe,EAAE;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uDAAe,EAAE;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,aAAa,4CAAK,CAAC,2CAAI;AACvB;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,aAAa,4CAAK,CAAC,2CAAI;AACvB;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,aAAa,4CAAK,CAAC,2CAAI;AACvB;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,aAAa,4CAAK,CAAC,2CAAI;AACvB;;AAEA;AACA,WAAW,IAAI;AACf,WAAW,OAAO;AAClB;AACO;AACP;AACA;;AAEA;AACA,WAAW,IAAI;AACf,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B;AACO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,yBAAyB,uDAAe,EAAE;AAC1C;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AClOA;;AAEwC;AACN;AACW;;AAE7C;AACA,aAAa,sBAAsB;AACnC,aAAa,sCAAsC;AACnD;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,aAAa,4CAAK,CAAC,2CAAI,cAAc,gDAAc;AACnD;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,aAAa,4CAAK,CAAC,2CAAI,cAAc,iDAAe;AACpD;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,aAAa,4CAAK,CAAC,2CAAI,cAAc,iDAAe;AACpD;;AAEA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,cAAc,iDAAe;AAC7B;AACA;AACA;AACA,iBAAiB,4CAAK,CAAC,2CAAI;AAC3B;AACA;AACA;AACA,uBAAuB,uDAAe,EAAE;AACxC;AACA,aAAa,4CAAK,CAAC,2CAAI;AACvB;;AAEA;AACA,WAAW,IAAI;AACf,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA,EAAE,sDAAoB;AACtB;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qDAAmB;AACpC;AACA;AACA,iBAAiB,qDAAmB;AACpC;AACA;AACA,iBAAiB,qDAAmB;AACpC;AACA;AACA,iBAAiB,qDAAmB;AACpC;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC9GwC;AACuB;AAC7B;AAC0B;;AAE5D;AACA,aAAa,sBAAsB;AACnC,aAAa,sCAAsC;AACnD;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,EAAE,4DAAgB;AAClB,cAAc,qDAAK;AACnB,aAAa,4CAAK,CAAC,2CAAI;AACvB;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,+BAA+B,gDAAc;AAC7C;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,+BAA+B,iDAAe;AAC9C;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,+BAA+B,iDAAe;AAC9C;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,YAAY,iDAAe;AAC3B;AACA,uBAAuB,uDAAe,EAAE;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA,wCAAwC,2CAAI,UAAU,0DAAU;AAChE;AACA;AACA;AACA;;AAEA;AACA,WAAW,IAAI;AACf,WAAW,OAAO;AAClB;AACO;AACP;AACA,EAAE,sDAAoB;AACtB;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA,SAAS,sDAAoB;AAC7B;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB,aAAa;AACb;AACO;AACP,kEAAkE,uDAAO;AACzE;;;;;;;;;;;;;;;;;;;;;;;;;;ACpIwC;AACuB;AAC7B;AACO;AACQ;;AAEjD;AACA,aAAa,sBAAsB;AACnC,aAAa,sCAAsC;AACnD;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACA;AACA;AACA,EAAE,6DAAgB;AAClB,kBAAkB,4CAAK,CAAC,2CAAI,SAAS,wDAAQ;AAC7C;AACA,oBAAoB,qDAAK;AACzB;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,+BAA+B,gDAAc;AAC7C;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,+BAA+B,iDAAe;AAC9C;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,+BAA+B,iDAAe;AAC9C;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,YAAY,iDAAe;AAC3B;AACA,uBAAuB,uDAAe,EAAE;AACxC;AACA;AACA;;AAEO,qBAAqB,mDAAW;;;;;;;;;;;;;;;;;;;;;;;;;ACzFC;AACN;AACW;;AAE7C;AACA,aAAa,sBAAsB;AACnC,aAAa,sCAAsC;AACnD;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,aAAa,4CAAK,CAAC,2CAAI;AACvB;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,+BAA+B,gDAAc;AAC7C;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,+BAA+B,iDAAe;AAC9C;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,+BAA+B,iDAAe;AAC9C;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,YAAY,iDAAe;AAC3B;AACA,uBAAuB,uDAAe,EAAE;AACxC;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP;AACA,uBAAuB,uDAAe,EAAE;AACxC;AACA;AACA;;AAEA;AACA,WAAW,IAAI;AACf,WAAW,OAAO;AAClB;AACO;AACP,EAAE,sDAAoB,MAAM,2CAAI;AAChC;;AAEA;AACA;AACA,4BAA4B,iDAAe;;AAE3C;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA,SAAS,sDAAoB;AAC7B;;;;;;;;;;;;;;;;;;;;;;;;;AChHwC;AACN;AACW;;AAE7C;AACA,aAAa,sBAAsB;AACnC,aAAa,sCAAsC;AACnD;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,aAAa,4CAAK,CAAC,2CAAI;AACvB;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,+BAA+B,gDAAc;AAC7C;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,+BAA+B,iDAAe;AAC9C;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,+BAA+B,iDAAe;AAC9C;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,YAAY,iDAAe;AAC3B;AACA,uBAAuB,uDAAe,EAAE;AACxC;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP;AACA,uBAAuB,uDAAe,EAAE;AACxC;AACA;AACA;;AAEA;AACA,WAAW,IAAI;AACf,WAAW,OAAO;AAClB;AACO;AACP,EAAE,sDAAoB,MAAM,2CAAI;AAChC;;AAEA;AACA;AACA,0BAA0B,iDAAe;;AAEzC;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA,SAAS,sDAAoB;AAC7B;;;;;;;;;;;;;;;;;;;;;;;AChHwC;AACN;;AAElC;AACA,aAAa,sBAAsB;AACnC,aAAa,sCAAsC;AACnD;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,aAAa,4CAAK,CAAC,2CAAI;AACvB;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,aAAa,4CAAK,CAAC,2CAAI,MAAM,gDAAc;AAC3C;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,aAAa,4CAAK,CAAC,2CAAI,MAAM,iDAAe;AAC5C;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,aAAa,4CAAK,CAAC,2CAAI,MAAM,iDAAe;AAC5C;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP,aAAa,4CAAK,CAAC,2CAAI,MAAM,iDAAe;AAC5C;;AAEA;AACA,WAAW,IAAI;AACf,WAAW,OAAO;AAClB;AACO;AACP,EAAE,sDAAoB,MAAM,2CAAI;AAChC;;AAEA,0BAA0B,iDAAe;;AAEzC;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA,SAAS,sDAAoB;AAC7B;;;;;;;;;;;;;;;;;;;;;;;;AC/EA;AACA;;AAEwC;AACK;AACN;;AAEvC;AACA,aAAa,sBAAsB;AACnC,aAAa,sCAAsC;AACnD,aAAa,sCAAsC;AACnD;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP;AACA,uBAAuB,uDAAe,EAAE;AACxC,IAAI;AACJ,eAAe,4CAAK,CAAC,2CAAI;AACzB;AACA,aAAa,4CAAK,CAAC,2CAAI;AACvB;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP;AACA,uBAAuB,uDAAe,EAAE;AACxC;AACA,aAAa,4CAAK,CAAC,2CAAI;AACvB;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACA;AACA;AACA;AACA,yBAAyB,uDAAe,EAAE;AAC1C;AACA;AACA,yBAAyB,uDAAe,EAAE;AAC1C;AACA;AACA,aAAa,4CAAK,CAAC,2CAAI;AACvB;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA,WAAW,IAAI;AACf,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B;AACO;AACP;;AAEA;AACA,cAAc,2CAAI;AAClB,IAAI;AACJ,cAAc,2CAAI;AAClB,IAAI;AACJ,cAAc,2CAAI;AAClB,IAAI;AACJ,cAAc,2CAAI;AAClB,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM,OAAO;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA,uBAAuB,uDAAe,EAAE;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA,uBAAuB,uDAAe,EAAE;AACxC;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA,uBAAuB,uDAAe,EAAE;AACxC;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA,4BAA4B,iDAAU;AACtC;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;;;;;;;;;;;;;;;;;ACnTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACsD;;AAEtD;AACA;AACA;;AAEA;;AAEO;AACP;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,yBAAyB;AACxC;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,eAAe,qDAAK;AACpB;AACA,MAAM;AACN;AACA,aAAa,sDAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3HA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,qBAAqB;AAChC,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,UAAU;AACrB,aAAa;AACb;AACO;AACP;AACA;;AAEO;AACP;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,EAAE,EAAE,gCAAgC;AACtG;;AAEO;AACP;AACA;AACA,aAAa,mBAAmB;AAChC,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ,iBAAiB,QAAQ,iBAAiB,UAAU,4BAA4B,EAAE,EAAE,SAAS;AAC9H;AACA,yBAAyB,QAAQ;AACjC;;AAEA;AACA,WAAW,wCAAwC;AACnD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW,UAAU;AACrB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChaA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;;AAOC;;;;;;;;;;;;;;;;;;;;;;AC1B4C;AACZ;AACM;;AAEvC;AACA,aAAa,4BAA4B;AACzC,aAAa,sCAAsC;AACnD,aAAa,wCAAwC;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,eAAe;AAC5B;AACA,iCAAiC;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,2CAAK;AACrB;AACA,sBAAsB,0CAAI;AAC1B;AACA;AACA;AACA,2BAA2B,uDAAe,EAAE,4BAA4B,WAAW,UAAU,kCAAkC;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,iBAAiB;AAC5B,WAAW,eAAe;AAC1B,aAAa;AACb;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uDAAe,EAAE;AAC1C;AACA;AACA,yBAAyB,uDAAe,EAAE,0CAA0C,EAAE,aAAa,YAAY;AAC/G;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,iBAAiB;AAC5B,WAAW,eAAe;AAC1B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uDAAe,EAAE;AAC1C;AACA;AACA,yBAAyB,uDAAe,EAAE,wCAAwC,GAAG,qBAAqB,YAAY;AACtH;AACA;AACA,yBAAyB,uDAAe,EAAE,qCAAqC,WAAW;AAC1F;AACA;AACA;AACA;AACA,2BAA2B,uDAAe,EAAE,wBAAwB,IAAI;AACxE;AACA;AACA;AACA;AACA,yBAAyB,uDAAe,EAAE,wCAAwC,GAAG,uBAAuB,YAAY;AACxH;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,iBAAiB;AAC5B,WAAW,eAAe;AAC1B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,2CAAI;AACzB;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,2CAAI;AACzB;AACA;;AAEA,qBAAqB,2CAAI;AACzB;AACA;;AAEA,qBAAqB,2CAAI;AACzB;AACA;AACA;AACA;AACA,uBAAuB,uDAAe,EAAE,qBAAqB,YAAY;AACzE;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,eAAe;AAC1B,aAAa;AACb;AACA;AACA;AACA,uBAAuB,uDAAe,EAAE;AACxC;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,uBAAuB,uDAAe,EAAE;AACxC;AACA;AACA,uBAAuB,uDAAe,EAAE;AACxC;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,eAAe;AAC1B,aAAa;AACb;AACA;AACA;AACA;AACA,uBAAuB,uDAAe,EAAE;AACxC;AACA;AACA;;AAEyD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChN7B;AACY;AACZ;AACiB;AACD;AACL;;AAEA;AACI;AACF;AACE;AACF;AACJ;AACA;AACI;;AAEzC;AACA,aAAa,sCAAsC;AACnD,aAAa,4CAA4C;AACzD,aAAa,kCAAkC;AAC/C,aAAa,0CAA0C;AACvD,aAAa,yCAAyC;AACtD,aAAa,4CAA4C;AACzD;;AAEA,WAAW,eAAe;AAC1B;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,cAAc,oBAAoB;AAC3B;AACP;AACA,WAAW,2CAAI,eAAe,iDAAU;AACxC,WAAW,2CAAI,iBAAiB,qDAAY;AAC5C,WAAW,2CAAI,gBAAgB,mDAAW;AAC1C,WAAW,2CAAI,iBAAiB,qDAAY;AAC5C,WAAW,2CAAI,gBAAgB,oDAAW;AAC1C,WAAW,2CAAI,cAAc,gDAAS;AACtC,WAAW,2CAAI,cAAc,gDAAS;AACtC,WAAW,2CAAI,gBAAgB,oDAAW;AAC1C;AACA;;AAEA;;AAEA,gBAAgB,sCAAE;;AAElB,iBAAiB,WAAW;AAC5B;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,cAAc;AAC3B,eAAe;AACf;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC,aAAa,cAAc;AAC3B,eAAe;AACf;AACA;AACA;AACA,yBAAyB,uDAAe,EAAE;AAC1C;AACA;AACA;AACA;;AAEA;AACA,YAAY,4CAAK,CAAC,2CAAI;AACtB,iBAAiB,4CAAK,CAAC,2CAAI;AAC3B,YAAY,4CAAK,CAAC,2CAAI;AACtB,aAAa,4CAAK,CAAC,2CAAI;AACvB,kBAAkB,4CAAK,CAAC,2CAAI;AAC5B,gBAAgB,4CAAK,CAAC,2CAAI;AAC1B;;AAEA,YAAY,wCAAwC;AACpD;AACA;AACA,aAAa,KAAK;AAClB,aAAa,QAAQ;AACrB,aAAa,eAAe;AAC5B,aAAa,WAAW;AACxB,eAAe;AACf;AACA;AACA;AACA,iBAAiB,4CAAK,CAAC,2CAAI;AAC3B,MAAM;AACN,iBAAiB,4CAAK,CAAC,2CAAI;AAC3B,MAAM;AACN,iBAAiB,4CAAK,CAAC,2CAAI;AAC3B;AACA,GAAG;;AAEH;AACA,aAAa,KAAK;AAClB,aAAa,QAAQ;AACrB,aAAa,eAAe;AAC5B,aAAa,WAAW;AACxB,eAAe;AACf;AACA;AACA;AACA,iBAAiB,4CAAK,CAAC,2CAAI;AAC3B,MAAM;AACN,iBAAiB,4CAAK,CAAC,2CAAI;AAC3B;AACA,GAAG;;AAEH;AACA,aAAa,KAAK;AAClB,aAAa,QAAQ;AACrB,aAAa,eAAe;AAC5B,aAAa,WAAW;AACxB,eAAe;AACf;AACA;AACA,eAAe,4CAAK,CAAC,2CAAI;AACzB,GAAG;;AAEH;AACA,aAAa,KAAK;AAClB,aAAa,QAAQ;AACrB,aAAa,eAAe;AAC5B,aAAa,WAAW;AACxB,eAAe;AACf;AACA;AACA,eAAe,4CAAK,CAAC,2CAAI;AACzB,GAAG;;AAEH;AACA,aAAa,KAAK;AAClB,aAAa,QAAQ;AACrB,aAAa,eAAe;AAC5B,aAAa,WAAW;AACxB,eAAe;AACf;AACA;AACA;AACA,GAAG;;AAEH;AACA,aAAa,KAAK;AAClB,aAAa,QAAQ;AACrB,aAAa,eAAe;AAC5B,aAAa,WAAW;AACxB,eAAe;AACf;AACA;AACA;AACA,GAAG;;AAEH;AACA,aAAa,KAAK;AAClB,aAAa,QAAQ;AACrB,aAAa,eAAe;AAC5B,aAAa,WAAW;AACxB,eAAe;AACf;AACA;AACA;AACA,GAAG;;AAEH;AACA,aAAa,KAAK;AAClB,aAAa,QAAQ;AACrB,aAAa,eAAe;AAC5B,aAAa,WAAW;AACxB,eAAe;AACf;AACA;AACA,eAAe,4CAAK,CAAC,2CAAI;AACzB,GAAG;;AAEH;AACA,aAAa,KAAK;AAClB,aAAa,QAAQ;AACrB,aAAa,eAAe;AAC5B,aAAa,WAAW;AACxB,eAAe;AACf;AACA;AACA,eAAe,4CAAK,CAAC,2CAAI;AACzB,GAAG;;AAEH;AACA,aAAa,KAAK;AAClB,aAAa,QAAQ;AACrB,aAAa,eAAe;AAC5B,aAAa,WAAW;AACxB,eAAe;AACf;AACA;AACA;AACA;AACA,6CAA6C,4CAAK,CAAC,2CAAI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4CAAK,CAAC,2CAAI,kCAAkC,4CAAK,CAAC,2CAAI;AACxE;AACA,gBAAgB,4CAAK,CAAC,2CAAI;AAC1B,GAAG;;AAEH;AACA,aAAa,KAAK;AAClB,aAAa,QAAQ;AACrB,aAAa,eAAe;AAC5B,aAAa,WAAW;AACxB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,4CAAK,CAAC,2CAAI;AACrD;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4CAAK,CAAC,2CAAI,4BAA4B,4CAAK,CAAC,2CAAI;AAClE;AACA,gBAAgB,4CAAK,CAAC,2CAAI;AAC1B;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,IAAI;AACtB;;AAEA;AACA,WAAW,KAAK;AAChB,WAAW,eAAe;AAC1B,WAAW,WAAW;AACtB,aAAa;AACb;AACA,0CAA0C;AAC1C,cAAc,0CAAE;AAChB,2EAA2E,qBAAqB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uDAAe,EAAE,oBAAoB,IAAI;AAChE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,uBAAuB;AAClC,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mBAAmB;AAC9B,WAAW,mBAAmB;AAC9B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,IAAI;AACf,WAAW,qBAAqB;AAChC,WAAW,oBAAoB;AAC/B,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB,WAAW,oBAAoB;AAC/B,WAAW,eAAe;AAC1B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sCAAE;AACxB;AACA;AACA;AACA;AACA,uEAAuE,QAAQ;AAC/E;AACA,aAAa,qDAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB,WAAW,eAAe;AAC1B,aAAa;AACb;AACA;AACA,4BAA4B;AAC5B;AACA;;AAEoD;;;;;;;;;;;;;;;;AC/cpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzGwC;AACN;AACI;AACF;AACE;AACF;AACJ;AACA;AACI;AACS;AACF;;AAE3C;AACA,aAAa,sCAAsC;AACnD;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA,qBAAqB,uDAAe,EAAE,6BAA6B,MAAM,cAAc,gBAAgB;AACvG;;AAEA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,iBAAiB,mBAAmB,uDAAe,EAAE,EAAE,IAAI;AAC3D;;AAEA,WAAW,gFAAgF;AACpF;;AAEP;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA,aAAa,kDAAgB;AAC7B,aAAa,mDAAiB;AAC9B,aAAa,mDAAiB;AAC9B,aAAa,mDAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA,aAAa,sDAAoB;AACjC,aAAa,uDAAqB;AAClC,aAAa,uDAAqB;AAClC,aAAa,uDAAqB;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,YAAY,0DAAwB;AACpC;AACA,aAAa,oDAAkB;AAC/B,aAAa,qDAAmB;AAChC,aAAa,qDAAmB;AAChC,aAAa,qDAAmB;AAChC;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,YAAY,4DAA0B;AACtC;AACA,aAAa,sDAAoB;AACjC,aAAa,uDAAqB;AAClC,aAAa,uDAAqB;AAClC,aAAa,uDAAqB;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,YAAY,0DAAwB;AACpC;AACA,aAAa,oDAAkB;AAC/B,aAAa,qDAAmB;AAChC,aAAa,qDAAmB;AAChC,aAAa,qDAAmB;AAChC;AACA;AACA;AACA,aAAa,6DAA2B;AACxC;AACA,mBAAmB,WAAW;AAC9B,YAAY,sDAAoB;AAChC;AACA,aAAa,gDAAc;AAC3B,aAAa,iDAAe;AAC5B,aAAa,iDAAe;AAC5B,aAAa,iDAAe;AAC5B;AACA;AACA;AACA,aAAa,yDAAuB;AACpC;AACA,mBAAmB,WAAW;AAC9B,YAAY,sDAAoB;AAChC;AACA,aAAa,gDAAc;AAC3B,aAAa,iDAAe;AAC5B,aAAa,iDAAe;AAC5B,aAAa,iDAAe;AAC5B;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA,aAAa,uDAAqB;AAClC;AACA,aAAa,qDAAmB;AAChC,aAAa,qDAAmB;AAChC,aAAa,qDAAmB;AAChC;AACA;AACA;AACA,aAAa,mDAAiB;;AAE9B,WAAW,SAAS;AACb;AACP;AACA,gBAAgB,QAAQ;AACxB,iBAAiB,4CAAK,CAAC,2CAAI;AAC3B;AACA;AACA,iBAAiB,UAAU;AAC3B,sBAAsB,4CAAK,CAAC,2CAAI;AAChC;AACA;AACA,kBAAkB,4CAAK,CAAC,2CAAI;AAC5B;AACA,kBAAkB,4CAAK,CAAC,2CAAI;AAC5B;AACA,kBAAkB,4CAAK,CAAC,2CAAI;AAC5B;AACA,kBAAkB,4CAAK,CAAC,2CAAI;AAC5B;AACA,kBAAkB,4CAAK,CAAC,2CAAI;AAC5B;AACA,kBAAkB,4CAAK,CAAC,2CAAI;AAC5B;AACA,kBAAkB,4CAAK,CAAC,2CAAI;;AAE5B;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA,SAAS,2CAAI;AACb,aAAa,0DAAS;AACtB,SAAS,2CAAI;AACb,aAAa,0DAAS;AACtB,SAAS,2CAAI;AACb,aAAa,0DAAS;AACtB,SAAS,2CAAI;AACb;AACA,eAAe,0DAAS;AACxB;AACA;AACA,SAAS,2CAAI;AACb;AACA,eAAe,0DAAS;AACxB;AACA;AACA,SAAS,2CAAI;AACb;AACA,eAAe,0DAAS;AACxB;AACA;AACA;AACA;AACA,SAAS,2CAAI;AACb;AACA,eAAe,0DAAS;AACxB;AACA;AACA;AACA;AACA,SAAS,2CAAI;AACb;AACA,eAAe,0DAAS;AACxB;AACA;AACA,SAAS,2CAAI;AACb;AACA,eAAe,0DAAS;AACxB;AACA;AACA;;;;;;;;;;;;;;;;;AChNA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,WAAW,IAAI,UAAU;AAC5C;;AAEA;AACA,aAAa,MAAM;AACnB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,KAAK;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA,eAAe,sBAAsB;AACrC;AACA;;AAEA;AACA;AACA,oBAAoB,UAAU,IAAI,WAAW;AAC7C;AACA;;AAEsB;;;;;;;;;;;;;;;;;;AClEe;;AAEd;AACvB,iEAAe,sCAAY;;;;;;;;;;;;;;;;ACH3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,SAAS;AACT;AACA;AACA,oCAAoC;AACpC;AACA;AACA,iEAAe,KAAK,EAAC;AACrB;;;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,qDAAQ;AAC/B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA,iEAAe,KAAK,EAAC;AACrB;;;;;;;;;;;;;;;;;;ACjFuC;AACV;AACtB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qDAAQ;AACnC;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAK;AACxB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,MAAM,UAAU,mBAAmB;AAC5D;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AACE;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B;AACrC;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0CAAI;AACzB;AACA;AACA;AACA,gBAAgB,mDAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mDAAQ;AACpC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0CAAI;AACzB;AACA,4BAA4B,YAAY;AACxC;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA,+DAA+D,YAAY;AAC3E;AACA;AACA,qBAAqB,0CAAI;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC1Q0C;AACN;AACpC;AACA;AACqC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,QAAQ;AACrB,aAAa,8BAA8B;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,YAAY;AACzB,eAAe;AACf;AACA;AACA;AACA,gBAAgB,YAAY,EAAE,uBAAuB;AACrD,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,QAAQ;AACrB,aAAa,6BAA6B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,yDAAyD,qBAAqB,IAAI,WAAW,6CAA6C,YAAY;AACtJ;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,gBAAgB,QAAQ;AACxB,aAAa,8DAA8D;AAC3E,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB,aAAa,4CAA4C;AACzD;;AAEA;AACA,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,QAAQ;AACxB,aAAa,8DAA8D;AAC3E,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA,MAAM;AACN,4DAA4D,sBAAsB,8BAA8B,4BAA4B;AAC5I;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,WAAW,+CAA+C;AAC1D,WAAW,+CAA+C;AAC1D,aAAa;AACb;AACO,2DAA2D,eAAe;AACjF,yBAAyB,yDAAyD;AAClF,0BAA0B,2DAA2D;AACrF,CAAC;;AAED;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB;AACO;AACP;AACA,aAAa,MAAM;AACnB,aAAa,QAAQ;AACrB,aAAa,8BAA8B;AAC3C,aAAa,6BAA6B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,WAAW,QAAQ;AACnB,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,WAAW,8BAA8B;AACzC,WAAW,8BAA8B;AACzC,aAAa;AACb;AACO,gBAAgB,8BAA8B;AACrD;;AAEA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,WAAW,QAAQ;AACnB,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO,iBAAiB,wBAAwB;AAChD,UAAU,iBAAiB,EAAE,6DAAK;AAClC;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,oBAAoB,iDAAM;AAC1B,GAAG;AACH;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA,aAAa,wBAAwB;AACrC;AACA,kBAAkB,qBAAqB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA,mCAAmC,MAAM;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,WAAW,QAAQ;AACnB,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO,mBAAmB,qCAAqC;AAC/D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;;;;;;;;;;;;;AC1VmC;;AAE5B,eAAe,iDAAO;AAC7B;AACA;AACA;AACA;AACA,CAAC;;AAEM,oBAAoB,iDAAO;AAClC;AACA;AACA;AACA;AACA,CAAC;;AAEM,kBAAkB,iDAAO;AAChC;AACA;AACA;AACA;AACA,CAAC;;AAEM,uBAAuB,iDAAO;AACrC;AACA;AACA;AACA;AACA,CAAC;;AAEM,kBAAkB,iDAAO;AAChC;AACA;AACA;AACA;AACA,CAAC;;AAEM,uBAAuB,iDAAO;AACrC;AACA;AACA;AACA;AACA,CAAC;;AAEM,qBAAqB,iDAAO;AACnC;AACA;AACA;AACA;AACA,CAAC;;AAEM,0BAA0B,iDAAO;AACxC;AACA;AACA;AACA;AACA,CAAC;;AAEM,gBAAgB,iDAAO;AAC9B;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;AC/DgC;;AAE1B,kBAAkB,+CAAK;AAC9B;AACA;AACA;AACA,CAAC;;AAEM,qBAAqB,+CAAK;AACjC;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACZD;;;;;;;;;;;;;;;;;;;;;;ACAiD;AACjD;AACA;AACqC;;AAErC,qBAAqB,0CAA0C,IAAI;AACnE,WAAW;AACX;;AAEA;AACA,WAAW,yBAAyB;AACpC,WAAW,KAAK;AAChB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0CAAG;AACvB;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;AACN,kBAAkB,0CAAG;AACrB;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd,WAAW,sBAAsB;AACjC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAc,0CAAG;AACjB;AACA;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;;AAEA;AACA,WAAW,yBAAyB;AACpC,WAAW,KAAK;AAChB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,0CAAG;AAC7C;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd,WAAW,sBAAsB;AACjC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA,yFAAyF,0CAAG;AAC5F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA,mDAAmD,yCAAyC,qBAAqB,aAAa;AAC9H;AACA,gBAAgB,0CAAG;AACnB;AACA,eAAe;AACf;AACA;AACA,WAAW;AACX;;AAEA;AACA,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,aAAa;AAC3B,gBAAgB;AAChB;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,iBAAiB;AAC9B,aAAa,iBAAiB;AAC9B,aAAa,GAAG;AAChB;AACA,iBAAiB,mBAAmB;AACpC,0DAA0D;;AAE1D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,WAAW,2BAA2B;AACtC,WAAW,0BAA0B;AACrC,aAAa;AACb;AACA,yBAAyB,sBAAsB;AAC/C;AACA;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC,cAAc,0CAAG;AACjB;AACA;AACA;AACA;;AAEA,qBAAqB,mBAAmB;AACxC;;AAEA;AACA,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,WAAW,QAAQ;AACnB,WAAW,iBAAiB;AAC5B,WAAW,2BAA2B;AACtC,WAAW,0BAA0B;AACrC,aAAa;AACb;AACA,yBAAyB,sBAAsB;AAC/C;AACA;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC,cAAc,0CAAG;;AAEjB,qBAAqB,mBAAmB;AACxC;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc,KAAK;AACnB;;AAEA;AACA,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,aAAa;AAC3B,aAAa,oGAAoG,EAAE,qGAAqG;AACxN,aAAa;AACb;AACA,yBAAyB,sCAAsC;AAC/D;AACA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA,GAAG;AACH;;AAEA;AACA,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,aAAa;AAC3B,WAAW,QAAQ;AACnB,WAAW,2BAA2B;AACtC,WAAW,iBAAiB;AAC5B,WAAW,2BAA2B;AACtC,WAAW,0BAA0B;AACrC,aAAa;AACb;AACA,yBAAyB,2BAA2B;AACpD;AACA;AACA;AACA;AACA,OAAO,mDAAa;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEsD;;;;;;;;;;;;;;;;;;;;;;;AC/QtD;;AAEA;AACA,WAAW,YAAY;AACvB;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,wCAAwC;AACnD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB,aAAa;AACb;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;;AAEgF;;;;;;;;;;;;;;;;;;;;;;;;;AClEtC;AACG;AACV;AACS;AAC5C;AACA;AAC0C;AACL;;AAErC;AACmC;;AAEnC;AACA,cAAc,gDAAgD;AAC9D,cAAc,QAAQ;AACtB,WAAW,GAAG;AACd,WAAW,8BAA8B;AACzC,aAAa;AACb;AACO;AACP,UAAU,iBAAiB;AAC3B;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B,aAAa,uDAAS;AACpE;AACA;AACA;AACA;AACA;AACA,mBAAmB,8BAA8B,YAAY,oDAAM;AACnE;AACA;AACA;;AAEA;AACA,cAAc,iBAAiB;AAC/B,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA,CAAC;;AAED;AACA,cAAc,iBAAiB;AAC/B,WAAW,oBAAoB;AAC/B;AACO;AACP;;AAEA,WAAW,+CAA+C;AAC1D;;AAEA;AACA,WAAW,iBAAiB;AAC5B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,aAAa;AAC3B,gBAAgB;AAChB;;AAEO;AACP;AACA,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,aAAa,0BAA0B;AACvC,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,0BAA0B,uCAAuC;AACjE;AACA;AACA,gBAAgB,kBAAkB;;AAElC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0BAA0B,uCAAuC;AACjE;AACA,uBAAuB,kCAAkC;AACzD;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc;AACvD;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B,0BAA0B,qDAAa;AACvC,0BAA0B,2BAA2B;AACrD;AACA;AACA;AACA;AACA,0BAA0B,2BAA2B;AACrD;AACA;AACA;AACA,yCAAyC,cAAc;AACvD;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,aAAa;AAC7B,aAAa,sCAAsC;AACnD,aAAa,SAAS;AACtB,eAAe;AACf;AACA;AACA;AACA,kBAAkB,sDAAsD;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,qDAAa;AACnB;AACA;;AAEA;AACA,aAAa,8BAA8B;AAC3C,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB,gBAAgB;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,aAAa;AAC7B,gBAAgB,SAAS;AACzB,aAAa,wCAAwC;AACrD,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,KAAK;AAClC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,cAAc,kCAAkC;AAChD;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,cAAc,2BAA2B;AACzC;AACA,mBAAmB,0BAA0B;AAC7C,SAAS,qDAAa;AACtB;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,aAAa;AAC7B,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,aAAa,0BAA0B;AACvC,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oDAAoD,YAAY;AAChE;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,aAAa,0CAA0C;AACvD,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,aAAa,MAAM;AACnB,aAAa,0BAA0B;AACvC,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,aAAa;AAC7B,aAAa,8CAA8C;AAC3D,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,aAAa;AAC7B,aAAa,oCAAoC;AACjD,eAAe;AACf;AACA;AACA;AACA;AACA,2BAA2B,iDAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kCAAkC;AACpE;AACA,uBAAuB,iBAAiB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,aAAa;AAC7B,aAAa,oCAAoC;AACjD,iBAAiB;AACjB;AACA;AACA;AACA;AACA,0BAA0B,8CAAa;AACvC;AACA;AACA;;AAEA,6BAA6B,GAAG;AAChC,2BAA2B,GAAG;AAC9B,mBAAmB,QAAQ;AAC3B;AACA,2BAA2B,GAAG;AAC9B;AACA,MAAM;AACN,yBAAyB,GAAG;AAC5B;;AAEA;AACA,kDAAkD,QAAQ;AAC1D;;AAEA;AACA,qCAAqC,GAAG;AACxC;AACA;AACA;;AAEA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,SAAS;AACzB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,aAAa;AAC7B,aAAa,sDAAsD;AACnE,aAAa,8BAA8B;AAC3C,eAAe;AACf;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,aAAa;AAC3B,WAAW,sDAAsD;AACjE,WAAW,8BAA8B;AACzC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,8BAA8B,uDAAS;AACvC;AACA,mBAAmB,QAAQ,IAAI,uDAAS;AACxC,0BAA0B,uDAAS,QAAQ,EAAE,OAAO;AACpD;AACA;AACA,SAAS,uDAAS;AAClB,8BAA8B,uDAAS;AACvC,yBAAyB,QAAQ,GAAG,uDAAS;AAC7C;AACA,SAAS,oDAAM;AACf,8BAA8B,oDAAM;AACpC,yBAAyB,QAAQ,GAAG,oDAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,qBAAqB;AAChC,WAAW,2BAA2B;AACtC;AACA;AACA,UAAU,SAAS;AACnB,iBAAiB,uDAAS;AAC1B,8CAA8C,WAAW;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB,WAAW,YAAY;AACvB,WAAW,qBAAqB;AAChC,WAAW,8BAA8B;AACzC;AACA;AACA,UAAU,SAAS;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA,qBAAqB,sDAAqB;AAC1C,kCAAkC,sDAAqB;AACvD;AACA,EAAE,gDAAe;AACjB,EAAE,gDAAe;AACjB;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;ACrlB0D;AACpB;;AAEtC;AACA;AACA;AACA,cAAc,QAAQ;AACtB,WAAW,MAAM;AACjB,WAAW,YAAY;AACvB;AACO;AACP;AACA,qBAAqB,sDAAqB;AAC1C,oCAAoC,sDAAqB;;AAEzD;AACA,EAAE,gDAAe;AACjB,EAAE,gDAAe;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACO;AACP,gBAAgB,iDAAM;AACtB,6BAA6B,8CAAa;AAC1C,+BAA+B,8CAAa;AAC5C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,iBAAiB;AAC5B,WAAW,SAAS;AACpB,aAAa;AACb;AACO;AACP;AACA;AACA,IAAI;AACJ,6BAA6B,+CAA+C;;AAE5E;AACA;AACA;AACA;AACA,MAAM,iDAAU;AAChB;AACA;AACA;;AAEA;AACA,aAAa,0CAA0C;AACvD;;AAEA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA,gBAAgB;AAChB;AACO;AACP;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,aAAa,YAAY;AACzB,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1FqC;;AAErC;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,WAAW,QAAQ;AACnB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,0CAA0C;AACrD;AACO,gBAAgB,oBAAoB;;AAE3C;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA,gBAAgB;AAChB;AACO;AACP;AACA;AACA,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,aAAa,0CAA0C;AACvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,YAAY;AACzB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,UAAU,8CAAa;AACvB;AACA,gCAAgC,8CAAa;AAC7C,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB,aAAa,0CAA0C;AACvD;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B;;;;;;;;;;;;;;;;;;AC5DA;;AAEkC;;AAElC;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;;AAEO,eAAe,gDAAI;AAC1B;AACA;AACA;AACA,CAAC;;AAEM,eAAe,gDAAI;AAC1B;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;ACvBkC;AACL;AACc;AACA;AACP;;AAErC;AAC8B;;AAEe;;;;;;;;;;;;;ACT7C;;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;ACAwC;;AAExC;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP,eAAe,yDAAM;AACrB,gBAAgB,yDAAM;AACtB;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB;AACO;AACP,EAAE,yDAAM;AACR;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP,SAAS,yDAAM;AACf;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,gDAAgD;AAChD;AACA,wCAAwC;AACxC;AACA,MAAM;AACN;AACA;AACA,2CAA2C;AAC3C,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6CAA6C;AAC5E;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY,SAAS;AAChC;AACA;AACA;AACA,sCAAsC;AACtC,+BAA+B;AAC/B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,+BAA+B,6CAA6C;AAC5E;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,2BAA2B,MAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iEAAe,+BAA+B,EAAC;;;;;;;;;;;;;;;;AC9H/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iEAAe,YAAY,EAAC;;;;;;;;;;;;;;;;AC1Fb;AACf;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;;;;;;;;;;;;;;;;;;ACT6C;AACM;AACH;AAChD;AACA;AACA;AACe,qBAAqB,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0DAAa;AACrC;AACA;AACA;AACA,gGAAgG,sCAAsC,MAAM,2BAA2B;AACvK;AACA;AACA,2FAA2F,mCAAmC,MAAM,wBAAwB;AAC5J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,eAAe,MAAM,sBAAsB;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI,YAAY;AAC7B,SAAS;AACT;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,wBAAwB;AACxE;AACA,oCAAoC,qDAAQ,+BAA+B,+BAA+B;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mDAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mGAAmG;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrTA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjB0C;AAC3B;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7BO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C,GAAG;;AAEH;;AAEA;AACA;AACA,mFAAmF,aAAa;AAChG;;AAEA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,iEAAiE,cAAc;AAC/E;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;ACnHA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClBuD;AAChD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sDAAW,SAAS,kDAAW;AAC1C;AACA;;;;;;;;;;;;;;;;ACrBuD;AAChD;AACP,WAAW,sDAAW,YAAY,kDAAW;AAC7C;AACA;;;;;;;;;;;;;;;;ACJiD;AAC1C;AACP,mBAAmB,8DAAY;AAC/B;AACA;AACA;;;;;;;;;;;;;;;;ACLiD;AAC1C;AACP,cAAc,8DAAY;AAC1B;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACA;AACG;AACD;AACa;AACA;AAC3D;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,8CAA8C;AAC9C,4BAA4B;AAC5B;AACA;;;;;;;;;;;;;;;;AC7KgD;AAChD;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8DAAW;AAC9B;AACA;AACA,mBAAmB,8DAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACzBgE;AACT;AACd;AACP;AAClC;AACA;AACA,6CAA6C,YAAY,IAAI,kBAAkB,IAAI,WAAW;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,UAAU,YAAY,SAAS;AAChF;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAQ;AACjC;AACA,uCAAuC;AACvC,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8DAAgB;AACtC,oBAAoB,4DAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;AC5WA;AACA;AACA;AACO;AACP;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY;AACZ,YAAY;AACZ,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACjGgE;AAChB;AAC6B;AACpB;AAChB;AACZ;AACK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAI;AACvB;AACA;AACA;AACA;AACA;AACA,eAAe,8DAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kDAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAgB,EAAE,4DAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAY;AACtC;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA,0BAA0B,oDAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAW;AAC/B;AACA,qCAAqC,2CAAU;AAC/C;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B,IAAI,4BAA4B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,QAAQ,2CAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mEAAoB;AACpC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACnbA;AACgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,cAAc,8DAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjOA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACO;AACP,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpBqC;AACc;AACnD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,mBAAmB,mDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA,WAAW,iEAAY;AACvB;AACA;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjBwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,iBAAiB,sDAAK;AACtB;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA,kCAAkC,YAAY,EAAE,OAAO,IAAI;AAC3D;AACA;;;;;;;;;;;;;;;;AChBwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,iBAAiB,sDAAK;AACtB;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;ACP4C;AACP;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA,CAAC;AACD;AACA,gBAAgB,mDAAW;AAC3B,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,SAAS,sDAAK;AACd;AACA;AACA;AACA,OAAO,sDAAK;AACZ;AACA,iEAAe,KAAK,EAAC;AACrB;;;;;;;;;;;;;;;;;;;;;AC/CqC;AACG;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY,EAAE,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,qBAAqB,IAAI,WAAW,6CAA6C,YAAY;AAC9J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,sBAAsB,8BAA8B,4BAA4B;AAClJ;AACA;AACA;AACO;AACP;AACA;AACA,+BAA+B,qBAAqB;AACpD,gCAAgC,uBAAuB;AACvD,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gBAAgB,8BAA8B;AACrD;AACA;AACO,iBAAiB,wBAAwB;AAChD,YAAY,iBAAiB,EAAE,6DAAK;AACpC;AACA;AACA;AACA;AACA,0BAA0B,iDAAM;AAChC,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,oBAAoB;AACpB,qBAAqB;AACrB,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA,yCAAyC,MAAM;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,oBAAoB;AACpB,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mBAAmB,qCAAqC;AAC/D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;ACzMkC;AAC3B,eAAe,+CAAK;AAC3B;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;ACNoC;AAC7B,eAAe,iDAAO;AAC7B;AACA;AACA;AACA;AACA,CAAC;AACM,oBAAoB,iDAAO;AAClC;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;ACboC;AAC7B,cAAc,iDAAO;AAC5B;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;ACPiC;AACjC;AACA,6DAA6D,UAAU,WAAW;AAClF,6DAA6D,yBAAyB,WAAW;AACjG;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,KAAK;AAChE;AACA;AACA;AACA;AACA;AACO,qBAAqB,8CAAI;AAChC;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;;;;;;;AC3BoC;AAC7B,eAAe,iDAAO;AAC7B;AACA;AACA;AACA;AACA,CAAC;AACM,oBAAoB,iDAAO;AAClC;AACA;AACA;AACA;AACA,CAAC;AACM,kBAAkB,iDAAO;AAChC;AACA;AACA;AACA;AACA,CAAC;AACM,uBAAuB,iDAAO;AACrC;AACA;AACA;AACA;AACA,CAAC;AACM,kBAAkB,iDAAO;AAChC;AACA;AACA;AACA;AACA,CAAC;AACM,uBAAuB,iDAAO;AACrC;AACA;AACA;AACA;AACA,CAAC;AACM,qBAAqB,iDAAO;AACnC;AACA;AACA;AACA;AACA,CAAC;AACM,0BAA0B,iDAAO;AACxC;AACA;AACA;AACA;AACA,CAAC;AACM,gBAAgB,iDAAO;AAC9B;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;ACvDkC;AAC3B,eAAe,+CAAK;AAC3B;AACA;AACA;AACA,CAAC;AACM,oBAAoB,+CAAK;AAChC;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;ACXkC;AAC3B,kBAAkB,+CAAK;AAC9B;AACA;AACA;AACA,CAAC;AACM,qBAAqB,+CAAK;AACjC;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;;ACXoC;AAC7B,eAAe,iDAAO;AAC7B;AACA;AACA;AACA;AACA,CAAC;AACM,kBAAkB,iDAAO;AAChC;AACA;AACA;AACA;AACA,CAAC;AACM,kBAAkB,iDAAO;AAChC;AACA;AACA;AACA;AACA,CAAC;AACM,qBAAqB,iDAAO;AACnC;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;ACzBoC;AAC7B,cAAc,iDAAO;AAC5B;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;ACPmD;AAClB;AAC1B,iBAAiB,8CAAI;AAC5B;AACA;AACA,qBAAqB,mDAAQ;AAC7B,qBAAqB,qDAAU;AAC/B,CAAC;AACD;;;;;;;;;;;;ACRA;AACA;AACU;AACV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACH4C;AACA;AACF;AACc;AACZ;AACA;AACA;AACA;AACF;AACU;AACX;AACF;AACU;AACR;AACuB;AACzD,gBAAgB,GAAG,+CAAY,KAAK,4CAAK,KAAK,4CAAK,KAAK,6CAAM,KAAK,6CAAM,KAAK,6CAAM,KAAK,6CAAM,KAAK,6CAAM,KAAK,6CAAM,KAAK,mDAAY;AACtI,iBAAiB,GAAG,6CAAI,KAAK,iDAAQ;AACrC,iBAAiB,GAAG,oDAAM;AACa;AAC9C;;;;;;;;;;;;ACnBU;AACV;;;;;;;;;;;;;;;;;;;;;;ACDO;AACA;AACP;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACxC2C;AACG;AACV;AACS;AACP;AACtC;AACoC;AAC7B;AACP,YAAY,iBAAiB;AAC7B;AACA;AACA,8DAA8D,uDAAS;AACvE;AACA,+DAA+D,oDAAM;AACrE;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC,kCAAkC,qDAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qDAAa;AACzB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kCAAkC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C,2BAA2B,qDAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,YAAY;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAM;AACrC;AACA;AACA;AACA;AACA,2BAA2B,qDAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8CAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,QAAQ;AAChE;AACA;AACA,sCAAsC;AACtC,mCAAmC;AACnC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uDAAS;AAC7C;AACA,gBAAgB,uDAAS;AACzB,kCAAkC,uDAAS,QAAQ,EAAE,OAAO;AAC5D;AACA;AACA,aAAa,uDAAS;AACtB,oCAAoC,uDAAS;AAC7C,oBAAoB,uDAAS;AAC7B;AACA,aAAa,oDAAM;AACnB,oCAAoC,oDAAM;AAC1C,oBAAoB,oDAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,mBAAmB,uDAAS;AAC5B,kDAAkD,WAAW;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sDAAqB;AAC5C,oCAAoC,sDAAqB;AACzD;AACA,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrXU;AACV;;;;;;;;;;;;;;;;;;ACDA;AACA;AACO;AACA;AACA;AACP;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;ACVqC;AAC9B;AACA;AACA;AACP,WAAW,iDAAM;AACjB;AACO;AACP,WAAW,iDAAM;AACjB;AACA;;;;;;;;;;;;;;;;;;;;ACT2D;AACpB;AACvC;AACA;AACA;AACO;AACP;AACA,uBAAuB,sDAAqB;AAC5C,sCAAsC,sDAAqB;AAC3D;AACA,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,iDAAM;AACxB,+BAA+B,8CAAa;AAC5C,iCAAiC,8CAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3DsC;AAC/B,gBAAgB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8CAAa;AAC/B;AACA,wCAAwC,8CAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/BqC;AACC;AACtC;AACA;AACA,eAAe,6CAAM;AACrB;AACA,WAAW,8CAAa;AACxB;AACO,mBAAmB;AAC1B;;;;;;;;;;;;ACTA;AACU;AACV;;;;;;;;;;;;;;;;;ACFA;AACmC;AACnC;AACA;AACA;AACO,eAAe,gDAAI;AAC1B;AACA;AACA;AACA,CAAC;AACM,eAAe,gDAAI;AAC1B;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA,YAAY,SAAS;AACrB;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA,mBAAmB;AACnB;AACA;AACA,oCAAoC,sBAAsB;AAC1D;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,gCAAgC,mCAAmC;AACnE;AACA;AACA,gCAAgC,mDAAmD;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA,mBAAmB;AACnB,sCAAsC,sBAAsB;AAC5D,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoC;AACL;AACc;AACA;AACP;AACtC;AAC+B;AACe;AAC9C;;;;;;;;;;;;;;;;;ACjNqC;AACC;AACA;AACF;AACC;AACrC;;;;;;;;;;;;ACLA;AACA;AACU;AACV;;;;;;;;;;;;;;;;;;ACHwC;AACjC;AACP,iBAAiB,yDAAM;AACvB,kBAAkB,yDAAM;AACxB;AACO;AACP,IAAI,yDAAM;AACV;AACA;AACO;AACP,WAAW,yDAAM;AACjB;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,kDAAkD;AAClD;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6CAA6C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6CAA6C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,+BAA+B,EAAC;AAC/C;;;;;;;;;;;;;;;ACzKA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,YAAY,EAAC;AAC5B;;;;;;;;;;;;;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACM;;AAElD;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA,8CAA8C,KAAK;AACnD;AACA;AACA;;AAEA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,gDAAoB;AACxC,oBAAoB,mDAAuB;;AAO1C;;;;;;;;;;;;;;;;;;;;;;ACjDD;AACA;AACA;AACA;AACmF;AACxC;AACF;AACQ;AACI;AACT;;AAE5C,cAAc,2CAAO;AACrB,eAAe,4DAAM;AACrB,2BAA2B,gEAAS;;AAEpC,mCAAmC,uBAAuB;AAC1D;AACA;AACA;AACA;AACA,UAAU,aAAa,QAAQ,sDAAY,GAAG,gCAAgC;AAC9E;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,gBAAgB;AAC3B,WAAW,mBAAmB;AAC9B,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,OAAO;AAClB;AACA,WAAW,gBAAgB;AAC3B,YAAY,iDAAiD;AAC7D;AACA;AACA;AACA,gCAAgC,iBAAiB,IAAI,cAAc,8BAA8B;AACjG,6BAA6B,kEAAe;AAC5C,UAAU,6DAAU,GAAG,YAAY;AACnC,UAAU,mEAAgB,GAAG,+BAA+B;AAC5D;AACA;;AAEA;AACA;AACA,YAAY,QAAQ,QAAQ,sDAAY,GAAG,qCAAqC;AAChF;AACA,IAAI;AACJ,wCAAwC,yBAAyB,SAAS;AAC1E,cAAc,+DAAQ;AACtB;;AAEA;AACA;AACA,aAAa,kBAAkB;AAC/B,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iEAAe,oBAAoB;;;;;;;;;;;;;;;;;;ACrGnC;AACA;AACA;AACA;AAC4C;AACA;;AAE5C;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,gBAAgB;AAC3B,WAAW,mBAAmB;AAC9B,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,OAAO;AAClB;AACA,YAAY,oDAAoD;AAChE;AACA;AACA;AACA,mCAAmC,QAAQ,IAAI,cAAc,oCAAoC;AACjG,qCAAqC,yDAAQ;AAC7C;;AAEA;AACA,2CAA2C,oCAAoC,oDAAoB,GAAG,OAAO,GAAG;AAChH;;AAEA;AACA;AACA,aAAa,kBAAkB;AAC/B,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iEAAe,uBAAuB;;;;;;;;;;;;;;;;;;;;;AChMtC;AACA;AACA;AACA;AACsC;AACe;AACL;;AAEhD;AACA;AACA;AACA,WAAW,sCAAsC;AACjD,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,iDAAG,gBAAgB,gEAAS;AACtC,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,sCAAsC;AACjD,YAAY,+BAA+B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;;AAEA;AACA,oDAAoD,QAAQ;AAC5D;;AAEA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA;AACA,WAAW,8DAAS;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkE;;;;;;;;;;;;;;;;;;;;;;AC3FlE;AACA;AACA;AACA;AACA;AACA;AACqC;AACT;AACA;AACiB;AACmD;AACrD;;AAE3C;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,MAAM;AACjB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,0BAA0B;AACrC;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,GAAG,eAAe;AAC7B,WAAW,gBAAgB;AAC3B;AACA,WAAW,gBAAgB;AAC3B;AACA,WAAW,gBAAgB;AAC3B;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,SAAS;AACpB;AACA,WAAW,UAAU;AACrB;AACA,YAAY,2BAA2B;AACvC;AACA;AACA,0BAA0B,gJAAgJ;AAC1K;AACA;AACA,4CAA4C,+BAA+B;AAC3E;;AAEA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA,cAAc,+DAAQ,gCAAgC,QAAQ;AAC9D;AACA;;AAEA,uCAAuC,kEAAe;AACtD,UAAU,6DAAU,GAAG,wBAAwB;AAC/C,UAAU,mEAAgB,GAAG,iBAAiB;AAC9C;;AAEA,uCAAuC,kEAAe;AACtD,UAAU,6DAAU,GAAG,wBAAwB;AAC/C,UAAU,+DAAY,GAAG,MAAM,+DAAQ,6BAA6B;AACpE;;AAEA,uCAAuC,kEAAe;AACtD,UAAU,6DAAU,GAAG,wBAAwB;AAC/C,UAAU,+DAAY,GAAG,MAAM,+DAAQ,6BAA6B;AACpE;;AAEA,oBAAoB,oDAAG,aAAa,kEAAkE;;AAEtG,qBAAqB,gDAAY;;AAEjC,oBAAoB,+CAAM,GAAG,gBAAgB;;AAE7C;AACA;AACA;AACA,aAAa,GAAG;AAChB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iBAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,kDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,oDAAI,GAAG,uEAAuE;;AAEnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,QAAQ;;;;;;;;;;;;;;;;;ACtPvB;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,2BAA2B;AACvC;AACA;AACA,yCAAyC,MAAM;AAC/C,8CAA8C,sBAAsB,uBAAuB;AAC3F;AACA;AACA;AACqC;;AAErC;;AAEA,yBAAyB;;AAEzB;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,sCAAsC;AAClD;AACA;AACA,qBAAqB,UAAU,8BAA8B,gJAAgJ;AAC7M,yBAAyB,wDAAQ,GAAG,sIAAsI;;AAE1K,UAAU,oBAAoB;;AAE9B;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,gEAAgE,QAAQ;;AAExF,0BAA0B,4BAA4B;AACtD;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,2BAA2B,yCAAyC,IAAI;;AAExE,0BAA0B,6BAA6B;AACvD;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ,WAAW;AAChC,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,uCAAuC,SAAS,IAAI;AACpD;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA,gBAAgB;AAChB,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iEAAe,SAAS;;;;;;;;;;;;;;;;;AClKxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;;AAErC;;AAEA;AACA;AACA,YAAY,mCAAmC;AAC/C;AACA;AACA,8BAA8B,gJAAgJ;AAC9K,yBAAyB,wDAAQ,GAAG,gJAAgJ;;AAEpL,UAAU,oBAAoB;;AAE9B;AACA;AACA;AACA,aAAa,GAAG;AAChB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,0BAA0B,6BAA6B;AACvD;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,GAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ,WAAW;AAChC,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,uCAAuC,2BAA2B,IAAI;AACtE,8BAA8B,0BAA0B;AACxD;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iEAAe,MAAM;;;;;;;;;;;;;;;;;;;;;;;;;ACpGrB;AACA;AACA;AACA;AACA;AACsC;AACN;AACI;AACe;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD,KAAK;AACxD;;AAEA;AACA;;AAEA,gBAAgB,kDAAM;AACtB,gBAAgB,qDAAS;AACzB,gBAAgB,oDAAQ;;AAEiE;;;;;;;;;;;;;;;;;;;AC1DzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,mDAAmD;AAC/D;AACA;AACA,4CAA4C,MAAM;AAClD,yCAAyC,MAAM;AAC/C,4CAA4C,4BAA4B,SAAS,GAAG;AACpF;AACA;AACA;AACA;AACoC;AACU;AACF;;AAE5C;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB;AACA,iBAAiB,YAAY,IAAI;AACjC,sBAAsB,6DAAY,GAAG,gCAAgC;AACrE,+BAA+B,6DAAY,GAAG,MAAM,+DAAQ,iDAAiD;;AAE7G;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA,YAAY,4CAA4C;AACxD;AACA;AACA;AACA,uCAAuC,gJAAgJ;AACvL;AACA,cAAc,+DAAQ,gCAAgC,QAAQ;;AAE9D;AACA,8BAA8B,WAAW;;AAEzC;AACA,8BAA8B,wDAAQ,KAAK,8JAA8J;;AAEzM;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,GAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ,WAAW;AAChC,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,uCAAuC,SAAS,IAAI;AACpD,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iEAAe,eAAe;;;;;;;;;;;;;;;;;ACvL9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;;AAErC;;AAEA;AACA;AACA,YAAY,qCAAqC;AACjD;AACA;AACA,gCAAgC,gJAAgJ;AAChL,yBAAyB,wDAAQ,GAAG,gJAAgJ;;AAEpL,UAAU,oBAAoB;;AAE9B;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,GAAG;AAChB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,0BAA0B,uBAAuB;AACjD;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,0BAA0B,6BAA6B;AACvD;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,GAAG;AACjB;AACA;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ,WAAW;AAChC,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,uCAAuC,SAAS,IAAI;AACpD;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA,gBAAgB;AAChB,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iEAAe,QAAQ;;;;;;;;;;;;;;;;;;;;;AC3HvB;AACA;AACA;AACA;AACA;AACA;AAC6E;AACnB;AAC1D;AACA;AACsE;AAC4B;AACtD;;AAE5C,gCAAgC,+DAAQ;;AAExC;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,gBAAgB;AAC3B;AACA,WAAW,MAAM;AACjB;AACA,YAAY,8BAA8B;AAC1C;AACA;AACA,4BAA4B,gCAAgC,IAAI;AAChE;AACA;AACA,4CAA4C,wBAAwB;AACpE;;AAEA,+BAA+B,yDAAQ,GAAG,uCAAuC;;AAEjF;AACA;AACA,cAAc,kEAAe,OAAO,6DAAU,GAAG,YAAY,SAAS,mEAAgB,GAAG,iBAAiB;AAC1G,cAAc,gEAAa;AAC3B;;AAEA,wCAAwC,6DAAU,GAAG,YAAY;;AAEjE;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,4BAA4B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4DAAc;AAC3B;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU,+IAA+I,UAAU;AAChL,cAAc,4BAA4B;AAC1C;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,oCAAoC,wEAAmB;AACvD,+EAA+E,UAAU;;AAEzF;;AAEA,SAAS,wEAAmB;AAC5B;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,0DAAW;AACzC;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,wDAAQ,GAAG,sEAAsE;;AAE5G;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,4BAA4B;AACzC,cAAc,SAAS;AACvB;AACA;AACA;AACA,SAAS,wDAAU;AACnB;AACA;;AAEA,YAAY,4BAA4B;;AAExC;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,qDAAO;AACpB;;AAEA,qBAAqB,wEAAmB;;AAExC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,4BAA4B;AACzC;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,0DAAW;AAC5B;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4DAAa;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIC;;;;;;;;;;;;;;;;;;;;;;;ACrL0C;AACF;AACQ;AACI;;AAErD,cAAc,2CAAO;AACrB,eAAe,4DAAM;AACrB,2BAA2B,gEAAS;;AAEpC;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,UAAU;AACxB,cAAc,UAAU;AACxB;AACA,0BAA0B,gDAAgD,IAAI;AAC9E;AACA;AACA,mCAAmC,kDAAkD;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,cAAc;AACxB;AACA;;AAEA;AACA;;AAEA;AACA,UAAU,kCAAkC;AAC5C,kBAAkB;AAClB,UAAU,aAAa,QAAQ,sDAAY,GAAG,sBAAsB;AACpE;AACA,WAAW;AACX;;AAEA;AACA,UAAU,QAAQ,QAAQ,sDAAY,GAAG,sBAAsB;AAC/D,oBAAoB,UAAU;AAC9B;;AAEA;AACA;AACA,WAAW,UAAU;AACrB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmE;;;;;;;;;;;;;;;;;;;;;;;;;AChGZ;;AAMjC;;AAMO;;;;;;;;;;;;;;;;;;;ACZyB;;AAEtD;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C,KAAK;AACnD;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,qDAAyB;;AAEiC;;;;;;;;;;;;;;;;;;ACxC9E;AACA;AACA;AACA;AACA;AACA;AACsE;AACP;;AAE/D;;AAEA;AACA;AACA,WAAW,iBAAiB;AAC5B,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,UAAU,4BAA4B;AACtC,SAAS,4DAAa;AACtB;;AAEA;AACA;AACA,YAAY,qDAAqD;AACjE;AACA;AACA;AACA,qCAAqC,UAAU;AAC/C;AACA;AACA;AACA,4CAA4C,0DAA0D;AACtG;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB;AACA;AACA,yBAAyB,KAAK,IAAI;AAClC;AACA;AACA;;AAEA;AACA,WAAW,+DAAkB;AAC7B;;AAEA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB;AACA;AACA,sCAAsC,KAAK,IAAI;AAC/C;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,GAAG;AAC7C;;AAEA,WAAW,0DAAW;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iEAAe,yBAAyB;;;;;;;;;;;;;;;;;;;;;;;;;ACzFxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AAC0F;AACd;AACN;AACJ;AACf;AACN;AACJ;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,mEAAoB;AAC1D;;AAEA;;AAEA;AACA;AACA,mBAAmB,qEAAgB,CAAC,mEAAoB;AACxD,sCAAsC,mEAAoB;AAC1D,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,qBAAqB;AAChC,WAAW,mBAAmB;AAC9B,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sCAAsC,mEAAoB;AAC1D;;AAEA,SAAS,+DAAkB;AAC3B;;AAEA,6BAA6B,2DAAU,GAAG,YAAY;;AAEtD;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,2CAA2C,iBAAiB;AAC5D;AACA,IAAI;AACJ;AACA,iDAAiD,4DAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,0BAA0B;AACtC;AACA;AACA,0BAA0B,gBAAgB,IAAI;AAC9C;AACA;AACA,4CAA4C,sBAAsB;AAClE;;AAEA;AACA,6BAA6B,gEAAe,OAAO,2DAAU,GAAG,YAAY,SAAS,6DAAY,GAAG,2BAA2B;;AAE/H;AACA,yBAAyB,2DAAU,GAAG,YAAY;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ,2BAA2B,kCAAkC;AAClF,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ,2BAA2B,kCAAkC;AAClF,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA,kCAAkC,sEAAiB;AACnD;AACA;;AAEA;AACA;AACA,aAAa,QAAQ,2BAA2B,kCAAkC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,oEAAe;;AAEzC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ,2BAA2B,kCAAkC;AAClF,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA,YAAY,sEAAiB;;AAE7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0CAA0C,+DAAkB;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAMC;;;;;;;;;;;;;;;;;;;;;AC5S0C;AACF;AACQ;AACI;AAC6B;;AAElF,cAAc,2CAAO;AACrB,eAAe,4DAAM;AACrB,2BAA2B,gEAAS;;AAEpC,+BAA+B,gBAAgB,IAAI;AACnD;AACA;AACA,4CAA4C,+BAA+B;AAC3E;AACA;;AAEA,6BAA6B,kEAAe;AAC5C,UAAU,6DAAU,GAAG,cAAc;AACrC,UAAU,mEAAgB,GAAG,iBAAiB;AAC9C;;AAEA;AACA;AACA,YAAY,QAAQ,QAAQ,sDAAY,GAAG,sBAAsB;AACjE;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,oCAAoC;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,6BAA6B,OAAO;AACpC;;AAEA,YAAY,aAAa,QAAQ,sDAAY,GAAG,gCAAgC;AAChF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,aAAa;;;;;;;;;;;;;;;;;;ACpE5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,cAAc;AACzB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEqD;;;;;;;;;;;;;;;;;ACzDX;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA,eAAe,wDAAa;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,YAAY,gBAAgB;AAC5B,YAAY,OAAO;AACnB;AACA;AACA;AACA,iDAAiD,UAAU;;AAE3D;AACA;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA;;AAEA,iEAAe;AACf;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;ACxF6B;AACa;AACF;AACQ;AACI;;AAErD,cAAc,2CAAO;AACrB,eAAe,4DAAM;AACrB,2BAA2B,gEAAS;;AAEpC;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB,cAAc,GAAG;AACjB,cAAc,eAAe;AAC7B;AACA,cAAc,eAAe;AAC7B,cAAc,OAAO,4BAA4B,uBAAuB;AACxE,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA,WAAW,4BAA4B;AACvC,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd;AACA,WAAW,kBAAkB;AAC7B,WAAW,qBAAqB;AAChC;AACA,WAAW,gCAAgC;AAC3C;AACA;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uBAAuB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,qDAAK;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,QAAQ,QAAQ,sDAAY,GAAG,6BAA6B;AACtE;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,kBAAkB;AAC7B,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,QAAQ,QAAQ,sDAAY,GAAG,sBAAsB;;AAE/D;AACA;;AAEA;AACA;AACA,WAAW,kBAAkB;AAC7B,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACA;AACA;AACA;AACA,UAAU,aAAa,QAAQ,sDAAY,GAAG,sBAAsB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA,UAAU,aAAa,QAAQ,sDAAY,GAAG,6BAA6B;AAC3E;AACA,gBAAgB,qDAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;ACxLD;AACA;AACA;AACA;AACA;AACA;AAC8B;AACkB;;AAEhD,uBAAuB,0DAAa;;AAEpC,uBAAuB,gBAAgB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,iDAAK;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,iDAAK;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iEAAe,KAAK;;;;;;;;;;;;;;;;;;;;;;;;ACjH8C;AACrB;AACA;AAC2B;;;;;;;;;;;;;;;;;;;;;;;;;ACHxE;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACqB;AACO;AACE;AACe;AACf;AAC2B;AACT;;AAEhD,QAAQ,0BAA0B,EAAE,+DAAkB;;AAEtD;AACA;;AAEA;AACA,uBAAuB,0DAAa;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,WAAW,gBAAgB;AAC3B;AACA,WAAW,gBAAgB;AAC3B;AACA,WAAW,gBAAgB;AAC3B;AACA,WAAW,UAAU;AACrB,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA,+BAA+B,4EAA4E,IAAI;AAC/G;AACA;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAK,GAAG,wCAAwC;AACvE;AACA;AACA;AACA,0BAA0B,+CAAM,GAAG,gBAAgB;AACnD,wBAAwB,+CAAM,GAAG,gBAAgB;;AAEjD;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAK;AAChB;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iDAAK;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,cAAc,kBAAkB;AAChC;AACA;AACA;AACA,0CAA0C,oBAAoB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iDAAK;AAC/B;AACA;AACA;AACA,QAAQ,oDAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,cAAc;AACvE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC,SAAS,gCAAgC,GAAG;AACrF;AACA;AACA;AACA;AACA,2DAA2D,eAAe;AAC1E;AACA;AACA,8BAA8B,iDAAK;AACnC;AACA,qEAAqE,WAAW;AAChF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA,uCAAuC,YAAY;AACnD;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,uCAAuC,gCAAgC,IAAI;AAC3E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iDAAK;AACtB;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,gCAAG;AACtC;;AAEA;;AAEA;AACA,+BAA+B,iDAAK;AACpC,8BAA8B,iDAAK;AACnC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,KAAK;AAClB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;;;;;;;;;;;;;;;;;;;;;;;;;;AChkBzD;AACA;AACA;AACA;AACsD;AACjB;AACa;AACW;AACd;AACJ;AACA;AACwB;AACJ;;AAE/D;;AAEA,gCAAgC,mEAAoB;;AAEpD;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,WAAW,wBAAwB;AACnC,WAAW,UAAU;AACrB,WAAW,mBAAmB;AAC9B,WAAW,QAAQ;AACnB,YAAY,wBAAwB;AACpC;AACA;AACA;AACA,yBAAyB,4CAA4C,IAAI;AACzE;AACA;AACA,4CAA4C,qBAAqB;AACjE;;AAEA;AACA;AACA;;AAEA,mBAAmB,yDAAQ;AAC3B;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ,qBAAqB,yDAAQ,GAAG,MAAM,+DAAQ,2BAA2B;AACzE,uBAAuB,gEAAU,GAAG,gBAAgB;AACpD;;AAEA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA,IAAI;AACJ,iDAAiD,IAAI;AACrD;;AAEA,8BAA8B,8DAAa,GAAG,MAAM;;AAEpD;;AAEA;AACA;AACA;AACA,8EAA8E,yCAAyC;AACvH;AACA;AACA;AACA;AACA;AACA,8CAA8C,kBAAkB;AAChE;AACA,gDAAgD,oCAAoC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,GAAG,eAAe;AAC/B;AACA,aAAa,SAAS;AACtB;AACA,aAAa,iBAAiB,0BAA0B,sCAAsC;AAC9F;AACA,aAAa;AACb,qDAAqD,sDAAsD;AAC3G;AACA,aAAa,gBAAgB,uCAAuC,sCAAsC;AAC1G;AACA,aAAa,gBAAgB,uCAAuC,sCAAsC;AAC1G;AACA,aAAa,gBAAgB,uCAAuC,sCAAsC;AAC1G,aAAa,QAAQ;AACrB,mBAAmB,kBAAkB;AACrC;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0GAA0G,IAAI;AAC/I;;AAEA;AACA;AACA;;AAEA,QAAQ,2DAAc;AACtB;AACA,mBAAmB,uDAAc;AACjC;AACA;AACA,yBAAyB,iFAAmB;AAC5C,kDAAkD,WAAW,sBAAsB,kDAAkD;AACrI;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,kDAAkD,WAAW,sBAAsB,6BAA6B;AAChH,6CAA6C,uEAAuE;AACpH;AACA,gBAAgB,uDAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,oEAAe;;AAE1C;AACA,qDAAqD,KAAK;AAC1D;;AAEA;;AAEA,gCAAgC,8JAA8J;;AAE9L;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6C;;;;;;;;;;;;;;;;ACzM7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,gBAAgB;AAC5B,aAAa,iCAAiC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB,IAAI;AAC7D;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,eAAe;;;;;;;;;;;;;;;;;;;;;;;;;AC1I9B;AACA;AACA;AACA;AACA;AAC0D;AACG;AACT;AACJ;AACM;;;;;;;;;;;;;;;;;;;;ACTtD;AACA;AACA;AACA;AACA;AACA;AACsC;AACe;AACO;AAChC;;AAE5B;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB;AACA,WAAW,QAAQ;AACnB,YAAY,6BAA6B;AACzC;AACA;AACA;AACA;AACA,kCAAkC,qBAAqB,IAAI;AAC3D;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA,gBAAgB,iDAAG,aAAa,gEAAS;AACzC,YAAY,SAAS,MAAM,uEAAiB;AAC5C,2CAA2C,QAAQ;;AAEnD;AACA,YAAY,oDAAK;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA,gBAAgB,iDAAG,aAAa,gEAAS;AACzC,YAAY,SAAS,MAAM,uEAAiB;AAC5C,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,gBAAgB;;;;;;;;;;;;;;;;;ACtF/B;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qCAAqC;AACxE;AAC6B;;AAE7B;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ,UAAU;AAC7B;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA,8BAA8B,sBAAsB,IAAI;AACxD;AACA;;AAEA,iBAAiB,wCAAK,SAAS,8BAA8B;AAC7D;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB,IAAI;AAC7D,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,YAAY;;;;;;;;;;;;;;;;;ACvH3B;AACA;AACA;AACA;AACA;AACA;AACqB;;AAErB;;AAEA;AACA;AACA;AACA,WAAW,QAAQ,UAAU;AAC7B;AACA,WAAW,QAAQ;AACnB,YAAY,4BAA4B;AACxC;AACA;AACA;AACA,4BAA4B,OAAO,IAAI;AACvC,gBAAgB,gCAAG;;AAEnB;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gCAAG;AACjB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,UAAU;;;;;;;;;;;;;;;;AC7GzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,+BAA+B;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,aAAa;;;;;;;;;;;;;;;;;;;;;ACtGE;AACF;AACS;AACuB;AACjB;;AAE3C;;AAEA;AACA;AACA;AACA,uEAAuE,kBAAkB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAA6C;AAC1E;AACA;AACA;AACA,6BAA6B,mEAAmE;AAChG;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,WAAW,cAAc;AACzB;AACA;AACA,WAAW,UAAU;AACrB;AACA,WAAW,SAAS;AACpB;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA,sBAAsB,6CAA6C;AACnE;AACA;AACA,4CAA4C,kBAAkB;AAC9D;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,+DAAQ;;AAEnC,oBAAoB,+CAAM,GAAG,gBAAgB;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gDAAY;;AAErC;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA,YAAY,6CAAI;AAChB,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,oCAAoC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uEAAiB;AACvD,gBAAgB,SAAS;AACzB;AACA;AACA,mFAAmF,QAAQ;AAC3F,gBAAgB,6CAAI;AACpB,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,cAAc;;AAE1B;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;;ACzS1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,QAAQ;;;;;;;;;;;;;;;;;ACXc;;AAIpC;;;;;;;;;;;;;;;;;;;ACJM;AACP;AACA;;AAEO;AACP;AACA;AACA;;AAEO;;AAEP,iEAAe,SAAS;;;;;;;UCXxB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJqB;;AAQQ;;AAKR;;AAEiD;;AAEnB;;AAEC;;AAMd;;AAOR;;AAQH","sources":["webpack://OrbitDB/./node_modules/abstract-level/abstract-chained-batch.js","webpack://OrbitDB/./node_modules/abstract-level/abstract-iterator.js","webpack://OrbitDB/./node_modules/abstract-level/abstract-level.js","webpack://OrbitDB/./node_modules/abstract-level/index.js","webpack://OrbitDB/./node_modules/abstract-level/lib/abstract-sublevel-iterator.js","webpack://OrbitDB/./node_modules/abstract-level/lib/abstract-sublevel.js","webpack://OrbitDB/./node_modules/abstract-level/lib/common.js","webpack://OrbitDB/./node_modules/abstract-level/lib/default-chained-batch.js","webpack://OrbitDB/./node_modules/abstract-level/lib/default-kv-iterator.js","webpack://OrbitDB/./node_modules/abstract-level/lib/deferred-iterator.js","webpack://OrbitDB/./node_modules/abstract-level/lib/next-tick-browser.js","webpack://OrbitDB/./node_modules/abstract-level/lib/range-options.js","webpack://OrbitDB/./node_modules/asn1js/build/index.es.js","webpack://OrbitDB/./node_modules/base64-js/index.js","webpack://OrbitDB/./node_modules/browser-level/index.js","webpack://OrbitDB/./node_modules/browser-level/iterator.js","webpack://OrbitDB/./node_modules/browser-level/util/clear.js","webpack://OrbitDB/./node_modules/browser-level/util/deserialize.js","webpack://OrbitDB/./node_modules/browser-level/util/key-range.js","webpack://OrbitDB/./node_modules/buffer/index.js","webpack://OrbitDB/./node_modules/catering/index.js","webpack://OrbitDB/./node_modules/catering/next-tick-browser.js","webpack://OrbitDB/./node_modules/eventemitter3/index.js","webpack://OrbitDB/./node_modules/events/events.js","webpack://OrbitDB/./node_modules/ieee754/index.js","webpack://OrbitDB/./node_modules/inherits/inherits_browser.js","webpack://OrbitDB/./node_modules/level-supports/index.js","webpack://OrbitDB/./node_modules/level-transcoder/index.js","webpack://OrbitDB/./node_modules/level-transcoder/lib/encoding.js","webpack://OrbitDB/./node_modules/level-transcoder/lib/encodings.js","webpack://OrbitDB/./node_modules/level-transcoder/lib/formats.js","webpack://OrbitDB/./node_modules/level-transcoder/lib/text-endec.js","webpack://OrbitDB/./node_modules/level/browser.js","webpack://OrbitDB/./node_modules/lru/index.js","webpack://OrbitDB/./node_modules/module-error/index.js","webpack://OrbitDB/./node_modules/pvtsutils/build/index.js","webpack://OrbitDB/./node_modules/pvutils/build/utils.es.js","webpack://OrbitDB/./node_modules/queue-microtask/index.js","webpack://OrbitDB/./node_modules/retimer/retimer.js","webpack://OrbitDB/./node_modules/retimer/time-browser.js","webpack://OrbitDB/./node_modules/run-parallel-limit/index.js","webpack://OrbitDB/./node_modules/timeout-abort-controller/index.js","webpack://OrbitDB/./node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/bases/base.js","webpack://OrbitDB/./node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/bases/base32.js","webpack://OrbitDB/./node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/bases/base58.js","webpack://OrbitDB/./node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/bytes.js","webpack://OrbitDB/./node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/cid.js","webpack://OrbitDB/./node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/hashes/digest.js","webpack://OrbitDB/./node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/link/interface.js","webpack://OrbitDB/./node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/varint.js","webpack://OrbitDB/./node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/vendor/base-x.js","webpack://OrbitDB/./node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/vendor/varint.js","webpack://OrbitDB/./node_modules/@ipld/dag-cbor/src/index.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/dist/src/errors.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/dist/src/hmac/index.browser.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/dist/src/hmac/lengths.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/dist/src/keys/ecdh/index.browser.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/dist/src/keys/ed25519/ed25519.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/dist/src/keys/ed25519/index.browser.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/dist/src/keys/ed25519/utils.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/dist/src/keys/index.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/dist/src/keys/key-stretcher.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/dist/src/keys/keys.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/dist/src/keys/rsa/index.browser.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/dist/src/keys/rsa/rsa.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/dist/src/keys/rsa/utils.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/dist/src/keys/secp256k1/index.browser.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/dist/src/keys/secp256k1/secp256k1.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/dist/src/keys/secp256k1/utils.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/dist/src/random-bytes.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/dist/src/util.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/dist/src/webcrypto/index.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/dist/src/webcrypto/webcrypto.browser.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base32.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base36.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bases/base58.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/bytes.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/cid.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/hashes/digest.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/hashes/hasher.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/hashes/identity.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/hashes/sha2-browser.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/link/interface.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/varint.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/vendor/base-x.js","webpack://OrbitDB/./node_modules/@libp2p/crypto/node_modules/multiformats/dist/src/vendor/varint.js","webpack://OrbitDB/./node_modules/@libp2p/interface/dist/src/errors.js","webpack://OrbitDB/./node_modules/@noble/curves/esm/_shortw_utils.js","webpack://OrbitDB/./node_modules/@noble/curves/esm/abstract/curve.js","webpack://OrbitDB/./node_modules/@noble/curves/esm/abstract/edwards.js","webpack://OrbitDB/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js","webpack://OrbitDB/./node_modules/@noble/curves/esm/abstract/modular.js","webpack://OrbitDB/./node_modules/@noble/curves/esm/abstract/montgomery.js","webpack://OrbitDB/./node_modules/@noble/curves/esm/abstract/utils.js","webpack://OrbitDB/./node_modules/@noble/curves/esm/abstract/weierstrass.js","webpack://OrbitDB/./node_modules/@noble/curves/esm/ed25519.js","webpack://OrbitDB/./node_modules/@noble/curves/esm/secp256k1.js","webpack://OrbitDB/./node_modules/@noble/hashes/esm/_assert.js","webpack://OrbitDB/./node_modules/@noble/hashes/esm/_md.js","webpack://OrbitDB/./node_modules/@noble/hashes/esm/_u64.js","webpack://OrbitDB/./node_modules/@noble/hashes/esm/crypto.js","webpack://OrbitDB/./node_modules/@noble/hashes/esm/hmac.js","webpack://OrbitDB/./node_modules/@noble/hashes/esm/sha256.js","webpack://OrbitDB/./node_modules/@noble/hashes/esm/sha512.js","webpack://OrbitDB/./node_modules/@noble/hashes/esm/utils.js","webpack://OrbitDB/./node_modules/cborg/cborg.js","webpack://OrbitDB/./node_modules/cborg/lib/0uint.js","webpack://OrbitDB/./node_modules/cborg/lib/1negint.js","webpack://OrbitDB/./node_modules/cborg/lib/2bytes.js","webpack://OrbitDB/./node_modules/cborg/lib/3string.js","webpack://OrbitDB/./node_modules/cborg/lib/4array.js","webpack://OrbitDB/./node_modules/cborg/lib/5map.js","webpack://OrbitDB/./node_modules/cborg/lib/6tag.js","webpack://OrbitDB/./node_modules/cborg/lib/7float.js","webpack://OrbitDB/./node_modules/cborg/lib/bl.js","webpack://OrbitDB/./node_modules/cborg/lib/byte-utils.js","webpack://OrbitDB/./node_modules/cborg/lib/common.js","webpack://OrbitDB/./node_modules/cborg/lib/decode.js","webpack://OrbitDB/./node_modules/cborg/lib/encode.js","webpack://OrbitDB/./node_modules/cborg/lib/is.js","webpack://OrbitDB/./node_modules/cborg/lib/jump.js","webpack://OrbitDB/./node_modules/cborg/lib/token.js","webpack://OrbitDB/./node_modules/eventemitter3/index.mjs","webpack://OrbitDB/./node_modules/it-drain/dist/src/index.js","webpack://OrbitDB/./node_modules/it-merge/dist/src/index.js","webpack://OrbitDB/./node_modules/it-pipe/dist/src/index.js","webpack://OrbitDB/./node_modules/it-pushable/dist/src/fifo.js","webpack://OrbitDB/./node_modules/it-pushable/dist/src/index.js","webpack://OrbitDB/./node_modules/multiformats/src/bases/base.js","webpack://OrbitDB/./node_modules/multiformats/src/bases/base32.js","webpack://OrbitDB/./node_modules/multiformats/src/bases/base58.js","webpack://OrbitDB/./node_modules/multiformats/src/bases/interface.js","webpack://OrbitDB/./node_modules/multiformats/src/block.js","webpack://OrbitDB/./node_modules/multiformats/src/bytes.js","webpack://OrbitDB/./node_modules/multiformats/src/cid.js","webpack://OrbitDB/./node_modules/multiformats/src/hashes/digest.js","webpack://OrbitDB/./node_modules/multiformats/src/hashes/hasher.js","webpack://OrbitDB/./node_modules/multiformats/src/hashes/sha2-browser.js","webpack://OrbitDB/./node_modules/multiformats/src/index.js","webpack://OrbitDB/./node_modules/multiformats/src/interface.js","webpack://OrbitDB/./node_modules/multiformats/src/link/interface.js","webpack://OrbitDB/./node_modules/multiformats/src/varint.js","webpack://OrbitDB/./node_modules/multiformats/vendor/base-x.js","webpack://OrbitDB/./node_modules/multiformats/vendor/varint.js","webpack://OrbitDB/./node_modules/p-defer/index.js","webpack://OrbitDB/./node_modules/p-queue/dist/index.js","webpack://OrbitDB/./node_modules/p-queue/dist/lower-bound.js","webpack://OrbitDB/./node_modules/p-queue/dist/priority-queue.js","webpack://OrbitDB/./node_modules/p-timeout/index.js","webpack://OrbitDB/./node_modules/protons-runtime/dist/src/codec.js","webpack://OrbitDB/./node_modules/protons-runtime/dist/src/codecs/enum.js","webpack://OrbitDB/./node_modules/protons-runtime/dist/src/codecs/message.js","webpack://OrbitDB/./node_modules/protons-runtime/dist/src/decode.js","webpack://OrbitDB/./node_modules/protons-runtime/dist/src/encode.js","webpack://OrbitDB/./node_modules/protons-runtime/dist/src/index.js","webpack://OrbitDB/./node_modules/protons-runtime/dist/src/utils/float.js","webpack://OrbitDB/./node_modules/protons-runtime/dist/src/utils/longbits.js","webpack://OrbitDB/./node_modules/protons-runtime/dist/src/utils/pool.js","webpack://OrbitDB/./node_modules/protons-runtime/dist/src/utils/reader.js","webpack://OrbitDB/./node_modules/protons-runtime/dist/src/utils/utf8.js","webpack://OrbitDB/./node_modules/protons-runtime/dist/src/utils/writer.js","webpack://OrbitDB/./node_modules/uint8-varint/dist/src/index.js","webpack://OrbitDB/./node_modules/uint8arrays/dist/src/alloc.js","webpack://OrbitDB/./node_modules/uint8arrays/dist/src/compare.js","webpack://OrbitDB/./node_modules/uint8arrays/dist/src/concat.js","webpack://OrbitDB/./node_modules/uint8arrays/dist/src/equals.js","webpack://OrbitDB/./node_modules/uint8arrays/dist/src/from-string.js","webpack://OrbitDB/./node_modules/uint8arrays/dist/src/to-string.js","webpack://OrbitDB/./node_modules/uint8arrays/dist/src/util/as-uint8array.js","webpack://OrbitDB/./node_modules/uint8arrays/dist/src/util/bases.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/bases/base.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/bases/base10.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/bases/base16.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/bases/base2.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/bases/base256emoji.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/bases/base32.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/bases/base36.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/bases/base58.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/bases/base64.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/bases/base8.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/bases/identity.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/bases/interface.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/basics.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/block/interface.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/bytes.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/cid.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/codecs/interface.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/codecs/json.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/codecs/raw.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/hashes/digest.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/hashes/hasher.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/hashes/identity.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/hashes/interface.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/hashes/sha2-browser.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/index.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/interface.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/link/interface.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/varint.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/vendor/base-x.js","webpack://OrbitDB/./node_modules/uint8arrays/node_modules/multiformats/dist/src/vendor/varint.js","webpack://OrbitDB/./src/access-controllers/index.js","webpack://OrbitDB/./src/access-controllers/ipfs.js","webpack://OrbitDB/./src/access-controllers/orbitdb.js","webpack://OrbitDB/./src/address.js","webpack://OrbitDB/./src/database.js","webpack://OrbitDB/./src/databases/documents.js","webpack://OrbitDB/./src/databases/events.js","webpack://OrbitDB/./src/databases/index.js","webpack://OrbitDB/./src/databases/keyvalue-indexed.js","webpack://OrbitDB/./src/databases/keyvalue.js","webpack://OrbitDB/./src/identities/identities.js","webpack://OrbitDB/./src/identities/identity.js","webpack://OrbitDB/./src/identities/index.js","webpack://OrbitDB/./src/identities/providers/index.js","webpack://OrbitDB/./src/identities/providers/publickey.js","webpack://OrbitDB/./src/key-store.js","webpack://OrbitDB/./src/manifest-store.js","webpack://OrbitDB/./src/oplog/clock.js","webpack://OrbitDB/./src/oplog/conflict-resolution.js","webpack://OrbitDB/./src/oplog/entry.js","webpack://OrbitDB/./src/oplog/heads.js","webpack://OrbitDB/./src/oplog/index.js","webpack://OrbitDB/./src/oplog/log.js","webpack://OrbitDB/./src/orbitdb.js","webpack://OrbitDB/./src/storage/composed.js","webpack://OrbitDB/./src/storage/index.js","webpack://OrbitDB/./src/storage/ipfs-block.js","webpack://OrbitDB/./src/storage/level.js","webpack://OrbitDB/./src/storage/lru.js","webpack://OrbitDB/./src/storage/memory.js","webpack://OrbitDB/./src/sync.js","webpack://OrbitDB/./src/utils/create-id.js","webpack://OrbitDB/./src/utils/index.js","webpack://OrbitDB/./src/utils/path-join.js","webpack://OrbitDB/webpack/bootstrap","webpack://OrbitDB/webpack/runtime/define property getters","webpack://OrbitDB/webpack/runtime/global","webpack://OrbitDB/webpack/runtime/hasOwnProperty shorthand","webpack://OrbitDB/webpack/runtime/make namespace object","webpack://OrbitDB/./src/index.js"],"sourcesContent":["'use strict'\n\nconst { fromCallback } = require('catering')\nconst ModuleError = require('module-error')\nconst { getCallback, getOptions } = require('./lib/common')\n\nconst kPromise = Symbol('promise')\nconst kStatus = Symbol('status')\nconst kOperations = Symbol('operations')\nconst kFinishClose = Symbol('finishClose')\nconst kCloseCallbacks = Symbol('closeCallbacks')\n\nclass AbstractChainedBatch {\n  constructor (db) {\n    if (typeof db !== 'object' || db === null) {\n      const hint = db === null ? 'null' : typeof db\n      throw new TypeError(`The first argument must be an abstract-level database, received ${hint}`)\n    }\n\n    this[kOperations] = []\n    this[kCloseCallbacks] = []\n    this[kStatus] = 'open'\n    this[kFinishClose] = this[kFinishClose].bind(this)\n\n    this.db = db\n    this.db.attachResource(this)\n    this.nextTick = db.nextTick\n  }\n\n  get length () {\n    return this[kOperations].length\n  }\n\n  put (key, value, options) {\n    if (this[kStatus] !== 'open') {\n      throw new ModuleError('Batch is not open: cannot call put() after write() or close()', {\n        code: 'LEVEL_BATCH_NOT_OPEN'\n      })\n    }\n\n    const err = this.db._checkKey(key) || this.db._checkValue(value)\n    if (err) throw err\n\n    const db = options && options.sublevel != null ? options.sublevel : this.db\n    const original = options\n    const keyEncoding = db.keyEncoding(options && options.keyEncoding)\n    const valueEncoding = db.valueEncoding(options && options.valueEncoding)\n    const keyFormat = keyEncoding.format\n\n    // Forward encoding options\n    options = { ...options, keyEncoding: keyFormat, valueEncoding: valueEncoding.format }\n\n    // Prevent double prefixing\n    if (db !== this.db) {\n      options.sublevel = null\n    }\n\n    const mappedKey = db.prefixKey(keyEncoding.encode(key), keyFormat)\n    const mappedValue = valueEncoding.encode(value)\n\n    this._put(mappedKey, mappedValue, options)\n    this[kOperations].push({ ...original, type: 'put', key, value })\n\n    return this\n  }\n\n  _put (key, value, options) {}\n\n  del (key, options) {\n    if (this[kStatus] !== 'open') {\n      throw new ModuleError('Batch is not open: cannot call del() after write() or close()', {\n        code: 'LEVEL_BATCH_NOT_OPEN'\n      })\n    }\n\n    const err = this.db._checkKey(key)\n    if (err) throw err\n\n    const db = options && options.sublevel != null ? options.sublevel : this.db\n    const original = options\n    const keyEncoding = db.keyEncoding(options && options.keyEncoding)\n    const keyFormat = keyEncoding.format\n\n    // Forward encoding options\n    options = { ...options, keyEncoding: keyFormat }\n\n    // Prevent double prefixing\n    if (db !== this.db) {\n      options.sublevel = null\n    }\n\n    this._del(db.prefixKey(keyEncoding.encode(key), keyFormat), options)\n    this[kOperations].push({ ...original, type: 'del', key })\n\n    return this\n  }\n\n  _del (key, options) {}\n\n  clear () {\n    if (this[kStatus] !== 'open') {\n      throw new ModuleError('Batch is not open: cannot call clear() after write() or close()', {\n        code: 'LEVEL_BATCH_NOT_OPEN'\n      })\n    }\n\n    this._clear()\n    this[kOperations] = []\n\n    return this\n  }\n\n  _clear () {}\n\n  write (options, callback) {\n    callback = getCallback(options, callback)\n    callback = fromCallback(callback, kPromise)\n    options = getOptions(options)\n\n    if (this[kStatus] !== 'open') {\n      this.nextTick(callback, new ModuleError('Batch is not open: cannot call write() after write() or close()', {\n        code: 'LEVEL_BATCH_NOT_OPEN'\n      }))\n    } else if (this.length === 0) {\n      this.close(callback)\n    } else {\n      this[kStatus] = 'writing'\n      this._write(options, (err) => {\n        this[kStatus] = 'closing'\n        this[kCloseCallbacks].push(() => callback(err))\n\n        // Emit after setting 'closing' status, because event may trigger a\n        // db close which in turn triggers (idempotently) closing this batch.\n        if (!err) this.db.emit('batch', this[kOperations])\n\n        this._close(this[kFinishClose])\n      })\n    }\n\n    return callback[kPromise]\n  }\n\n  _write (options, callback) {}\n\n  close (callback) {\n    callback = fromCallback(callback, kPromise)\n\n    if (this[kStatus] === 'closing') {\n      this[kCloseCallbacks].push(callback)\n    } else if (this[kStatus] === 'closed') {\n      this.nextTick(callback)\n    } else {\n      this[kCloseCallbacks].push(callback)\n\n      if (this[kStatus] !== 'writing') {\n        this[kStatus] = 'closing'\n        this._close(this[kFinishClose])\n      }\n    }\n\n    return callback[kPromise]\n  }\n\n  _close (callback) {\n    this.nextTick(callback)\n  }\n\n  [kFinishClose] () {\n    this[kStatus] = 'closed'\n    this.db.detachResource(this)\n\n    const callbacks = this[kCloseCallbacks]\n    this[kCloseCallbacks] = []\n\n    for (const cb of callbacks) {\n      cb()\n    }\n  }\n}\n\nexports.AbstractChainedBatch = AbstractChainedBatch\n","'use strict'\n\nconst { fromCallback } = require('catering')\nconst ModuleError = require('module-error')\nconst { getOptions, getCallback } = require('./lib/common')\n\nconst kPromise = Symbol('promise')\nconst kCallback = Symbol('callback')\nconst kWorking = Symbol('working')\nconst kHandleOne = Symbol('handleOne')\nconst kHandleMany = Symbol('handleMany')\nconst kAutoClose = Symbol('autoClose')\nconst kFinishWork = Symbol('finishWork')\nconst kReturnMany = Symbol('returnMany')\nconst kClosing = Symbol('closing')\nconst kHandleClose = Symbol('handleClose')\nconst kClosed = Symbol('closed')\nconst kCloseCallbacks = Symbol('closeCallbacks')\nconst kKeyEncoding = Symbol('keyEncoding')\nconst kValueEncoding = Symbol('valueEncoding')\nconst kAbortOnClose = Symbol('abortOnClose')\nconst kLegacy = Symbol('legacy')\nconst kKeys = Symbol('keys')\nconst kValues = Symbol('values')\nconst kLimit = Symbol('limit')\nconst kCount = Symbol('count')\n\nconst emptyOptions = Object.freeze({})\nconst noop = () => {}\nlet warnedEnd = false\n\n// This class is an internal utility for common functionality between AbstractIterator,\n// AbstractKeyIterator and AbstractValueIterator. It's not exported.\nclass CommonIterator {\n  constructor (db, options, legacy) {\n    if (typeof db !== 'object' || db === null) {\n      const hint = db === null ? 'null' : typeof db\n      throw new TypeError(`The first argument must be an abstract-level database, received ${hint}`)\n    }\n\n    if (typeof options !== 'object' || options === null) {\n      throw new TypeError('The second argument must be an options object')\n    }\n\n    this[kClosed] = false\n    this[kCloseCallbacks] = []\n    this[kWorking] = false\n    this[kClosing] = false\n    this[kAutoClose] = false\n    this[kCallback] = null\n    this[kHandleOne] = this[kHandleOne].bind(this)\n    this[kHandleMany] = this[kHandleMany].bind(this)\n    this[kHandleClose] = this[kHandleClose].bind(this)\n    this[kKeyEncoding] = options[kKeyEncoding]\n    this[kValueEncoding] = options[kValueEncoding]\n    this[kLegacy] = legacy\n    this[kLimit] = Number.isInteger(options.limit) && options.limit >= 0 ? options.limit : Infinity\n    this[kCount] = 0\n\n    // Undocumented option to abort pending work on close(). Used by the\n    // many-level module as a temporary solution to a blocked close().\n    // TODO (next major): consider making this the default behavior. Native\n    // implementations should have their own logic to safely close iterators.\n    this[kAbortOnClose] = !!options.abortOnClose\n\n    this.db = db\n    this.db.attachResource(this)\n    this.nextTick = db.nextTick\n  }\n\n  get count () {\n    return this[kCount]\n  }\n\n  get limit () {\n    return this[kLimit]\n  }\n\n  next (callback) {\n    let promise\n\n    if (callback === undefined) {\n      promise = new Promise((resolve, reject) => {\n        callback = (err, key, value) => {\n          if (err) reject(err)\n          else if (!this[kLegacy]) resolve(key)\n          else if (key === undefined && value === undefined) resolve()\n          else resolve([key, value])\n        }\n      })\n    } else if (typeof callback !== 'function') {\n      throw new TypeError('Callback must be a function')\n    }\n\n    if (this[kClosing]) {\n      this.nextTick(callback, new ModuleError('Iterator is not open: cannot call next() after close()', {\n        code: 'LEVEL_ITERATOR_NOT_OPEN'\n      }))\n    } else if (this[kWorking]) {\n      this.nextTick(callback, new ModuleError('Iterator is busy: cannot call next() until previous call has completed', {\n        code: 'LEVEL_ITERATOR_BUSY'\n      }))\n    } else {\n      this[kWorking] = true\n      this[kCallback] = callback\n\n      if (this[kCount] >= this[kLimit]) this.nextTick(this[kHandleOne], null)\n      else this._next(this[kHandleOne])\n    }\n\n    return promise\n  }\n\n  _next (callback) {\n    this.nextTick(callback)\n  }\n\n  nextv (size, options, callback) {\n    callback = getCallback(options, callback)\n    callback = fromCallback(callback, kPromise)\n    options = getOptions(options, emptyOptions)\n\n    if (!Number.isInteger(size)) {\n      this.nextTick(callback, new TypeError(\"The first argument 'size' must be an integer\"))\n      return callback[kPromise]\n    }\n\n    if (this[kClosing]) {\n      this.nextTick(callback, new ModuleError('Iterator is not open: cannot call nextv() after close()', {\n        code: 'LEVEL_ITERATOR_NOT_OPEN'\n      }))\n    } else if (this[kWorking]) {\n      this.nextTick(callback, new ModuleError('Iterator is busy: cannot call nextv() until previous call has completed', {\n        code: 'LEVEL_ITERATOR_BUSY'\n      }))\n    } else {\n      if (size < 1) size = 1\n      if (this[kLimit] < Infinity) size = Math.min(size, this[kLimit] - this[kCount])\n\n      this[kWorking] = true\n      this[kCallback] = callback\n\n      if (size <= 0) this.nextTick(this[kHandleMany], null, [])\n      else this._nextv(size, options, this[kHandleMany])\n    }\n\n    return callback[kPromise]\n  }\n\n  _nextv (size, options, callback) {\n    const acc = []\n    const onnext = (err, key, value) => {\n      if (err) {\n        return callback(err)\n      } else if (this[kLegacy] ? key === undefined && value === undefined : key === undefined) {\n        return callback(null, acc)\n      }\n\n      acc.push(this[kLegacy] ? [key, value] : key)\n\n      if (acc.length === size) {\n        callback(null, acc)\n      } else {\n        this._next(onnext)\n      }\n    }\n\n    this._next(onnext)\n  }\n\n  all (options, callback) {\n    callback = getCallback(options, callback)\n    callback = fromCallback(callback, kPromise)\n    options = getOptions(options, emptyOptions)\n\n    if (this[kClosing]) {\n      this.nextTick(callback, new ModuleError('Iterator is not open: cannot call all() after close()', {\n        code: 'LEVEL_ITERATOR_NOT_OPEN'\n      }))\n    } else if (this[kWorking]) {\n      this.nextTick(callback, new ModuleError('Iterator is busy: cannot call all() until previous call has completed', {\n        code: 'LEVEL_ITERATOR_BUSY'\n      }))\n    } else {\n      this[kWorking] = true\n      this[kCallback] = callback\n      this[kAutoClose] = true\n\n      if (this[kCount] >= this[kLimit]) this.nextTick(this[kHandleMany], null, [])\n      else this._all(options, this[kHandleMany])\n    }\n\n    return callback[kPromise]\n  }\n\n  _all (options, callback) {\n    // Must count here because we're directly calling _nextv()\n    let count = this[kCount]\n    const acc = []\n\n    const nextv = () => {\n      // Not configurable, because implementations should optimize _all().\n      const size = this[kLimit] < Infinity ? Math.min(1e3, this[kLimit] - count) : 1e3\n\n      if (size <= 0) {\n        this.nextTick(callback, null, acc)\n      } else {\n        this._nextv(size, emptyOptions, onnextv)\n      }\n    }\n\n    const onnextv = (err, items) => {\n      if (err) {\n        callback(err)\n      } else if (items.length === 0) {\n        callback(null, acc)\n      } else {\n        acc.push.apply(acc, items)\n        count += items.length\n        nextv()\n      }\n    }\n\n    nextv()\n  }\n\n  [kFinishWork] () {\n    const cb = this[kCallback]\n\n    // Callback will be null if work was aborted on close\n    if (this[kAbortOnClose] && cb === null) return noop\n\n    this[kWorking] = false\n    this[kCallback] = null\n\n    if (this[kClosing]) this._close(this[kHandleClose])\n\n    return cb\n  }\n\n  [kReturnMany] (cb, err, items) {\n    if (this[kAutoClose]) {\n      this.close(cb.bind(null, err, items))\n    } else {\n      cb(err, items)\n    }\n  }\n\n  seek (target, options) {\n    options = getOptions(options, emptyOptions)\n\n    if (this[kClosing]) {\n      // Don't throw here, to be kind to implementations that wrap\n      // another db and don't necessarily control when the db is closed\n    } else if (this[kWorking]) {\n      throw new ModuleError('Iterator is busy: cannot call seek() until next() has completed', {\n        code: 'LEVEL_ITERATOR_BUSY'\n      })\n    } else {\n      const keyEncoding = this.db.keyEncoding(options.keyEncoding || this[kKeyEncoding])\n      const keyFormat = keyEncoding.format\n\n      if (options.keyEncoding !== keyFormat) {\n        options = { ...options, keyEncoding: keyFormat }\n      }\n\n      const mapped = this.db.prefixKey(keyEncoding.encode(target), keyFormat)\n      this._seek(mapped, options)\n    }\n  }\n\n  _seek (target, options) {\n    throw new ModuleError('Iterator does not support seek()', {\n      code: 'LEVEL_NOT_SUPPORTED'\n    })\n  }\n\n  close (callback) {\n    callback = fromCallback(callback, kPromise)\n\n    if (this[kClosed]) {\n      this.nextTick(callback)\n    } else if (this[kClosing]) {\n      this[kCloseCallbacks].push(callback)\n    } else {\n      this[kClosing] = true\n      this[kCloseCallbacks].push(callback)\n\n      if (!this[kWorking]) {\n        this._close(this[kHandleClose])\n      } else if (this[kAbortOnClose]) {\n        // Don't wait for work to finish. Subsequently ignore the result.\n        const cb = this[kFinishWork]()\n\n        cb(new ModuleError('Aborted on iterator close()', {\n          code: 'LEVEL_ITERATOR_NOT_OPEN'\n        }))\n      }\n    }\n\n    return callback[kPromise]\n  }\n\n  _close (callback) {\n    this.nextTick(callback)\n  }\n\n  [kHandleClose] () {\n    this[kClosed] = true\n    this.db.detachResource(this)\n\n    const callbacks = this[kCloseCallbacks]\n    this[kCloseCallbacks] = []\n\n    for (const cb of callbacks) {\n      cb()\n    }\n  }\n\n  async * [Symbol.asyncIterator] () {\n    try {\n      let item\n\n      while ((item = (await this.next())) !== undefined) {\n        yield item\n      }\n    } finally {\n      if (!this[kClosed]) await this.close()\n    }\n  }\n}\n\n// For backwards compatibility this class is not (yet) called AbstractEntryIterator.\nclass AbstractIterator extends CommonIterator {\n  constructor (db, options) {\n    super(db, options, true)\n    this[kKeys] = options.keys !== false\n    this[kValues] = options.values !== false\n  }\n\n  [kHandleOne] (err, key, value) {\n    const cb = this[kFinishWork]()\n    if (err) return cb(err)\n\n    try {\n      key = this[kKeys] && key !== undefined ? this[kKeyEncoding].decode(key) : undefined\n      value = this[kValues] && value !== undefined ? this[kValueEncoding].decode(value) : undefined\n    } catch (err) {\n      return cb(new IteratorDecodeError('entry', err))\n    }\n\n    if (!(key === undefined && value === undefined)) {\n      this[kCount]++\n    }\n\n    cb(null, key, value)\n  }\n\n  [kHandleMany] (err, entries) {\n    const cb = this[kFinishWork]()\n    if (err) return this[kReturnMany](cb, err)\n\n    try {\n      for (const entry of entries) {\n        const key = entry[0]\n        const value = entry[1]\n\n        entry[0] = this[kKeys] && key !== undefined ? this[kKeyEncoding].decode(key) : undefined\n        entry[1] = this[kValues] && value !== undefined ? this[kValueEncoding].decode(value) : undefined\n      }\n    } catch (err) {\n      return this[kReturnMany](cb, new IteratorDecodeError('entries', err))\n    }\n\n    this[kCount] += entries.length\n    this[kReturnMany](cb, null, entries)\n  }\n\n  end (callback) {\n    if (!warnedEnd && typeof console !== 'undefined') {\n      warnedEnd = true\n      console.warn(new ModuleError(\n        'The iterator.end() method was renamed to close() and end() is an alias that will be removed in a future version',\n        { code: 'LEVEL_LEGACY' }\n      ))\n    }\n\n    return this.close(callback)\n  }\n}\n\nclass AbstractKeyIterator extends CommonIterator {\n  constructor (db, options) {\n    super(db, options, false)\n  }\n\n  [kHandleOne] (err, key) {\n    const cb = this[kFinishWork]()\n    if (err) return cb(err)\n\n    try {\n      key = key !== undefined ? this[kKeyEncoding].decode(key) : undefined\n    } catch (err) {\n      return cb(new IteratorDecodeError('key', err))\n    }\n\n    if (key !== undefined) this[kCount]++\n    cb(null, key)\n  }\n\n  [kHandleMany] (err, keys) {\n    const cb = this[kFinishWork]()\n    if (err) return this[kReturnMany](cb, err)\n\n    try {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i]\n        keys[i] = key !== undefined ? this[kKeyEncoding].decode(key) : undefined\n      }\n    } catch (err) {\n      return this[kReturnMany](cb, new IteratorDecodeError('keys', err))\n    }\n\n    this[kCount] += keys.length\n    this[kReturnMany](cb, null, keys)\n  }\n}\n\nclass AbstractValueIterator extends CommonIterator {\n  constructor (db, options) {\n    super(db, options, false)\n  }\n\n  [kHandleOne] (err, value) {\n    const cb = this[kFinishWork]()\n    if (err) return cb(err)\n\n    try {\n      value = value !== undefined ? this[kValueEncoding].decode(value) : undefined\n    } catch (err) {\n      return cb(new IteratorDecodeError('value', err))\n    }\n\n    if (value !== undefined) this[kCount]++\n    cb(null, value)\n  }\n\n  [kHandleMany] (err, values) {\n    const cb = this[kFinishWork]()\n    if (err) return this[kReturnMany](cb, err)\n\n    try {\n      for (let i = 0; i < values.length; i++) {\n        const value = values[i]\n        values[i] = value !== undefined ? this[kValueEncoding].decode(value) : undefined\n      }\n    } catch (err) {\n      return this[kReturnMany](cb, new IteratorDecodeError('values', err))\n    }\n\n    this[kCount] += values.length\n    this[kReturnMany](cb, null, values)\n  }\n}\n\n// Internal utility, not typed or exported\nclass IteratorDecodeError extends ModuleError {\n  constructor (subject, cause) {\n    super(`Iterator could not decode ${subject}`, {\n      code: 'LEVEL_DECODE_ERROR',\n      cause\n    })\n  }\n}\n\n// To help migrating to abstract-level\nfor (const k of ['_ended property', '_nexting property', '_end method']) {\n  Object.defineProperty(AbstractIterator.prototype, k.split(' ')[0], {\n    get () { throw new ModuleError(`The ${k} has been removed`, { code: 'LEVEL_LEGACY' }) },\n    set () { throw new ModuleError(`The ${k} has been removed`, { code: 'LEVEL_LEGACY' }) }\n  })\n}\n\n// Exposed so that AbstractLevel can set these options\nAbstractIterator.keyEncoding = kKeyEncoding\nAbstractIterator.valueEncoding = kValueEncoding\n\nexports.AbstractIterator = AbstractIterator\nexports.AbstractKeyIterator = AbstractKeyIterator\nexports.AbstractValueIterator = AbstractValueIterator\n","'use strict'\n\nconst { supports } = require('level-supports')\nconst { Transcoder } = require('level-transcoder')\nconst { EventEmitter } = require('events')\nconst { fromCallback } = require('catering')\nconst ModuleError = require('module-error')\nconst { AbstractIterator } = require('./abstract-iterator')\nconst { DefaultKeyIterator, DefaultValueIterator } = require('./lib/default-kv-iterator')\nconst { DeferredIterator, DeferredKeyIterator, DeferredValueIterator } = require('./lib/deferred-iterator')\nconst { DefaultChainedBatch } = require('./lib/default-chained-batch')\nconst { getCallback, getOptions } = require('./lib/common')\nconst rangeOptions = require('./lib/range-options')\n\nconst kPromise = Symbol('promise')\nconst kLanded = Symbol('landed')\nconst kResources = Symbol('resources')\nconst kCloseResources = Symbol('closeResources')\nconst kOperations = Symbol('operations')\nconst kUndefer = Symbol('undefer')\nconst kDeferOpen = Symbol('deferOpen')\nconst kOptions = Symbol('options')\nconst kStatus = Symbol('status')\nconst kDefaultOptions = Symbol('defaultOptions')\nconst kTranscoder = Symbol('transcoder')\nconst kKeyEncoding = Symbol('keyEncoding')\nconst kValueEncoding = Symbol('valueEncoding')\nconst noop = () => {}\n\nclass AbstractLevel extends EventEmitter {\n  constructor (manifest, options) {\n    super()\n\n    if (typeof manifest !== 'object' || manifest === null) {\n      throw new TypeError(\"The first argument 'manifest' must be an object\")\n    }\n\n    options = getOptions(options)\n    const { keyEncoding, valueEncoding, passive, ...forward } = options\n\n    this[kResources] = new Set()\n    this[kOperations] = []\n    this[kDeferOpen] = true\n    this[kOptions] = forward\n    this[kStatus] = 'opening'\n\n    this.supports = supports(manifest, {\n      status: true,\n      promises: true,\n      clear: true,\n      getMany: true,\n      deferredOpen: true,\n\n      // TODO (next major): add seek\n      snapshots: manifest.snapshots !== false,\n      permanence: manifest.permanence !== false,\n\n      // TODO: remove from level-supports because it's always supported\n      keyIterator: true,\n      valueIterator: true,\n      iteratorNextv: true,\n      iteratorAll: true,\n\n      encodings: manifest.encodings || {},\n      events: Object.assign({}, manifest.events, {\n        opening: true,\n        open: true,\n        closing: true,\n        closed: true,\n        put: true,\n        del: true,\n        batch: true,\n        clear: true\n      })\n    })\n\n    this[kTranscoder] = new Transcoder(formats(this))\n    this[kKeyEncoding] = this[kTranscoder].encoding(keyEncoding || 'utf8')\n    this[kValueEncoding] = this[kTranscoder].encoding(valueEncoding || 'utf8')\n\n    // Add custom and transcoder encodings to manifest\n    for (const encoding of this[kTranscoder].encodings()) {\n      if (!this.supports.encodings[encoding.commonName]) {\n        this.supports.encodings[encoding.commonName] = true\n      }\n    }\n\n    this[kDefaultOptions] = {\n      empty: Object.freeze({}),\n      entry: Object.freeze({\n        keyEncoding: this[kKeyEncoding].commonName,\n        valueEncoding: this[kValueEncoding].commonName\n      }),\n      key: Object.freeze({\n        keyEncoding: this[kKeyEncoding].commonName\n      })\n    }\n\n    // Let subclass finish its constructor\n    this.nextTick(() => {\n      if (this[kDeferOpen]) {\n        this.open({ passive: false }, noop)\n      }\n    })\n  }\n\n  get status () {\n    return this[kStatus]\n  }\n\n  keyEncoding (encoding) {\n    return this[kTranscoder].encoding(encoding != null ? encoding : this[kKeyEncoding])\n  }\n\n  valueEncoding (encoding) {\n    return this[kTranscoder].encoding(encoding != null ? encoding : this[kValueEncoding])\n  }\n\n  open (options, callback) {\n    callback = getCallback(options, callback)\n    callback = fromCallback(callback, kPromise)\n\n    options = { ...this[kOptions], ...getOptions(options) }\n\n    options.createIfMissing = options.createIfMissing !== false\n    options.errorIfExists = !!options.errorIfExists\n\n    const maybeOpened = (err) => {\n      if (this[kStatus] === 'closing' || this[kStatus] === 'opening') {\n        // Wait until pending state changes are done\n        this.once(kLanded, err ? () => maybeOpened(err) : maybeOpened)\n      } else if (this[kStatus] !== 'open') {\n        callback(new ModuleError('Database is not open', {\n          code: 'LEVEL_DATABASE_NOT_OPEN',\n          cause: err\n        }))\n      } else {\n        callback()\n      }\n    }\n\n    if (options.passive) {\n      if (this[kStatus] === 'opening') {\n        this.once(kLanded, maybeOpened)\n      } else {\n        this.nextTick(maybeOpened)\n      }\n    } else if (this[kStatus] === 'closed' || this[kDeferOpen]) {\n      this[kDeferOpen] = false\n      this[kStatus] = 'opening'\n      this.emit('opening')\n\n      this._open(options, (err) => {\n        if (err) {\n          this[kStatus] = 'closed'\n\n          // Resources must be safe to close in any db state\n          this[kCloseResources](() => {\n            this.emit(kLanded)\n            maybeOpened(err)\n          })\n\n          this[kUndefer]()\n          return\n        }\n\n        this[kStatus] = 'open'\n        this[kUndefer]()\n        this.emit(kLanded)\n\n        // Only emit public event if pending state changes are done\n        if (this[kStatus] === 'open') this.emit('open')\n\n        // TODO (next major): remove this alias\n        if (this[kStatus] === 'open') this.emit('ready')\n\n        maybeOpened()\n      })\n    } else if (this[kStatus] === 'open') {\n      this.nextTick(maybeOpened)\n    } else {\n      this.once(kLanded, () => this.open(options, callback))\n    }\n\n    return callback[kPromise]\n  }\n\n  _open (options, callback) {\n    this.nextTick(callback)\n  }\n\n  close (callback) {\n    callback = fromCallback(callback, kPromise)\n\n    const maybeClosed = (err) => {\n      if (this[kStatus] === 'opening' || this[kStatus] === 'closing') {\n        // Wait until pending state changes are done\n        this.once(kLanded, err ? maybeClosed(err) : maybeClosed)\n      } else if (this[kStatus] !== 'closed') {\n        callback(new ModuleError('Database is not closed', {\n          code: 'LEVEL_DATABASE_NOT_CLOSED',\n          cause: err\n        }))\n      } else {\n        callback()\n      }\n    }\n\n    if (this[kStatus] === 'open') {\n      this[kStatus] = 'closing'\n      this.emit('closing')\n\n      const cancel = (err) => {\n        this[kStatus] = 'open'\n        this[kUndefer]()\n        this.emit(kLanded)\n        maybeClosed(err)\n      }\n\n      this[kCloseResources](() => {\n        this._close((err) => {\n          if (err) return cancel(err)\n\n          this[kStatus] = 'closed'\n          this[kUndefer]()\n          this.emit(kLanded)\n\n          // Only emit public event if pending state changes are done\n          if (this[kStatus] === 'closed') this.emit('closed')\n\n          maybeClosed()\n        })\n      })\n    } else if (this[kStatus] === 'closed') {\n      this.nextTick(maybeClosed)\n    } else {\n      this.once(kLanded, () => this.close(callback))\n    }\n\n    return callback[kPromise]\n  }\n\n  [kCloseResources] (callback) {\n    if (this[kResources].size === 0) {\n      return this.nextTick(callback)\n    }\n\n    let pending = this[kResources].size\n    let sync = true\n\n    const next = () => {\n      if (--pending === 0) {\n        // We don't have tests for generic resources, so dezalgo\n        if (sync) this.nextTick(callback)\n        else callback()\n      }\n    }\n\n    // In parallel so that all resources know they are closed\n    for (const resource of this[kResources]) {\n      resource.close(next)\n    }\n\n    sync = false\n    this[kResources].clear()\n  }\n\n  _close (callback) {\n    this.nextTick(callback)\n  }\n\n  get (key, options, callback) {\n    callback = getCallback(options, callback)\n    callback = fromCallback(callback, kPromise)\n    options = getOptions(options, this[kDefaultOptions].entry)\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.get(key, options, callback))\n      return callback[kPromise]\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise]\n    }\n\n    const err = this._checkKey(key)\n\n    if (err) {\n      this.nextTick(callback, err)\n      return callback[kPromise]\n    }\n\n    const keyEncoding = this.keyEncoding(options.keyEncoding)\n    const valueEncoding = this.valueEncoding(options.valueEncoding)\n    const keyFormat = keyEncoding.format\n    const valueFormat = valueEncoding.format\n\n    // Forward encoding options to the underlying store\n    if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {\n      // Avoid spread operator because of https://bugs.chromium.org/p/chromium/issues/detail?id=1204540\n      options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat })\n    }\n\n    this._get(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err, value) => {\n      if (err) {\n        // Normalize not found error for backwards compatibility with abstract-leveldown and level(up)\n        if (err.code === 'LEVEL_NOT_FOUND' || err.notFound || /NotFound/i.test(err)) {\n          if (!err.code) err.code = 'LEVEL_NOT_FOUND' // Preferred way going forward\n          if (!err.notFound) err.notFound = true // Same as level-errors\n          if (!err.status) err.status = 404 // Same as level-errors\n        }\n\n        return callback(err)\n      }\n\n      try {\n        value = valueEncoding.decode(value)\n      } catch (err) {\n        return callback(new ModuleError('Could not decode value', {\n          code: 'LEVEL_DECODE_ERROR',\n          cause: err\n        }))\n      }\n\n      callback(null, value)\n    })\n\n    return callback[kPromise]\n  }\n\n  _get (key, options, callback) {\n    this.nextTick(callback, new Error('NotFound'))\n  }\n\n  getMany (keys, options, callback) {\n    callback = getCallback(options, callback)\n    callback = fromCallback(callback, kPromise)\n    options = getOptions(options, this[kDefaultOptions].entry)\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.getMany(keys, options, callback))\n      return callback[kPromise]\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise]\n    }\n\n    if (!Array.isArray(keys)) {\n      this.nextTick(callback, new TypeError(\"The first argument 'keys' must be an array\"))\n      return callback[kPromise]\n    }\n\n    if (keys.length === 0) {\n      this.nextTick(callback, null, [])\n      return callback[kPromise]\n    }\n\n    const keyEncoding = this.keyEncoding(options.keyEncoding)\n    const valueEncoding = this.valueEncoding(options.valueEncoding)\n    const keyFormat = keyEncoding.format\n    const valueFormat = valueEncoding.format\n\n    // Forward encoding options\n    if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {\n      options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat })\n    }\n\n    const mappedKeys = new Array(keys.length)\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i]\n      const err = this._checkKey(key)\n\n      if (err) {\n        this.nextTick(callback, err)\n        return callback[kPromise]\n      }\n\n      mappedKeys[i] = this.prefixKey(keyEncoding.encode(key), keyFormat)\n    }\n\n    this._getMany(mappedKeys, options, (err, values) => {\n      if (err) return callback(err)\n\n      try {\n        for (let i = 0; i < values.length; i++) {\n          if (values[i] !== undefined) {\n            values[i] = valueEncoding.decode(values[i])\n          }\n        }\n      } catch (err) {\n        return callback(new ModuleError(`Could not decode one or more of ${values.length} value(s)`, {\n          code: 'LEVEL_DECODE_ERROR',\n          cause: err\n        }))\n      }\n\n      callback(null, values)\n    })\n\n    return callback[kPromise]\n  }\n\n  _getMany (keys, options, callback) {\n    this.nextTick(callback, null, new Array(keys.length).fill(undefined))\n  }\n\n  put (key, value, options, callback) {\n    callback = getCallback(options, callback)\n    callback = fromCallback(callback, kPromise)\n    options = getOptions(options, this[kDefaultOptions].entry)\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.put(key, value, options, callback))\n      return callback[kPromise]\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise]\n    }\n\n    const err = this._checkKey(key) || this._checkValue(value)\n\n    if (err) {\n      this.nextTick(callback, err)\n      return callback[kPromise]\n    }\n\n    const keyEncoding = this.keyEncoding(options.keyEncoding)\n    const valueEncoding = this.valueEncoding(options.valueEncoding)\n    const keyFormat = keyEncoding.format\n    const valueFormat = valueEncoding.format\n\n    // Forward encoding options\n    if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {\n      options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat })\n    }\n\n    const mappedKey = this.prefixKey(keyEncoding.encode(key), keyFormat)\n    const mappedValue = valueEncoding.encode(value)\n\n    this._put(mappedKey, mappedValue, options, (err) => {\n      if (err) return callback(err)\n      this.emit('put', key, value)\n      callback()\n    })\n\n    return callback[kPromise]\n  }\n\n  _put (key, value, options, callback) {\n    this.nextTick(callback)\n  }\n\n  del (key, options, callback) {\n    callback = getCallback(options, callback)\n    callback = fromCallback(callback, kPromise)\n    options = getOptions(options, this[kDefaultOptions].key)\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.del(key, options, callback))\n      return callback[kPromise]\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise]\n    }\n\n    const err = this._checkKey(key)\n\n    if (err) {\n      this.nextTick(callback, err)\n      return callback[kPromise]\n    }\n\n    const keyEncoding = this.keyEncoding(options.keyEncoding)\n    const keyFormat = keyEncoding.format\n\n    // Forward encoding options\n    if (options.keyEncoding !== keyFormat) {\n      options = Object.assign({}, options, { keyEncoding: keyFormat })\n    }\n\n    this._del(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err) => {\n      if (err) return callback(err)\n      this.emit('del', key)\n      callback()\n    })\n\n    return callback[kPromise]\n  }\n\n  _del (key, options, callback) {\n    this.nextTick(callback)\n  }\n\n  batch (operations, options, callback) {\n    if (!arguments.length) {\n      if (this[kStatus] === 'opening') return new DefaultChainedBatch(this)\n      if (this[kStatus] !== 'open') {\n        throw new ModuleError('Database is not open', {\n          code: 'LEVEL_DATABASE_NOT_OPEN'\n        })\n      }\n      return this._chainedBatch()\n    }\n\n    if (typeof operations === 'function') callback = operations\n    else callback = getCallback(options, callback)\n\n    callback = fromCallback(callback, kPromise)\n    options = getOptions(options, this[kDefaultOptions].empty)\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.batch(operations, options, callback))\n      return callback[kPromise]\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise]\n    }\n\n    if (!Array.isArray(operations)) {\n      this.nextTick(callback, new TypeError(\"The first argument 'operations' must be an array\"))\n      return callback[kPromise]\n    }\n\n    if (operations.length === 0) {\n      this.nextTick(callback)\n      return callback[kPromise]\n    }\n\n    const mapped = new Array(operations.length)\n    const { keyEncoding: ke, valueEncoding: ve, ...forward } = options\n\n    for (let i = 0; i < operations.length; i++) {\n      if (typeof operations[i] !== 'object' || operations[i] === null) {\n        this.nextTick(callback, new TypeError('A batch operation must be an object'))\n        return callback[kPromise]\n      }\n\n      const op = Object.assign({}, operations[i])\n\n      if (op.type !== 'put' && op.type !== 'del') {\n        this.nextTick(callback, new TypeError(\"A batch operation must have a type property that is 'put' or 'del'\"))\n        return callback[kPromise]\n      }\n\n      const err = this._checkKey(op.key)\n\n      if (err) {\n        this.nextTick(callback, err)\n        return callback[kPromise]\n      }\n\n      const db = op.sublevel != null ? op.sublevel : this\n      const keyEncoding = db.keyEncoding(op.keyEncoding || ke)\n      const keyFormat = keyEncoding.format\n\n      op.key = db.prefixKey(keyEncoding.encode(op.key), keyFormat)\n      op.keyEncoding = keyFormat\n\n      if (op.type === 'put') {\n        const valueErr = this._checkValue(op.value)\n\n        if (valueErr) {\n          this.nextTick(callback, valueErr)\n          return callback[kPromise]\n        }\n\n        const valueEncoding = db.valueEncoding(op.valueEncoding || ve)\n\n        op.value = valueEncoding.encode(op.value)\n        op.valueEncoding = valueEncoding.format\n      }\n\n      // Prevent double prefixing\n      if (db !== this) {\n        op.sublevel = null\n      }\n\n      mapped[i] = op\n    }\n\n    this._batch(mapped, forward, (err) => {\n      if (err) return callback(err)\n      this.emit('batch', operations)\n      callback()\n    })\n\n    return callback[kPromise]\n  }\n\n  _batch (operations, options, callback) {\n    this.nextTick(callback)\n  }\n\n  sublevel (name, options) {\n    return this._sublevel(name, AbstractSublevel.defaults(options))\n  }\n\n  _sublevel (name, options) {\n    return new AbstractSublevel(this, name, options)\n  }\n\n  prefixKey (key, keyFormat) {\n    return key\n  }\n\n  clear (options, callback) {\n    callback = getCallback(options, callback)\n    callback = fromCallback(callback, kPromise)\n    options = getOptions(options, this[kDefaultOptions].empty)\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.clear(options, callback))\n      return callback[kPromise]\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise]\n    }\n\n    const original = options\n    const keyEncoding = this.keyEncoding(options.keyEncoding)\n\n    options = rangeOptions(options, keyEncoding)\n    options.keyEncoding = keyEncoding.format\n\n    if (options.limit === 0) {\n      this.nextTick(callback)\n    } else {\n      this._clear(options, (err) => {\n        if (err) return callback(err)\n        this.emit('clear', original)\n        callback()\n      })\n    }\n\n    return callback[kPromise]\n  }\n\n  _clear (options, callback) {\n    this.nextTick(callback)\n  }\n\n  iterator (options) {\n    const keyEncoding = this.keyEncoding(options && options.keyEncoding)\n    const valueEncoding = this.valueEncoding(options && options.valueEncoding)\n\n    options = rangeOptions(options, keyEncoding)\n    options.keys = options.keys !== false\n    options.values = options.values !== false\n\n    // We need the original encoding options in AbstractIterator in order to decode data\n    options[AbstractIterator.keyEncoding] = keyEncoding\n    options[AbstractIterator.valueEncoding] = valueEncoding\n\n    // Forward encoding options to private API\n    options.keyEncoding = keyEncoding.format\n    options.valueEncoding = valueEncoding.format\n\n    if (this[kStatus] === 'opening') {\n      return new DeferredIterator(this, options)\n    } else if (this[kStatus] !== 'open') {\n      throw new ModuleError('Database is not open', {\n        code: 'LEVEL_DATABASE_NOT_OPEN'\n      })\n    }\n\n    return this._iterator(options)\n  }\n\n  _iterator (options) {\n    return new AbstractIterator(this, options)\n  }\n\n  keys (options) {\n    // Also include valueEncoding (though unused) because we may fallback to _iterator()\n    const keyEncoding = this.keyEncoding(options && options.keyEncoding)\n    const valueEncoding = this.valueEncoding(options && options.valueEncoding)\n\n    options = rangeOptions(options, keyEncoding)\n\n    // We need the original encoding options in AbstractKeyIterator in order to decode data\n    options[AbstractIterator.keyEncoding] = keyEncoding\n    options[AbstractIterator.valueEncoding] = valueEncoding\n\n    // Forward encoding options to private API\n    options.keyEncoding = keyEncoding.format\n    options.valueEncoding = valueEncoding.format\n\n    if (this[kStatus] === 'opening') {\n      return new DeferredKeyIterator(this, options)\n    } else if (this[kStatus] !== 'open') {\n      throw new ModuleError('Database is not open', {\n        code: 'LEVEL_DATABASE_NOT_OPEN'\n      })\n    }\n\n    return this._keys(options)\n  }\n\n  _keys (options) {\n    return new DefaultKeyIterator(this, options)\n  }\n\n  values (options) {\n    const keyEncoding = this.keyEncoding(options && options.keyEncoding)\n    const valueEncoding = this.valueEncoding(options && options.valueEncoding)\n\n    options = rangeOptions(options, keyEncoding)\n\n    // We need the original encoding options in AbstractValueIterator in order to decode data\n    options[AbstractIterator.keyEncoding] = keyEncoding\n    options[AbstractIterator.valueEncoding] = valueEncoding\n\n    // Forward encoding options to private API\n    options.keyEncoding = keyEncoding.format\n    options.valueEncoding = valueEncoding.format\n\n    if (this[kStatus] === 'opening') {\n      return new DeferredValueIterator(this, options)\n    } else if (this[kStatus] !== 'open') {\n      throw new ModuleError('Database is not open', {\n        code: 'LEVEL_DATABASE_NOT_OPEN'\n      })\n    }\n\n    return this._values(options)\n  }\n\n  _values (options) {\n    return new DefaultValueIterator(this, options)\n  }\n\n  defer (fn) {\n    if (typeof fn !== 'function') {\n      throw new TypeError('The first argument must be a function')\n    }\n\n    this[kOperations].push(fn)\n  }\n\n  [kUndefer] () {\n    if (this[kOperations].length === 0) {\n      return\n    }\n\n    const operations = this[kOperations]\n    this[kOperations] = []\n\n    for (const op of operations) {\n      op()\n    }\n  }\n\n  // TODO: docs and types\n  attachResource (resource) {\n    if (typeof resource !== 'object' || resource === null ||\n      typeof resource.close !== 'function') {\n      throw new TypeError('The first argument must be a resource object')\n    }\n\n    this[kResources].add(resource)\n  }\n\n  // TODO: docs and types\n  detachResource (resource) {\n    this[kResources].delete(resource)\n  }\n\n  _chainedBatch () {\n    return new DefaultChainedBatch(this)\n  }\n\n  _checkKey (key) {\n    if (key === null || key === undefined) {\n      return new ModuleError('Key cannot be null or undefined', {\n        code: 'LEVEL_INVALID_KEY'\n      })\n    }\n  }\n\n  _checkValue (value) {\n    if (value === null || value === undefined) {\n      return new ModuleError('Value cannot be null or undefined', {\n        code: 'LEVEL_INVALID_VALUE'\n      })\n    }\n  }\n}\n\n// Expose browser-compatible nextTick for dependents\n// TODO: after we drop node 10, also use queueMicrotask in node\nAbstractLevel.prototype.nextTick = require('./lib/next-tick')\n\nconst { AbstractSublevel } = require('./lib/abstract-sublevel')({ AbstractLevel })\n\nexports.AbstractLevel = AbstractLevel\nexports.AbstractSublevel = AbstractSublevel\n\nconst maybeError = function (db, callback) {\n  if (db[kStatus] !== 'open') {\n    db.nextTick(callback, new ModuleError('Database is not open', {\n      code: 'LEVEL_DATABASE_NOT_OPEN'\n    }))\n    return true\n  }\n\n  return false\n}\n\nconst formats = function (db) {\n  return Object.keys(db.supports.encodings)\n    .filter(k => !!db.supports.encodings[k])\n}\n","'use strict'\n\nexports.AbstractLevel = require('./abstract-level').AbstractLevel\nexports.AbstractSublevel = require('./abstract-level').AbstractSublevel\nexports.AbstractIterator = require('./abstract-iterator').AbstractIterator\nexports.AbstractKeyIterator = require('./abstract-iterator').AbstractKeyIterator\nexports.AbstractValueIterator = require('./abstract-iterator').AbstractValueIterator\nexports.AbstractChainedBatch = require('./abstract-chained-batch').AbstractChainedBatch\n","'use strict'\n\nconst { AbstractIterator, AbstractKeyIterator, AbstractValueIterator } = require('../abstract-iterator')\n\nconst kUnfix = Symbol('unfix')\nconst kIterator = Symbol('iterator')\nconst kHandleOne = Symbol('handleOne')\nconst kHandleMany = Symbol('handleMany')\nconst kCallback = Symbol('callback')\n\n// TODO: unfix natively if db supports it\nclass AbstractSublevelIterator extends AbstractIterator {\n  constructor (db, options, iterator, unfix) {\n    super(db, options)\n\n    this[kIterator] = iterator\n    this[kUnfix] = unfix\n    this[kHandleOne] = this[kHandleOne].bind(this)\n    this[kHandleMany] = this[kHandleMany].bind(this)\n    this[kCallback] = null\n  }\n\n  [kHandleOne] (err, key, value) {\n    const callback = this[kCallback]\n    if (err) return callback(err)\n    if (key !== undefined) key = this[kUnfix](key)\n    callback(err, key, value)\n  }\n\n  [kHandleMany] (err, entries) {\n    const callback = this[kCallback]\n    if (err) return callback(err)\n\n    for (const entry of entries) {\n      const key = entry[0]\n      if (key !== undefined) entry[0] = this[kUnfix](key)\n    }\n\n    callback(err, entries)\n  }\n}\n\nclass AbstractSublevelKeyIterator extends AbstractKeyIterator {\n  constructor (db, options, iterator, unfix) {\n    super(db, options)\n\n    this[kIterator] = iterator\n    this[kUnfix] = unfix\n    this[kHandleOne] = this[kHandleOne].bind(this)\n    this[kHandleMany] = this[kHandleMany].bind(this)\n    this[kCallback] = null\n  }\n\n  [kHandleOne] (err, key) {\n    const callback = this[kCallback]\n    if (err) return callback(err)\n    if (key !== undefined) key = this[kUnfix](key)\n    callback(err, key)\n  }\n\n  [kHandleMany] (err, keys) {\n    const callback = this[kCallback]\n    if (err) return callback(err)\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i]\n      if (key !== undefined) keys[i] = this[kUnfix](key)\n    }\n\n    callback(err, keys)\n  }\n}\n\nclass AbstractSublevelValueIterator extends AbstractValueIterator {\n  constructor (db, options, iterator) {\n    super(db, options)\n    this[kIterator] = iterator\n  }\n}\n\nfor (const Iterator of [AbstractSublevelIterator, AbstractSublevelKeyIterator]) {\n  Iterator.prototype._next = function (callback) {\n    this[kCallback] = callback\n    this[kIterator].next(this[kHandleOne])\n  }\n\n  Iterator.prototype._nextv = function (size, options, callback) {\n    this[kCallback] = callback\n    this[kIterator].nextv(size, options, this[kHandleMany])\n  }\n\n  Iterator.prototype._all = function (options, callback) {\n    this[kCallback] = callback\n    this[kIterator].all(options, this[kHandleMany])\n  }\n}\n\nfor (const Iterator of [AbstractSublevelValueIterator]) {\n  Iterator.prototype._next = function (callback) {\n    this[kIterator].next(callback)\n  }\n\n  Iterator.prototype._nextv = function (size, options, callback) {\n    this[kIterator].nextv(size, options, callback)\n  }\n\n  Iterator.prototype._all = function (options, callback) {\n    this[kIterator].all(options, callback)\n  }\n}\n\nfor (const Iterator of [AbstractSublevelIterator, AbstractSublevelKeyIterator, AbstractSublevelValueIterator]) {\n  Iterator.prototype._seek = function (target, options) {\n    this[kIterator].seek(target, options)\n  }\n\n  Iterator.prototype._close = function (callback) {\n    this[kIterator].close(callback)\n  }\n}\n\nexports.AbstractSublevelIterator = AbstractSublevelIterator\nexports.AbstractSublevelKeyIterator = AbstractSublevelKeyIterator\nexports.AbstractSublevelValueIterator = AbstractSublevelValueIterator\n","'use strict'\n\nconst ModuleError = require('module-error')\nconst { Buffer } = require('buffer') || {}\nconst {\n  AbstractSublevelIterator,\n  AbstractSublevelKeyIterator,\n  AbstractSublevelValueIterator\n} = require('./abstract-sublevel-iterator')\n\nconst kPrefix = Symbol('prefix')\nconst kUpperBound = Symbol('upperBound')\nconst kPrefixRange = Symbol('prefixRange')\nconst kParent = Symbol('parent')\nconst kUnfix = Symbol('unfix')\n\nconst textEncoder = new TextEncoder()\nconst defaults = { separator: '!' }\n\n// Wrapped to avoid circular dependency\nmodule.exports = function ({ AbstractLevel }) {\n  class AbstractSublevel extends AbstractLevel {\n    static defaults (options) {\n      // To help migrating from subleveldown to abstract-level\n      if (typeof options === 'string') {\n        throw new ModuleError('The subleveldown string shorthand for { separator } has been removed', {\n          code: 'LEVEL_LEGACY'\n        })\n      } else if (options && options.open) {\n        throw new ModuleError('The subleveldown open option has been removed', {\n          code: 'LEVEL_LEGACY'\n        })\n      }\n\n      if (options == null) {\n        return defaults\n      } else if (!options.separator) {\n        return { ...options, separator: '!' }\n      } else {\n        return options\n      }\n    }\n\n    // TODO: add autoClose option, which if true, does parent.attachResource(this)\n    constructor (db, name, options) {\n      // Don't forward AbstractSublevel options to AbstractLevel\n      const { separator, manifest, ...forward } = AbstractSublevel.defaults(options)\n      name = trim(name, separator)\n\n      // Reserve one character between separator and name to give us an upper bound\n      const reserved = separator.charCodeAt(0) + 1\n      const parent = db[kParent] || db\n\n      // Keys should sort like ['!a!', '!a!!a!', '!a\"', '!aa!', '!b!'].\n      // Use ASCII for consistent length between string, Buffer and Uint8Array\n      if (!textEncoder.encode(name).every(x => x > reserved && x < 127)) {\n        throw new ModuleError(`Prefix must use bytes > ${reserved} < ${127}`, {\n          code: 'LEVEL_INVALID_PREFIX'\n        })\n      }\n\n      super(mergeManifests(parent, manifest), forward)\n\n      const prefix = (db.prefix || '') + separator + name + separator\n      const upperBound = prefix.slice(0, -1) + String.fromCharCode(reserved)\n\n      this[kParent] = parent\n      this[kPrefix] = new MultiFormat(prefix)\n      this[kUpperBound] = new MultiFormat(upperBound)\n      this[kUnfix] = new Unfixer()\n\n      this.nextTick = parent.nextTick\n    }\n\n    prefixKey (key, keyFormat) {\n      if (keyFormat === 'utf8') {\n        return this[kPrefix].utf8 + key\n      } else if (key.byteLength === 0) {\n        // Fast path for empty key (no copy)\n        return this[kPrefix][keyFormat]\n      } else if (keyFormat === 'view') {\n        const view = this[kPrefix].view\n        const result = new Uint8Array(view.byteLength + key.byteLength)\n\n        result.set(view, 0)\n        result.set(key, view.byteLength)\n\n        return result\n      } else {\n        const buffer = this[kPrefix].buffer\n        return Buffer.concat([buffer, key], buffer.byteLength + key.byteLength)\n      }\n    }\n\n    // Not exposed for now.\n    [kPrefixRange] (range, keyFormat) {\n      if (range.gte !== undefined) {\n        range.gte = this.prefixKey(range.gte, keyFormat)\n      } else if (range.gt !== undefined) {\n        range.gt = this.prefixKey(range.gt, keyFormat)\n      } else {\n        range.gte = this[kPrefix][keyFormat]\n      }\n\n      if (range.lte !== undefined) {\n        range.lte = this.prefixKey(range.lte, keyFormat)\n      } else if (range.lt !== undefined) {\n        range.lt = this.prefixKey(range.lt, keyFormat)\n      } else {\n        range.lte = this[kUpperBound][keyFormat]\n      }\n    }\n\n    get prefix () {\n      return this[kPrefix].utf8\n    }\n\n    get db () {\n      return this[kParent]\n    }\n\n    _open (options, callback) {\n      // The parent db must open itself or be (re)opened by the user because\n      // a sublevel should not initiate state changes on the rest of the db.\n      this[kParent].open({ passive: true }, callback)\n    }\n\n    _put (key, value, options, callback) {\n      this[kParent].put(key, value, options, callback)\n    }\n\n    _get (key, options, callback) {\n      this[kParent].get(key, options, callback)\n    }\n\n    _getMany (keys, options, callback) {\n      this[kParent].getMany(keys, options, callback)\n    }\n\n    _del (key, options, callback) {\n      this[kParent].del(key, options, callback)\n    }\n\n    _batch (operations, options, callback) {\n      this[kParent].batch(operations, options, callback)\n    }\n\n    _clear (options, callback) {\n      // TODO (refactor): move to AbstractLevel\n      this[kPrefixRange](options, options.keyEncoding)\n      this[kParent].clear(options, callback)\n    }\n\n    _iterator (options) {\n      // TODO (refactor): move to AbstractLevel\n      this[kPrefixRange](options, options.keyEncoding)\n      const iterator = this[kParent].iterator(options)\n      const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding)\n      return new AbstractSublevelIterator(this, options, iterator, unfix)\n    }\n\n    _keys (options) {\n      this[kPrefixRange](options, options.keyEncoding)\n      const iterator = this[kParent].keys(options)\n      const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding)\n      return new AbstractSublevelKeyIterator(this, options, iterator, unfix)\n    }\n\n    _values (options) {\n      this[kPrefixRange](options, options.keyEncoding)\n      const iterator = this[kParent].values(options)\n      return new AbstractSublevelValueIterator(this, options, iterator)\n    }\n  }\n\n  return { AbstractSublevel }\n}\n\nconst mergeManifests = function (parent, manifest) {\n  return {\n    // Inherit manifest of parent db\n    ...parent.supports,\n\n    // Disable unsupported features\n    createIfMissing: false,\n    errorIfExists: false,\n\n    // Unset additional events because we're not forwarding them\n    events: {},\n\n    // Unset additional methods (like approximateSize) which we can't support here unless\n    // the AbstractSublevel class is overridden by an implementation of `abstract-level`.\n    additionalMethods: {},\n\n    // Inherit manifest of custom AbstractSublevel subclass. Such a class is not\n    // allowed to override encodings.\n    ...manifest,\n\n    encodings: {\n      utf8: supportsEncoding(parent, 'utf8'),\n      buffer: supportsEncoding(parent, 'buffer'),\n      view: supportsEncoding(parent, 'view')\n    }\n  }\n}\n\nconst supportsEncoding = function (parent, encoding) {\n  // Prefer a non-transcoded encoding for optimal performance\n  return parent.supports.encodings[encoding]\n    ? parent.keyEncoding(encoding).name === encoding\n    : false\n}\n\nclass MultiFormat {\n  constructor (key) {\n    this.utf8 = key\n    this.view = textEncoder.encode(key)\n    this.buffer = Buffer ? Buffer.from(this.view.buffer, 0, this.view.byteLength) : {}\n  }\n}\n\nclass Unfixer {\n  constructor () {\n    this.cache = new Map()\n  }\n\n  get (prefixLength, keyFormat) {\n    let unfix = this.cache.get(keyFormat)\n\n    if (unfix === undefined) {\n      if (keyFormat === 'view') {\n        unfix = function (prefixLength, key) {\n          // Avoid Uint8Array#slice() because it copies\n          return key.subarray(prefixLength)\n        }.bind(null, prefixLength)\n      } else {\n        unfix = function (prefixLength, key) {\n          // Avoid Buffer#subarray() because it's slow\n          return key.slice(prefixLength)\n        }.bind(null, prefixLength)\n      }\n\n      this.cache.set(keyFormat, unfix)\n    }\n\n    return unfix\n  }\n}\n\nconst trim = function (str, char) {\n  let start = 0\n  let end = str.length\n\n  while (start < end && str[start] === char) start++\n  while (end > start && str[end - 1] === char) end--\n\n  return str.slice(start, end)\n}\n","'use strict'\n\nexports.getCallback = function (options, callback) {\n  return typeof options === 'function' ? options : callback\n}\n\nexports.getOptions = function (options, def) {\n  if (typeof options === 'object' && options !== null) {\n    return options\n  }\n\n  if (def !== undefined) {\n    return def\n  }\n\n  return {}\n}\n","'use strict'\n\nconst { AbstractChainedBatch } = require('../abstract-chained-batch')\nconst ModuleError = require('module-error')\nconst kEncoded = Symbol('encoded')\n\n// Functional default for chained batch, with support of deferred open\nclass DefaultChainedBatch extends AbstractChainedBatch {\n  constructor (db) {\n    super(db)\n    this[kEncoded] = []\n  }\n\n  _put (key, value, options) {\n    this[kEncoded].push({ ...options, type: 'put', key, value })\n  }\n\n  _del (key, options) {\n    this[kEncoded].push({ ...options, type: 'del', key })\n  }\n\n  _clear () {\n    this[kEncoded] = []\n  }\n\n  // Assumes this[kEncoded] cannot change after write()\n  _write (options, callback) {\n    if (this.db.status === 'opening') {\n      this.db.defer(() => this._write(options, callback))\n    } else if (this.db.status === 'open') {\n      if (this[kEncoded].length === 0) this.nextTick(callback)\n      else this.db._batch(this[kEncoded], options, callback)\n    } else {\n      this.nextTick(callback, new ModuleError('Batch is not open: cannot call write() after write() or close()', {\n        code: 'LEVEL_BATCH_NOT_OPEN'\n      }))\n    }\n  }\n}\n\nexports.DefaultChainedBatch = DefaultChainedBatch\n","'use strict'\n\nconst { AbstractKeyIterator, AbstractValueIterator } = require('../abstract-iterator')\n\nconst kIterator = Symbol('iterator')\nconst kCallback = Symbol('callback')\nconst kHandleOne = Symbol('handleOne')\nconst kHandleMany = Symbol('handleMany')\n\nclass DefaultKeyIterator extends AbstractKeyIterator {\n  constructor (db, options) {\n    super(db, options)\n\n    this[kIterator] = db.iterator({ ...options, keys: true, values: false })\n    this[kHandleOne] = this[kHandleOne].bind(this)\n    this[kHandleMany] = this[kHandleMany].bind(this)\n  }\n}\n\nclass DefaultValueIterator extends AbstractValueIterator {\n  constructor (db, options) {\n    super(db, options)\n\n    this[kIterator] = db.iterator({ ...options, keys: false, values: true })\n    this[kHandleOne] = this[kHandleOne].bind(this)\n    this[kHandleMany] = this[kHandleMany].bind(this)\n  }\n}\n\nfor (const Iterator of [DefaultKeyIterator, DefaultValueIterator]) {\n  const keys = Iterator === DefaultKeyIterator\n  const mapEntry = keys ? (entry) => entry[0] : (entry) => entry[1]\n\n  Iterator.prototype._next = function (callback) {\n    this[kCallback] = callback\n    this[kIterator].next(this[kHandleOne])\n  }\n\n  Iterator.prototype[kHandleOne] = function (err, key, value) {\n    const callback = this[kCallback]\n    if (err) callback(err)\n    else callback(null, keys ? key : value)\n  }\n\n  Iterator.prototype._nextv = function (size, options, callback) {\n    this[kCallback] = callback\n    this[kIterator].nextv(size, options, this[kHandleMany])\n  }\n\n  Iterator.prototype._all = function (options, callback) {\n    this[kCallback] = callback\n    this[kIterator].all(options, this[kHandleMany])\n  }\n\n  Iterator.prototype[kHandleMany] = function (err, entries) {\n    const callback = this[kCallback]\n    if (err) callback(err)\n    else callback(null, entries.map(mapEntry))\n  }\n\n  Iterator.prototype._seek = function (target, options) {\n    this[kIterator].seek(target, options)\n  }\n\n  Iterator.prototype._close = function (callback) {\n    this[kIterator].close(callback)\n  }\n}\n\n// Internal utilities, should be typed as AbstractKeyIterator and AbstractValueIterator\nexports.DefaultKeyIterator = DefaultKeyIterator\nexports.DefaultValueIterator = DefaultValueIterator\n","'use strict'\n\nconst { AbstractIterator, AbstractKeyIterator, AbstractValueIterator } = require('../abstract-iterator')\nconst ModuleError = require('module-error')\n\nconst kNut = Symbol('nut')\nconst kUndefer = Symbol('undefer')\nconst kFactory = Symbol('factory')\n\nclass DeferredIterator extends AbstractIterator {\n  constructor (db, options) {\n    super(db, options)\n\n    this[kNut] = null\n    this[kFactory] = () => db.iterator(options)\n\n    this.db.defer(() => this[kUndefer]())\n  }\n}\n\nclass DeferredKeyIterator extends AbstractKeyIterator {\n  constructor (db, options) {\n    super(db, options)\n\n    this[kNut] = null\n    this[kFactory] = () => db.keys(options)\n\n    this.db.defer(() => this[kUndefer]())\n  }\n}\n\nclass DeferredValueIterator extends AbstractValueIterator {\n  constructor (db, options) {\n    super(db, options)\n\n    this[kNut] = null\n    this[kFactory] = () => db.values(options)\n\n    this.db.defer(() => this[kUndefer]())\n  }\n}\n\nfor (const Iterator of [DeferredIterator, DeferredKeyIterator, DeferredValueIterator]) {\n  Iterator.prototype[kUndefer] = function () {\n    if (this.db.status === 'open') {\n      this[kNut] = this[kFactory]()\n    }\n  }\n\n  Iterator.prototype._next = function (callback) {\n    if (this[kNut] !== null) {\n      this[kNut].next(callback)\n    } else if (this.db.status === 'opening') {\n      this.db.defer(() => this._next(callback))\n    } else {\n      this.nextTick(callback, new ModuleError('Iterator is not open: cannot call next() after close()', {\n        code: 'LEVEL_ITERATOR_NOT_OPEN'\n      }))\n    }\n  }\n\n  Iterator.prototype._nextv = function (size, options, callback) {\n    if (this[kNut] !== null) {\n      this[kNut].nextv(size, options, callback)\n    } else if (this.db.status === 'opening') {\n      this.db.defer(() => this._nextv(size, options, callback))\n    } else {\n      this.nextTick(callback, new ModuleError('Iterator is not open: cannot call nextv() after close()', {\n        code: 'LEVEL_ITERATOR_NOT_OPEN'\n      }))\n    }\n  }\n\n  Iterator.prototype._all = function (options, callback) {\n    if (this[kNut] !== null) {\n      this[kNut].all(callback)\n    } else if (this.db.status === 'opening') {\n      this.db.defer(() => this._all(options, callback))\n    } else {\n      this.nextTick(callback, new ModuleError('Iterator is not open: cannot call all() after close()', {\n        code: 'LEVEL_ITERATOR_NOT_OPEN'\n      }))\n    }\n  }\n\n  Iterator.prototype._seek = function (target, options) {\n    if (this[kNut] !== null) {\n      // TODO: explain why we need _seek() rather than seek() here\n      this[kNut]._seek(target, options)\n    } else if (this.db.status === 'opening') {\n      this.db.defer(() => this._seek(target, options))\n    }\n  }\n\n  Iterator.prototype._close = function (callback) {\n    if (this[kNut] !== null) {\n      this[kNut].close(callback)\n    } else if (this.db.status === 'opening') {\n      this.db.defer(() => this._close(callback))\n    } else {\n      this.nextTick(callback)\n    }\n  }\n}\n\nexports.DeferredIterator = DeferredIterator\nexports.DeferredKeyIterator = DeferredKeyIterator\nexports.DeferredValueIterator = DeferredValueIterator\n","'use strict'\n\nconst queueMicrotask = require('queue-microtask')\n\nmodule.exports = function (fn, ...args) {\n  if (args.length === 0) {\n    queueMicrotask(fn)\n  } else {\n    queueMicrotask(() => fn(...args))\n  }\n}\n","'use strict'\n\nconst ModuleError = require('module-error')\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nconst rangeOptions = new Set(['lt', 'lte', 'gt', 'gte'])\n\nmodule.exports = function (options, keyEncoding) {\n  const result = {}\n\n  for (const k in options) {\n    if (!hasOwnProperty.call(options, k)) continue\n    if (k === 'keyEncoding' || k === 'valueEncoding') continue\n\n    if (k === 'start' || k === 'end') {\n      throw new ModuleError(`The legacy range option '${k}' has been removed`, {\n        code: 'LEVEL_LEGACY'\n      })\n    } else if (k === 'encoding') {\n      // To help migrating to abstract-level\n      throw new ModuleError(\"The levelup-style 'encoding' alias has been removed, use 'valueEncoding' instead\", {\n        code: 'LEVEL_LEGACY'\n      })\n    }\n\n    if (rangeOptions.has(k)) {\n      // Note that we don't reject nullish and empty options here. While\n      // those types are invalid as keys, they are valid as range options.\n      result[k] = keyEncoding.encode(options[k])\n    } else {\n      result[k] = options[k]\n    }\n  }\n\n  result.reverse = !!result.reverse\n  result.limit = Number.isInteger(result.limit) && result.limit >= 0 ? result.limit : -1\n\n  return result\n}\n","/*!\n * Copyright (c) 2014, GMO GlobalSign\n * Copyright (c) 2015-2022, Peculiar Ventures\n * All rights reserved.\n * \n * Author 2014-2019, Yury Strozhevsky\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n * \n * * Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n * \n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n */\n\nimport * as pvtsutils from 'pvtsutils';\nimport * as pvutils from 'pvutils';\n\nfunction assertBigInt() {\r\n    if (typeof BigInt === \"undefined\") {\r\n        throw new Error(\"BigInt is not defined. Your environment doesn't implement BigInt.\");\r\n    }\r\n}\r\nfunction concat(buffers) {\r\n    let outputLength = 0;\r\n    let prevLength = 0;\r\n    for (let i = 0; i < buffers.length; i++) {\r\n        const buffer = buffers[i];\r\n        outputLength += buffer.byteLength;\r\n    }\r\n    const retView = new Uint8Array(outputLength);\r\n    for (let i = 0; i < buffers.length; i++) {\r\n        const buffer = buffers[i];\r\n        retView.set(new Uint8Array(buffer), prevLength);\r\n        prevLength += buffer.byteLength;\r\n    }\r\n    return retView.buffer;\r\n}\r\nfunction checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {\r\n    if (!(inputBuffer instanceof Uint8Array)) {\r\n        baseBlock.error = \"Wrong parameter: inputBuffer must be 'Uint8Array'\";\r\n        return false;\r\n    }\r\n    if (!inputBuffer.byteLength) {\r\n        baseBlock.error = \"Wrong parameter: inputBuffer has zero length\";\r\n        return false;\r\n    }\r\n    if (inputOffset < 0) {\r\n        baseBlock.error = \"Wrong parameter: inputOffset less than zero\";\r\n        return false;\r\n    }\r\n    if (inputLength < 0) {\r\n        baseBlock.error = \"Wrong parameter: inputLength less than zero\";\r\n        return false;\r\n    }\r\n    if ((inputBuffer.byteLength - inputOffset - inputLength) < 0) {\r\n        baseBlock.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\r\n        return false;\r\n    }\r\n    return true;\r\n}\n\nclass ViewWriter {\r\n    constructor() {\r\n        this.items = [];\r\n    }\r\n    write(buf) {\r\n        this.items.push(buf);\r\n    }\r\n    final() {\r\n        return concat(this.items);\r\n    }\r\n}\n\nconst powers2 = [new Uint8Array([1])];\r\nconst digitsString = \"0123456789\";\r\nconst NAME = \"name\";\r\nconst VALUE_HEX_VIEW = \"valueHexView\";\r\nconst IS_HEX_ONLY = \"isHexOnly\";\r\nconst ID_BLOCK = \"idBlock\";\r\nconst TAG_CLASS = \"tagClass\";\r\nconst TAG_NUMBER = \"tagNumber\";\r\nconst IS_CONSTRUCTED = \"isConstructed\";\r\nconst FROM_BER = \"fromBER\";\r\nconst TO_BER = \"toBER\";\r\nconst LOCAL = \"local\";\r\nconst EMPTY_STRING = \"\";\r\nconst EMPTY_BUFFER = new ArrayBuffer(0);\r\nconst EMPTY_VIEW = new Uint8Array(0);\r\nconst END_OF_CONTENT_NAME = \"EndOfContent\";\r\nconst OCTET_STRING_NAME = \"OCTET STRING\";\r\nconst BIT_STRING_NAME = \"BIT STRING\";\n\nfunction HexBlock(BaseClass) {\r\n    var _a;\r\n    return _a = class Some extends BaseClass {\r\n            constructor(...args) {\r\n                var _a;\r\n                super(...args);\r\n                const params = args[0] || {};\r\n                this.isHexOnly = (_a = params.isHexOnly) !== null && _a !== void 0 ? _a : false;\r\n                this.valueHexView = params.valueHex ? pvtsutils.BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;\r\n            }\r\n            get valueHex() {\r\n                return this.valueHexView.slice().buffer;\r\n            }\r\n            set valueHex(value) {\r\n                this.valueHexView = new Uint8Array(value);\r\n            }\r\n            fromBER(inputBuffer, inputOffset, inputLength) {\r\n                const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;\r\n                if (!checkBufferParams(this, view, inputOffset, inputLength)) {\r\n                    return -1;\r\n                }\r\n                const endLength = inputOffset + inputLength;\r\n                this.valueHexView = view.subarray(inputOffset, endLength);\r\n                if (!this.valueHexView.length) {\r\n                    this.warnings.push(\"Zero buffer length\");\r\n                    return inputOffset;\r\n                }\r\n                this.blockLength = inputLength;\r\n                return endLength;\r\n            }\r\n            toBER(sizeOnly = false) {\r\n                if (!this.isHexOnly) {\r\n                    this.error = \"Flag 'isHexOnly' is not set, abort\";\r\n                    return EMPTY_BUFFER;\r\n                }\r\n                if (sizeOnly) {\r\n                    return new ArrayBuffer(this.valueHexView.byteLength);\r\n                }\r\n                return (this.valueHexView.byteLength === this.valueHexView.buffer.byteLength)\r\n                    ? this.valueHexView.buffer\r\n                    : this.valueHexView.slice().buffer;\r\n            }\r\n            toJSON() {\r\n                return {\r\n                    ...super.toJSON(),\r\n                    isHexOnly: this.isHexOnly,\r\n                    valueHex: pvtsutils.Convert.ToHex(this.valueHexView),\r\n                };\r\n            }\r\n        },\r\n        _a.NAME = \"hexBlock\",\r\n        _a;\r\n}\n\nclass LocalBaseBlock {\r\n    constructor({ blockLength = 0, error = EMPTY_STRING, warnings = [], valueBeforeDecode = EMPTY_VIEW, } = {}) {\r\n        this.blockLength = blockLength;\r\n        this.error = error;\r\n        this.warnings = warnings;\r\n        this.valueBeforeDecodeView = pvtsutils.BufferSourceConverter.toUint8Array(valueBeforeDecode);\r\n    }\r\n    static blockName() {\r\n        return this.NAME;\r\n    }\r\n    get valueBeforeDecode() {\r\n        return this.valueBeforeDecodeView.slice().buffer;\r\n    }\r\n    set valueBeforeDecode(value) {\r\n        this.valueBeforeDecodeView = new Uint8Array(value);\r\n    }\r\n    toJSON() {\r\n        return {\r\n            blockName: this.constructor.NAME,\r\n            blockLength: this.blockLength,\r\n            error: this.error,\r\n            warnings: this.warnings,\r\n            valueBeforeDecode: pvtsutils.Convert.ToHex(this.valueBeforeDecodeView),\r\n        };\r\n    }\r\n}\r\nLocalBaseBlock.NAME = \"baseBlock\";\n\nclass ValueBlock extends LocalBaseBlock {\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        throw TypeError(\"User need to make a specific function in a class which extends 'ValueBlock'\");\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        throw TypeError(\"User need to make a specific function in a class which extends 'ValueBlock'\");\r\n    }\r\n}\r\nValueBlock.NAME = \"valueBlock\";\n\nclass LocalIdentificationBlock extends HexBlock(LocalBaseBlock) {\r\n    constructor({ idBlock = {}, } = {}) {\r\n        var _a, _b, _c, _d;\r\n        super();\r\n        if (idBlock) {\r\n            this.isHexOnly = (_a = idBlock.isHexOnly) !== null && _a !== void 0 ? _a : false;\r\n            this.valueHexView = idBlock.valueHex ? pvtsutils.BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;\r\n            this.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;\r\n            this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;\r\n            this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;\r\n        }\r\n        else {\r\n            this.tagClass = -1;\r\n            this.tagNumber = -1;\r\n            this.isConstructed = false;\r\n        }\r\n    }\r\n    toBER(sizeOnly = false) {\r\n        let firstOctet = 0;\r\n        switch (this.tagClass) {\r\n            case 1:\r\n                firstOctet |= 0x00;\r\n                break;\r\n            case 2:\r\n                firstOctet |= 0x40;\r\n                break;\r\n            case 3:\r\n                firstOctet |= 0x80;\r\n                break;\r\n            case 4:\r\n                firstOctet |= 0xC0;\r\n                break;\r\n            default:\r\n                this.error = \"Unknown tag class\";\r\n                return EMPTY_BUFFER;\r\n        }\r\n        if (this.isConstructed)\r\n            firstOctet |= 0x20;\r\n        if (this.tagNumber < 31 && !this.isHexOnly) {\r\n            const retView = new Uint8Array(1);\r\n            if (!sizeOnly) {\r\n                let number = this.tagNumber;\r\n                number &= 0x1F;\r\n                firstOctet |= number;\r\n                retView[0] = firstOctet;\r\n            }\r\n            return retView.buffer;\r\n        }\r\n        if (!this.isHexOnly) {\r\n            const encodedBuf = pvutils.utilToBase(this.tagNumber, 7);\r\n            const encodedView = new Uint8Array(encodedBuf);\r\n            const size = encodedBuf.byteLength;\r\n            const retView = new Uint8Array(size + 1);\r\n            retView[0] = (firstOctet | 0x1F);\r\n            if (!sizeOnly) {\r\n                for (let i = 0; i < (size - 1); i++)\r\n                    retView[i + 1] = encodedView[i] | 0x80;\r\n                retView[size] = encodedView[size - 1];\r\n            }\r\n            return retView.buffer;\r\n        }\r\n        const retView = new Uint8Array(this.valueHexView.byteLength + 1);\r\n        retView[0] = (firstOctet | 0x1F);\r\n        if (!sizeOnly) {\r\n            const curView = this.valueHexView;\r\n            for (let i = 0; i < (curView.length - 1); i++)\r\n                retView[i + 1] = curView[i] | 0x80;\r\n            retView[this.valueHexView.byteLength] = curView[curView.length - 1];\r\n        }\r\n        return retView.buffer;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        if (intBuffer.length === 0) {\r\n            this.error = \"Zero buffer length\";\r\n            return -1;\r\n        }\r\n        const tagClassMask = intBuffer[0] & 0xC0;\r\n        switch (tagClassMask) {\r\n            case 0x00:\r\n                this.tagClass = (1);\r\n                break;\r\n            case 0x40:\r\n                this.tagClass = (2);\r\n                break;\r\n            case 0x80:\r\n                this.tagClass = (3);\r\n                break;\r\n            case 0xC0:\r\n                this.tagClass = (4);\r\n                break;\r\n            default:\r\n                this.error = \"Unknown tag class\";\r\n                return -1;\r\n        }\r\n        this.isConstructed = (intBuffer[0] & 0x20) === 0x20;\r\n        this.isHexOnly = false;\r\n        const tagNumberMask = intBuffer[0] & 0x1F;\r\n        if (tagNumberMask !== 0x1F) {\r\n            this.tagNumber = (tagNumberMask);\r\n            this.blockLength = 1;\r\n        }\r\n        else {\r\n            let count = 1;\r\n            let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);\r\n            let tagNumberBufferMaxLength = 255;\r\n            while (intBuffer[count] & 0x80) {\r\n                intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\r\n                count++;\r\n                if (count >= intBuffer.length) {\r\n                    this.error = \"End of input reached before message was fully decoded\";\r\n                    return -1;\r\n                }\r\n                if (count === tagNumberBufferMaxLength) {\r\n                    tagNumberBufferMaxLength += 255;\r\n                    const tempBufferView = new Uint8Array(tagNumberBufferMaxLength);\r\n                    for (let i = 0; i < intTagNumberBuffer.length; i++)\r\n                        tempBufferView[i] = intTagNumberBuffer[i];\r\n                    intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);\r\n                }\r\n            }\r\n            this.blockLength = (count + 1);\r\n            intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\r\n            const tempBufferView = new Uint8Array(count);\r\n            for (let i = 0; i < count; i++)\r\n                tempBufferView[i] = intTagNumberBuffer[i];\r\n            intTagNumberBuffer = this.valueHexView = new Uint8Array(count);\r\n            intTagNumberBuffer.set(tempBufferView);\r\n            if (this.blockLength <= 9)\r\n                this.tagNumber = pvutils.utilFromBase(intTagNumberBuffer, 7);\r\n            else {\r\n                this.isHexOnly = true;\r\n                this.warnings.push(\"Tag too long, represented as hex-coded\");\r\n            }\r\n        }\r\n        if (((this.tagClass === 1)) &&\r\n            (this.isConstructed)) {\r\n            switch (this.tagNumber) {\r\n                case 1:\r\n                case 2:\r\n                case 5:\r\n                case 6:\r\n                case 9:\r\n                case 13:\r\n                case 14:\r\n                case 23:\r\n                case 24:\r\n                case 31:\r\n                case 32:\r\n                case 33:\r\n                case 34:\r\n                    this.error = \"Constructed encoding used for primitive type\";\r\n                    return -1;\r\n            }\r\n        }\r\n        return (inputOffset + this.blockLength);\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            tagClass: this.tagClass,\r\n            tagNumber: this.tagNumber,\r\n            isConstructed: this.isConstructed,\r\n        };\r\n    }\r\n}\r\nLocalIdentificationBlock.NAME = \"identificationBlock\";\n\nclass LocalLengthBlock extends LocalBaseBlock {\r\n    constructor({ lenBlock = {}, } = {}) {\r\n        var _a, _b, _c;\r\n        super();\r\n        this.isIndefiniteForm = (_a = lenBlock.isIndefiniteForm) !== null && _a !== void 0 ? _a : false;\r\n        this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;\r\n        this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const view = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, view, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);\r\n        if (intBuffer.length === 0) {\r\n            this.error = \"Zero buffer length\";\r\n            return -1;\r\n        }\r\n        if (intBuffer[0] === 0xFF) {\r\n            this.error = \"Length block 0xFF is reserved by standard\";\r\n            return -1;\r\n        }\r\n        this.isIndefiniteForm = intBuffer[0] === 0x80;\r\n        if (this.isIndefiniteForm) {\r\n            this.blockLength = 1;\r\n            return (inputOffset + this.blockLength);\r\n        }\r\n        this.longFormUsed = !!(intBuffer[0] & 0x80);\r\n        if (this.longFormUsed === false) {\r\n            this.length = (intBuffer[0]);\r\n            this.blockLength = 1;\r\n            return (inputOffset + this.blockLength);\r\n        }\r\n        const count = intBuffer[0] & 0x7F;\r\n        if (count > 8) {\r\n            this.error = \"Too big integer\";\r\n            return -1;\r\n        }\r\n        if ((count + 1) > intBuffer.length) {\r\n            this.error = \"End of input reached before message was fully decoded\";\r\n            return -1;\r\n        }\r\n        const lenOffset = inputOffset + 1;\r\n        const lengthBufferView = view.subarray(lenOffset, lenOffset + count);\r\n        if (lengthBufferView[count - 1] === 0x00)\r\n            this.warnings.push(\"Needlessly long encoded length\");\r\n        this.length = pvutils.utilFromBase(lengthBufferView, 8);\r\n        if (this.longFormUsed && (this.length <= 127))\r\n            this.warnings.push(\"Unnecessary usage of long length form\");\r\n        this.blockLength = count + 1;\r\n        return (inputOffset + this.blockLength);\r\n    }\r\n    toBER(sizeOnly = false) {\r\n        let retBuf;\r\n        let retView;\r\n        if (this.length > 127)\r\n            this.longFormUsed = true;\r\n        if (this.isIndefiniteForm) {\r\n            retBuf = new ArrayBuffer(1);\r\n            if (sizeOnly === false) {\r\n                retView = new Uint8Array(retBuf);\r\n                retView[0] = 0x80;\r\n            }\r\n            return retBuf;\r\n        }\r\n        if (this.longFormUsed) {\r\n            const encodedBuf = pvutils.utilToBase(this.length, 8);\r\n            if (encodedBuf.byteLength > 127) {\r\n                this.error = \"Too big length\";\r\n                return (EMPTY_BUFFER);\r\n            }\r\n            retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);\r\n            if (sizeOnly)\r\n                return retBuf;\r\n            const encodedView = new Uint8Array(encodedBuf);\r\n            retView = new Uint8Array(retBuf);\r\n            retView[0] = encodedBuf.byteLength | 0x80;\r\n            for (let i = 0; i < encodedBuf.byteLength; i++)\r\n                retView[i + 1] = encodedView[i];\r\n            return retBuf;\r\n        }\r\n        retBuf = new ArrayBuffer(1);\r\n        if (sizeOnly === false) {\r\n            retView = new Uint8Array(retBuf);\r\n            retView[0] = this.length;\r\n        }\r\n        return retBuf;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            isIndefiniteForm: this.isIndefiniteForm,\r\n            longFormUsed: this.longFormUsed,\r\n            length: this.length,\r\n        };\r\n    }\r\n}\r\nLocalLengthBlock.NAME = \"lengthBlock\";\n\nconst typeStore = {};\n\nclass BaseBlock extends LocalBaseBlock {\r\n    constructor({ name = EMPTY_STRING, optional = false, primitiveSchema, ...parameters } = {}, valueBlockType) {\r\n        super(parameters);\r\n        this.name = name;\r\n        this.optional = optional;\r\n        if (primitiveSchema) {\r\n            this.primitiveSchema = primitiveSchema;\r\n        }\r\n        this.idBlock = new LocalIdentificationBlock(parameters);\r\n        this.lenBlock = new LocalLengthBlock(parameters);\r\n        this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm) ? inputLength : this.lenBlock.length);\r\n        if (resultOffset === -1) {\r\n            this.error = this.valueBlock.error;\r\n            return resultOffset;\r\n        }\r\n        if (!this.idBlock.error.length)\r\n            this.blockLength += this.idBlock.blockLength;\r\n        if (!this.lenBlock.error.length)\r\n            this.blockLength += this.lenBlock.blockLength;\r\n        if (!this.valueBlock.error.length)\r\n            this.blockLength += this.valueBlock.blockLength;\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        const _writer = writer || new ViewWriter();\r\n        if (!writer) {\r\n            prepareIndefiniteForm(this);\r\n        }\r\n        const idBlockBuf = this.idBlock.toBER(sizeOnly);\r\n        _writer.write(idBlockBuf);\r\n        if (this.lenBlock.isIndefiniteForm) {\r\n            _writer.write(new Uint8Array([0x80]).buffer);\r\n            this.valueBlock.toBER(sizeOnly, _writer);\r\n            _writer.write(new ArrayBuffer(2));\r\n        }\r\n        else {\r\n            const valueBlockBuf = this.valueBlock.toBER(sizeOnly);\r\n            this.lenBlock.length = valueBlockBuf.byteLength;\r\n            const lenBlockBuf = this.lenBlock.toBER(sizeOnly);\r\n            _writer.write(lenBlockBuf);\r\n            _writer.write(valueBlockBuf);\r\n        }\r\n        if (!writer) {\r\n            return _writer.final();\r\n        }\r\n        return EMPTY_BUFFER;\r\n    }\r\n    toJSON() {\r\n        const object = {\r\n            ...super.toJSON(),\r\n            idBlock: this.idBlock.toJSON(),\r\n            lenBlock: this.lenBlock.toJSON(),\r\n            valueBlock: this.valueBlock.toJSON(),\r\n            name: this.name,\r\n            optional: this.optional,\r\n        };\r\n        if (this.primitiveSchema)\r\n            object.primitiveSchema = this.primitiveSchema.toJSON();\r\n        return object;\r\n    }\r\n    toString(encoding = \"ascii\") {\r\n        if (encoding === \"ascii\") {\r\n            return this.onAsciiEncoding();\r\n        }\r\n        return pvtsutils.Convert.ToHex(this.toBER());\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${pvtsutils.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`;\r\n    }\r\n    isEqual(other) {\r\n        if (this === other) {\r\n            return true;\r\n        }\r\n        if (!(other instanceof this.constructor)) {\r\n            return false;\r\n        }\r\n        const thisRaw = this.toBER();\r\n        const otherRaw = other.toBER();\r\n        return pvutils.isEqualBuffer(thisRaw, otherRaw);\r\n    }\r\n}\r\nBaseBlock.NAME = \"BaseBlock\";\r\nfunction prepareIndefiniteForm(baseBlock) {\r\n    if (baseBlock instanceof typeStore.Constructed) {\r\n        for (const value of baseBlock.valueBlock.value) {\r\n            if (prepareIndefiniteForm(value)) {\r\n                baseBlock.lenBlock.isIndefiniteForm = true;\r\n            }\r\n        }\r\n    }\r\n    return !!baseBlock.lenBlock.isIndefiniteForm;\r\n}\n\nclass BaseStringBlock extends BaseBlock {\r\n    constructor({ value = EMPTY_STRING, ...parameters } = {}, stringValueBlockType) {\r\n        super(parameters, stringValueBlockType);\r\n        if (value) {\r\n            this.fromString(value);\r\n        }\r\n    }\r\n    getValue() {\r\n        return this.valueBlock.value;\r\n    }\r\n    setValue(value) {\r\n        this.valueBlock.value = value;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm) ? inputLength : this.lenBlock.length);\r\n        if (resultOffset === -1) {\r\n            this.error = this.valueBlock.error;\r\n            return resultOffset;\r\n        }\r\n        this.fromBuffer(this.valueBlock.valueHexView);\r\n        if (!this.idBlock.error.length)\r\n            this.blockLength += this.idBlock.blockLength;\r\n        if (!this.lenBlock.error.length)\r\n            this.blockLength += this.lenBlock.blockLength;\r\n        if (!this.valueBlock.error.length)\r\n            this.blockLength += this.valueBlock.blockLength;\r\n        return resultOffset;\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : '${this.valueBlock.value}'`;\r\n    }\r\n}\r\nBaseStringBlock.NAME = \"BaseStringBlock\";\n\nclass LocalPrimitiveValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ isHexOnly = true, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.isHexOnly = isHexOnly;\r\n    }\r\n}\r\nLocalPrimitiveValueBlock.NAME = \"PrimitiveValueBlock\";\n\nvar _a$w;\r\nclass Primitive extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalPrimitiveValueBlock);\r\n        this.idBlock.isConstructed = false;\r\n    }\r\n}\r\n_a$w = Primitive;\r\n(() => {\r\n    typeStore.Primitive = _a$w;\r\n})();\r\nPrimitive.NAME = \"PRIMITIVE\";\n\nfunction localChangeType(inputObject, newType) {\r\n    if (inputObject instanceof newType) {\r\n        return inputObject;\r\n    }\r\n    const newObject = new newType();\r\n    newObject.idBlock = inputObject.idBlock;\r\n    newObject.lenBlock = inputObject.lenBlock;\r\n    newObject.warnings = inputObject.warnings;\r\n    newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;\r\n    return newObject;\r\n}\r\nfunction localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {\r\n    const incomingOffset = inputOffset;\r\n    let returnObject = new BaseBlock({}, ValueBlock);\r\n    const baseBlock = new LocalBaseBlock();\r\n    if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {\r\n        returnObject.error = baseBlock.error;\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);\r\n    if (!intBuffer.length) {\r\n        returnObject.error = \"Zero buffer length\";\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);\r\n    if (returnObject.idBlock.warnings.length) {\r\n        returnObject.warnings.concat(returnObject.idBlock.warnings);\r\n    }\r\n    if (resultOffset === -1) {\r\n        returnObject.error = returnObject.idBlock.error;\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    inputOffset = resultOffset;\r\n    inputLength -= returnObject.idBlock.blockLength;\r\n    resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);\r\n    if (returnObject.lenBlock.warnings.length) {\r\n        returnObject.warnings.concat(returnObject.lenBlock.warnings);\r\n    }\r\n    if (resultOffset === -1) {\r\n        returnObject.error = returnObject.lenBlock.error;\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    inputOffset = resultOffset;\r\n    inputLength -= returnObject.lenBlock.blockLength;\r\n    if (!returnObject.idBlock.isConstructed &&\r\n        returnObject.lenBlock.isIndefiniteForm) {\r\n        returnObject.error = \"Indefinite length form used for primitive encoding form\";\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    let newASN1Type = BaseBlock;\r\n    switch (returnObject.idBlock.tagClass) {\r\n        case 1:\r\n            if ((returnObject.idBlock.tagNumber >= 37) &&\r\n                (returnObject.idBlock.isHexOnly === false)) {\r\n                returnObject.error = \"UNIVERSAL 37 and upper tags are reserved by ASN.1 standard\";\r\n                return {\r\n                    offset: -1,\r\n                    result: returnObject\r\n                };\r\n            }\r\n            switch (returnObject.idBlock.tagNumber) {\r\n                case 0:\r\n                    if ((returnObject.idBlock.isConstructed) &&\r\n                        (returnObject.lenBlock.length > 0)) {\r\n                        returnObject.error = \"Type [UNIVERSAL 0] is reserved\";\r\n                        return {\r\n                            offset: -1,\r\n                            result: returnObject\r\n                        };\r\n                    }\r\n                    newASN1Type = typeStore.EndOfContent;\r\n                    break;\r\n                case 1:\r\n                    newASN1Type = typeStore.Boolean;\r\n                    break;\r\n                case 2:\r\n                    newASN1Type = typeStore.Integer;\r\n                    break;\r\n                case 3:\r\n                    newASN1Type = typeStore.BitString;\r\n                    break;\r\n                case 4:\r\n                    newASN1Type = typeStore.OctetString;\r\n                    break;\r\n                case 5:\r\n                    newASN1Type = typeStore.Null;\r\n                    break;\r\n                case 6:\r\n                    newASN1Type = typeStore.ObjectIdentifier;\r\n                    break;\r\n                case 10:\r\n                    newASN1Type = typeStore.Enumerated;\r\n                    break;\r\n                case 12:\r\n                    newASN1Type = typeStore.Utf8String;\r\n                    break;\r\n                case 13:\r\n                    newASN1Type = typeStore.RelativeObjectIdentifier;\r\n                    break;\r\n                case 14:\r\n                    newASN1Type = typeStore.TIME;\r\n                    break;\r\n                case 15:\r\n                    returnObject.error = \"[UNIVERSAL 15] is reserved by ASN.1 standard\";\r\n                    return {\r\n                        offset: -1,\r\n                        result: returnObject\r\n                    };\r\n                case 16:\r\n                    newASN1Type = typeStore.Sequence;\r\n                    break;\r\n                case 17:\r\n                    newASN1Type = typeStore.Set;\r\n                    break;\r\n                case 18:\r\n                    newASN1Type = typeStore.NumericString;\r\n                    break;\r\n                case 19:\r\n                    newASN1Type = typeStore.PrintableString;\r\n                    break;\r\n                case 20:\r\n                    newASN1Type = typeStore.TeletexString;\r\n                    break;\r\n                case 21:\r\n                    newASN1Type = typeStore.VideotexString;\r\n                    break;\r\n                case 22:\r\n                    newASN1Type = typeStore.IA5String;\r\n                    break;\r\n                case 23:\r\n                    newASN1Type = typeStore.UTCTime;\r\n                    break;\r\n                case 24:\r\n                    newASN1Type = typeStore.GeneralizedTime;\r\n                    break;\r\n                case 25:\r\n                    newASN1Type = typeStore.GraphicString;\r\n                    break;\r\n                case 26:\r\n                    newASN1Type = typeStore.VisibleString;\r\n                    break;\r\n                case 27:\r\n                    newASN1Type = typeStore.GeneralString;\r\n                    break;\r\n                case 28:\r\n                    newASN1Type = typeStore.UniversalString;\r\n                    break;\r\n                case 29:\r\n                    newASN1Type = typeStore.CharacterString;\r\n                    break;\r\n                case 30:\r\n                    newASN1Type = typeStore.BmpString;\r\n                    break;\r\n                case 31:\r\n                    newASN1Type = typeStore.DATE;\r\n                    break;\r\n                case 32:\r\n                    newASN1Type = typeStore.TimeOfDay;\r\n                    break;\r\n                case 33:\r\n                    newASN1Type = typeStore.DateTime;\r\n                    break;\r\n                case 34:\r\n                    newASN1Type = typeStore.Duration;\r\n                    break;\r\n                default: {\r\n                    const newObject = returnObject.idBlock.isConstructed\r\n                        ? new typeStore.Constructed()\r\n                        : new typeStore.Primitive();\r\n                    newObject.idBlock = returnObject.idBlock;\r\n                    newObject.lenBlock = returnObject.lenBlock;\r\n                    newObject.warnings = returnObject.warnings;\r\n                    returnObject = newObject;\r\n                }\r\n            }\r\n            break;\r\n        case 2:\r\n        case 3:\r\n        case 4:\r\n        default: {\r\n            newASN1Type = returnObject.idBlock.isConstructed\r\n                ? typeStore.Constructed\r\n                : typeStore.Primitive;\r\n        }\r\n    }\r\n    returnObject = localChangeType(returnObject, newASN1Type);\r\n    resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);\r\n    returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);\r\n    return {\r\n        offset: resultOffset,\r\n        result: returnObject\r\n    };\r\n}\r\nfunction fromBER(inputBuffer) {\r\n    if (!inputBuffer.byteLength) {\r\n        const result = new BaseBlock({}, ValueBlock);\r\n        result.error = \"Input buffer has zero length\";\r\n        return {\r\n            offset: -1,\r\n            result\r\n        };\r\n    }\r\n    return localFromBER(pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);\r\n}\n\nfunction checkLen(indefiniteLength, length) {\r\n    if (indefiniteLength) {\r\n        return 1;\r\n    }\r\n    return length;\r\n}\r\nclass LocalConstructedValueBlock extends ValueBlock {\r\n    constructor({ value = [], isIndefiniteForm = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = value;\r\n        this.isIndefiniteForm = isIndefiniteForm;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const view = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, view, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);\r\n        if (this.valueBeforeDecodeView.length === 0) {\r\n            this.warnings.push(\"Zero buffer length\");\r\n            return inputOffset;\r\n        }\r\n        let currentOffset = inputOffset;\r\n        while (checkLen(this.isIndefiniteForm, inputLength) > 0) {\r\n            const returnObject = localFromBER(view, currentOffset, inputLength);\r\n            if (returnObject.offset === -1) {\r\n                this.error = returnObject.result.error;\r\n                this.warnings.concat(returnObject.result.warnings);\r\n                return -1;\r\n            }\r\n            currentOffset = returnObject.offset;\r\n            this.blockLength += returnObject.result.blockLength;\r\n            inputLength -= returnObject.result.blockLength;\r\n            this.value.push(returnObject.result);\r\n            if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {\r\n                break;\r\n            }\r\n        }\r\n        if (this.isIndefiniteForm) {\r\n            if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {\r\n                this.value.pop();\r\n            }\r\n            else {\r\n                this.warnings.push(\"No EndOfContent block encoded\");\r\n            }\r\n        }\r\n        return currentOffset;\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        const _writer = writer || new ViewWriter();\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            this.value[i].toBER(sizeOnly, _writer);\r\n        }\r\n        if (!writer) {\r\n            return _writer.final();\r\n        }\r\n        return EMPTY_BUFFER;\r\n    }\r\n    toJSON() {\r\n        const object = {\r\n            ...super.toJSON(),\r\n            isIndefiniteForm: this.isIndefiniteForm,\r\n            value: [],\r\n        };\r\n        for (const value of this.value) {\r\n            object.value.push(value.toJSON());\r\n        }\r\n        return object;\r\n    }\r\n}\r\nLocalConstructedValueBlock.NAME = \"ConstructedValueBlock\";\n\nvar _a$v;\r\nclass Constructed extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalConstructedValueBlock);\r\n        this.idBlock.isConstructed = true;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\r\n        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm) ? inputLength : this.lenBlock.length);\r\n        if (resultOffset === -1) {\r\n            this.error = this.valueBlock.error;\r\n            return resultOffset;\r\n        }\r\n        if (!this.idBlock.error.length)\r\n            this.blockLength += this.idBlock.blockLength;\r\n        if (!this.lenBlock.error.length)\r\n            this.blockLength += this.lenBlock.blockLength;\r\n        if (!this.valueBlock.error.length)\r\n            this.blockLength += this.valueBlock.blockLength;\r\n        return resultOffset;\r\n    }\r\n    onAsciiEncoding() {\r\n        const values = [];\r\n        for (const value of this.valueBlock.value) {\r\n            values.push(value.toString(\"ascii\").split(\"\\n\").map(o => `  ${o}`).join(\"\\n\"));\r\n        }\r\n        const blockName = this.idBlock.tagClass === 3\r\n            ? `[${this.idBlock.tagNumber}]`\r\n            : this.constructor.NAME;\r\n        return values.length\r\n            ? `${blockName} :\\n${values.join(\"\\n\")}`\r\n            : `${blockName} :`;\r\n    }\r\n}\r\n_a$v = Constructed;\r\n(() => {\r\n    typeStore.Constructed = _a$v;\r\n})();\r\nConstructed.NAME = \"CONSTRUCTED\";\n\nclass LocalEndOfContentValueBlock extends ValueBlock {\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        return inputOffset;\r\n    }\r\n    toBER(sizeOnly) {\r\n        return EMPTY_BUFFER;\r\n    }\r\n}\r\nLocalEndOfContentValueBlock.override = \"EndOfContentValueBlock\";\n\nvar _a$u;\r\nclass EndOfContent extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalEndOfContentValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 0;\r\n    }\r\n}\r\n_a$u = EndOfContent;\r\n(() => {\r\n    typeStore.EndOfContent = _a$u;\r\n})();\r\nEndOfContent.NAME = END_OF_CONTENT_NAME;\n\nvar _a$t;\r\nclass Null extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, ValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 5;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        if (this.lenBlock.length > 0)\r\n            this.warnings.push(\"Non-zero length of value block for Null type\");\r\n        if (!this.idBlock.error.length)\r\n            this.blockLength += this.idBlock.blockLength;\r\n        if (!this.lenBlock.error.length)\r\n            this.blockLength += this.lenBlock.blockLength;\r\n        this.blockLength += inputLength;\r\n        if ((inputOffset + inputLength) > inputBuffer.byteLength) {\r\n            this.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\r\n            return -1;\r\n        }\r\n        return (inputOffset + inputLength);\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        const retBuf = new ArrayBuffer(2);\r\n        if (!sizeOnly) {\r\n            const retView = new Uint8Array(retBuf);\r\n            retView[0] = 0x05;\r\n            retView[1] = 0x00;\r\n        }\r\n        if (writer) {\r\n            writer.write(retBuf);\r\n        }\r\n        return retBuf;\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME}`;\r\n    }\r\n}\r\n_a$t = Null;\r\n(() => {\r\n    typeStore.Null = _a$t;\r\n})();\r\nNull.NAME = \"NULL\";\n\nclass LocalBooleanValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ value, ...parameters } = {}) {\r\n        super(parameters);\r\n        if (parameters.valueHex) {\r\n            this.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(parameters.valueHex);\r\n        }\r\n        else {\r\n            this.valueHexView = new Uint8Array(1);\r\n        }\r\n        if (value) {\r\n            this.value = value;\r\n        }\r\n    }\r\n    get value() {\r\n        for (const octet of this.valueHexView) {\r\n            if (octet > 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    set value(value) {\r\n        this.valueHexView[0] = value ? 0xFF : 0x00;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        if (inputLength > 1)\r\n            this.warnings.push(\"Boolean value encoded in more then 1 octet\");\r\n        this.isHexOnly = true;\r\n        pvutils.utilDecodeTC.call(this);\r\n        this.blockLength = inputLength;\r\n        return (inputOffset + inputLength);\r\n    }\r\n    toBER() {\r\n        return this.valueHexView.slice();\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            value: this.value,\r\n        };\r\n    }\r\n}\r\nLocalBooleanValueBlock.NAME = \"BooleanValueBlock\";\n\nvar _a$s;\r\nclass Boolean extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalBooleanValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 1;\r\n    }\r\n    getValue() {\r\n        return this.valueBlock.value;\r\n    }\r\n    setValue(value) {\r\n        this.valueBlock.value = value;\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.getValue}`;\r\n    }\r\n}\r\n_a$s = Boolean;\r\n(() => {\r\n    typeStore.Boolean = _a$s;\r\n})();\r\nBoolean.NAME = \"BOOLEAN\";\n\nclass LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\r\n    constructor({ isConstructed = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.isConstructed = isConstructed;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        let resultOffset = 0;\r\n        if (this.isConstructed) {\r\n            this.isHexOnly = false;\r\n            resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\r\n            if (resultOffset === -1)\r\n                return resultOffset;\r\n            for (let i = 0; i < this.value.length; i++) {\r\n                const currentBlockName = this.value[i].constructor.NAME;\r\n                if (currentBlockName === END_OF_CONTENT_NAME) {\r\n                    if (this.isIndefiniteForm)\r\n                        break;\r\n                    else {\r\n                        this.error = \"EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only\";\r\n                        return -1;\r\n                    }\r\n                }\r\n                if (currentBlockName !== OCTET_STRING_NAME) {\r\n                    this.error = \"OCTET STRING may consists of OCTET STRINGs only\";\r\n                    return -1;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this.isHexOnly = true;\r\n            resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\r\n            this.blockLength = inputLength;\r\n        }\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        if (this.isConstructed)\r\n            return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);\r\n        return sizeOnly\r\n            ? new ArrayBuffer(this.valueHexView.byteLength)\r\n            : this.valueHexView.slice().buffer;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            isConstructed: this.isConstructed,\r\n        };\r\n    }\r\n}\r\nLocalOctetStringValueBlock.NAME = \"OctetStringValueBlock\";\n\nvar _a$r;\r\nclass OctetString extends BaseBlock {\r\n    constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {\r\n        var _b, _c;\r\n        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : (parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length));\r\n        super({\r\n            idBlock: {\r\n                isConstructed: parameters.isConstructed,\r\n                ...idBlock,\r\n            },\r\n            lenBlock: {\r\n                ...lenBlock,\r\n                isIndefiniteForm: !!parameters.isIndefiniteForm,\r\n            },\r\n            ...parameters,\r\n        }, LocalOctetStringValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 4;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        this.valueBlock.isConstructed = this.idBlock.isConstructed;\r\n        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\r\n        if (inputLength === 0) {\r\n            if (this.idBlock.error.length === 0)\r\n                this.blockLength += this.idBlock.blockLength;\r\n            if (this.lenBlock.error.length === 0)\r\n                this.blockLength += this.lenBlock.blockLength;\r\n            return inputOffset;\r\n        }\r\n        if (!this.valueBlock.isConstructed) {\r\n            const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;\r\n            const buf = view.subarray(inputOffset, inputOffset + inputLength);\r\n            try {\r\n                if (buf.byteLength) {\r\n                    const asn = localFromBER(buf, 0, buf.byteLength);\r\n                    if (asn.offset !== -1 && asn.offset === inputLength) {\r\n                        this.valueBlock.value = [asn.result];\r\n                    }\r\n                }\r\n            }\r\n            catch (e) {\r\n            }\r\n        }\r\n        return super.fromBER(inputBuffer, inputOffset, inputLength);\r\n    }\r\n    onAsciiEncoding() {\r\n        if (this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length)) {\r\n            return Constructed.prototype.onAsciiEncoding.call(this);\r\n        }\r\n        return `${this.constructor.NAME} : ${pvtsutils.Convert.ToHex(this.valueBlock.valueHexView)}`;\r\n    }\r\n    getValue() {\r\n        if (!this.idBlock.isConstructed) {\r\n            return this.valueBlock.valueHexView.slice().buffer;\r\n        }\r\n        const array = [];\r\n        for (const content of this.valueBlock.value) {\r\n            if (content instanceof OctetString) {\r\n                array.push(content.valueBlock.valueHexView);\r\n            }\r\n        }\r\n        return pvtsutils.BufferSourceConverter.concat(array);\r\n    }\r\n}\r\n_a$r = OctetString;\r\n(() => {\r\n    typeStore.OctetString = _a$r;\r\n})();\r\nOctetString.NAME = OCTET_STRING_NAME;\n\nclass LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\r\n    constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.unusedBits = unusedBits;\r\n        this.isConstructed = isConstructed;\r\n        this.blockLength = this.valueHexView.byteLength;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        if (!inputLength) {\r\n            return inputOffset;\r\n        }\r\n        let resultOffset = -1;\r\n        if (this.isConstructed) {\r\n            resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\r\n            if (resultOffset === -1)\r\n                return resultOffset;\r\n            for (const value of this.value) {\r\n                const currentBlockName = value.constructor.NAME;\r\n                if (currentBlockName === END_OF_CONTENT_NAME) {\r\n                    if (this.isIndefiniteForm)\r\n                        break;\r\n                    else {\r\n                        this.error = \"EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only\";\r\n                        return -1;\r\n                    }\r\n                }\r\n                if (currentBlockName !== BIT_STRING_NAME) {\r\n                    this.error = \"BIT STRING may consists of BIT STRINGs only\";\r\n                    return -1;\r\n                }\r\n                const valueBlock = value.valueBlock;\r\n                if ((this.unusedBits > 0) && (valueBlock.unusedBits > 0)) {\r\n                    this.error = \"Using of \\\"unused bits\\\" inside constructive BIT STRING allowed for least one only\";\r\n                    return -1;\r\n                }\r\n                this.unusedBits = valueBlock.unusedBits;\r\n            }\r\n            return resultOffset;\r\n        }\r\n        const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        this.unusedBits = intBuffer[0];\r\n        if (this.unusedBits > 7) {\r\n            this.error = \"Unused bits for BitString must be in range 0-7\";\r\n            return -1;\r\n        }\r\n        if (!this.unusedBits) {\r\n            const buf = intBuffer.subarray(1);\r\n            try {\r\n                if (buf.byteLength) {\r\n                    const asn = localFromBER(buf, 0, buf.byteLength);\r\n                    if (asn.offset !== -1 && asn.offset === (inputLength - 1)) {\r\n                        this.value = [asn.result];\r\n                    }\r\n                }\r\n            }\r\n            catch (e) {\r\n            }\r\n        }\r\n        this.valueHexView = intBuffer.subarray(1);\r\n        this.blockLength = intBuffer.length;\r\n        return (inputOffset + inputLength);\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        if (this.isConstructed) {\r\n            return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);\r\n        }\r\n        if (sizeOnly) {\r\n            return new ArrayBuffer(this.valueHexView.byteLength + 1);\r\n        }\r\n        if (!this.valueHexView.byteLength) {\r\n            return EMPTY_BUFFER;\r\n        }\r\n        const retView = new Uint8Array(this.valueHexView.length + 1);\r\n        retView[0] = this.unusedBits;\r\n        retView.set(this.valueHexView, 1);\r\n        return retView.buffer;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            unusedBits: this.unusedBits,\r\n            isConstructed: this.isConstructed,\r\n        };\r\n    }\r\n}\r\nLocalBitStringValueBlock.NAME = \"BitStringValueBlock\";\n\nvar _a$q;\r\nclass BitString extends BaseBlock {\r\n    constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {\r\n        var _b, _c;\r\n        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : (parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length));\r\n        super({\r\n            idBlock: {\r\n                isConstructed: parameters.isConstructed,\r\n                ...idBlock,\r\n            },\r\n            lenBlock: {\r\n                ...lenBlock,\r\n                isIndefiniteForm: !!parameters.isIndefiniteForm,\r\n            },\r\n            ...parameters,\r\n        }, LocalBitStringValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 3;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        this.valueBlock.isConstructed = this.idBlock.isConstructed;\r\n        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\r\n        return super.fromBER(inputBuffer, inputOffset, inputLength);\r\n    }\r\n    onAsciiEncoding() {\r\n        if (this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length)) {\r\n            return Constructed.prototype.onAsciiEncoding.call(this);\r\n        }\r\n        else {\r\n            const bits = [];\r\n            const valueHex = this.valueBlock.valueHexView;\r\n            for (const byte of valueHex) {\r\n                bits.push(byte.toString(2).padStart(8, \"0\"));\r\n            }\r\n            const bitsStr = bits.join(\"\");\r\n            return `${this.constructor.NAME} : ${bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits)}`;\r\n        }\r\n    }\r\n}\r\n_a$q = BitString;\r\n(() => {\r\n    typeStore.BitString = _a$q;\r\n})();\r\nBitString.NAME = BIT_STRING_NAME;\n\nvar _a$p;\r\nfunction viewAdd(first, second) {\r\n    const c = new Uint8Array([0]);\r\n    const firstView = new Uint8Array(first);\r\n    const secondView = new Uint8Array(second);\r\n    let firstViewCopy = firstView.slice(0);\r\n    const firstViewCopyLength = firstViewCopy.length - 1;\r\n    const secondViewCopy = secondView.slice(0);\r\n    const secondViewCopyLength = secondViewCopy.length - 1;\r\n    let value = 0;\r\n    const max = (secondViewCopyLength < firstViewCopyLength) ? firstViewCopyLength : secondViewCopyLength;\r\n    let counter = 0;\r\n    for (let i = max; i >= 0; i--, counter++) {\r\n        switch (true) {\r\n            case (counter < secondViewCopy.length):\r\n                value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];\r\n                break;\r\n            default:\r\n                value = firstViewCopy[firstViewCopyLength - counter] + c[0];\r\n        }\r\n        c[0] = value / 10;\r\n        switch (true) {\r\n            case (counter >= firstViewCopy.length):\r\n                firstViewCopy = pvutils.utilConcatView(new Uint8Array([value % 10]), firstViewCopy);\r\n                break;\r\n            default:\r\n                firstViewCopy[firstViewCopyLength - counter] = value % 10;\r\n        }\r\n    }\r\n    if (c[0] > 0)\r\n        firstViewCopy = pvutils.utilConcatView(c, firstViewCopy);\r\n    return firstViewCopy;\r\n}\r\nfunction power2(n) {\r\n    if (n >= powers2.length) {\r\n        for (let p = powers2.length; p <= n; p++) {\r\n            const c = new Uint8Array([0]);\r\n            let digits = (powers2[p - 1]).slice(0);\r\n            for (let i = (digits.length - 1); i >= 0; i--) {\r\n                const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);\r\n                c[0] = newValue[0] / 10;\r\n                digits[i] = newValue[0] % 10;\r\n            }\r\n            if (c[0] > 0)\r\n                digits = pvutils.utilConcatView(c, digits);\r\n            powers2.push(digits);\r\n        }\r\n    }\r\n    return powers2[n];\r\n}\r\nfunction viewSub(first, second) {\r\n    let b = 0;\r\n    const firstView = new Uint8Array(first);\r\n    const secondView = new Uint8Array(second);\r\n    const firstViewCopy = firstView.slice(0);\r\n    const firstViewCopyLength = firstViewCopy.length - 1;\r\n    const secondViewCopy = secondView.slice(0);\r\n    const secondViewCopyLength = secondViewCopy.length - 1;\r\n    let value;\r\n    let counter = 0;\r\n    for (let i = secondViewCopyLength; i >= 0; i--, counter++) {\r\n        value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;\r\n        switch (true) {\r\n            case (value < 0):\r\n                b = 1;\r\n                firstViewCopy[firstViewCopyLength - counter] = value + 10;\r\n                break;\r\n            default:\r\n                b = 0;\r\n                firstViewCopy[firstViewCopyLength - counter] = value;\r\n        }\r\n    }\r\n    if (b > 0) {\r\n        for (let i = (firstViewCopyLength - secondViewCopyLength + 1); i >= 0; i--, counter++) {\r\n            value = firstViewCopy[firstViewCopyLength - counter] - b;\r\n            if (value < 0) {\r\n                b = 1;\r\n                firstViewCopy[firstViewCopyLength - counter] = value + 10;\r\n            }\r\n            else {\r\n                b = 0;\r\n                firstViewCopy[firstViewCopyLength - counter] = value;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return firstViewCopy.slice();\r\n}\r\nclass LocalIntegerValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ value, ...parameters } = {}) {\r\n        super(parameters);\r\n        this._valueDec = 0;\r\n        if (parameters.valueHex) {\r\n            this.setValueHex();\r\n        }\r\n        if (value !== undefined) {\r\n            this.valueDec = value;\r\n        }\r\n    }\r\n    setValueHex() {\r\n        if (this.valueHexView.length >= 4) {\r\n            this.warnings.push(\"Too big Integer for decoding, hex only\");\r\n            this.isHexOnly = true;\r\n            this._valueDec = 0;\r\n        }\r\n        else {\r\n            this.isHexOnly = false;\r\n            if (this.valueHexView.length > 0) {\r\n                this._valueDec = pvutils.utilDecodeTC.call(this);\r\n            }\r\n        }\r\n    }\r\n    set valueDec(v) {\r\n        this._valueDec = v;\r\n        this.isHexOnly = false;\r\n        this.valueHexView = new Uint8Array(pvutils.utilEncodeTC(v));\r\n    }\r\n    get valueDec() {\r\n        return this._valueDec;\r\n    }\r\n    fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {\r\n        const offset = this.fromBER(inputBuffer, inputOffset, inputLength);\r\n        if (offset === -1)\r\n            return offset;\r\n        const view = this.valueHexView;\r\n        if ((view[0] === 0x00) && ((view[1] & 0x80) !== 0)) {\r\n            this.valueHexView = view.subarray(1);\r\n        }\r\n        else {\r\n            if (expectedLength !== 0) {\r\n                if (view.length < expectedLength) {\r\n                    if ((expectedLength - view.length) > 1)\r\n                        expectedLength = view.length + 1;\r\n                    this.valueHexView = view.subarray(expectedLength - view.length);\r\n                }\r\n            }\r\n        }\r\n        return offset;\r\n    }\r\n    toDER(sizeOnly = false) {\r\n        const view = this.valueHexView;\r\n        switch (true) {\r\n            case ((view[0] & 0x80) !== 0):\r\n                {\r\n                    const updatedView = new Uint8Array(this.valueHexView.length + 1);\r\n                    updatedView[0] = 0x00;\r\n                    updatedView.set(view, 1);\r\n                    this.valueHexView = updatedView;\r\n                }\r\n                break;\r\n            case ((view[0] === 0x00) && ((view[1] & 0x80) === 0)):\r\n                {\r\n                    this.valueHexView = this.valueHexView.subarray(1);\r\n                }\r\n                break;\r\n        }\r\n        return this.toBER(sizeOnly);\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\r\n        if (resultOffset === -1) {\r\n            return resultOffset;\r\n        }\r\n        this.setValueHex();\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly) {\r\n        return sizeOnly\r\n            ? new ArrayBuffer(this.valueHexView.length)\r\n            : this.valueHexView.slice().buffer;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            valueDec: this.valueDec,\r\n        };\r\n    }\r\n    toString() {\r\n        const firstBit = (this.valueHexView.length * 8) - 1;\r\n        let digits = new Uint8Array((this.valueHexView.length * 8) / 3);\r\n        let bitNumber = 0;\r\n        let currentByte;\r\n        const asn1View = this.valueHexView;\r\n        let result = \"\";\r\n        let flag = false;\r\n        for (let byteNumber = (asn1View.byteLength - 1); byteNumber >= 0; byteNumber--) {\r\n            currentByte = asn1View[byteNumber];\r\n            for (let i = 0; i < 8; i++) {\r\n                if ((currentByte & 1) === 1) {\r\n                    switch (bitNumber) {\r\n                        case firstBit:\r\n                            digits = viewSub(power2(bitNumber), digits);\r\n                            result = \"-\";\r\n                            break;\r\n                        default:\r\n                            digits = viewAdd(digits, power2(bitNumber));\r\n                    }\r\n                }\r\n                bitNumber++;\r\n                currentByte >>= 1;\r\n            }\r\n        }\r\n        for (let i = 0; i < digits.length; i++) {\r\n            if (digits[i])\r\n                flag = true;\r\n            if (flag)\r\n                result += digitsString.charAt(digits[i]);\r\n        }\r\n        if (flag === false)\r\n            result += digitsString.charAt(0);\r\n        return result;\r\n    }\r\n}\r\n_a$p = LocalIntegerValueBlock;\r\nLocalIntegerValueBlock.NAME = \"IntegerValueBlock\";\r\n(() => {\r\n    Object.defineProperty(_a$p.prototype, \"valueHex\", {\r\n        set: function (v) {\r\n            this.valueHexView = new Uint8Array(v);\r\n            this.setValueHex();\r\n        },\r\n        get: function () {\r\n            return this.valueHexView.slice().buffer;\r\n        },\r\n    });\r\n})();\n\nvar _a$o;\r\nclass Integer extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalIntegerValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 2;\r\n    }\r\n    toBigInt() {\r\n        assertBigInt();\r\n        return BigInt(this.valueBlock.toString());\r\n    }\r\n    static fromBigInt(value) {\r\n        assertBigInt();\r\n        const bigIntValue = BigInt(value);\r\n        const writer = new ViewWriter();\r\n        const hex = bigIntValue.toString(16).replace(/^-/, \"\");\r\n        const view = new Uint8Array(pvtsutils.Convert.FromHex(hex));\r\n        if (bigIntValue < 0) {\r\n            const first = new Uint8Array(view.length + (view[0] & 0x80 ? 1 : 0));\r\n            first[0] |= 0x80;\r\n            const firstInt = BigInt(`0x${pvtsutils.Convert.ToHex(first)}`);\r\n            const secondInt = firstInt + bigIntValue;\r\n            const second = pvtsutils.BufferSourceConverter.toUint8Array(pvtsutils.Convert.FromHex(secondInt.toString(16)));\r\n            second[0] |= 0x80;\r\n            writer.write(second);\r\n        }\r\n        else {\r\n            if (view[0] & 0x80) {\r\n                writer.write(new Uint8Array([0]));\r\n            }\r\n            writer.write(view);\r\n        }\r\n        const res = new Integer({\r\n            valueHex: writer.final(),\r\n        });\r\n        return res;\r\n    }\r\n    convertToDER() {\r\n        const integer = new Integer({ valueHex: this.valueBlock.valueHexView });\r\n        integer.valueBlock.toDER();\r\n        return integer;\r\n    }\r\n    convertFromDER() {\r\n        return new Integer({\r\n            valueHex: this.valueBlock.valueHexView[0] === 0\r\n                ? this.valueBlock.valueHexView.subarray(1)\r\n                : this.valueBlock.valueHexView,\r\n        });\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;\r\n    }\r\n}\r\n_a$o = Integer;\r\n(() => {\r\n    typeStore.Integer = _a$o;\r\n})();\r\nInteger.NAME = \"INTEGER\";\n\nvar _a$n;\r\nclass Enumerated extends Integer {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 10;\r\n    }\r\n}\r\n_a$n = Enumerated;\r\n(() => {\r\n    typeStore.Enumerated = _a$n;\r\n})();\r\nEnumerated.NAME = \"ENUMERATED\";\n\nclass LocalSidValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.valueDec = valueDec;\r\n        this.isFirstSid = isFirstSid;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        if (!inputLength) {\r\n            return inputOffset;\r\n        }\r\n        const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        this.valueHexView = new Uint8Array(inputLength);\r\n        for (let i = 0; i < inputLength; i++) {\r\n            this.valueHexView[i] = intBuffer[i] & 0x7F;\r\n            this.blockLength++;\r\n            if ((intBuffer[i] & 0x80) === 0x00)\r\n                break;\r\n        }\r\n        const tempView = new Uint8Array(this.blockLength);\r\n        for (let i = 0; i < this.blockLength; i++) {\r\n            tempView[i] = this.valueHexView[i];\r\n        }\r\n        this.valueHexView = tempView;\r\n        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\r\n            this.error = \"End of input reached before message was fully decoded\";\r\n            return -1;\r\n        }\r\n        if (this.valueHexView[0] === 0x00)\r\n            this.warnings.push(\"Needlessly long format of SID encoding\");\r\n        if (this.blockLength <= 8)\r\n            this.valueDec = pvutils.utilFromBase(this.valueHexView, 7);\r\n        else {\r\n            this.isHexOnly = true;\r\n            this.warnings.push(\"Too big SID for decoding, hex only\");\r\n        }\r\n        return (inputOffset + this.blockLength);\r\n    }\r\n    set valueBigInt(value) {\r\n        assertBigInt();\r\n        let bits = BigInt(value).toString(2);\r\n        while (bits.length % 7) {\r\n            bits = \"0\" + bits;\r\n        }\r\n        const bytes = new Uint8Array(bits.length / 7);\r\n        for (let i = 0; i < bytes.length; i++) {\r\n            bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 0x80 : 0);\r\n        }\r\n        this.fromBER(bytes.buffer, 0, bytes.length);\r\n    }\r\n    toBER(sizeOnly) {\r\n        if (this.isHexOnly) {\r\n            if (sizeOnly)\r\n                return (new ArrayBuffer(this.valueHexView.byteLength));\r\n            const curView = this.valueHexView;\r\n            const retView = new Uint8Array(this.blockLength);\r\n            for (let i = 0; i < (this.blockLength - 1); i++)\r\n                retView[i] = curView[i] | 0x80;\r\n            retView[this.blockLength - 1] = curView[this.blockLength - 1];\r\n            return retView.buffer;\r\n        }\r\n        const encodedBuf = pvutils.utilToBase(this.valueDec, 7);\r\n        if (encodedBuf.byteLength === 0) {\r\n            this.error = \"Error during encoding SID value\";\r\n            return EMPTY_BUFFER;\r\n        }\r\n        const retView = new Uint8Array(encodedBuf.byteLength);\r\n        if (!sizeOnly) {\r\n            const encodedView = new Uint8Array(encodedBuf);\r\n            const len = encodedBuf.byteLength - 1;\r\n            for (let i = 0; i < len; i++)\r\n                retView[i] = encodedView[i] | 0x80;\r\n            retView[len] = encodedView[len];\r\n        }\r\n        return retView;\r\n    }\r\n    toString() {\r\n        let result = \"\";\r\n        if (this.isHexOnly)\r\n            result = pvtsutils.Convert.ToHex(this.valueHexView);\r\n        else {\r\n            if (this.isFirstSid) {\r\n                let sidValue = this.valueDec;\r\n                if (this.valueDec <= 39)\r\n                    result = \"0.\";\r\n                else {\r\n                    if (this.valueDec <= 79) {\r\n                        result = \"1.\";\r\n                        sidValue -= 40;\r\n                    }\r\n                    else {\r\n                        result = \"2.\";\r\n                        sidValue -= 80;\r\n                    }\r\n                }\r\n                result += sidValue.toString();\r\n            }\r\n            else\r\n                result = this.valueDec.toString();\r\n        }\r\n        return result;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            valueDec: this.valueDec,\r\n            isFirstSid: this.isFirstSid,\r\n        };\r\n    }\r\n}\r\nLocalSidValueBlock.NAME = \"sidBlock\";\n\nclass LocalObjectIdentifierValueBlock extends ValueBlock {\r\n    constructor({ value = EMPTY_STRING, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = [];\r\n        if (value) {\r\n            this.fromString(value);\r\n        }\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        let resultOffset = inputOffset;\r\n        while (inputLength > 0) {\r\n            const sidBlock = new LocalSidValueBlock();\r\n            resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\r\n            if (resultOffset === -1) {\r\n                this.blockLength = 0;\r\n                this.error = sidBlock.error;\r\n                return resultOffset;\r\n            }\r\n            if (this.value.length === 0)\r\n                sidBlock.isFirstSid = true;\r\n            this.blockLength += sidBlock.blockLength;\r\n            inputLength -= sidBlock.blockLength;\r\n            this.value.push(sidBlock);\r\n        }\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly) {\r\n        const retBuffers = [];\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            const valueBuf = this.value[i].toBER(sizeOnly);\r\n            if (valueBuf.byteLength === 0) {\r\n                this.error = this.value[i].error;\r\n                return EMPTY_BUFFER;\r\n            }\r\n            retBuffers.push(valueBuf);\r\n        }\r\n        return concat(retBuffers);\r\n    }\r\n    fromString(string) {\r\n        this.value = [];\r\n        let pos1 = 0;\r\n        let pos2 = 0;\r\n        let sid = \"\";\r\n        let flag = false;\r\n        do {\r\n            pos2 = string.indexOf(\".\", pos1);\r\n            if (pos2 === -1)\r\n                sid = string.substring(pos1);\r\n            else\r\n                sid = string.substring(pos1, pos2);\r\n            pos1 = pos2 + 1;\r\n            if (flag) {\r\n                const sidBlock = this.value[0];\r\n                let plus = 0;\r\n                switch (sidBlock.valueDec) {\r\n                    case 0:\r\n                        break;\r\n                    case 1:\r\n                        plus = 40;\r\n                        break;\r\n                    case 2:\r\n                        plus = 80;\r\n                        break;\r\n                    default:\r\n                        this.value = [];\r\n                        return;\r\n                }\r\n                const parsedSID = parseInt(sid, 10);\r\n                if (isNaN(parsedSID))\r\n                    return;\r\n                sidBlock.valueDec = parsedSID + plus;\r\n                flag = false;\r\n            }\r\n            else {\r\n                const sidBlock = new LocalSidValueBlock();\r\n                if (sid > Number.MAX_SAFE_INTEGER) {\r\n                    assertBigInt();\r\n                    const sidValue = BigInt(sid);\r\n                    sidBlock.valueBigInt = sidValue;\r\n                }\r\n                else {\r\n                    sidBlock.valueDec = parseInt(sid, 10);\r\n                    if (isNaN(sidBlock.valueDec))\r\n                        return;\r\n                }\r\n                if (!this.value.length) {\r\n                    sidBlock.isFirstSid = true;\r\n                    flag = true;\r\n                }\r\n                this.value.push(sidBlock);\r\n            }\r\n        } while (pos2 !== -1);\r\n    }\r\n    toString() {\r\n        let result = \"\";\r\n        let isHexOnly = false;\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            isHexOnly = this.value[i].isHexOnly;\r\n            let sidStr = this.value[i].toString();\r\n            if (i !== 0)\r\n                result = `${result}.`;\r\n            if (isHexOnly) {\r\n                sidStr = `{${sidStr}}`;\r\n                if (this.value[i].isFirstSid)\r\n                    result = `2.{${sidStr} - 80}`;\r\n                else\r\n                    result += sidStr;\r\n            }\r\n            else\r\n                result += sidStr;\r\n        }\r\n        return result;\r\n    }\r\n    toJSON() {\r\n        const object = {\r\n            ...super.toJSON(),\r\n            value: this.toString(),\r\n            sidArray: [],\r\n        };\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            object.sidArray.push(this.value[i].toJSON());\r\n        }\r\n        return object;\r\n    }\r\n}\r\nLocalObjectIdentifierValueBlock.NAME = \"ObjectIdentifierValueBlock\";\n\nvar _a$m;\r\nclass ObjectIdentifier extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalObjectIdentifierValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 6;\r\n    }\r\n    getValue() {\r\n        return this.valueBlock.toString();\r\n    }\r\n    setValue(value) {\r\n        this.valueBlock.fromString(value);\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.valueBlock.toString() || \"empty\"}`;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            value: this.getValue(),\r\n        };\r\n    }\r\n}\r\n_a$m = ObjectIdentifier;\r\n(() => {\r\n    typeStore.ObjectIdentifier = _a$m;\r\n})();\r\nObjectIdentifier.NAME = \"OBJECT IDENTIFIER\";\n\nclass LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock) {\r\n    constructor({ valueDec = 0, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.valueDec = valueDec;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        if (inputLength === 0)\r\n            return inputOffset;\r\n        const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength))\r\n            return -1;\r\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        this.valueHexView = new Uint8Array(inputLength);\r\n        for (let i = 0; i < inputLength; i++) {\r\n            this.valueHexView[i] = intBuffer[i] & 0x7F;\r\n            this.blockLength++;\r\n            if ((intBuffer[i] & 0x80) === 0x00)\r\n                break;\r\n        }\r\n        const tempView = new Uint8Array(this.blockLength);\r\n        for (let i = 0; i < this.blockLength; i++)\r\n            tempView[i] = this.valueHexView[i];\r\n        this.valueHexView = tempView;\r\n        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\r\n            this.error = \"End of input reached before message was fully decoded\";\r\n            return -1;\r\n        }\r\n        if (this.valueHexView[0] === 0x00)\r\n            this.warnings.push(\"Needlessly long format of SID encoding\");\r\n        if (this.blockLength <= 8)\r\n            this.valueDec = pvutils.utilFromBase(this.valueHexView, 7);\r\n        else {\r\n            this.isHexOnly = true;\r\n            this.warnings.push(\"Too big SID for decoding, hex only\");\r\n        }\r\n        return (inputOffset + this.blockLength);\r\n    }\r\n    toBER(sizeOnly) {\r\n        if (this.isHexOnly) {\r\n            if (sizeOnly)\r\n                return (new ArrayBuffer(this.valueHexView.byteLength));\r\n            const curView = this.valueHexView;\r\n            const retView = new Uint8Array(this.blockLength);\r\n            for (let i = 0; i < (this.blockLength - 1); i++)\r\n                retView[i] = curView[i] | 0x80;\r\n            retView[this.blockLength - 1] = curView[this.blockLength - 1];\r\n            return retView.buffer;\r\n        }\r\n        const encodedBuf = pvutils.utilToBase(this.valueDec, 7);\r\n        if (encodedBuf.byteLength === 0) {\r\n            this.error = \"Error during encoding SID value\";\r\n            return EMPTY_BUFFER;\r\n        }\r\n        const retView = new Uint8Array(encodedBuf.byteLength);\r\n        if (!sizeOnly) {\r\n            const encodedView = new Uint8Array(encodedBuf);\r\n            const len = encodedBuf.byteLength - 1;\r\n            for (let i = 0; i < len; i++)\r\n                retView[i] = encodedView[i] | 0x80;\r\n            retView[len] = encodedView[len];\r\n        }\r\n        return retView.buffer;\r\n    }\r\n    toString() {\r\n        let result = \"\";\r\n        if (this.isHexOnly)\r\n            result = pvtsutils.Convert.ToHex(this.valueHexView);\r\n        else {\r\n            result = this.valueDec.toString();\r\n        }\r\n        return result;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            valueDec: this.valueDec,\r\n        };\r\n    }\r\n}\r\nLocalRelativeSidValueBlock.NAME = \"relativeSidBlock\";\n\nclass LocalRelativeObjectIdentifierValueBlock extends ValueBlock {\r\n    constructor({ value = EMPTY_STRING, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = [];\r\n        if (value) {\r\n            this.fromString(value);\r\n        }\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        let resultOffset = inputOffset;\r\n        while (inputLength > 0) {\r\n            const sidBlock = new LocalRelativeSidValueBlock();\r\n            resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\r\n            if (resultOffset === -1) {\r\n                this.blockLength = 0;\r\n                this.error = sidBlock.error;\r\n                return resultOffset;\r\n            }\r\n            this.blockLength += sidBlock.blockLength;\r\n            inputLength -= sidBlock.blockLength;\r\n            this.value.push(sidBlock);\r\n        }\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        const retBuffers = [];\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            const valueBuf = this.value[i].toBER(sizeOnly);\r\n            if (valueBuf.byteLength === 0) {\r\n                this.error = this.value[i].error;\r\n                return EMPTY_BUFFER;\r\n            }\r\n            retBuffers.push(valueBuf);\r\n        }\r\n        return concat(retBuffers);\r\n    }\r\n    fromString(string) {\r\n        this.value = [];\r\n        let pos1 = 0;\r\n        let pos2 = 0;\r\n        let sid = \"\";\r\n        do {\r\n            pos2 = string.indexOf(\".\", pos1);\r\n            if (pos2 === -1)\r\n                sid = string.substring(pos1);\r\n            else\r\n                sid = string.substring(pos1, pos2);\r\n            pos1 = pos2 + 1;\r\n            const sidBlock = new LocalRelativeSidValueBlock();\r\n            sidBlock.valueDec = parseInt(sid, 10);\r\n            if (isNaN(sidBlock.valueDec))\r\n                return true;\r\n            this.value.push(sidBlock);\r\n        } while (pos2 !== -1);\r\n        return true;\r\n    }\r\n    toString() {\r\n        let result = \"\";\r\n        let isHexOnly = false;\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            isHexOnly = this.value[i].isHexOnly;\r\n            let sidStr = this.value[i].toString();\r\n            if (i !== 0)\r\n                result = `${result}.`;\r\n            if (isHexOnly) {\r\n                sidStr = `{${sidStr}}`;\r\n                result += sidStr;\r\n            }\r\n            else\r\n                result += sidStr;\r\n        }\r\n        return result;\r\n    }\r\n    toJSON() {\r\n        const object = {\r\n            ...super.toJSON(),\r\n            value: this.toString(),\r\n            sidArray: [],\r\n        };\r\n        for (let i = 0; i < this.value.length; i++)\r\n            object.sidArray.push(this.value[i].toJSON());\r\n        return object;\r\n    }\r\n}\r\nLocalRelativeObjectIdentifierValueBlock.NAME = \"RelativeObjectIdentifierValueBlock\";\n\nvar _a$l;\r\nclass RelativeObjectIdentifier extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalRelativeObjectIdentifierValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 13;\r\n    }\r\n    getValue() {\r\n        return this.valueBlock.toString();\r\n    }\r\n    setValue(value) {\r\n        this.valueBlock.fromString(value);\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.valueBlock.toString() || \"empty\"}`;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            value: this.getValue(),\r\n        };\r\n    }\r\n}\r\n_a$l = RelativeObjectIdentifier;\r\n(() => {\r\n    typeStore.RelativeObjectIdentifier = _a$l;\r\n})();\r\nRelativeObjectIdentifier.NAME = \"RelativeObjectIdentifier\";\n\nvar _a$k;\r\nclass Sequence extends Constructed {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 16;\r\n    }\r\n}\r\n_a$k = Sequence;\r\n(() => {\r\n    typeStore.Sequence = _a$k;\r\n})();\r\nSequence.NAME = \"SEQUENCE\";\n\nvar _a$j;\r\nclass Set extends Constructed {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 17;\r\n    }\r\n}\r\n_a$j = Set;\r\n(() => {\r\n    typeStore.Set = _a$j;\r\n})();\r\nSet.NAME = \"SET\";\n\nclass LocalStringValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ ...parameters } = {}) {\r\n        super(parameters);\r\n        this.isHexOnly = true;\r\n        this.value = EMPTY_STRING;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            value: this.value,\r\n        };\r\n    }\r\n}\r\nLocalStringValueBlock.NAME = \"StringValueBlock\";\n\nclass LocalSimpleStringValueBlock extends LocalStringValueBlock {\r\n}\r\nLocalSimpleStringValueBlock.NAME = \"SimpleStringValueBlock\";\n\nclass LocalSimpleStringBlock extends BaseStringBlock {\r\n    constructor({ ...parameters } = {}) {\r\n        super(parameters, LocalSimpleStringValueBlock);\r\n    }\r\n    fromBuffer(inputBuffer) {\r\n        this.valueBlock.value = String.fromCharCode.apply(null, pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer));\r\n    }\r\n    fromString(inputString) {\r\n        const strLen = inputString.length;\r\n        const view = this.valueBlock.valueHexView = new Uint8Array(strLen);\r\n        for (let i = 0; i < strLen; i++)\r\n            view[i] = inputString.charCodeAt(i);\r\n        this.valueBlock.value = inputString;\r\n    }\r\n}\r\nLocalSimpleStringBlock.NAME = \"SIMPLE STRING\";\n\nclass LocalUtf8StringValueBlock extends LocalSimpleStringBlock {\r\n    fromBuffer(inputBuffer) {\r\n        this.valueBlock.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        try {\r\n            this.valueBlock.value = pvtsutils.Convert.ToUtf8String(inputBuffer);\r\n        }\r\n        catch (ex) {\r\n            this.warnings.push(`Error during \"decodeURIComponent\": ${ex}, using raw string`);\r\n            this.valueBlock.value = pvtsutils.Convert.ToBinary(inputBuffer);\r\n        }\r\n    }\r\n    fromString(inputString) {\r\n        this.valueBlock.valueHexView = new Uint8Array(pvtsutils.Convert.FromUtf8String(inputString));\r\n        this.valueBlock.value = inputString;\r\n    }\r\n}\r\nLocalUtf8StringValueBlock.NAME = \"Utf8StringValueBlock\";\n\nvar _a$i;\r\nclass Utf8String extends LocalUtf8StringValueBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 12;\r\n    }\r\n}\r\n_a$i = Utf8String;\r\n(() => {\r\n    typeStore.Utf8String = _a$i;\r\n})();\r\nUtf8String.NAME = \"UTF8String\";\n\nclass LocalBmpStringValueBlock extends LocalSimpleStringBlock {\r\n    fromBuffer(inputBuffer) {\r\n        this.valueBlock.value = pvtsutils.Convert.ToUtf16String(inputBuffer);\r\n        this.valueBlock.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n    }\r\n    fromString(inputString) {\r\n        this.valueBlock.value = inputString;\r\n        this.valueBlock.valueHexView = new Uint8Array(pvtsutils.Convert.FromUtf16String(inputString));\r\n    }\r\n}\r\nLocalBmpStringValueBlock.NAME = \"BmpStringValueBlock\";\n\nvar _a$h;\r\nclass BmpString extends LocalBmpStringValueBlock {\r\n    constructor({ ...parameters } = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 30;\r\n    }\r\n}\r\n_a$h = BmpString;\r\n(() => {\r\n    typeStore.BmpString = _a$h;\r\n})();\r\nBmpString.NAME = \"BMPString\";\n\nclass LocalUniversalStringValueBlock extends LocalSimpleStringBlock {\r\n    fromBuffer(inputBuffer) {\r\n        const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);\r\n        const valueView = new Uint8Array(copyBuffer);\r\n        for (let i = 0; i < valueView.length; i += 4) {\r\n            valueView[i] = valueView[i + 3];\r\n            valueView[i + 1] = valueView[i + 2];\r\n            valueView[i + 2] = 0x00;\r\n            valueView[i + 3] = 0x00;\r\n        }\r\n        this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));\r\n    }\r\n    fromString(inputString) {\r\n        const strLength = inputString.length;\r\n        const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);\r\n        for (let i = 0; i < strLength; i++) {\r\n            const codeBuf = pvutils.utilToBase(inputString.charCodeAt(i), 8);\r\n            const codeView = new Uint8Array(codeBuf);\r\n            if (codeView.length > 4)\r\n                continue;\r\n            const dif = 4 - codeView.length;\r\n            for (let j = (codeView.length - 1); j >= 0; j--)\r\n                valueHexView[i * 4 + j + dif] = codeView[j];\r\n        }\r\n        this.valueBlock.value = inputString;\r\n    }\r\n}\r\nLocalUniversalStringValueBlock.NAME = \"UniversalStringValueBlock\";\n\nvar _a$g;\r\nclass UniversalString extends LocalUniversalStringValueBlock {\r\n    constructor({ ...parameters } = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 28;\r\n    }\r\n}\r\n_a$g = UniversalString;\r\n(() => {\r\n    typeStore.UniversalString = _a$g;\r\n})();\r\nUniversalString.NAME = \"UniversalString\";\n\nvar _a$f;\r\nclass NumericString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 18;\r\n    }\r\n}\r\n_a$f = NumericString;\r\n(() => {\r\n    typeStore.NumericString = _a$f;\r\n})();\r\nNumericString.NAME = \"NumericString\";\n\nvar _a$e;\r\nclass PrintableString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 19;\r\n    }\r\n}\r\n_a$e = PrintableString;\r\n(() => {\r\n    typeStore.PrintableString = _a$e;\r\n})();\r\nPrintableString.NAME = \"PrintableString\";\n\nvar _a$d;\r\nclass TeletexString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 20;\r\n    }\r\n}\r\n_a$d = TeletexString;\r\n(() => {\r\n    typeStore.TeletexString = _a$d;\r\n})();\r\nTeletexString.NAME = \"TeletexString\";\n\nvar _a$c;\r\nclass VideotexString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 21;\r\n    }\r\n}\r\n_a$c = VideotexString;\r\n(() => {\r\n    typeStore.VideotexString = _a$c;\r\n})();\r\nVideotexString.NAME = \"VideotexString\";\n\nvar _a$b;\r\nclass IA5String extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 22;\r\n    }\r\n}\r\n_a$b = IA5String;\r\n(() => {\r\n    typeStore.IA5String = _a$b;\r\n})();\r\nIA5String.NAME = \"IA5String\";\n\nvar _a$a;\r\nclass GraphicString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 25;\r\n    }\r\n}\r\n_a$a = GraphicString;\r\n(() => {\r\n    typeStore.GraphicString = _a$a;\r\n})();\r\nGraphicString.NAME = \"GraphicString\";\n\nvar _a$9;\r\nclass VisibleString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 26;\r\n    }\r\n}\r\n_a$9 = VisibleString;\r\n(() => {\r\n    typeStore.VisibleString = _a$9;\r\n})();\r\nVisibleString.NAME = \"VisibleString\";\n\nvar _a$8;\r\nclass GeneralString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 27;\r\n    }\r\n}\r\n_a$8 = GeneralString;\r\n(() => {\r\n    typeStore.GeneralString = _a$8;\r\n})();\r\nGeneralString.NAME = \"GeneralString\";\n\nvar _a$7;\r\nclass CharacterString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 29;\r\n    }\r\n}\r\n_a$7 = CharacterString;\r\n(() => {\r\n    typeStore.CharacterString = _a$7;\r\n})();\r\nCharacterString.NAME = \"CharacterString\";\n\nvar _a$6;\r\nclass UTCTime extends VisibleString {\r\n    constructor({ value, valueDate, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.year = 0;\r\n        this.month = 0;\r\n        this.day = 0;\r\n        this.hour = 0;\r\n        this.minute = 0;\r\n        this.second = 0;\r\n        if (value) {\r\n            this.fromString(value);\r\n            this.valueBlock.valueHexView = new Uint8Array(value.length);\r\n            for (let i = 0; i < value.length; i++)\r\n                this.valueBlock.valueHexView[i] = value.charCodeAt(i);\r\n        }\r\n        if (valueDate) {\r\n            this.fromDate(valueDate);\r\n            this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());\r\n        }\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 23;\r\n    }\r\n    fromBuffer(inputBuffer) {\r\n        this.fromString(String.fromCharCode.apply(null, pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer)));\r\n    }\r\n    toBuffer() {\r\n        const str = this.toString();\r\n        const buffer = new ArrayBuffer(str.length);\r\n        const view = new Uint8Array(buffer);\r\n        for (let i = 0; i < str.length; i++)\r\n            view[i] = str.charCodeAt(i);\r\n        return buffer;\r\n    }\r\n    fromDate(inputDate) {\r\n        this.year = inputDate.getUTCFullYear();\r\n        this.month = inputDate.getUTCMonth() + 1;\r\n        this.day = inputDate.getUTCDate();\r\n        this.hour = inputDate.getUTCHours();\r\n        this.minute = inputDate.getUTCMinutes();\r\n        this.second = inputDate.getUTCSeconds();\r\n    }\r\n    toDate() {\r\n        return (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second)));\r\n    }\r\n    fromString(inputString) {\r\n        const parser = /(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z/ig;\r\n        const parserArray = parser.exec(inputString);\r\n        if (parserArray === null) {\r\n            this.error = \"Wrong input string for conversion\";\r\n            return;\r\n        }\r\n        const year = parseInt(parserArray[1], 10);\r\n        if (year >= 50)\r\n            this.year = 1900 + year;\r\n        else\r\n            this.year = 2000 + year;\r\n        this.month = parseInt(parserArray[2], 10);\r\n        this.day = parseInt(parserArray[3], 10);\r\n        this.hour = parseInt(parserArray[4], 10);\r\n        this.minute = parseInt(parserArray[5], 10);\r\n        this.second = parseInt(parserArray[6], 10);\r\n    }\r\n    toString(encoding = \"iso\") {\r\n        if (encoding === \"iso\") {\r\n            const outputArray = new Array(7);\r\n            outputArray[0] = pvutils.padNumber(((this.year < 2000) ? (this.year - 1900) : (this.year - 2000)), 2);\r\n            outputArray[1] = pvutils.padNumber(this.month, 2);\r\n            outputArray[2] = pvutils.padNumber(this.day, 2);\r\n            outputArray[3] = pvutils.padNumber(this.hour, 2);\r\n            outputArray[4] = pvutils.padNumber(this.minute, 2);\r\n            outputArray[5] = pvutils.padNumber(this.second, 2);\r\n            outputArray[6] = \"Z\";\r\n            return outputArray.join(\"\");\r\n        }\r\n        return super.toString(encoding);\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            year: this.year,\r\n            month: this.month,\r\n            day: this.day,\r\n            hour: this.hour,\r\n            minute: this.minute,\r\n            second: this.second,\r\n        };\r\n    }\r\n}\r\n_a$6 = UTCTime;\r\n(() => {\r\n    typeStore.UTCTime = _a$6;\r\n})();\r\nUTCTime.NAME = \"UTCTime\";\n\nvar _a$5;\r\nclass GeneralizedTime extends UTCTime {\r\n    constructor(parameters = {}) {\r\n        var _b;\r\n        super(parameters);\r\n        (_b = this.millisecond) !== null && _b !== void 0 ? _b : (this.millisecond = 0);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 24;\r\n    }\r\n    fromDate(inputDate) {\r\n        super.fromDate(inputDate);\r\n        this.millisecond = inputDate.getUTCMilliseconds();\r\n    }\r\n    toDate() {\r\n        return (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)));\r\n    }\r\n    fromString(inputString) {\r\n        let isUTC = false;\r\n        let timeString = \"\";\r\n        let dateTimeString = \"\";\r\n        let fractionPart = 0;\r\n        let parser;\r\n        let hourDifference = 0;\r\n        let minuteDifference = 0;\r\n        if (inputString[inputString.length - 1] === \"Z\") {\r\n            timeString = inputString.substring(0, inputString.length - 1);\r\n            isUTC = true;\r\n        }\r\n        else {\r\n            const number = new Number(inputString[inputString.length - 1]);\r\n            if (isNaN(number.valueOf()))\r\n                throw new Error(\"Wrong input string for conversion\");\r\n            timeString = inputString;\r\n        }\r\n        if (isUTC) {\r\n            if (timeString.indexOf(\"+\") !== -1)\r\n                throw new Error(\"Wrong input string for conversion\");\r\n            if (timeString.indexOf(\"-\") !== -1)\r\n                throw new Error(\"Wrong input string for conversion\");\r\n        }\r\n        else {\r\n            let multiplier = 1;\r\n            let differencePosition = timeString.indexOf(\"+\");\r\n            let differenceString = \"\";\r\n            if (differencePosition === -1) {\r\n                differencePosition = timeString.indexOf(\"-\");\r\n                multiplier = -1;\r\n            }\r\n            if (differencePosition !== -1) {\r\n                differenceString = timeString.substring(differencePosition + 1);\r\n                timeString = timeString.substring(0, differencePosition);\r\n                if ((differenceString.length !== 2) && (differenceString.length !== 4))\r\n                    throw new Error(\"Wrong input string for conversion\");\r\n                let number = parseInt(differenceString.substring(0, 2), 10);\r\n                if (isNaN(number.valueOf()))\r\n                    throw new Error(\"Wrong input string for conversion\");\r\n                hourDifference = multiplier * number;\r\n                if (differenceString.length === 4) {\r\n                    number = parseInt(differenceString.substring(2, 4), 10);\r\n                    if (isNaN(number.valueOf()))\r\n                        throw new Error(\"Wrong input string for conversion\");\r\n                    minuteDifference = multiplier * number;\r\n                }\r\n            }\r\n        }\r\n        let fractionPointPosition = timeString.indexOf(\".\");\r\n        if (fractionPointPosition === -1)\r\n            fractionPointPosition = timeString.indexOf(\",\");\r\n        if (fractionPointPosition !== -1) {\r\n            const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);\r\n            if (isNaN(fractionPartCheck.valueOf()))\r\n                throw new Error(\"Wrong input string for conversion\");\r\n            fractionPart = fractionPartCheck.valueOf();\r\n            dateTimeString = timeString.substring(0, fractionPointPosition);\r\n        }\r\n        else\r\n            dateTimeString = timeString;\r\n        switch (true) {\r\n            case (dateTimeString.length === 8):\r\n                parser = /(\\d{4})(\\d{2})(\\d{2})/ig;\r\n                if (fractionPointPosition !== -1)\r\n                    throw new Error(\"Wrong input string for conversion\");\r\n                break;\r\n            case (dateTimeString.length === 10):\r\n                parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})/ig;\r\n                if (fractionPointPosition !== -1) {\r\n                    let fractionResult = 60 * fractionPart;\r\n                    this.minute = Math.floor(fractionResult);\r\n                    fractionResult = 60 * (fractionResult - this.minute);\r\n                    this.second = Math.floor(fractionResult);\r\n                    fractionResult = 1000 * (fractionResult - this.second);\r\n                    this.millisecond = Math.floor(fractionResult);\r\n                }\r\n                break;\r\n            case (dateTimeString.length === 12):\r\n                parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\r\n                if (fractionPointPosition !== -1) {\r\n                    let fractionResult = 60 * fractionPart;\r\n                    this.second = Math.floor(fractionResult);\r\n                    fractionResult = 1000 * (fractionResult - this.second);\r\n                    this.millisecond = Math.floor(fractionResult);\r\n                }\r\n                break;\r\n            case (dateTimeString.length === 14):\r\n                parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\r\n                if (fractionPointPosition !== -1) {\r\n                    const fractionResult = 1000 * fractionPart;\r\n                    this.millisecond = Math.floor(fractionResult);\r\n                }\r\n                break;\r\n            default:\r\n                throw new Error(\"Wrong input string for conversion\");\r\n        }\r\n        const parserArray = parser.exec(dateTimeString);\r\n        if (parserArray === null)\r\n            throw new Error(\"Wrong input string for conversion\");\r\n        for (let j = 1; j < parserArray.length; j++) {\r\n            switch (j) {\r\n                case 1:\r\n                    this.year = parseInt(parserArray[j], 10);\r\n                    break;\r\n                case 2:\r\n                    this.month = parseInt(parserArray[j], 10);\r\n                    break;\r\n                case 3:\r\n                    this.day = parseInt(parserArray[j], 10);\r\n                    break;\r\n                case 4:\r\n                    this.hour = parseInt(parserArray[j], 10) + hourDifference;\r\n                    break;\r\n                case 5:\r\n                    this.minute = parseInt(parserArray[j], 10) + minuteDifference;\r\n                    break;\r\n                case 6:\r\n                    this.second = parseInt(parserArray[j], 10);\r\n                    break;\r\n                default:\r\n                    throw new Error(\"Wrong input string for conversion\");\r\n            }\r\n        }\r\n        if (isUTC === false) {\r\n            const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\r\n            this.year = tempDate.getUTCFullYear();\r\n            this.month = tempDate.getUTCMonth();\r\n            this.day = tempDate.getUTCDay();\r\n            this.hour = tempDate.getUTCHours();\r\n            this.minute = tempDate.getUTCMinutes();\r\n            this.second = tempDate.getUTCSeconds();\r\n            this.millisecond = tempDate.getUTCMilliseconds();\r\n        }\r\n    }\r\n    toString(encoding = \"iso\") {\r\n        if (encoding === \"iso\") {\r\n            const outputArray = [];\r\n            outputArray.push(pvutils.padNumber(this.year, 4));\r\n            outputArray.push(pvutils.padNumber(this.month, 2));\r\n            outputArray.push(pvutils.padNumber(this.day, 2));\r\n            outputArray.push(pvutils.padNumber(this.hour, 2));\r\n            outputArray.push(pvutils.padNumber(this.minute, 2));\r\n            outputArray.push(pvutils.padNumber(this.second, 2));\r\n            if (this.millisecond !== 0) {\r\n                outputArray.push(\".\");\r\n                outputArray.push(pvutils.padNumber(this.millisecond, 3));\r\n            }\r\n            outputArray.push(\"Z\");\r\n            return outputArray.join(\"\");\r\n        }\r\n        return super.toString(encoding);\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            millisecond: this.millisecond,\r\n        };\r\n    }\r\n}\r\n_a$5 = GeneralizedTime;\r\n(() => {\r\n    typeStore.GeneralizedTime = _a$5;\r\n})();\r\nGeneralizedTime.NAME = \"GeneralizedTime\";\n\nvar _a$4;\r\nclass DATE extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 31;\r\n    }\r\n}\r\n_a$4 = DATE;\r\n(() => {\r\n    typeStore.DATE = _a$4;\r\n})();\r\nDATE.NAME = \"DATE\";\n\nvar _a$3;\r\nclass TimeOfDay extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 32;\r\n    }\r\n}\r\n_a$3 = TimeOfDay;\r\n(() => {\r\n    typeStore.TimeOfDay = _a$3;\r\n})();\r\nTimeOfDay.NAME = \"TimeOfDay\";\n\nvar _a$2;\r\nclass DateTime extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 33;\r\n    }\r\n}\r\n_a$2 = DateTime;\r\n(() => {\r\n    typeStore.DateTime = _a$2;\r\n})();\r\nDateTime.NAME = \"DateTime\";\n\nvar _a$1;\r\nclass Duration extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 34;\r\n    }\r\n}\r\n_a$1 = Duration;\r\n(() => {\r\n    typeStore.Duration = _a$1;\r\n})();\r\nDuration.NAME = \"Duration\";\n\nvar _a;\r\nclass TIME extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 14;\r\n    }\r\n}\r\n_a = TIME;\r\n(() => {\r\n    typeStore.TIME = _a;\r\n})();\r\nTIME.NAME = \"TIME\";\n\nclass Any {\r\n    constructor({ name = EMPTY_STRING, optional = false, } = {}) {\r\n        this.name = name;\r\n        this.optional = optional;\r\n    }\r\n}\n\nclass Choice extends Any {\r\n    constructor({ value = [], ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = value;\r\n    }\r\n}\n\nclass Repeated extends Any {\r\n    constructor({ value = new Any(), local = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = value;\r\n        this.local = local;\r\n    }\r\n}\n\nclass RawData {\r\n    constructor({ data = EMPTY_VIEW } = {}) {\r\n        this.dataView = pvtsutils.BufferSourceConverter.toUint8Array(data);\r\n    }\r\n    get data() {\r\n        return this.dataView.slice().buffer;\r\n    }\r\n    set data(value) {\r\n        this.dataView = pvtsutils.BufferSourceConverter.toUint8Array(value);\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const endLength = inputOffset + inputLength;\r\n        this.dataView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);\r\n        return endLength;\r\n    }\r\n    toBER(sizeOnly) {\r\n        return this.dataView.slice().buffer;\r\n    }\r\n}\n\nfunction compareSchema(root, inputData, inputSchema) {\r\n    if (inputSchema instanceof Choice) {\r\n        for (let j = 0; j < inputSchema.value.length; j++) {\r\n            const result = compareSchema(root, inputData, inputSchema.value[j]);\r\n            if (result.verified) {\r\n                return {\r\n                    verified: true,\r\n                    result: root\r\n                };\r\n            }\r\n        }\r\n        {\r\n            const _result = {\r\n                verified: false,\r\n                result: {\r\n                    error: \"Wrong values for Choice type\"\r\n                },\r\n            };\r\n            if (inputSchema.hasOwnProperty(NAME))\r\n                _result.name = inputSchema.name;\r\n            return _result;\r\n        }\r\n    }\r\n    if (inputSchema instanceof Any) {\r\n        if (inputSchema.hasOwnProperty(NAME))\r\n            root[inputSchema.name] = inputData;\r\n        return {\r\n            verified: true,\r\n            result: root\r\n        };\r\n    }\r\n    if ((root instanceof Object) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong root object\" }\r\n        };\r\n    }\r\n    if ((inputData instanceof Object) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 data\" }\r\n        };\r\n    }\r\n    if ((inputSchema instanceof Object) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if ((ID_BLOCK in inputSchema) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if ((FROM_BER in inputSchema.idBlock) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if ((TO_BER in inputSchema.idBlock) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    const encodedId = inputSchema.idBlock.toBER(false);\r\n    if (encodedId.byteLength === 0) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Error encoding idBlock for ASN.1 schema\" }\r\n        };\r\n    }\r\n    const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);\r\n    if (decodedOffset === -1) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Error decoding idBlock for ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {\r\n        return {\r\n            verified: false,\r\n            result: root\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {\r\n        return {\r\n            verified: false,\r\n            result: root\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {\r\n        return {\r\n            verified: false,\r\n            result: root\r\n        };\r\n    }\r\n    if (!(IS_HEX_ONLY in inputSchema.idBlock)) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {\r\n        return {\r\n            verified: false,\r\n            result: root\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.isHexOnly) {\r\n        if ((VALUE_HEX_VIEW in inputSchema.idBlock) === false) {\r\n            return {\r\n                verified: false,\r\n                result: { error: \"Wrong ASN.1 schema\" }\r\n            };\r\n        }\r\n        const schemaView = inputSchema.idBlock.valueHexView;\r\n        const asn1View = inputData.idBlock.valueHexView;\r\n        if (schemaView.length !== asn1View.length) {\r\n            return {\r\n                verified: false,\r\n                result: root\r\n            };\r\n        }\r\n        for (let i = 0; i < schemaView.length; i++) {\r\n            if (schemaView[i] !== asn1View[1]) {\r\n                return {\r\n                    verified: false,\r\n                    result: root\r\n                };\r\n            }\r\n        }\r\n    }\r\n    if (inputSchema.name) {\r\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n        if (inputSchema.name)\r\n            root[inputSchema.name] = inputData;\r\n    }\r\n    if (inputSchema instanceof typeStore.Constructed) {\r\n        let admission = 0;\r\n        let result = {\r\n            verified: false,\r\n            result: {\r\n                error: \"Unknown error\",\r\n            }\r\n        };\r\n        let maxLength = inputSchema.valueBlock.value.length;\r\n        if (maxLength > 0) {\r\n            if (inputSchema.valueBlock.value[0] instanceof Repeated) {\r\n                maxLength = inputData.valueBlock.value.length;\r\n            }\r\n        }\r\n        if (maxLength === 0) {\r\n            return {\r\n                verified: true,\r\n                result: root\r\n            };\r\n        }\r\n        if ((inputData.valueBlock.value.length === 0) &&\r\n            (inputSchema.valueBlock.value.length !== 0)) {\r\n            let _optional = true;\r\n            for (let i = 0; i < inputSchema.valueBlock.value.length; i++)\r\n                _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);\r\n            if (_optional) {\r\n                return {\r\n                    verified: true,\r\n                    result: root\r\n                };\r\n            }\r\n            if (inputSchema.name) {\r\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                if (inputSchema.name)\r\n                    delete root[inputSchema.name];\r\n            }\r\n            root.error = \"Inconsistent object length\";\r\n            return {\r\n                verified: false,\r\n                result: root\r\n            };\r\n        }\r\n        for (let i = 0; i < maxLength; i++) {\r\n            if ((i - admission) >= inputData.valueBlock.value.length) {\r\n                if (inputSchema.valueBlock.value[i].optional === false) {\r\n                    const _result = {\r\n                        verified: false,\r\n                        result: root\r\n                    };\r\n                    root.error = \"Inconsistent length between ASN.1 data and schema\";\r\n                    if (inputSchema.name) {\r\n                        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                        if (inputSchema.name) {\r\n                            delete root[inputSchema.name];\r\n                            _result.name = inputSchema.name;\r\n                        }\r\n                    }\r\n                    return _result;\r\n                }\r\n            }\r\n            else {\r\n                if (inputSchema.valueBlock.value[0] instanceof Repeated) {\r\n                    result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);\r\n                    if (result.verified === false) {\r\n                        if (inputSchema.valueBlock.value[0].optional)\r\n                            admission++;\r\n                        else {\r\n                            if (inputSchema.name) {\r\n                                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                                if (inputSchema.name)\r\n                                    delete root[inputSchema.name];\r\n                            }\r\n                            return result;\r\n                        }\r\n                    }\r\n                    if ((NAME in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].name.length > 0)) {\r\n                        let arrayRoot = {};\r\n                        if ((LOCAL in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].local))\r\n                            arrayRoot = inputData;\r\n                        else\r\n                            arrayRoot = root;\r\n                        if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === \"undefined\")\r\n                            arrayRoot[inputSchema.valueBlock.value[0].name] = [];\r\n                        arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);\r\n                    }\r\n                }\r\n                else {\r\n                    result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);\r\n                    if (result.verified === false) {\r\n                        if (inputSchema.valueBlock.value[i].optional)\r\n                            admission++;\r\n                        else {\r\n                            if (inputSchema.name) {\r\n                                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                                if (inputSchema.name)\r\n                                    delete root[inputSchema.name];\r\n                            }\r\n                            return result;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (result.verified === false) {\r\n            const _result = {\r\n                verified: false,\r\n                result: root\r\n            };\r\n            if (inputSchema.name) {\r\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                if (inputSchema.name) {\r\n                    delete root[inputSchema.name];\r\n                    _result.name = inputSchema.name;\r\n                }\r\n            }\r\n            return _result;\r\n        }\r\n        return {\r\n            verified: true,\r\n            result: root\r\n        };\r\n    }\r\n    if (inputSchema.primitiveSchema &&\r\n        (VALUE_HEX_VIEW in inputData.valueBlock)) {\r\n        const asn1 = localFromBER(inputData.valueBlock.valueHexView);\r\n        if (asn1.offset === -1) {\r\n            const _result = {\r\n                verified: false,\r\n                result: asn1.result\r\n            };\r\n            if (inputSchema.name) {\r\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                if (inputSchema.name) {\r\n                    delete root[inputSchema.name];\r\n                    _result.name = inputSchema.name;\r\n                }\r\n            }\r\n            return _result;\r\n        }\r\n        return compareSchema(root, asn1.result, inputSchema.primitiveSchema);\r\n    }\r\n    return {\r\n        verified: true,\r\n        result: root\r\n    };\r\n}\r\nfunction verifySchema(inputBuffer, inputSchema) {\r\n    if ((inputSchema instanceof Object) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema type\" }\r\n        };\r\n    }\r\n    const asn1 = localFromBER(pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer));\r\n    if (asn1.offset === -1) {\r\n        return {\r\n            verified: false,\r\n            result: asn1.result\r\n        };\r\n    }\r\n    return compareSchema(asn1.result, asn1.result, inputSchema);\r\n}\n\nexport { Any, BaseBlock, BaseStringBlock, BitString, BmpString, Boolean, CharacterString, Choice, Constructed, DATE, DateTime, Duration, EndOfContent, Enumerated, GeneralString, GeneralizedTime, GraphicString, HexBlock, IA5String, Integer, Null, NumericString, ObjectIdentifier, OctetString, Primitive, PrintableString, RawData, RelativeObjectIdentifier, Repeated, Sequence, Set, TIME, TeletexString, TimeOfDay, UTCTime, UniversalString, Utf8String, ValueBlock, VideotexString, ViewWriter, VisibleString, compareSchema, fromBER, verifySchema };\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/* global indexedDB */\n\n'use strict'\n\nconst { AbstractLevel } = require('abstract-level')\nconst ModuleError = require('module-error')\nconst parallel = require('run-parallel-limit')\nconst { fromCallback } = require('catering')\nconst { Iterator } = require('./iterator')\nconst deserialize = require('./util/deserialize')\nconst clear = require('./util/clear')\nconst createKeyRange = require('./util/key-range')\n\n// Keep as-is for compatibility with existing level-js databases\nconst DEFAULT_PREFIX = 'level-js-'\n\nconst kIDB = Symbol('idb')\nconst kNamePrefix = Symbol('namePrefix')\nconst kLocation = Symbol('location')\nconst kVersion = Symbol('version')\nconst kStore = Symbol('store')\nconst kOnComplete = Symbol('onComplete')\nconst kPromise = Symbol('promise')\n\nclass BrowserLevel extends AbstractLevel {\n  constructor (location, options, _) {\n    // To help migrating to abstract-level\n    if (typeof options === 'function' || typeof _ === 'function') {\n      throw new ModuleError('The levelup-style callback argument has been removed', {\n        code: 'LEVEL_LEGACY'\n      })\n    }\n\n    const { prefix, version, ...forward } = options || {}\n\n    super({\n      encodings: { view: true },\n      snapshots: false,\n      createIfMissing: false,\n      errorIfExists: false,\n      seek: true\n    }, forward)\n\n    if (typeof location !== 'string') {\n      throw new Error('constructor requires a location string argument')\n    }\n\n    // TODO (next major): remove default prefix\n    this[kLocation] = location\n    this[kNamePrefix] = prefix == null ? DEFAULT_PREFIX : prefix\n    this[kVersion] = parseInt(version || 1, 10)\n    this[kIDB] = null\n  }\n\n  get location () {\n    return this[kLocation]\n  }\n\n  get namePrefix () {\n    return this[kNamePrefix]\n  }\n\n  get version () {\n    return this[kVersion]\n  }\n\n  // Exposed for backwards compat and unit tests\n  get db () {\n    return this[kIDB]\n  }\n\n  get type () {\n    return 'browser-level'\n  }\n\n  _open (options, callback) {\n    const req = indexedDB.open(this[kNamePrefix] + this[kLocation], this[kVersion])\n\n    req.onerror = function () {\n      callback(req.error || new Error('unknown error'))\n    }\n\n    req.onsuccess = () => {\n      this[kIDB] = req.result\n      callback()\n    }\n\n    req.onupgradeneeded = (ev) => {\n      const db = ev.target.result\n\n      if (!db.objectStoreNames.contains(this[kLocation])) {\n        db.createObjectStore(this[kLocation])\n      }\n    }\n  }\n\n  [kStore] (mode) {\n    const transaction = this[kIDB].transaction([this[kLocation]], mode)\n    return transaction.objectStore(this[kLocation])\n  }\n\n  [kOnComplete] (request, callback) {\n    const transaction = request.transaction\n\n    // Take advantage of the fact that a non-canceled request error aborts\n    // the transaction. I.e. no need to listen for \"request.onerror\".\n    transaction.onabort = function () {\n      callback(transaction.error || new Error('aborted by user'))\n    }\n\n    transaction.oncomplete = function () {\n      callback(null, request.result)\n    }\n  }\n\n  _get (key, options, callback) {\n    const store = this[kStore]('readonly')\n    let req\n\n    try {\n      req = store.get(key)\n    } catch (err) {\n      return this.nextTick(callback, err)\n    }\n\n    this[kOnComplete](req, function (err, value) {\n      if (err) return callback(err)\n\n      if (value === undefined) {\n        return callback(new ModuleError('Entry not found', {\n          code: 'LEVEL_NOT_FOUND'\n        }))\n      }\n\n      callback(null, deserialize(value))\n    })\n  }\n\n  _getMany (keys, options, callback) {\n    const store = this[kStore]('readonly')\n    const tasks = keys.map((key) => (next) => {\n      let request\n\n      try {\n        request = store.get(key)\n      } catch (err) {\n        return next(err)\n      }\n\n      request.onsuccess = () => {\n        const value = request.result\n        next(null, value === undefined ? value : deserialize(value))\n      }\n\n      request.onerror = (ev) => {\n        ev.stopPropagation()\n        next(request.error)\n      }\n    })\n\n    parallel(tasks, 16, callback)\n  }\n\n  _del (key, options, callback) {\n    const store = this[kStore]('readwrite')\n    let req\n\n    try {\n      req = store.delete(key)\n    } catch (err) {\n      return this.nextTick(callback, err)\n    }\n\n    this[kOnComplete](req, callback)\n  }\n\n  _put (key, value, options, callback) {\n    const store = this[kStore]('readwrite')\n    let req\n\n    try {\n      // Will throw a DataError or DataCloneError if the environment\n      // does not support serializing the key or value respectively.\n      req = store.put(value, key)\n    } catch (err) {\n      return this.nextTick(callback, err)\n    }\n\n    this[kOnComplete](req, callback)\n  }\n\n  // TODO: implement key and value iterators\n  _iterator (options) {\n    return new Iterator(this, this[kLocation], options)\n  }\n\n  _batch (operations, options, callback) {\n    const store = this[kStore]('readwrite')\n    const transaction = store.transaction\n    let index = 0\n    let error\n\n    transaction.onabort = function () {\n      callback(error || transaction.error || new Error('aborted by user'))\n    }\n\n    transaction.oncomplete = function () {\n      callback()\n    }\n\n    // Wait for a request to complete before making the next, saving CPU.\n    function loop () {\n      const op = operations[index++]\n      const key = op.key\n\n      let req\n\n      try {\n        req = op.type === 'del' ? store.delete(key) : store.put(op.value, key)\n      } catch (err) {\n        error = err\n        transaction.abort()\n        return\n      }\n\n      if (index < operations.length) {\n        req.onsuccess = loop\n      } else if (typeof transaction.commit === 'function') {\n        // Commit now instead of waiting for auto-commit\n        transaction.commit()\n      }\n    }\n\n    loop()\n  }\n\n  _clear (options, callback) {\n    let keyRange\n    let req\n\n    try {\n      keyRange = createKeyRange(options)\n    } catch (e) {\n      // The lower key is greater than the upper key.\n      // IndexedDB throws an error, but we'll just do nothing.\n      return this.nextTick(callback)\n    }\n\n    if (options.limit >= 0) {\n      // IDBObjectStore#delete(range) doesn't have such an option.\n      // Fall back to cursor-based implementation.\n      return clear(this, this[kLocation], keyRange, options, callback)\n    }\n\n    try {\n      const store = this[kStore]('readwrite')\n      req = keyRange ? store.delete(keyRange) : store.clear()\n    } catch (err) {\n      return this.nextTick(callback, err)\n    }\n\n    this[kOnComplete](req, callback)\n  }\n\n  _close (callback) {\n    this[kIDB].close()\n    this.nextTick(callback)\n  }\n}\n\nBrowserLevel.destroy = function (location, prefix, callback) {\n  if (typeof prefix === 'function') {\n    callback = prefix\n    prefix = DEFAULT_PREFIX\n  }\n\n  callback = fromCallback(callback, kPromise)\n  const request = indexedDB.deleteDatabase(prefix + location)\n\n  request.onsuccess = function () {\n    callback()\n  }\n\n  request.onerror = function (err) {\n    callback(err)\n  }\n\n  return callback[kPromise]\n}\n\nexports.BrowserLevel = BrowserLevel\n","'use strict'\n\nconst { AbstractIterator } = require('abstract-level')\nconst createKeyRange = require('./util/key-range')\nconst deserialize = require('./util/deserialize')\n\nconst kCache = Symbol('cache')\nconst kFinished = Symbol('finished')\nconst kOptions = Symbol('options')\nconst kCurrentOptions = Symbol('currentOptions')\nconst kPosition = Symbol('position')\nconst kLocation = Symbol('location')\nconst kFirst = Symbol('first')\nconst emptyOptions = {}\n\nclass Iterator extends AbstractIterator {\n  constructor (db, location, options) {\n    super(db, options)\n\n    this[kCache] = []\n    this[kFinished] = this.limit === 0\n    this[kOptions] = options\n    this[kCurrentOptions] = { ...options }\n    this[kPosition] = undefined\n    this[kLocation] = location\n    this[kFirst] = true\n  }\n\n  // Note: if called by _all() then size can be Infinity. This is an internal\n  // detail; by design AbstractIterator.nextv() does not support Infinity.\n  _nextv (size, options, callback) {\n    this[kFirst] = false\n\n    if (this[kFinished]) {\n      return this.nextTick(callback, null, [])\n    } else if (this[kCache].length > 0) {\n      // TODO: mixing next and nextv is not covered by test suite\n      size = Math.min(size, this[kCache].length)\n      return this.nextTick(callback, null, this[kCache].splice(0, size))\n    }\n\n    // Adjust range by what we already visited\n    if (this[kPosition] !== undefined) {\n      if (this[kOptions].reverse) {\n        this[kCurrentOptions].lt = this[kPosition]\n        this[kCurrentOptions].lte = undefined\n      } else {\n        this[kCurrentOptions].gt = this[kPosition]\n        this[kCurrentOptions].gte = undefined\n      }\n    }\n\n    let keyRange\n\n    try {\n      keyRange = createKeyRange(this[kCurrentOptions])\n    } catch (_) {\n      // The lower key is greater than the upper key.\n      // IndexedDB throws an error, but we'll just return 0 results.\n      this[kFinished] = true\n      return this.nextTick(callback, null, [])\n    }\n\n    const transaction = this.db.db.transaction([this[kLocation]], 'readonly')\n    const store = transaction.objectStore(this[kLocation])\n    const entries = []\n\n    if (!this[kOptions].reverse) {\n      let keys\n      let values\n\n      const complete = () => {\n        // Wait for both requests to complete\n        if (keys === undefined || values === undefined) return\n\n        const length = Math.max(keys.length, values.length)\n\n        if (length === 0 || size === Infinity) {\n          this[kFinished] = true\n        } else {\n          this[kPosition] = keys[length - 1]\n        }\n\n        // Resize\n        entries.length = length\n\n        // Merge keys and values\n        for (let i = 0; i < length; i++) {\n          const key = keys[i]\n          const value = values[i]\n\n          entries[i] = [\n            this[kOptions].keys && key !== undefined ? deserialize(key) : undefined,\n            this[kOptions].values && value !== undefined ? deserialize(value) : undefined\n          ]\n        }\n\n        maybeCommit(transaction)\n      }\n\n      // If keys were not requested and size is Infinity, we don't have to keep\n      // track of position and can thus skip getting keys.\n      if (this[kOptions].keys || size < Infinity) {\n        store.getAllKeys(keyRange, size < Infinity ? size : undefined).onsuccess = (ev) => {\n          keys = ev.target.result\n          complete()\n        }\n      } else {\n        keys = []\n        this.nextTick(complete)\n      }\n\n      if (this[kOptions].values) {\n        store.getAll(keyRange, size < Infinity ? size : undefined).onsuccess = (ev) => {\n          values = ev.target.result\n          complete()\n        }\n      } else {\n        values = []\n        this.nextTick(complete)\n      }\n    } else {\n      // Can't use getAll() in reverse, so use a slower cursor that yields one item at a time\n      // TODO: test if all target browsers support openKeyCursor\n      const method = !this[kOptions].values && store.openKeyCursor ? 'openKeyCursor' : 'openCursor'\n\n      store[method](keyRange, 'prev').onsuccess = (ev) => {\n        const cursor = ev.target.result\n\n        if (cursor) {\n          const { key, value } = cursor\n          this[kPosition] = key\n\n          entries.push([\n            this[kOptions].keys && key !== undefined ? deserialize(key) : undefined,\n            this[kOptions].values && value !== undefined ? deserialize(value) : undefined\n          ])\n\n          if (entries.length < size) {\n            cursor.continue()\n          } else {\n            maybeCommit(transaction)\n          }\n        } else {\n          this[kFinished] = true\n        }\n      }\n    }\n\n    // If an error occurs (on the request), the transaction will abort.\n    transaction.onabort = () => {\n      callback(transaction.error || new Error('aborted by user'))\n      callback = null\n    }\n\n    transaction.oncomplete = () => {\n      callback(null, entries)\n      callback = null\n    }\n  }\n\n  _next (callback) {\n    if (this[kCache].length > 0) {\n      const [key, value] = this[kCache].shift()\n      this.nextTick(callback, null, key, value)\n    } else if (this[kFinished]) {\n      this.nextTick(callback)\n    } else {\n      let size = Math.min(100, this.limit - this.count)\n\n      if (this[kFirst]) {\n        // It's common to only want one entry initially or after a seek()\n        this[kFirst] = false\n        size = 1\n      }\n\n      this._nextv(size, emptyOptions, (err, entries) => {\n        if (err) return callback(err)\n        this[kCache] = entries\n        this._next(callback)\n      })\n    }\n  }\n\n  _all (options, callback) {\n    this[kFirst] = false\n\n    // TODO: mixing next and all is not covered by test suite\n    const cache = this[kCache].splice(0, this[kCache].length)\n    const size = this.limit - this.count - cache.length\n\n    if (size <= 0) {\n      return this.nextTick(callback, null, cache)\n    }\n\n    this._nextv(size, emptyOptions, (err, entries) => {\n      if (err) return callback(err)\n      if (cache.length > 0) entries = cache.concat(entries)\n      callback(null, entries)\n    })\n  }\n\n  _seek (target, options) {\n    this[kFirst] = true\n    this[kCache] = []\n    this[kFinished] = false\n    this[kPosition] = undefined\n\n    // TODO: not covered by test suite\n    this[kCurrentOptions] = { ...this[kOptions] }\n\n    let keyRange\n\n    try {\n      keyRange = createKeyRange(this[kOptions])\n    } catch (_) {\n      this[kFinished] = true\n      return\n    }\n\n    if (keyRange !== null && !keyRange.includes(target)) {\n      this[kFinished] = true\n    } else if (this[kOptions].reverse) {\n      this[kCurrentOptions].lte = target\n    } else {\n      this[kCurrentOptions].gte = target\n    }\n  }\n}\n\nexports.Iterator = Iterator\n\nfunction maybeCommit (transaction) {\n  // Commit (meaning close) now instead of waiting for auto-commit\n  if (typeof transaction.commit === 'function') {\n    transaction.commit()\n  }\n}\n","'use strict'\n\nmodule.exports = function clear (db, location, keyRange, options, callback) {\n  if (options.limit === 0) return db.nextTick(callback)\n\n  const transaction = db.db.transaction([location], 'readwrite')\n  const store = transaction.objectStore(location)\n  let count = 0\n\n  transaction.oncomplete = function () {\n    callback()\n  }\n\n  transaction.onabort = function () {\n    callback(transaction.error || new Error('aborted by user'))\n  }\n\n  // A key cursor is faster (skips reading values) but not supported by IE\n  // TODO: we no longer support IE. Test others\n  const method = store.openKeyCursor ? 'openKeyCursor' : 'openCursor'\n  const direction = options.reverse ? 'prev' : 'next'\n\n  store[method](keyRange, direction).onsuccess = function (ev) {\n    const cursor = ev.target.result\n\n    if (cursor) {\n      // Wait for a request to complete before continuing, saving CPU.\n      store.delete(cursor.key).onsuccess = function () {\n        if (options.limit <= 0 || ++count < options.limit) {\n          cursor.continue()\n        }\n      }\n    }\n  }\n}\n","'use strict'\n\nconst textEncoder = new TextEncoder()\n\nmodule.exports = function (data) {\n  if (data instanceof Uint8Array) {\n    return data\n  } else if (data instanceof ArrayBuffer) {\n    return new Uint8Array(data)\n  } else {\n    // Non-binary data stored with an old version (level-js < 5.0.0)\n    return textEncoder.encode(data)\n  }\n}\n","/* global IDBKeyRange */\n\n'use strict'\n\nmodule.exports = function createKeyRange (options) {\n  const lower = options.gte !== undefined ? options.gte : options.gt !== undefined ? options.gt : undefined\n  const upper = options.lte !== undefined ? options.lte : options.lt !== undefined ? options.lt : undefined\n  const lowerExclusive = options.gte === undefined\n  const upperExclusive = options.lte === undefined\n\n  if (lower !== undefined && upper !== undefined) {\n    return IDBKeyRange.bound(lower, upper, lowerExclusive, upperExclusive)\n  } else if (lower !== undefined) {\n    return IDBKeyRange.lowerBound(lower, lowerExclusive)\n  } else if (upper !== undefined) {\n    return IDBKeyRange.upperBound(upper, upperExclusive)\n  } else {\n    return null\n  }\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n","'use strict'\n\nvar nextTick = require('./next-tick')\n\nexports.fromCallback = function (callback, symbol) {\n  if (callback === undefined) {\n    var promise = new Promise(function (resolve, reject) {\n      callback = function (err, res) {\n        if (err) reject(err)\n        else resolve(res)\n      }\n    })\n\n    callback[symbol !== undefined ? symbol : 'promise'] = promise\n  } else if (typeof callback !== 'function') {\n    throw new TypeError('Callback must be a function')\n  }\n\n  return callback\n}\n\nexports.fromPromise = function (promise, callback) {\n  if (callback === undefined) return promise\n\n  promise\n    .then(function (res) { nextTick(() => callback(null, res)) })\n    .catch(function (err) { nextTick(() => callback(err)) })\n}\n","module.exports = typeof queueMicrotask === 'function' ? queueMicrotask : (fn) => Promise.resolve().then(fn)\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict'\n\nexports.supports = function supports (...manifests) {\n  const manifest = manifests.reduce((acc, m) => Object.assign(acc, m), {})\n\n  return Object.assign(manifest, {\n    snapshots: manifest.snapshots || false,\n    permanence: manifest.permanence || false,\n    seek: manifest.seek || false,\n    clear: manifest.clear || false,\n    getMany: manifest.getMany || false,\n    keyIterator: manifest.keyIterator || false,\n    valueIterator: manifest.valueIterator || false,\n    iteratorNextv: manifest.iteratorNextv || false,\n    iteratorAll: manifest.iteratorAll || false,\n    status: manifest.status || false,\n    createIfMissing: manifest.createIfMissing || false,\n    errorIfExists: manifest.errorIfExists || false,\n    deferredOpen: manifest.deferredOpen || false,\n    promises: manifest.promises || false,\n    streams: manifest.streams || false,\n    encodings: Object.assign({}, manifest.encodings),\n    events: Object.assign({}, manifest.events),\n    additionalMethods: Object.assign({}, manifest.additionalMethods)\n  })\n}\n","'use strict'\n\nconst ModuleError = require('module-error')\nconst encodings = require('./lib/encodings')\nconst { Encoding } = require('./lib/encoding')\nconst { BufferFormat, ViewFormat, UTF8Format } = require('./lib/formats')\n\nconst kFormats = Symbol('formats')\nconst kEncodings = Symbol('encodings')\nconst validFormats = new Set(['buffer', 'view', 'utf8'])\n\n/** @template T */\nclass Transcoder {\n  /**\n   * @param {Array<'buffer'|'view'|'utf8'>} formats\n   */\n  constructor (formats) {\n    if (!Array.isArray(formats)) {\n      throw new TypeError(\"The first argument 'formats' must be an array\")\n    } else if (!formats.every(f => validFormats.has(f))) {\n      // Note: we only only support aliases in key- and valueEncoding options (where we already did)\n      throw new TypeError(\"Format must be one of 'buffer', 'view', 'utf8'\")\n    }\n\n    /** @type {Map<string|MixedEncoding<any, any, any>, Encoding<any, any, any>>} */\n    this[kEncodings] = new Map()\n    this[kFormats] = new Set(formats)\n\n    // Register encodings (done early in order to populate encodings())\n    for (const k in encodings) {\n      try {\n        this.encoding(k)\n      } catch (err) {\n        /* istanbul ignore if: assertion */\n        if (err.code !== 'LEVEL_ENCODING_NOT_SUPPORTED') throw err\n      }\n    }\n  }\n\n  /**\n   * @returns {Array<Encoding<any,T,any>>}\n   */\n  encodings () {\n    return Array.from(new Set(this[kEncodings].values()))\n  }\n\n  /**\n   * @param {string|MixedEncoding<any, any, any>} encoding\n   * @returns {Encoding<any, T, any>}\n   */\n  encoding (encoding) {\n    let resolved = this[kEncodings].get(encoding)\n\n    if (resolved === undefined) {\n      if (typeof encoding === 'string' && encoding !== '') {\n        resolved = lookup[encoding]\n\n        if (!resolved) {\n          throw new ModuleError(`Encoding '${encoding}' is not found`, {\n            code: 'LEVEL_ENCODING_NOT_FOUND'\n          })\n        }\n      } else if (typeof encoding !== 'object' || encoding === null) {\n        throw new TypeError(\"First argument 'encoding' must be a string or object\")\n      } else {\n        resolved = from(encoding)\n      }\n\n      const { name, format } = resolved\n\n      if (!this[kFormats].has(format)) {\n        if (this[kFormats].has('view')) {\n          resolved = resolved.createViewTranscoder()\n        } else if (this[kFormats].has('buffer')) {\n          resolved = resolved.createBufferTranscoder()\n        } else if (this[kFormats].has('utf8')) {\n          resolved = resolved.createUTF8Transcoder()\n        } else {\n          throw new ModuleError(`Encoding '${name}' cannot be transcoded`, {\n            code: 'LEVEL_ENCODING_NOT_SUPPORTED'\n          })\n        }\n      }\n\n      for (const k of [encoding, name, resolved.name, resolved.commonName]) {\n        this[kEncodings].set(k, resolved)\n      }\n    }\n\n    return resolved\n  }\n}\n\nexports.Transcoder = Transcoder\n\n/**\n * @param {MixedEncoding<any, any, any>} options\n * @returns {Encoding<any, any, any>}\n */\nfunction from (options) {\n  if (options instanceof Encoding) {\n    return options\n  }\n\n  // Loosely typed for ecosystem compatibility\n  const maybeType = 'type' in options && typeof options.type === 'string' ? options.type : undefined\n  const name = options.name || maybeType || `anonymous-${anonymousCount++}`\n\n  switch (detectFormat(options)) {\n    case 'view': return new ViewFormat({ ...options, name })\n    case 'utf8': return new UTF8Format({ ...options, name })\n    case 'buffer': return new BufferFormat({ ...options, name })\n    default: {\n      throw new TypeError(\"Format must be one of 'buffer', 'view', 'utf8'\")\n    }\n  }\n}\n\n/**\n * If format is not provided, fallback to detecting `level-codec`\n * or `multiformats` encodings, else assume a format of buffer.\n * @param {MixedEncoding<any, any, any>} options\n * @returns {string}\n */\nfunction detectFormat (options) {\n  if ('format' in options && options.format !== undefined) {\n    return options.format\n  } else if ('buffer' in options && typeof options.buffer === 'boolean') {\n    return options.buffer ? 'buffer' : 'utf8' // level-codec\n  } else if ('code' in options && Number.isInteger(options.code)) {\n    return 'view' // multiformats\n  } else {\n    return 'buffer'\n  }\n}\n\n/**\n * @typedef {import('./lib/encoding').MixedEncoding<TIn,TFormat,TOut>} MixedEncoding\n * @template TIn, TFormat, TOut\n */\n\n/**\n * @type {Object.<string, Encoding<any, any, any>>}\n */\nconst aliases = {\n  binary: encodings.buffer,\n  'utf-8': encodings.utf8\n}\n\n/**\n * @type {Object.<string, Encoding<any, any, any>>}\n */\nconst lookup = {\n  ...encodings,\n  ...aliases\n}\n\nlet anonymousCount = 0\n","'use strict'\n\nconst ModuleError = require('module-error')\nconst formats = new Set(['buffer', 'view', 'utf8'])\n\n/**\n * @template TIn, TFormat, TOut\n * @abstract\n */\nclass Encoding {\n  /**\n   * @param {IEncoding<TIn,TFormat,TOut>} options\n   */\n  constructor (options) {\n    /** @type {(data: TIn) => TFormat} */\n    this.encode = options.encode || this.encode\n\n    /** @type {(data: TFormat) => TOut} */\n    this.decode = options.decode || this.decode\n\n    /** @type {string} */\n    this.name = options.name || this.name\n\n    /** @type {string} */\n    this.format = options.format || this.format\n\n    if (typeof this.encode !== 'function') {\n      throw new TypeError(\"The 'encode' property must be a function\")\n    }\n\n    if (typeof this.decode !== 'function') {\n      throw new TypeError(\"The 'decode' property must be a function\")\n    }\n\n    this.encode = this.encode.bind(this)\n    this.decode = this.decode.bind(this)\n\n    if (typeof this.name !== 'string' || this.name === '') {\n      throw new TypeError(\"The 'name' property must be a string\")\n    }\n\n    if (typeof this.format !== 'string' || !formats.has(this.format)) {\n      throw new TypeError(\"The 'format' property must be one of 'buffer', 'view', 'utf8'\")\n    }\n\n    if (options.createViewTranscoder) {\n      this.createViewTranscoder = options.createViewTranscoder\n    }\n\n    if (options.createBufferTranscoder) {\n      this.createBufferTranscoder = options.createBufferTranscoder\n    }\n\n    if (options.createUTF8Transcoder) {\n      this.createUTF8Transcoder = options.createUTF8Transcoder\n    }\n  }\n\n  get commonName () {\n    return /** @type {string} */ (this.name.split('+')[0])\n  }\n\n  /** @return {BufferFormat<TIn,TOut>} */\n  createBufferTranscoder () {\n    throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'buffer'`, {\n      code: 'LEVEL_ENCODING_NOT_SUPPORTED'\n    })\n  }\n\n  /** @return {ViewFormat<TIn,TOut>} */\n  createViewTranscoder () {\n    throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'view'`, {\n      code: 'LEVEL_ENCODING_NOT_SUPPORTED'\n    })\n  }\n\n  /** @return {UTF8Format<TIn,TOut>} */\n  createUTF8Transcoder () {\n    throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'utf8'`, {\n      code: 'LEVEL_ENCODING_NOT_SUPPORTED'\n    })\n  }\n}\n\nexports.Encoding = Encoding\n\n/**\n * @typedef {import('./encoding').IEncoding<TIn,TFormat,TOut>} IEncoding\n * @template TIn, TFormat, TOut\n */\n\n/**\n * @typedef {import('./formats').BufferFormat<TIn,TOut>} BufferFormat\n * @template TIn, TOut\n */\n\n/**\n * @typedef {import('./formats').ViewFormat<TIn,TOut>} ViewFormat\n * @template TIn, TOut\n */\n\n/**\n * @typedef {import('./formats').UTF8Format<TIn,TOut>} UTF8Format\n * @template TIn, TOut\n */\n","'use strict'\n\nconst { Buffer } = require('buffer') || { Buffer: { isBuffer: () => false } }\nconst { textEncoder, textDecoder } = require('./text-endec')()\nconst { BufferFormat, ViewFormat, UTF8Format } = require('./formats')\n\n/** @type {<T>(v: T) => v} */\nconst identity = (v) => v\n\n/**\n * @type {typeof import('./encodings').utf8}\n */\nexports.utf8 = new UTF8Format({\n  encode: function (data) {\n    // On node 16.9.1 buffer.toString() is 5x faster than TextDecoder\n    return Buffer.isBuffer(data)\n      ? data.toString('utf8')\n      : ArrayBuffer.isView(data)\n        ? textDecoder.decode(data)\n        : String(data)\n  },\n  decode: identity,\n  name: 'utf8',\n  createViewTranscoder () {\n    return new ViewFormat({\n      encode: function (data) {\n        return ArrayBuffer.isView(data) ? data : textEncoder.encode(data)\n      },\n      decode: function (data) {\n        return textDecoder.decode(data)\n      },\n      name: `${this.name}+view`\n    })\n  },\n  createBufferTranscoder () {\n    return new BufferFormat({\n      encode: function (data) {\n        return Buffer.isBuffer(data)\n          ? data\n          : ArrayBuffer.isView(data)\n            ? Buffer.from(data.buffer, data.byteOffset, data.byteLength)\n            : Buffer.from(String(data), 'utf8')\n      },\n      decode: function (data) {\n        return data.toString('utf8')\n      },\n      name: `${this.name}+buffer`\n    })\n  }\n})\n\n/**\n * @type {typeof import('./encodings').json}\n */\nexports.json = new UTF8Format({\n  encode: JSON.stringify,\n  decode: JSON.parse,\n  name: 'json'\n})\n\n/**\n * @type {typeof import('./encodings').buffer}\n */\nexports.buffer = new BufferFormat({\n  encode: function (data) {\n    return Buffer.isBuffer(data)\n      ? data\n      : ArrayBuffer.isView(data)\n        ? Buffer.from(data.buffer, data.byteOffset, data.byteLength)\n        : Buffer.from(String(data), 'utf8')\n  },\n  decode: identity,\n  name: 'buffer',\n  createViewTranscoder () {\n    return new ViewFormat({\n      encode: function (data) {\n        return ArrayBuffer.isView(data) ? data : Buffer.from(String(data), 'utf8')\n      },\n      decode: function (data) {\n        return Buffer.from(data.buffer, data.byteOffset, data.byteLength)\n      },\n      name: `${this.name}+view`\n    })\n  }\n})\n\n/**\n * @type {typeof import('./encodings').view}\n */\nexports.view = new ViewFormat({\n  encode: function (data) {\n    return ArrayBuffer.isView(data) ? data : textEncoder.encode(data)\n  },\n  decode: identity,\n  name: 'view',\n  createBufferTranscoder () {\n    return new BufferFormat({\n      encode: function (data) {\n        return Buffer.isBuffer(data)\n          ? data\n          : ArrayBuffer.isView(data)\n            ? Buffer.from(data.buffer, data.byteOffset, data.byteLength)\n            : Buffer.from(String(data), 'utf8')\n      },\n      decode: identity,\n      name: `${this.name}+buffer`\n    })\n  }\n})\n\n/**\n * @type {typeof import('./encodings').hex}\n */\nexports.hex = new BufferFormat({\n  encode: function (data) {\n    return Buffer.isBuffer(data) ? data : Buffer.from(String(data), 'hex')\n  },\n  decode: function (buffer) {\n    return buffer.toString('hex')\n  },\n  name: 'hex'\n})\n\n/**\n * @type {typeof import('./encodings').base64}\n */\nexports.base64 = new BufferFormat({\n  encode: function (data) {\n    return Buffer.isBuffer(data) ? data : Buffer.from(String(data), 'base64')\n  },\n  decode: function (buffer) {\n    return buffer.toString('base64')\n  },\n  name: 'base64'\n})\n","'use strict'\n\nconst { Buffer } = require('buffer') || {}\nconst { Encoding } = require('./encoding')\nconst textEndec = require('./text-endec')\n\n/**\n * @template TIn, TOut\n * @extends {Encoding<TIn,Buffer,TOut>}\n */\nclass BufferFormat extends Encoding {\n  /**\n   * @param {Omit<IEncoding<TIn, Buffer, TOut>, 'format'>} options\n   */\n  constructor (options) {\n    super({ ...options, format: 'buffer' })\n  }\n\n  /** @override */\n  createViewTranscoder () {\n    return new ViewFormat({\n      encode: this.encode, // Buffer is a view (UInt8Array)\n      decode: (data) => this.decode(\n        Buffer.from(data.buffer, data.byteOffset, data.byteLength)\n      ),\n      name: `${this.name}+view`\n    })\n  }\n\n  /** @override */\n  createBufferTranscoder () {\n    return this\n  }\n}\n\n/**\n * @extends {Encoding<TIn,Uint8Array,TOut>}\n * @template TIn, TOut\n */\nclass ViewFormat extends Encoding {\n  /**\n   * @param {Omit<IEncoding<TIn, Uint8Array, TOut>, 'format'>} options\n   */\n  constructor (options) {\n    super({ ...options, format: 'view' })\n  }\n\n  /** @override */\n  createBufferTranscoder () {\n    return new BufferFormat({\n      encode: (data) => {\n        const view = this.encode(data)\n        return Buffer.from(view.buffer, view.byteOffset, view.byteLength)\n      },\n      decode: this.decode, // Buffer is a view (UInt8Array)\n      name: `${this.name}+buffer`\n    })\n  }\n\n  /** @override */\n  createViewTranscoder () {\n    return this\n  }\n}\n\n/**\n * @extends {Encoding<TIn,string,TOut>}\n * @template TIn, TOut\n */\nclass UTF8Format extends Encoding {\n  /**\n   * @param {Omit<IEncoding<TIn, string, TOut>, 'format'>} options\n   */\n  constructor (options) {\n    super({ ...options, format: 'utf8' })\n  }\n\n  /** @override */\n  createBufferTranscoder () {\n    return new BufferFormat({\n      encode: (data) => Buffer.from(this.encode(data), 'utf8'),\n      decode: (data) => this.decode(data.toString('utf8')),\n      name: `${this.name}+buffer`\n    })\n  }\n\n  /** @override */\n  createViewTranscoder () {\n    const { textEncoder, textDecoder } = textEndec()\n\n    return new ViewFormat({\n      encode: (data) => textEncoder.encode(this.encode(data)),\n      decode: (data) => this.decode(textDecoder.decode(data)),\n      name: `${this.name}+view`\n    })\n  }\n\n  /** @override */\n  createUTF8Transcoder () {\n    return this\n  }\n}\n\nexports.BufferFormat = BufferFormat\nexports.ViewFormat = ViewFormat\nexports.UTF8Format = UTF8Format\n\n/**\n * @typedef {import('./encoding').IEncoding<TIn,TFormat,TOut>} IEncoding\n * @template TIn, TFormat, TOut\n */\n","'use strict'\n\n/** @type {{ textEncoder: TextEncoder, textDecoder: TextDecoder }|null} */\nlet lazy = null\n\n/**\n * Get semi-global instances of TextEncoder and TextDecoder.\n * @returns {{ textEncoder: TextEncoder, textDecoder: TextDecoder }}\n */\nmodule.exports = function () {\n  if (lazy === null) {\n    lazy = {\n      textEncoder: new TextEncoder(),\n      textDecoder: new TextDecoder()\n    }\n  }\n\n  return lazy\n}\n","exports.Level = require('browser-level').BrowserLevel\n","var events = require('events')\nvar inherits = require('inherits')\n\nmodule.exports = LRU\n\nfunction LRU (opts) {\n  if (!(this instanceof LRU)) return new LRU(opts)\n  if (typeof opts === 'number') opts = {max: opts}\n  if (!opts) opts = {}\n  events.EventEmitter.call(this)\n  this.cache = {}\n  this.head = this.tail = null\n  this.length = 0\n  this.max = opts.max || 1000\n  this.maxAge = opts.maxAge || 0\n}\n\ninherits(LRU, events.EventEmitter)\n\nObject.defineProperty(LRU.prototype, 'keys', {\n  get: function () { return Object.keys(this.cache) }\n})\n\nLRU.prototype.clear = function () {\n  this.cache = {}\n  this.head = this.tail = null\n  this.length = 0\n}\n\nLRU.prototype.remove = function (key) {\n  if (typeof key !== 'string') key = '' + key\n  if (!this.cache.hasOwnProperty(key)) return\n\n  var element = this.cache[key]\n  delete this.cache[key]\n  this._unlink(key, element.prev, element.next)\n  return element.value\n}\n\nLRU.prototype._unlink = function (key, prev, next) {\n  this.length--\n\n  if (this.length === 0) {\n    this.head = this.tail = null\n  } else {\n    if (this.head === key) {\n      this.head = prev\n      this.cache[this.head].next = null\n    } else if (this.tail === key) {\n      this.tail = next\n      this.cache[this.tail].prev = null\n    } else {\n      this.cache[prev].next = next\n      this.cache[next].prev = prev\n    }\n  }\n}\n\nLRU.prototype.peek = function (key) {\n  if (!this.cache.hasOwnProperty(key)) return\n\n  var element = this.cache[key]\n\n  if (!this._checkAge(key, element)) return\n  return element.value\n}\n\nLRU.prototype.set = function (key, value) {\n  if (typeof key !== 'string') key = '' + key\n\n  var element\n\n  if (this.cache.hasOwnProperty(key)) {\n    element = this.cache[key]\n    element.value = value\n    if (this.maxAge) element.modified = Date.now()\n\n    // If it's already the head, there's nothing more to do:\n    if (key === this.head) return value\n    this._unlink(key, element.prev, element.next)\n  } else {\n    element = {value: value, modified: 0, next: null, prev: null}\n    if (this.maxAge) element.modified = Date.now()\n    this.cache[key] = element\n\n    // Eviction is only possible if the key didn't already exist:\n    if (this.length === this.max) this.evict()\n  }\n\n  this.length++\n  element.next = null\n  element.prev = this.head\n\n  if (this.head) this.cache[this.head].next = key\n  this.head = key\n\n  if (!this.tail) this.tail = key\n  return value\n}\n\nLRU.prototype._checkAge = function (key, element) {\n  if (this.maxAge && (Date.now() - element.modified) > this.maxAge) {\n    this.remove(key)\n    this.emit('evict', {key: key, value: element.value})\n    return false\n  }\n  return true\n}\n\nLRU.prototype.get = function (key) {\n  if (typeof key !== 'string') key = '' + key\n  if (!this.cache.hasOwnProperty(key)) return\n\n  var element = this.cache[key]\n\n  if (!this._checkAge(key, element)) return\n\n  if (this.head !== key) {\n    if (key === this.tail) {\n      this.tail = element.next\n      this.cache[this.tail].prev = null\n    } else {\n      // Set prev.next -> element.next:\n      this.cache[element.prev].next = element.next\n    }\n\n    // Set element.next.prev -> element.prev:\n    this.cache[element.next].prev = element.prev\n\n    // Element is the new head\n    this.cache[this.head].next = key\n    element.prev = this.head\n    element.next = null\n    this.head = key\n  }\n\n  return element.value\n}\n\nLRU.prototype.evict = function () {\n  if (!this.tail) return\n  var key = this.tail\n  var value = this.remove(this.tail)\n  this.emit('evict', {key: key, value: value})\n}\n","'use strict'\n\nmodule.exports = class ModuleError extends Error {\n  /**\n   * @param {string} message Error message\n   * @param {{ code?: string, cause?: Error, expected?: boolean, transient?: boolean }} [options]\n   */\n  constructor (message, options) {\n    super(message || '')\n\n    if (typeof options === 'object' && options !== null) {\n      if (options.code) this.code = String(options.code)\n      if (options.expected) this.expected = true\n      if (options.transient) this.transient = true\n      if (options.cause) this.cause = options.cause\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor)\n    }\n  }\n}\n","/*!\n * MIT License\n * \n * Copyright (c) 2017-2022 Peculiar Ventures, LLC\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n * \n */\n\n'use strict';\n\nconst ARRAY_BUFFER_NAME = \"[object ArrayBuffer]\";\nclass BufferSourceConverter {\n    static isArrayBuffer(data) {\n        return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;\n    }\n    static toArrayBuffer(data) {\n        if (this.isArrayBuffer(data)) {\n            return data;\n        }\n        if (data.byteLength === data.buffer.byteLength) {\n            return data.buffer;\n        }\n        if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {\n            return data.buffer;\n        }\n        return this.toUint8Array(data.buffer)\n            .slice(data.byteOffset, data.byteOffset + data.byteLength)\n            .buffer;\n    }\n    static toUint8Array(data) {\n        return this.toView(data, Uint8Array);\n    }\n    static toView(data, type) {\n        if (data.constructor === type) {\n            return data;\n        }\n        if (this.isArrayBuffer(data)) {\n            return new type(data);\n        }\n        if (this.isArrayBufferView(data)) {\n            return new type(data.buffer, data.byteOffset, data.byteLength);\n        }\n        throw new TypeError(\"The provided value is not of type '(ArrayBuffer or ArrayBufferView)'\");\n    }\n    static isBufferSource(data) {\n        return this.isArrayBufferView(data)\n            || this.isArrayBuffer(data);\n    }\n    static isArrayBufferView(data) {\n        return ArrayBuffer.isView(data)\n            || (data && this.isArrayBuffer(data.buffer));\n    }\n    static isEqual(a, b) {\n        const aView = BufferSourceConverter.toUint8Array(a);\n        const bView = BufferSourceConverter.toUint8Array(b);\n        if (aView.length !== bView.byteLength) {\n            return false;\n        }\n        for (let i = 0; i < aView.length; i++) {\n            if (aView[i] !== bView[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static concat(...args) {\n        let buffers;\n        if (Array.isArray(args[0]) && !(args[1] instanceof Function)) {\n            buffers = args[0];\n        }\n        else if (Array.isArray(args[0]) && args[1] instanceof Function) {\n            buffers = args[0];\n        }\n        else {\n            if (args[args.length - 1] instanceof Function) {\n                buffers = args.slice(0, args.length - 1);\n            }\n            else {\n                buffers = args;\n            }\n        }\n        let size = 0;\n        for (const buffer of buffers) {\n            size += buffer.byteLength;\n        }\n        const res = new Uint8Array(size);\n        let offset = 0;\n        for (const buffer of buffers) {\n            const view = this.toUint8Array(buffer);\n            res.set(view, offset);\n            offset += view.length;\n        }\n        if (args[args.length - 1] instanceof Function) {\n            return this.toView(res, args[args.length - 1]);\n        }\n        return res.buffer;\n    }\n}\n\nconst STRING_TYPE = \"string\";\nconst HEX_REGEX = /^[0-9a-f]+$/i;\nconst BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;\nconst BASE64URL_REGEX = /^[a-zA-Z0-9-_]+$/;\nclass Utf8Converter {\n    static fromString(text) {\n        const s = unescape(encodeURIComponent(text));\n        const uintArray = new Uint8Array(s.length);\n        for (let i = 0; i < s.length; i++) {\n            uintArray[i] = s.charCodeAt(i);\n        }\n        return uintArray.buffer;\n    }\n    static toString(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        let encodedString = \"\";\n        for (let i = 0; i < buf.length; i++) {\n            encodedString += String.fromCharCode(buf[i]);\n        }\n        const decodedString = decodeURIComponent(escape(encodedString));\n        return decodedString;\n    }\n}\nclass Utf16Converter {\n    static toString(buffer, littleEndian = false) {\n        const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);\n        const dataView = new DataView(arrayBuffer);\n        let res = \"\";\n        for (let i = 0; i < arrayBuffer.byteLength; i += 2) {\n            const code = dataView.getUint16(i, littleEndian);\n            res += String.fromCharCode(code);\n        }\n        return res;\n    }\n    static fromString(text, littleEndian = false) {\n        const res = new ArrayBuffer(text.length * 2);\n        const dataView = new DataView(res);\n        for (let i = 0; i < text.length; i++) {\n            dataView.setUint16(i * 2, text.charCodeAt(i), littleEndian);\n        }\n        return res;\n    }\n}\nclass Convert {\n    static isHex(data) {\n        return typeof data === STRING_TYPE\n            && HEX_REGEX.test(data);\n    }\n    static isBase64(data) {\n        return typeof data === STRING_TYPE\n            && BASE64_REGEX.test(data);\n    }\n    static isBase64Url(data) {\n        return typeof data === STRING_TYPE\n            && BASE64URL_REGEX.test(data);\n    }\n    static ToString(buffer, enc = \"utf8\") {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        switch (enc.toLowerCase()) {\n            case \"utf8\":\n                return this.ToUtf8String(buf);\n            case \"binary\":\n                return this.ToBinary(buf);\n            case \"hex\":\n                return this.ToHex(buf);\n            case \"base64\":\n                return this.ToBase64(buf);\n            case \"base64url\":\n                return this.ToBase64Url(buf);\n            case \"utf16le\":\n                return Utf16Converter.toString(buf, true);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.toString(buf);\n            default:\n                throw new Error(`Unknown type of encoding '${enc}'`);\n        }\n    }\n    static FromString(str, enc = \"utf8\") {\n        if (!str) {\n            return new ArrayBuffer(0);\n        }\n        switch (enc.toLowerCase()) {\n            case \"utf8\":\n                return this.FromUtf8String(str);\n            case \"binary\":\n                return this.FromBinary(str);\n            case \"hex\":\n                return this.FromHex(str);\n            case \"base64\":\n                return this.FromBase64(str);\n            case \"base64url\":\n                return this.FromBase64Url(str);\n            case \"utf16le\":\n                return Utf16Converter.fromString(str, true);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.fromString(str);\n            default:\n                throw new Error(`Unknown type of encoding '${enc}'`);\n        }\n    }\n    static ToBase64(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        if (typeof btoa !== \"undefined\") {\n            const binary = this.ToString(buf, \"binary\");\n            return btoa(binary);\n        }\n        else {\n            return Buffer.from(buf).toString(\"base64\");\n        }\n    }\n    static FromBase64(base64) {\n        const formatted = this.formatString(base64);\n        if (!formatted) {\n            return new ArrayBuffer(0);\n        }\n        if (!Convert.isBase64(formatted)) {\n            throw new TypeError(\"Argument 'base64Text' is not Base64 encoded\");\n        }\n        if (typeof atob !== \"undefined\") {\n            return this.FromBinary(atob(formatted));\n        }\n        else {\n            return new Uint8Array(Buffer.from(formatted, \"base64\")).buffer;\n        }\n    }\n    static FromBase64Url(base64url) {\n        const formatted = this.formatString(base64url);\n        if (!formatted) {\n            return new ArrayBuffer(0);\n        }\n        if (!Convert.isBase64Url(formatted)) {\n            throw new TypeError(\"Argument 'base64url' is not Base64Url encoded\");\n        }\n        return this.FromBase64(this.Base64Padding(formatted.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\")));\n    }\n    static ToBase64Url(data) {\n        return this.ToBase64(data).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/\\=/g, \"\");\n    }\n    static FromUtf8String(text, encoding = Convert.DEFAULT_UTF8_ENCODING) {\n        switch (encoding) {\n            case \"ascii\":\n                return this.FromBinary(text);\n            case \"utf8\":\n                return Utf8Converter.fromString(text);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.fromString(text);\n            case \"utf16le\":\n            case \"usc2\":\n                return Utf16Converter.fromString(text, true);\n            default:\n                throw new Error(`Unknown type of encoding '${encoding}'`);\n        }\n    }\n    static ToUtf8String(buffer, encoding = Convert.DEFAULT_UTF8_ENCODING) {\n        switch (encoding) {\n            case \"ascii\":\n                return this.ToBinary(buffer);\n            case \"utf8\":\n                return Utf8Converter.toString(buffer);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.toString(buffer);\n            case \"utf16le\":\n            case \"usc2\":\n                return Utf16Converter.toString(buffer, true);\n            default:\n                throw new Error(`Unknown type of encoding '${encoding}'`);\n        }\n    }\n    static FromBinary(text) {\n        const stringLength = text.length;\n        const resultView = new Uint8Array(stringLength);\n        for (let i = 0; i < stringLength; i++) {\n            resultView[i] = text.charCodeAt(i);\n        }\n        return resultView.buffer;\n    }\n    static ToBinary(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        let res = \"\";\n        for (let i = 0; i < buf.length; i++) {\n            res += String.fromCharCode(buf[i]);\n        }\n        return res;\n    }\n    static ToHex(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        let result = \"\";\n        const len = buf.length;\n        for (let i = 0; i < len; i++) {\n            const byte = buf[i];\n            if (byte < 16) {\n                result += \"0\";\n            }\n            result += byte.toString(16);\n        }\n        return result;\n    }\n    static FromHex(hexString) {\n        let formatted = this.formatString(hexString);\n        if (!formatted) {\n            return new ArrayBuffer(0);\n        }\n        if (!Convert.isHex(formatted)) {\n            throw new TypeError(\"Argument 'hexString' is not HEX encoded\");\n        }\n        if (formatted.length % 2) {\n            formatted = `0${formatted}`;\n        }\n        const res = new Uint8Array(formatted.length / 2);\n        for (let i = 0; i < formatted.length; i = i + 2) {\n            const c = formatted.slice(i, i + 2);\n            res[i / 2] = parseInt(c, 16);\n        }\n        return res.buffer;\n    }\n    static ToUtf16String(buffer, littleEndian = false) {\n        return Utf16Converter.toString(buffer, littleEndian);\n    }\n    static FromUtf16String(text, littleEndian = false) {\n        return Utf16Converter.fromString(text, littleEndian);\n    }\n    static Base64Padding(base64) {\n        const padCount = 4 - (base64.length % 4);\n        if (padCount < 4) {\n            for (let i = 0; i < padCount; i++) {\n                base64 += \"=\";\n            }\n        }\n        return base64;\n    }\n    static formatString(data) {\n        return (data === null || data === void 0 ? void 0 : data.replace(/[\\n\\r\\t ]/g, \"\")) || \"\";\n    }\n}\nConvert.DEFAULT_UTF8_ENCODING = \"utf8\";\n\nfunction assign(target, ...sources) {\n    const res = arguments[0];\n    for (let i = 1; i < arguments.length; i++) {\n        const obj = arguments[i];\n        for (const prop in obj) {\n            res[prop] = obj[prop];\n        }\n    }\n    return res;\n}\nfunction combine(...buf) {\n    const totalByteLength = buf.map((item) => item.byteLength).reduce((prev, cur) => prev + cur);\n    const res = new Uint8Array(totalByteLength);\n    let currentPos = 0;\n    buf.map((item) => new Uint8Array(item)).forEach((arr) => {\n        for (const item2 of arr) {\n            res[currentPos++] = item2;\n        }\n    });\n    return res.buffer;\n}\nfunction isEqual(bytes1, bytes2) {\n    if (!(bytes1 && bytes2)) {\n        return false;\n    }\n    if (bytes1.byteLength !== bytes2.byteLength) {\n        return false;\n    }\n    const b1 = new Uint8Array(bytes1);\n    const b2 = new Uint8Array(bytes2);\n    for (let i = 0; i < bytes1.byteLength; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nexports.BufferSourceConverter = BufferSourceConverter;\nexports.Convert = Convert;\nexports.assign = assign;\nexports.combine = combine;\nexports.isEqual = isEqual;\n","/*!\n Copyright (c) Peculiar Ventures, LLC\n*/\n\nfunction getUTCDate(date) {\r\n    return new Date(date.getTime() + (date.getTimezoneOffset() * 60000));\r\n}\r\nfunction getParametersValue(parameters, name, defaultValue) {\r\n    var _a;\r\n    if ((parameters instanceof Object) === false) {\r\n        return defaultValue;\r\n    }\r\n    return (_a = parameters[name]) !== null && _a !== void 0 ? _a : defaultValue;\r\n}\r\nfunction bufferToHexCodes(inputBuffer, inputOffset = 0, inputLength = (inputBuffer.byteLength - inputOffset), insertSpace = false) {\r\n    let result = \"\";\r\n    for (const item of (new Uint8Array(inputBuffer, inputOffset, inputLength))) {\r\n        const str = item.toString(16).toUpperCase();\r\n        if (str.length === 1) {\r\n            result += \"0\";\r\n        }\r\n        result += str;\r\n        if (insertSpace) {\r\n            result += \" \";\r\n        }\r\n    }\r\n    return result.trim();\r\n}\r\nfunction checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {\r\n    if (!(inputBuffer instanceof ArrayBuffer)) {\r\n        baseBlock.error = \"Wrong parameter: inputBuffer must be \\\"ArrayBuffer\\\"\";\r\n        return false;\r\n    }\r\n    if (!inputBuffer.byteLength) {\r\n        baseBlock.error = \"Wrong parameter: inputBuffer has zero length\";\r\n        return false;\r\n    }\r\n    if (inputOffset < 0) {\r\n        baseBlock.error = \"Wrong parameter: inputOffset less than zero\";\r\n        return false;\r\n    }\r\n    if (inputLength < 0) {\r\n        baseBlock.error = \"Wrong parameter: inputLength less than zero\";\r\n        return false;\r\n    }\r\n    if ((inputBuffer.byteLength - inputOffset - inputLength) < 0) {\r\n        baseBlock.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nfunction utilFromBase(inputBuffer, inputBase) {\r\n    let result = 0;\r\n    if (inputBuffer.length === 1) {\r\n        return inputBuffer[0];\r\n    }\r\n    for (let i = (inputBuffer.length - 1); i >= 0; i--) {\r\n        result += inputBuffer[(inputBuffer.length - 1) - i] * Math.pow(2, inputBase * i);\r\n    }\r\n    return result;\r\n}\r\nfunction utilToBase(value, base, reserved = (-1)) {\r\n    const internalReserved = reserved;\r\n    let internalValue = value;\r\n    let result = 0;\r\n    let biggest = Math.pow(2, base);\r\n    for (let i = 1; i < 8; i++) {\r\n        if (value < biggest) {\r\n            let retBuf;\r\n            if (internalReserved < 0) {\r\n                retBuf = new ArrayBuffer(i);\r\n                result = i;\r\n            }\r\n            else {\r\n                if (internalReserved < i) {\r\n                    return (new ArrayBuffer(0));\r\n                }\r\n                retBuf = new ArrayBuffer(internalReserved);\r\n                result = internalReserved;\r\n            }\r\n            const retView = new Uint8Array(retBuf);\r\n            for (let j = (i - 1); j >= 0; j--) {\r\n                const basis = Math.pow(2, j * base);\r\n                retView[result - j - 1] = Math.floor(internalValue / basis);\r\n                internalValue -= (retView[result - j - 1]) * basis;\r\n            }\r\n            return retBuf;\r\n        }\r\n        biggest *= Math.pow(2, base);\r\n    }\r\n    return new ArrayBuffer(0);\r\n}\r\nfunction utilConcatBuf(...buffers) {\r\n    let outputLength = 0;\r\n    let prevLength = 0;\r\n    for (const buffer of buffers) {\r\n        outputLength += buffer.byteLength;\r\n    }\r\n    const retBuf = new ArrayBuffer(outputLength);\r\n    const retView = new Uint8Array(retBuf);\r\n    for (const buffer of buffers) {\r\n        retView.set(new Uint8Array(buffer), prevLength);\r\n        prevLength += buffer.byteLength;\r\n    }\r\n    return retBuf;\r\n}\r\nfunction utilConcatView(...views) {\r\n    let outputLength = 0;\r\n    let prevLength = 0;\r\n    for (const view of views) {\r\n        outputLength += view.length;\r\n    }\r\n    const retBuf = new ArrayBuffer(outputLength);\r\n    const retView = new Uint8Array(retBuf);\r\n    for (const view of views) {\r\n        retView.set(view, prevLength);\r\n        prevLength += view.length;\r\n    }\r\n    return retView;\r\n}\r\nfunction utilDecodeTC() {\r\n    const buf = new Uint8Array(this.valueHex);\r\n    if (this.valueHex.byteLength >= 2) {\r\n        const condition1 = (buf[0] === 0xFF) && (buf[1] & 0x80);\r\n        const condition2 = (buf[0] === 0x00) && ((buf[1] & 0x80) === 0x00);\r\n        if (condition1 || condition2) {\r\n            this.warnings.push(\"Needlessly long format\");\r\n        }\r\n    }\r\n    const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);\r\n    const bigIntView = new Uint8Array(bigIntBuffer);\r\n    for (let i = 0; i < this.valueHex.byteLength; i++) {\r\n        bigIntView[i] = 0;\r\n    }\r\n    bigIntView[0] = (buf[0] & 0x80);\r\n    const bigInt = utilFromBase(bigIntView, 8);\r\n    const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);\r\n    const smallIntView = new Uint8Array(smallIntBuffer);\r\n    for (let j = 0; j < this.valueHex.byteLength; j++) {\r\n        smallIntView[j] = buf[j];\r\n    }\r\n    smallIntView[0] &= 0x7F;\r\n    const smallInt = utilFromBase(smallIntView, 8);\r\n    return (smallInt - bigInt);\r\n}\r\nfunction utilEncodeTC(value) {\r\n    const modValue = (value < 0) ? (value * (-1)) : value;\r\n    let bigInt = 128;\r\n    for (let i = 1; i < 8; i++) {\r\n        if (modValue <= bigInt) {\r\n            if (value < 0) {\r\n                const smallInt = bigInt - modValue;\r\n                const retBuf = utilToBase(smallInt, 8, i);\r\n                const retView = new Uint8Array(retBuf);\r\n                retView[0] |= 0x80;\r\n                return retBuf;\r\n            }\r\n            let retBuf = utilToBase(modValue, 8, i);\r\n            let retView = new Uint8Array(retBuf);\r\n            if (retView[0] & 0x80) {\r\n                const tempBuf = retBuf.slice(0);\r\n                const tempView = new Uint8Array(tempBuf);\r\n                retBuf = new ArrayBuffer(retBuf.byteLength + 1);\r\n                retView = new Uint8Array(retBuf);\r\n                for (let k = 0; k < tempBuf.byteLength; k++) {\r\n                    retView[k + 1] = tempView[k];\r\n                }\r\n                retView[0] = 0x00;\r\n            }\r\n            return retBuf;\r\n        }\r\n        bigInt *= Math.pow(2, 8);\r\n    }\r\n    return (new ArrayBuffer(0));\r\n}\r\nfunction isEqualBuffer(inputBuffer1, inputBuffer2) {\r\n    if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {\r\n        return false;\r\n    }\r\n    const view1 = new Uint8Array(inputBuffer1);\r\n    const view2 = new Uint8Array(inputBuffer2);\r\n    for (let i = 0; i < view1.length; i++) {\r\n        if (view1[i] !== view2[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction padNumber(inputNumber, fullLength) {\r\n    const str = inputNumber.toString(10);\r\n    if (fullLength < str.length) {\r\n        return \"\";\r\n    }\r\n    const dif = fullLength - str.length;\r\n    const padding = new Array(dif);\r\n    for (let i = 0; i < dif; i++) {\r\n        padding[i] = \"0\";\r\n    }\r\n    const paddingString = padding.join(\"\");\r\n    return paddingString.concat(str);\r\n}\r\nconst base64Template = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\nconst base64UrlTemplate = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\";\r\nfunction toBase64(input, useUrlTemplate = false, skipPadding = false, skipLeadingZeros = false) {\r\n    let i = 0;\r\n    let flag1 = 0;\r\n    let flag2 = 0;\r\n    let output = \"\";\r\n    const template = (useUrlTemplate) ? base64UrlTemplate : base64Template;\r\n    if (skipLeadingZeros) {\r\n        let nonZeroPosition = 0;\r\n        for (let i = 0; i < input.length; i++) {\r\n            if (input.charCodeAt(i) !== 0) {\r\n                nonZeroPosition = i;\r\n                break;\r\n            }\r\n        }\r\n        input = input.slice(nonZeroPosition);\r\n    }\r\n    while (i < input.length) {\r\n        const chr1 = input.charCodeAt(i++);\r\n        if (i >= input.length) {\r\n            flag1 = 1;\r\n        }\r\n        const chr2 = input.charCodeAt(i++);\r\n        if (i >= input.length) {\r\n            flag2 = 1;\r\n        }\r\n        const chr3 = input.charCodeAt(i++);\r\n        const enc1 = chr1 >> 2;\r\n        const enc2 = ((chr1 & 0x03) << 4) | (chr2 >> 4);\r\n        let enc3 = ((chr2 & 0x0F) << 2) | (chr3 >> 6);\r\n        let enc4 = chr3 & 0x3F;\r\n        if (flag1 === 1) {\r\n            enc3 = enc4 = 64;\r\n        }\r\n        else {\r\n            if (flag2 === 1) {\r\n                enc4 = 64;\r\n            }\r\n        }\r\n        if (skipPadding) {\r\n            if (enc3 === 64) {\r\n                output += `${template.charAt(enc1)}${template.charAt(enc2)}`;\r\n            }\r\n            else {\r\n                if (enc4 === 64) {\r\n                    output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}`;\r\n                }\r\n                else {\r\n                    output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;\r\n        }\r\n    }\r\n    return output;\r\n}\r\nfunction fromBase64(input, useUrlTemplate = false, cutTailZeros = false) {\r\n    const template = (useUrlTemplate) ? base64UrlTemplate : base64Template;\r\n    function indexOf(toSearch) {\r\n        for (let i = 0; i < 64; i++) {\r\n            if (template.charAt(i) === toSearch)\r\n                return i;\r\n        }\r\n        return 64;\r\n    }\r\n    function test(incoming) {\r\n        return ((incoming === 64) ? 0x00 : incoming);\r\n    }\r\n    let i = 0;\r\n    let output = \"\";\r\n    while (i < input.length) {\r\n        const enc1 = indexOf(input.charAt(i++));\r\n        const enc2 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));\r\n        const enc3 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));\r\n        const enc4 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));\r\n        const chr1 = (test(enc1) << 2) | (test(enc2) >> 4);\r\n        const chr2 = ((test(enc2) & 0x0F) << 4) | (test(enc3) >> 2);\r\n        const chr3 = ((test(enc3) & 0x03) << 6) | test(enc4);\r\n        output += String.fromCharCode(chr1);\r\n        if (enc3 !== 64) {\r\n            output += String.fromCharCode(chr2);\r\n        }\r\n        if (enc4 !== 64) {\r\n            output += String.fromCharCode(chr3);\r\n        }\r\n    }\r\n    if (cutTailZeros) {\r\n        const outputLength = output.length;\r\n        let nonZeroStart = (-1);\r\n        for (let i = (outputLength - 1); i >= 0; i--) {\r\n            if (output.charCodeAt(i) !== 0) {\r\n                nonZeroStart = i;\r\n                break;\r\n            }\r\n        }\r\n        if (nonZeroStart !== (-1)) {\r\n            output = output.slice(0, nonZeroStart + 1);\r\n        }\r\n        else {\r\n            output = \"\";\r\n        }\r\n    }\r\n    return output;\r\n}\r\nfunction arrayBufferToString(buffer) {\r\n    let resultString = \"\";\r\n    const view = new Uint8Array(buffer);\r\n    for (const element of view) {\r\n        resultString += String.fromCharCode(element);\r\n    }\r\n    return resultString;\r\n}\r\nfunction stringToArrayBuffer(str) {\r\n    const stringLength = str.length;\r\n    const resultBuffer = new ArrayBuffer(stringLength);\r\n    const resultView = new Uint8Array(resultBuffer);\r\n    for (let i = 0; i < stringLength; i++) {\r\n        resultView[i] = str.charCodeAt(i);\r\n    }\r\n    return resultBuffer;\r\n}\r\nconst log2 = Math.log(2);\r\nfunction nearestPowerOf2(length) {\r\n    const base = (Math.log(length) / log2);\r\n    const floor = Math.floor(base);\r\n    const round = Math.round(base);\r\n    return ((floor === round) ? floor : round);\r\n}\r\nfunction clearProps(object, propsArray) {\r\n    for (const prop of propsArray) {\r\n        delete object[prop];\r\n    }\r\n}\n\nexport { arrayBufferToString, bufferToHexCodes, checkBufferParams, clearProps, fromBase64, getParametersValue, getUTCDate, isEqualBuffer, nearestPowerOf2, padNumber, stringToArrayBuffer, toBase64, utilConcatBuf, utilConcatView, utilDecodeTC, utilEncodeTC, utilFromBase, utilToBase };\n","/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)\n  // reuse resolved promise, and allocate it lazily\n  : cb => (promise || (promise = Promise.resolve()))\n    .then(cb)\n    .catch(err => setTimeout(() => { throw err }, 0))\n","'use strict'\n\nconst getTime = require('./time')\n\nclass Retimer {\n  constructor (callback, timeout, args) {\n    const that = this\n\n    this._started = getTime()\n    this._rescheduled = 0\n    this._scheduled = timeout\n    this._args = args\n    this._triggered = false\n\n    this._timerWrapper = () => {\n      if (that._rescheduled > 0) {\n        that._scheduled = that._rescheduled - (getTime() - that._started)\n        that._schedule(that._scheduled)\n      } else {\n        that._triggered = true\n        callback.apply(null, that._args)\n      }\n    }\n\n    this._timer = setTimeout(this._timerWrapper, timeout)\n  }\n\n  reschedule (timeout) {\n    if (!timeout) {\n      timeout = this._scheduled\n    }\n    const now = getTime()\n    if ((now + timeout) - (this._started + this._scheduled) < 0) {\n      clearTimeout(this._timer)\n      this._schedule(timeout)\n    } else if (!this._triggered) {\n      this._started = now\n      this._rescheduled = timeout\n    } else {\n      this._schedule(timeout)\n    }\n  }\n\n  _schedule (timeout) {\n    this._triggered = false\n    this._started = getTime()\n    this._rescheduled = 0\n    this._scheduled = timeout\n    this._timer = setTimeout(this._timerWrapper, timeout)\n  }\n\n  clear () {\n    clearTimeout(this._timer)\n  }\n}\n\nfunction retimer () {\n  if (typeof arguments[0] !== 'function') {\n    throw new Error('callback needed')\n  }\n\n  if (typeof arguments[1] !== 'number') {\n    throw new Error('timeout needed')\n  }\n\n  let args\n\n  if (arguments.length > 0) {\n    args = new Array(arguments.length - 2)\n\n    /* eslint-disable no-var */\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i + 2]\n    }\n  }\n\n  return new Retimer(arguments[0], arguments[1], args)\n}\n\nmodule.exports = retimer\n","'use strict'\n\nmodule.exports = function getTime () {\n  return Date.now()\n}\n","/*! run-parallel-limit. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nmodule.exports = runParallelLimit\n\nconst queueMicrotask = require('queue-microtask')\n\nfunction runParallelLimit (tasks, limit, cb) {\n  if (typeof limit !== 'number') throw new Error('second argument must be a Number')\n  let results, len, pending, keys, isErrored\n  let isSync = true\n  let next\n\n  if (Array.isArray(tasks)) {\n    results = []\n    pending = len = tasks.length\n  } else {\n    keys = Object.keys(tasks)\n    results = {}\n    pending = len = keys.length\n  }\n\n  function done (err) {\n    function end () {\n      if (cb) cb(err, results)\n      cb = null\n    }\n    if (isSync) queueMicrotask(end)\n    else end()\n  }\n\n  function each (i, err, result) {\n    results[i] = result\n    if (err) isErrored = true\n    if (--pending === 0 || err) {\n      done(err)\n    } else if (!isErrored && next < len) {\n      let key\n      if (keys) {\n        key = keys[next]\n        next += 1\n        tasks[key](function (err, result) { each(key, err, result) })\n      } else {\n        key = next\n        next += 1\n        tasks[key](function (err, result) { each(key, err, result) })\n      }\n    }\n  }\n\n  next = limit\n  if (!pending) {\n    // empty\n    done(null)\n  } else if (keys) {\n    // object\n    keys.some(function (key, i) {\n      tasks[key](function (err, result) { each(key, err, result) })\n      if (i === limit - 1) return true // early return\n      return false\n    })\n  } else {\n    // array\n    tasks.some(function (task, i) {\n      task(function (err, result) { each(i, err, result) })\n      if (i === limit - 1) return true // early return\n      return false\n    })\n  }\n\n  isSync = false\n}\n","'use strict'\n\nconst { AbortController } = globalThis\n\n// @ts-expect-error no types\nconst retimer = require('retimer')\n\nclass TimeoutController extends AbortController {\n  /**\n   * @constructor\n   * @param {number} ms milliseconds\n   */\n  constructor (ms) {\n    super()\n    this._ms = ms\n    this._timer = retimer(() => this.abort(), ms)\n    // Patch for safari not supported extending built in classes\n    Object.setPrototypeOf(this, TimeoutController.prototype)\n  }\n\n  /**\n   * Aborts the controller and clears the timer\n   */\n  abort () {\n    this._timer.clear()\n    return super.abort()\n  }\n\n  /**\n   * Clears the timer\n   */\n  clear () {\n    this._timer.clear()\n  }\n\n  /**\n   * Resets the timer\n   */\n  reset () {\n    this._timer.clear()\n    this._timer = retimer(() => this.abort(), this._ms)\n  }\n}\n\nmodule.exports = {\n  TimeoutController\n}\n","import { coerce } from '../bytes.js';\nimport basex from '../vendor/base-x.js';\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder {\n    name;\n    prefix;\n    baseEncode;\n    constructor(name, prefix, baseEncode) {\n        this.name = name;\n        this.prefix = prefix;\n        this.baseEncode = baseEncode;\n    }\n    encode(bytes) {\n        if (bytes instanceof Uint8Array) {\n            return `${this.prefix}${this.baseEncode(bytes)}`;\n        }\n        else {\n            throw Error('Unknown type, must be binary type');\n        }\n    }\n}\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder {\n    name;\n    prefix;\n    baseDecode;\n    prefixCodePoint;\n    constructor(name, prefix, baseDecode) {\n        this.name = name;\n        this.prefix = prefix;\n        /* c8 ignore next 3 */\n        if (prefix.codePointAt(0) === undefined) {\n            throw new Error('Invalid prefix character');\n        }\n        this.prefixCodePoint = prefix.codePointAt(0);\n        this.baseDecode = baseDecode;\n    }\n    decode(text) {\n        if (typeof text === 'string') {\n            if (text.codePointAt(0) !== this.prefixCodePoint) {\n                throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n            }\n            return this.baseDecode(text.slice(this.prefix.length));\n        }\n        else {\n            throw Error('Can only multibase decode strings');\n        }\n    }\n    or(decoder) {\n        return or(this, decoder);\n    }\n}\nclass ComposedDecoder {\n    decoders;\n    constructor(decoders) {\n        this.decoders = decoders;\n    }\n    or(decoder) {\n        return or(this, decoder);\n    }\n    decode(input) {\n        const prefix = input[0];\n        const decoder = this.decoders[prefix];\n        if (decoder != null) {\n            return decoder.decode(input);\n        }\n        else {\n            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n        }\n    }\n}\nexport function or(left, right) {\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    return new ComposedDecoder({\n        ...(left.decoders ?? { [left.prefix]: left }),\n        ...(right.decoders ?? { [right.prefix]: right })\n    });\n}\nexport class Codec {\n    name;\n    prefix;\n    baseEncode;\n    baseDecode;\n    encoder;\n    decoder;\n    constructor(name, prefix, baseEncode, baseDecode) {\n        this.name = name;\n        this.prefix = prefix;\n        this.baseEncode = baseEncode;\n        this.baseDecode = baseDecode;\n        this.encoder = new Encoder(name, prefix, baseEncode);\n        this.decoder = new Decoder(name, prefix, baseDecode);\n    }\n    encode(input) {\n        return this.encoder.encode(input);\n    }\n    decode(input) {\n        return this.decoder.decode(input);\n    }\n}\nexport function from({ name, prefix, encode, decode }) {\n    return new Codec(name, prefix, encode, decode);\n}\nexport function baseX({ name, prefix, alphabet }) {\n    const { encode, decode } = basex(alphabet, name);\n    return from({\n        prefix,\n        name,\n        encode,\n        decode: (text) => coerce(decode(text))\n    });\n}\nfunction decode(string, alphabet, bitsPerChar, name) {\n    // Build the character lookup table:\n    const codes = {};\n    for (let i = 0; i < alphabet.length; ++i) {\n        codes[alphabet[i]] = i;\n    }\n    // Count the padding bytes:\n    let end = string.length;\n    while (string[end - 1] === '=') {\n        --end;\n    }\n    // Allocate the output:\n    const out = new Uint8Array((end * bitsPerChar / 8) | 0);\n    // Parse the data:\n    let bits = 0; // Number of bits currently in the buffer\n    let buffer = 0; // Bits waiting to be written out, MSB first\n    let written = 0; // Next byte to write\n    for (let i = 0; i < end; ++i) {\n        // Read one character from the string:\n        const value = codes[string[i]];\n        if (value === undefined) {\n            throw new SyntaxError(`Non-${name} character`);\n        }\n        // Append the bits to the buffer:\n        buffer = (buffer << bitsPerChar) | value;\n        bits += bitsPerChar;\n        // Write out some bits if the buffer has a byte's worth:\n        if (bits >= 8) {\n            bits -= 8;\n            out[written++] = 0xff & (buffer >> bits);\n        }\n    }\n    // Verify that we have received just enough bits:\n    if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n        throw new SyntaxError('Unexpected end of data');\n    }\n    return out;\n}\nfunction encode(data, alphabet, bitsPerChar) {\n    const pad = alphabet[alphabet.length - 1] === '=';\n    const mask = (1 << bitsPerChar) - 1;\n    let out = '';\n    let bits = 0; // Number of bits currently in the buffer\n    let buffer = 0; // Bits waiting to be written out, MSB first\n    for (let i = 0; i < data.length; ++i) {\n        // Slurp data into the buffer:\n        buffer = (buffer << 8) | data[i];\n        bits += 8;\n        // Write out as much as we can:\n        while (bits > bitsPerChar) {\n            bits -= bitsPerChar;\n            out += alphabet[mask & (buffer >> bits)];\n        }\n    }\n    // Partial character:\n    if (bits !== 0) {\n        out += alphabet[mask & (buffer << (bitsPerChar - bits))];\n    }\n    // Add padding characters until we hit a byte boundary:\n    if (pad) {\n        while (((out.length * bitsPerChar) & 7) !== 0) {\n            out += '=';\n        }\n    }\n    return out;\n}\n/**\n * RFC4648 Factory\n */\nexport function rfc4648({ name, prefix, bitsPerChar, alphabet }) {\n    return from({\n        prefix,\n        name,\n        encode(input) {\n            return encode(input, alphabet, bitsPerChar);\n        },\n        decode(input) {\n            return decode(input, alphabet, bitsPerChar, name);\n        }\n    });\n}\n//# sourceMappingURL=base.js.map","import { rfc4648 } from './base.js';\nexport const base32 = rfc4648({\n    prefix: 'b',\n    name: 'base32',\n    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n    bitsPerChar: 5\n});\nexport const base32upper = rfc4648({\n    prefix: 'B',\n    name: 'base32upper',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n    bitsPerChar: 5\n});\nexport const base32pad = rfc4648({\n    prefix: 'c',\n    name: 'base32pad',\n    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n    bitsPerChar: 5\n});\nexport const base32padupper = rfc4648({\n    prefix: 'C',\n    name: 'base32padupper',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n    bitsPerChar: 5\n});\nexport const base32hex = rfc4648({\n    prefix: 'v',\n    name: 'base32hex',\n    alphabet: '0123456789abcdefghijklmnopqrstuv',\n    bitsPerChar: 5\n});\nexport const base32hexupper = rfc4648({\n    prefix: 'V',\n    name: 'base32hexupper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n    bitsPerChar: 5\n});\nexport const base32hexpad = rfc4648({\n    prefix: 't',\n    name: 'base32hexpad',\n    alphabet: '0123456789abcdefghijklmnopqrstuv=',\n    bitsPerChar: 5\n});\nexport const base32hexpadupper = rfc4648({\n    prefix: 'T',\n    name: 'base32hexpadupper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n    bitsPerChar: 5\n});\nexport const base32z = rfc4648({\n    prefix: 'h',\n    name: 'base32z',\n    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n    bitsPerChar: 5\n});\n//# sourceMappingURL=base32.js.map","import { baseX } from './base.js';\nexport const base58btc = baseX({\n    name: 'base58btc',\n    prefix: 'z',\n    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n});\nexport const base58flickr = baseX({\n    name: 'base58flickr',\n    prefix: 'Z',\n    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n});\n//# sourceMappingURL=base58.js.map","export const empty = new Uint8Array(0);\nexport function toHex(d) {\n    return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');\n}\nexport function fromHex(hex) {\n    const hexes = hex.match(/../g);\n    return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;\n}\nexport function equals(aa, bb) {\n    if (aa === bb)\n        return true;\n    if (aa.byteLength !== bb.byteLength) {\n        return false;\n    }\n    for (let ii = 0; ii < aa.byteLength; ii++) {\n        if (aa[ii] !== bb[ii]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function coerce(o) {\n    if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')\n        return o;\n    if (o instanceof ArrayBuffer)\n        return new Uint8Array(o);\n    if (ArrayBuffer.isView(o)) {\n        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n    }\n    throw new Error('Unknown type, must be binary type');\n}\nexport function isBinary(o) {\n    return o instanceof ArrayBuffer || ArrayBuffer.isView(o);\n}\nexport function fromString(str) {\n    return new TextEncoder().encode(str);\n}\nexport function toString(b) {\n    return new TextDecoder().decode(b);\n}\n//# sourceMappingURL=bytes.js.map","import { base32 } from './bases/base32.js';\nimport { base58btc } from './bases/base58.js';\nimport { coerce } from './bytes.js';\nimport * as Digest from './hashes/digest.js';\nimport * as varint from './varint.js';\n// This way TS will also expose all the types from module\nexport * from './link/interface.js';\nexport function format(link, base) {\n    const { bytes, version } = link;\n    switch (version) {\n        case 0:\n            return toStringV0(bytes, baseCache(link), base ?? base58btc.encoder);\n        default:\n            return toStringV1(bytes, baseCache(link), (base ?? base32.encoder));\n    }\n}\nexport function toJSON(link) {\n    return {\n        '/': format(link)\n    };\n}\nexport function fromJSON(json) {\n    return CID.parse(json['/']);\n}\nconst cache = new WeakMap();\nfunction baseCache(cid) {\n    const baseCache = cache.get(cid);\n    if (baseCache == null) {\n        const baseCache = new Map();\n        cache.set(cid, baseCache);\n        return baseCache;\n    }\n    return baseCache;\n}\nexport class CID {\n    code;\n    version;\n    multihash;\n    bytes;\n    '/';\n    /**\n     * @param version - Version of the CID\n     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n     * @param multihash - (Multi)hash of the of the content.\n     */\n    constructor(version, code, multihash, bytes) {\n        this.code = code;\n        this.version = version;\n        this.multihash = multihash;\n        this.bytes = bytes;\n        // flag to serializers that this is a CID and\n        // should be treated specially\n        this['/'] = bytes;\n    }\n    /**\n     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n     * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n     *\n     * @deprecated\n     */\n    get asCID() {\n        return this;\n    }\n    // ArrayBufferView\n    get byteOffset() {\n        return this.bytes.byteOffset;\n    }\n    // ArrayBufferView\n    get byteLength() {\n        return this.bytes.byteLength;\n    }\n    toV0() {\n        switch (this.version) {\n            case 0: {\n                return this;\n            }\n            case 1: {\n                const { code, multihash } = this;\n                if (code !== DAG_PB_CODE) {\n                    throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n                }\n                // sha2-256\n                if (multihash.code !== SHA_256_CODE) {\n                    throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n                }\n                return (CID.createV0(multihash));\n            }\n            default: {\n                throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);\n            }\n        }\n    }\n    toV1() {\n        switch (this.version) {\n            case 0: {\n                const { code, digest } = this.multihash;\n                const multihash = Digest.create(code, digest);\n                return (CID.createV1(this.code, multihash));\n            }\n            case 1: {\n                return this;\n            }\n            default: {\n                throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);\n            }\n        }\n    }\n    equals(other) {\n        return CID.equals(this, other);\n    }\n    static equals(self, other) {\n        const unknown = other;\n        return (unknown != null &&\n            self.code === unknown.code &&\n            self.version === unknown.version &&\n            Digest.equals(self.multihash, unknown.multihash));\n    }\n    toString(base) {\n        return format(this, base);\n    }\n    toJSON() {\n        return { '/': format(this) };\n    }\n    link() {\n        return this;\n    }\n    [Symbol.toStringTag] = 'CID';\n    // Legacy\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return `CID(${this.toString()})`;\n    }\n    /**\n     * Takes any input `value` and returns a `CID` instance if it was\n     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n     * it will return value back. If `value` is not instance of this CID\n     * class, but is compatible CID it will return new instance of this\n     * `CID` class. Otherwise returns null.\n     *\n     * This allows two different incompatible versions of CID library to\n     * co-exist and interop as long as binary interface is compatible.\n     */\n    static asCID(input) {\n        if (input == null) {\n            return null;\n        }\n        const value = input;\n        if (value instanceof CID) {\n            // If value is instance of CID then we're all set.\n            return value;\n        }\n        else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n            // If value isn't instance of this CID class but `this.asCID === this` or\n            // `value['/'] === value.bytes` is true it is CID instance coming from a\n            // different implementation (diff version or duplicate). In that case we\n            // rebase it to this `CID` implementation so caller is guaranteed to get\n            // instance with expected API.\n            const { version, code, multihash, bytes } = value;\n            return new CID(version, code, multihash, bytes ?? encodeCID(version, code, multihash.bytes));\n        }\n        else if (value[cidSymbol] === true) {\n            // If value is a CID from older implementation that used to be tagged via\n            // symbol we still rebase it to the this `CID` implementation by\n            // delegating that to a constructor.\n            const { version, multihash, code } = value;\n            const digest = Digest.decode(multihash);\n            return CID.create(version, code, digest);\n        }\n        else {\n            // Otherwise value is not a CID (or an incompatible version of it) in\n            // which case we return `null`.\n            return null;\n        }\n    }\n    /**\n     * @param version - Version of the CID\n     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n     * @param digest - (Multi)hash of the of the content.\n     */\n    static create(version, code, digest) {\n        if (typeof code !== 'number') {\n            throw new Error('String codecs are no longer supported');\n        }\n        if (!(digest.bytes instanceof Uint8Array)) {\n            throw new Error('Invalid digest');\n        }\n        switch (version) {\n            case 0: {\n                if (code !== DAG_PB_CODE) {\n                    throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);\n                }\n                else {\n                    return new CID(version, code, digest, digest.bytes);\n                }\n            }\n            case 1: {\n                const bytes = encodeCID(version, code, digest.bytes);\n                return new CID(version, code, digest, bytes);\n            }\n            default: {\n                throw new Error('Invalid version');\n            }\n        }\n    }\n    /**\n     * Simplified version of `create` for CIDv0.\n     */\n    static createV0(digest) {\n        return CID.create(0, DAG_PB_CODE, digest);\n    }\n    /**\n     * Simplified version of `create` for CIDv1.\n     *\n     * @param code - Content encoding format code.\n     * @param digest - Multihash of the content.\n     */\n    static createV1(code, digest) {\n        return CID.create(1, code, digest);\n    }\n    /**\n     * Decoded a CID from its binary representation. The byte array must contain\n     * only the CID with no additional bytes.\n     *\n     * An error will be thrown if the bytes provided do not contain a valid\n     * binary representation of a CID.\n     */\n    static decode(bytes) {\n        const [cid, remainder] = CID.decodeFirst(bytes);\n        if (remainder.length !== 0) {\n            throw new Error('Incorrect length');\n        }\n        return cid;\n    }\n    /**\n     * Decoded a CID from its binary representation at the beginning of a byte\n     * array.\n     *\n     * Returns an array with the first element containing the CID and the second\n     * element containing the remainder of the original byte array. The remainder\n     * will be a zero-length byte array if the provided bytes only contained a\n     * binary CID representation.\n     */\n    static decodeFirst(bytes) {\n        const specs = CID.inspectBytes(bytes);\n        const prefixSize = specs.size - specs.multihashSize;\n        const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));\n        if (multihashBytes.byteLength !== specs.multihashSize) {\n            throw new Error('Incorrect length');\n        }\n        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n        const digest = new Digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n        const cid = specs.version === 0\n            ? CID.createV0(digest)\n            : CID.createV1(specs.codec, digest);\n        return [cid, bytes.subarray(specs.size)];\n    }\n    /**\n     * Inspect the initial bytes of a CID to determine its properties.\n     *\n     * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n     * bytes but for larger multicodec code values and larger multihash digest\n     * lengths these varints can be quite large. It is recommended that at least\n     * 10 bytes be made available in the `initialBytes` argument for a complete\n     * inspection.\n     */\n    static inspectBytes(initialBytes) {\n        let offset = 0;\n        const next = () => {\n            const [i, length] = varint.decode(initialBytes.subarray(offset));\n            offset += length;\n            return i;\n        };\n        let version = next();\n        let codec = DAG_PB_CODE;\n        if (version === 18) {\n            // CIDv0\n            version = 0;\n            offset = 0;\n        }\n        else {\n            codec = next();\n        }\n        if (version !== 0 && version !== 1) {\n            throw new RangeError(`Invalid CID version ${version}`);\n        }\n        const prefixSize = offset;\n        const multihashCode = next(); // multihash code\n        const digestSize = next(); // multihash length\n        const size = offset + digestSize;\n        const multihashSize = size - prefixSize;\n        return { version, codec, multihashCode, digestSize, multihashSize, size };\n    }\n    /**\n     * Takes cid in a string representation and creates an instance. If `base`\n     * decoder is not provided will use a default from the configuration. It will\n     * throw an error if encoding of the CID is not compatible with supplied (or\n     * a default decoder).\n     */\n    static parse(source, base) {\n        const [prefix, bytes] = parseCIDtoBytes(source, base);\n        const cid = CID.decode(bytes);\n        if (cid.version === 0 && source[0] !== 'Q') {\n            throw Error('Version 0 CID string must not include multibase prefix');\n        }\n        // Cache string representation to avoid computing it on `this.toString()`\n        baseCache(cid).set(prefix, source);\n        return cid;\n    }\n}\nfunction parseCIDtoBytes(source, base) {\n    switch (source[0]) {\n        // CIDv0 is parsed differently\n        case 'Q': {\n            const decoder = base ?? base58btc;\n            return [\n                base58btc.prefix,\n                decoder.decode(`${base58btc.prefix}${source}`)\n            ];\n        }\n        case base58btc.prefix: {\n            const decoder = base ?? base58btc;\n            return [base58btc.prefix, decoder.decode(source)];\n        }\n        case base32.prefix: {\n            const decoder = base ?? base32;\n            return [base32.prefix, decoder.decode(source)];\n        }\n        default: {\n            if (base == null) {\n                throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');\n            }\n            return [source[0], base.decode(source)];\n        }\n    }\n}\nfunction toStringV0(bytes, cache, base) {\n    const { prefix } = base;\n    if (prefix !== base58btc.prefix) {\n        throw Error(`Cannot string encode V0 in ${base.name} encoding`);\n    }\n    const cid = cache.get(prefix);\n    if (cid == null) {\n        const cid = base.encode(bytes).slice(1);\n        cache.set(prefix, cid);\n        return cid;\n    }\n    else {\n        return cid;\n    }\n}\nfunction toStringV1(bytes, cache, base) {\n    const { prefix } = base;\n    const cid = cache.get(prefix);\n    if (cid == null) {\n        const cid = base.encode(bytes);\n        cache.set(prefix, cid);\n        return cid;\n    }\n    else {\n        return cid;\n    }\n}\nconst DAG_PB_CODE = 0x70;\nconst SHA_256_CODE = 0x12;\nfunction encodeCID(version, code, multihash) {\n    const codeOffset = varint.encodingLength(version);\n    const hashOffset = codeOffset + varint.encodingLength(code);\n    const bytes = new Uint8Array(hashOffset + multihash.byteLength);\n    varint.encodeTo(version, bytes, 0);\n    varint.encodeTo(code, bytes, codeOffset);\n    bytes.set(multihash, hashOffset);\n    return bytes;\n}\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID');\n//# sourceMappingURL=cid.js.map","import { coerce, equals as equalBytes } from '../bytes.js';\nimport * as varint from '../varint.js';\n/**\n * Creates a multihash digest.\n */\nexport function create(code, digest) {\n    const size = digest.byteLength;\n    const sizeOffset = varint.encodingLength(code);\n    const digestOffset = sizeOffset + varint.encodingLength(size);\n    const bytes = new Uint8Array(digestOffset + size);\n    varint.encodeTo(code, bytes, 0);\n    varint.encodeTo(size, bytes, sizeOffset);\n    bytes.set(digest, digestOffset);\n    return new Digest(code, size, digest, bytes);\n}\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nexport function decode(multihash) {\n    const bytes = coerce(multihash);\n    const [code, sizeOffset] = varint.decode(bytes);\n    const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset));\n    const digest = bytes.subarray(sizeOffset + digestOffset);\n    if (digest.byteLength !== size) {\n        throw new Error('Incorrect length');\n    }\n    return new Digest(code, size, digest, bytes);\n}\nexport function equals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    else {\n        const data = b;\n        return (a.code === data.code &&\n            a.size === data.size &&\n            data.bytes instanceof Uint8Array &&\n            equalBytes(a.bytes, data.bytes));\n    }\n}\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nexport class Digest {\n    code;\n    size;\n    digest;\n    bytes;\n    /**\n     * Creates a multihash digest.\n     */\n    constructor(code, size, digest, bytes) {\n        this.code = code;\n        this.size = size;\n        this.digest = digest;\n        this.bytes = bytes;\n    }\n}\n//# sourceMappingURL=digest.js.map","/* eslint-disable @typescript-eslint/no-unnecessary-type-constraint */\n/* eslint-disable no-use-before-define */\nexport {};\n//# sourceMappingURL=interface.js.map","import varint from './vendor/varint.js';\nexport function decode(data, offset = 0) {\n    const code = varint.decode(data, offset);\n    return [code, varint.decode.bytes];\n}\nexport function encodeTo(int, target, offset = 0) {\n    varint.encode(int, target, offset);\n    return target;\n}\nexport function encodingLength(int) {\n    return varint.encodingLength(int);\n}\n//# sourceMappingURL=varint.js.map","/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base(ALPHABET, name) {\n    if (ALPHABET.length >= 255) {\n        throw new TypeError('Alphabet too long');\n    }\n    var BASE_MAP = new Uint8Array(256);\n    for (var j = 0; j < BASE_MAP.length; j++) {\n        BASE_MAP[j] = 255;\n    }\n    for (var i = 0; i < ALPHABET.length; i++) {\n        var x = ALPHABET.charAt(i);\n        var xc = x.charCodeAt(0);\n        if (BASE_MAP[xc] !== 255) {\n            throw new TypeError(x + ' is ambiguous');\n        }\n        BASE_MAP[xc] = i;\n    }\n    var BASE = ALPHABET.length;\n    var LEADER = ALPHABET.charAt(0);\n    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n    /**\n     * @param {any[] | Iterable<number>} source\n     */\n    function encode(source) {\n        // @ts-ignore\n        if (source instanceof Uint8Array)\n            ;\n        else if (ArrayBuffer.isView(source)) {\n            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n        }\n        else if (Array.isArray(source)) {\n            source = Uint8Array.from(source);\n        }\n        if (!(source instanceof Uint8Array)) {\n            throw new TypeError('Expected Uint8Array');\n        }\n        if (source.length === 0) {\n            return '';\n        }\n        // Skip & count leading zeroes.\n        var zeroes = 0;\n        var length = 0;\n        var pbegin = 0;\n        var pend = source.length;\n        while (pbegin !== pend && source[pbegin] === 0) {\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n        var b58 = new Uint8Array(size);\n        // Process the bytes.\n        while (pbegin !== pend) {\n            var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            var i = 0;\n            for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n                carry += (256 * b58[it1]) >>> 0;\n                b58[it1] = (carry % BASE) >>> 0;\n                carry = (carry / BASE) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('Non-zero carry');\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        var it2 = size - length;\n        while (it2 !== size && b58[it2] === 0) {\n            it2++;\n        }\n        // Translate the result into a string.\n        var str = LEADER.repeat(zeroes);\n        for (; it2 < size; ++it2) {\n            str += ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    /**\n     * @param {string | string[]} source\n     */\n    function decodeUnsafe(source) {\n        if (typeof source !== 'string') {\n            throw new TypeError('Expected String');\n        }\n        if (source.length === 0) {\n            return new Uint8Array();\n        }\n        var psz = 0;\n        // Skip leading spaces.\n        if (source[psz] === ' ') {\n            return;\n        }\n        // Skip and count leading '1's.\n        var zeroes = 0;\n        var length = 0;\n        while (source[psz] === LEADER) {\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n        var b256 = new Uint8Array(size);\n        // Process the characters.\n        while (source[psz]) {\n            // Decode character\n            var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n            if (carry === 255) {\n                return;\n            }\n            var i = 0;\n            for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n                carry += (BASE * b256[it3]) >>> 0;\n                b256[it3] = (carry % 256) >>> 0;\n                carry = (carry / 256) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('Non-zero carry');\n            }\n            length = i;\n            psz++;\n        }\n        // Skip trailing spaces.\n        if (source[psz] === ' ') {\n            return;\n        }\n        // Skip leading zeroes in b256.\n        var it4 = size - length;\n        while (it4 !== size && b256[it4] === 0) {\n            it4++;\n        }\n        var vch = new Uint8Array(zeroes + (size - it4));\n        var j = zeroes;\n        while (it4 !== size) {\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n    /**\n     * @param {string | string[]} string\n     */\n    function decode(string) {\n        var buffer = decodeUnsafe(string);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error(`Non-${name} character`);\n    }\n    return {\n        encode: encode,\n        decodeUnsafe: decodeUnsafe,\n        decode: decode\n    };\n}\nvar src = base;\nvar _brrp__multiformats_scope_baseX = src;\nexport default _brrp__multiformats_scope_baseX;\n//# sourceMappingURL=base-x.js.map","/* eslint-disable */\nvar encode_1 = encode;\nvar MSB = 0x80, REST = 0x7F, MSBALL = ~REST, INT = Math.pow(2, 31);\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n    out = out || [];\n    offset = offset || 0;\n    var oldOffset = offset;\n    while (num >= INT) {\n        out[offset++] = (num & 0xFF) | MSB;\n        num /= 128;\n    }\n    while (num & MSBALL) {\n        out[offset++] = (num & 0xFF) | MSB;\n        num >>>= 7;\n    }\n    out[offset] = num | 0;\n    // @ts-ignore\n    encode.bytes = offset - oldOffset + 1;\n    return out;\n}\nvar decode = read;\nvar MSB$1 = 0x80, REST$1 = 0x7F;\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n    do {\n        if (counter >= l) {\n            // @ts-ignore\n            read.bytes = 0;\n            throw new RangeError('Could not decode varint');\n        }\n        b = buf[counter++];\n        res += shift < 28\n            ? (b & REST$1) << shift\n            : (b & REST$1) * Math.pow(2, shift);\n        shift += 7;\n    } while (b >= MSB$1);\n    // @ts-ignore\n    read.bytes = counter - offset;\n    return res;\n}\nvar N1 = Math.pow(2, 7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\nvar length = function (/** @type {number} */ value) {\n    return (value < N1 ? 1\n        : value < N2 ? 2\n            : value < N3 ? 3\n                : value < N4 ? 4\n                    : value < N5 ? 5\n                        : value < N6 ? 6\n                            : value < N7 ? 7\n                                : value < N8 ? 8\n                                    : value < N9 ? 9\n                                        : 10);\n};\nvar varint = {\n    encode: encode_1,\n    decode: decode,\n    encodingLength: length\n};\nvar _brrp_varint = varint;\nexport default _brrp_varint;\n//# sourceMappingURL=varint.js.map","import * as cborg from 'cborg'\nimport { CID } from 'multiformats/cid'\n\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\nconst CID_CBOR_TAG = 42\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nexport function toByteView (buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength)\n  }\n\n  return buf\n}\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal.\n *\n * @param {any} obj\n * @returns {cborg.Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1)\n  bytes.set(cid.bytes, 1) // prefix is 0x00, for historical reasons\n  return [\n    new cborg.Token(cborg.Type.tag, CID_CBOR_TAG),\n    new cborg.Token(cborg.Type.bytes, bytes)\n  ]\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null\n}\n\nconst _encodeOptions = {\n  float64: true,\n  typeEncoders: {\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\nexport const encodeOptions = {\n  ..._encodeOptions,\n  typeEncoders: {\n    ..._encodeOptions.typeEncoders\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {CID}\n */\nfunction cidDecoder (bytes) {\n  if (bytes[0] !== 0) {\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00')\n  }\n  return CID.decode(bytes.subarray(1)) // ignore leading 0x00\n}\n\nconst _decodeOptions = {\n  allowIndefinite: false,\n  coerceUndefinedToNull: true,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\n_decodeOptions.tags[CID_CBOR_TAG] = cidDecoder\n\nexport const decodeOptions = {\n  ..._decodeOptions,\n  tags: _decodeOptions.tags.slice()\n}\n\nexport const name = 'dag-cbor'\nexport const code = 0x71\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborg.encode(node, _encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => cborg.decode(toByteView(data), _decodeOptions)\n","/**\n * Signing a message failed\n */\nexport class SigningError extends Error {\n    constructor(message = 'An error occurred while signing a message') {\n        super(message);\n        this.name = 'SigningError';\n    }\n}\n/**\n * Verifying a message signature failed\n */\nexport class VerificationError extends Error {\n    constructor(message = 'An error occurred while verifying a message') {\n        super(message);\n        this.name = 'VerificationError';\n    }\n}\n/**\n * WebCrypto was not available in the current context\n */\nexport class WebCryptoMissingError extends Error {\n    constructor(message = 'Missing Web Crypto API') {\n        super(message);\n        this.name = 'WebCryptoMissingError';\n    }\n}\n//# sourceMappingURL=errors.js.map","import webcrypto from '../webcrypto/index.js';\nimport lengths from './lengths.js';\nconst hashTypes = {\n    SHA1: 'SHA-1',\n    SHA256: 'SHA-256',\n    SHA512: 'SHA-512'\n};\nconst sign = async (key, data) => {\n    const buf = await webcrypto.get().subtle.sign({ name: 'HMAC' }, key, data);\n    return new Uint8Array(buf, 0, buf.byteLength);\n};\nexport async function create(hashType, secret) {\n    const hash = hashTypes[hashType];\n    const key = await webcrypto.get().subtle.importKey('raw', secret, {\n        name: 'HMAC',\n        hash: { name: hash }\n    }, false, ['sign']);\n    return {\n        async digest(data) {\n            return sign(key, data);\n        },\n        length: lengths[hashType]\n    };\n}\n//# sourceMappingURL=index.browser.js.map","export default {\n    SHA1: 20,\n    SHA256: 32,\n    SHA512: 64\n};\n//# sourceMappingURL=lengths.js.map","import { InvalidParametersError } from '@libp2p/interface';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { base64urlToBuffer } from '../../util.js';\nimport webcrypto from '../../webcrypto/index.js';\nconst curveLengths = {\n    'P-256': 32,\n    'P-384': 48,\n    'P-521': 66\n};\nconst curveTypes = Object.keys(curveLengths);\nconst names = curveTypes.join(' / ');\nexport async function generateEphemeralKeyPair(curve) {\n    if (curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521') {\n        throw new InvalidParametersError(`Unknown curve: ${curve}. Must be ${names}`);\n    }\n    const pair = await webcrypto.get().subtle.generateKey({\n        name: 'ECDH',\n        namedCurve: curve\n    }, true, ['deriveBits']);\n    // forcePrivate is used for testing only\n    const genSharedKey = async (theirPub, forcePrivate) => {\n        let privateKey;\n        if (forcePrivate != null) {\n            privateKey = await webcrypto.get().subtle.importKey('jwk', unmarshalPrivateKey(curve, forcePrivate), {\n                name: 'ECDH',\n                namedCurve: curve\n            }, false, ['deriveBits']);\n        }\n        else {\n            privateKey = pair.privateKey;\n        }\n        const key = await webcrypto.get().subtle.importKey('jwk', unmarshalPublicKey(curve, theirPub), {\n            name: 'ECDH',\n            namedCurve: curve\n        }, false, []);\n        const buffer = await webcrypto.get().subtle.deriveBits({\n            name: 'ECDH',\n            public: key\n        }, privateKey, curveLengths[curve] * 8);\n        return new Uint8Array(buffer, 0, buffer.byteLength);\n    };\n    const publicKey = await webcrypto.get().subtle.exportKey('jwk', pair.publicKey);\n    const ecdhKey = {\n        key: marshalPublicKey(publicKey),\n        genSharedKey\n    };\n    return ecdhKey;\n}\n// Marshal converts a jwk encoded ECDH public key into the\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\n// go-ipfs uses)\nfunction marshalPublicKey(jwk) {\n    if (jwk.crv == null || jwk.x == null || jwk.y == null) {\n        throw new InvalidParametersError('JWK was missing components');\n    }\n    if (jwk.crv !== 'P-256' && jwk.crv !== 'P-384' && jwk.crv !== 'P-521') {\n        throw new InvalidParametersError(`Unknown curve: ${jwk.crv}. Must be ${names}`);\n    }\n    const byteLen = curveLengths[jwk.crv];\n    return uint8ArrayConcat([\n        Uint8Array.from([4]), // uncompressed point\n        base64urlToBuffer(jwk.x, byteLen),\n        base64urlToBuffer(jwk.y, byteLen)\n    ], 1 + byteLen * 2);\n}\n/**\n * Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\n */\nfunction unmarshalPublicKey(curve, key) {\n    if (curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521') {\n        throw new InvalidParametersError(`Unknown curve: ${curve}. Must be ${names}`);\n    }\n    const byteLen = curveLengths[curve];\n    if (!uint8ArrayEquals(key.subarray(0, 1), Uint8Array.from([4]))) {\n        throw new InvalidParametersError('Cannot unmarshal public key - invalid key format');\n    }\n    return {\n        kty: 'EC',\n        crv: curve,\n        x: uint8ArrayToString(key.subarray(1, byteLen + 1), 'base64url'),\n        y: uint8ArrayToString(key.subarray(1 + byteLen), 'base64url'),\n        ext: true\n    };\n}\nconst unmarshalPrivateKey = (curve, key) => ({\n    ...unmarshalPublicKey(curve, key.public),\n    d: uint8ArrayToString(key.private, 'base64url')\n});\n//# sourceMappingURL=index.browser.js.map","import { base58btc } from 'multiformats/bases/base58';\nimport { CID } from 'multiformats/cid';\nimport {} from 'multiformats/hashes/digest';\nimport { identity } from 'multiformats/hashes/identity';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { publicKeyToProtobuf } from '../index.js';\nimport { ensureEd25519Key } from './utils.js';\nimport * as crypto from './index.js';\nexport class Ed25519PublicKey {\n    type = 'Ed25519';\n    raw;\n    constructor(key) {\n        this.raw = ensureEd25519Key(key, crypto.publicKeyLength);\n    }\n    toMultihash() {\n        return identity.digest(publicKeyToProtobuf(this));\n    }\n    toCID() {\n        return CID.createV1(114, this.toMultihash());\n    }\n    toString() {\n        return base58btc.encode(this.toMultihash().bytes).substring(1);\n    }\n    equals(key) {\n        if (key == null || !(key.raw instanceof Uint8Array)) {\n            return false;\n        }\n        return uint8ArrayEquals(this.raw, key.raw);\n    }\n    verify(data, sig) {\n        return crypto.hashAndVerify(this.raw, sig, data);\n    }\n}\nexport class Ed25519PrivateKey {\n    type = 'Ed25519';\n    raw;\n    publicKey;\n    // key       - 64 byte Uint8Array containing private key\n    // publicKey - 32 byte Uint8Array containing public key\n    constructor(key, publicKey) {\n        this.raw = ensureEd25519Key(key, crypto.privateKeyLength);\n        this.publicKey = new Ed25519PublicKey(publicKey);\n    }\n    equals(key) {\n        if (key == null || !(key.raw instanceof Uint8Array)) {\n            return false;\n        }\n        return uint8ArrayEquals(this.raw, key.raw);\n    }\n    sign(message) {\n        return crypto.hashAndSign(this.raw, message);\n    }\n}\n//# sourceMappingURL=ed25519.js.map","import { ed25519 as ed } from '@noble/curves/ed25519';\nconst PUBLIC_KEY_BYTE_LENGTH = 32;\nconst PRIVATE_KEY_BYTE_LENGTH = 64; // private key is actually 32 bytes but for historical reasons we concat private and public keys\nconst KEYS_BYTE_LENGTH = 32;\nexport { PUBLIC_KEY_BYTE_LENGTH as publicKeyLength };\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength };\nexport function generateKey() {\n    // the actual private key (32 bytes)\n    const privateKeyRaw = ed.utils.randomPrivateKey();\n    const publicKey = ed.getPublicKey(privateKeyRaw);\n    // concatenated the public key to the private key\n    const privateKey = concatKeys(privateKeyRaw, publicKey);\n    return {\n        privateKey,\n        publicKey\n    };\n}\n/**\n * Generate keypair from a 32 byte uint8array\n */\nexport function generateKeyFromSeed(seed) {\n    if (seed.length !== KEYS_BYTE_LENGTH) {\n        throw new TypeError('\"seed\" must be 32 bytes in length.');\n    }\n    else if (!(seed instanceof Uint8Array)) {\n        throw new TypeError('\"seed\" must be a node.js Buffer, or Uint8Array.');\n    }\n    // based on node forges algorithm, the seed is used directly as private key\n    const privateKeyRaw = seed;\n    const publicKey = ed.getPublicKey(privateKeyRaw);\n    const privateKey = concatKeys(privateKeyRaw, publicKey);\n    return {\n        privateKey,\n        publicKey\n    };\n}\nexport function hashAndSign(privateKey, msg) {\n    const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH);\n    return ed.sign(msg instanceof Uint8Array ? msg : msg.subarray(), privateKeyRaw);\n}\nexport function hashAndVerify(publicKey, sig, msg) {\n    return ed.verify(sig, msg instanceof Uint8Array ? msg : msg.subarray(), publicKey);\n}\nfunction concatKeys(privateKeyRaw, publicKey) {\n    const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);\n    for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {\n        privateKey[i] = privateKeyRaw[i];\n        privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i];\n    }\n    return privateKey;\n}\n//# sourceMappingURL=index.browser.js.map","import { InvalidParametersError } from '@libp2p/interface';\nimport { Ed25519PublicKey as Ed25519PublicKeyClass, Ed25519PrivateKey as Ed25519PrivateKeyClass } from './ed25519.js';\nimport * as crypto from './index.js';\nexport function unmarshalEd25519PrivateKey(bytes) {\n    // Try the old, redundant public key version\n    if (bytes.length > crypto.privateKeyLength) {\n        bytes = ensureEd25519Key(bytes, crypto.privateKeyLength + crypto.publicKeyLength);\n        const privateKeyBytes = bytes.subarray(0, crypto.privateKeyLength);\n        const publicKeyBytes = bytes.subarray(crypto.privateKeyLength, bytes.length);\n        return new Ed25519PrivateKeyClass(privateKeyBytes, publicKeyBytes);\n    }\n    bytes = ensureEd25519Key(bytes, crypto.privateKeyLength);\n    const privateKeyBytes = bytes.subarray(0, crypto.privateKeyLength);\n    const publicKeyBytes = bytes.subarray(crypto.publicKeyLength);\n    return new Ed25519PrivateKeyClass(privateKeyBytes, publicKeyBytes);\n}\nexport function unmarshalEd25519PublicKey(bytes) {\n    bytes = ensureEd25519Key(bytes, crypto.publicKeyLength);\n    return new Ed25519PublicKeyClass(bytes);\n}\nexport async function generateEd25519KeyPair() {\n    const { privateKey, publicKey } = crypto.generateKey();\n    return new Ed25519PrivateKeyClass(privateKey, publicKey);\n}\nexport async function generateEd25519KeyPairFromSeed(seed) {\n    const { privateKey, publicKey } = crypto.generateKeyFromSeed(seed);\n    return new Ed25519PrivateKeyClass(privateKey, publicKey);\n}\nexport function ensureEd25519Key(key, length) {\n    key = Uint8Array.from(key ?? []);\n    if (key.length !== length) {\n        throw new InvalidParametersError(`Key must be a Uint8Array of length ${length}, got ${key.length}`);\n    }\n    return key;\n}\n//# sourceMappingURL=utils.js.map","/**\n * @packageDocumentation\n *\n * ## Supported Key Types\n *\n * Currently the `'RSA'`, `'ed25519'`, and `secp256k1` types are supported, although ed25519 and secp256k1 keys support only signing and verification of messages.\n *\n * For encryption / decryption support, RSA keys should be used.\n */\nimport { UnsupportedKeyTypeError } from '@libp2p/interface';\nimport { generateEd25519KeyPair, generateEd25519KeyPairFromSeed, unmarshalEd25519PrivateKey, unmarshalEd25519PublicKey } from './ed25519/utils.js';\nimport * as pb from './keys.js';\nimport { pkcs1ToRSAPrivateKey, pkixToRSAPublicKey, generateRSAKeyPair } from './rsa/utils.js';\nimport { generateSecp256k1KeyPair, unmarshalSecp256k1PrivateKey, unmarshalSecp256k1PublicKey } from './secp256k1/utils.js';\nexport { generateEphemeralKeyPair } from './ecdh/index.js';\nexport { keyStretcher } from './key-stretcher.js';\nexport async function generateKeyPair(type, bits) {\n    if (type === 'Ed25519') {\n        return generateEd25519KeyPair();\n    }\n    if (type === 'secp256k1') {\n        return generateSecp256k1KeyPair();\n    }\n    if (type === 'RSA') {\n        return generateRSAKeyPair(bits ?? 2048);\n    }\n    throw new UnsupportedKeyTypeError();\n}\nexport async function generateKeyPairFromSeed(type, seed) {\n    if (type !== 'Ed25519') {\n        throw new UnsupportedKeyTypeError('Seed key derivation only supported for Ed25519 keys');\n    }\n    return generateEd25519KeyPairFromSeed(seed);\n}\n/**\n * Converts a protobuf serialized public key into its representative object\n */\nexport function publicKeyFromProtobuf(buf) {\n    const { Type, Data } = pb.PublicKey.decode(buf);\n    const data = Data ?? new Uint8Array();\n    switch (Type) {\n        case pb.KeyType.RSA:\n            return pkixToRSAPublicKey(data);\n        case pb.KeyType.Ed25519:\n            return unmarshalEd25519PublicKey(data);\n        case pb.KeyType.secp256k1:\n            return unmarshalSecp256k1PublicKey(data);\n        default:\n            throw new UnsupportedKeyTypeError();\n    }\n}\n/**\n * Creates a public key from the raw key bytes\n */\nexport function publicKeyFromRaw(buf) {\n    if (buf.byteLength === 32) {\n        return unmarshalEd25519PublicKey(buf);\n    }\n    else if (buf.byteLength === 33) {\n        return unmarshalSecp256k1PublicKey(buf);\n    }\n    else {\n        return pkixToRSAPublicKey(buf);\n    }\n}\n/**\n * Creates a public key from an identity multihash which contains a protobuf\n * encoded Ed25519 or secp256k1 public key.\n *\n * RSA keys are not supported as in practice we they are not stored in identity\n * multihashes since the hash would be very large.\n */\nexport function publicKeyFromMultihash(digest) {\n    const { Type, Data } = pb.PublicKey.decode(digest.digest);\n    const data = Data ?? new Uint8Array();\n    switch (Type) {\n        case pb.KeyType.Ed25519:\n            return unmarshalEd25519PublicKey(data);\n        case pb.KeyType.secp256k1:\n            return unmarshalSecp256k1PublicKey(data);\n        default:\n            throw new UnsupportedKeyTypeError();\n    }\n}\n/**\n * Converts a public key object into a protobuf serialized public key\n */\nexport function publicKeyToProtobuf(key) {\n    return pb.PublicKey.encode({\n        Type: pb.KeyType[key.type],\n        Data: key.raw\n    });\n}\n/**\n * Converts a protobuf serialized private key into its representative object\n */\nexport function privateKeyFromProtobuf(buf) {\n    const decoded = pb.PrivateKey.decode(buf);\n    const data = decoded.Data ?? new Uint8Array();\n    switch (decoded.Type) {\n        case pb.KeyType.RSA:\n            return pkcs1ToRSAPrivateKey(data);\n        case pb.KeyType.Ed25519:\n            return unmarshalEd25519PrivateKey(data);\n        case pb.KeyType.secp256k1:\n            return unmarshalSecp256k1PrivateKey(data);\n        default:\n            throw new UnsupportedKeyTypeError();\n    }\n}\n/**\n * Creates a private key from the raw key bytes. For Ed25519 keys this requires\n * the public key to be appended to the private key otherwise we can't\n * differentiate between Ed25519 and secp256k1 keys as they are the same length.\n */\nexport function privateKeyFromRaw(buf) {\n    if (buf.byteLength === 64) {\n        return unmarshalEd25519PrivateKey(buf);\n    }\n    else if (buf.byteLength === 32) {\n        return unmarshalSecp256k1PrivateKey(buf);\n    }\n    else {\n        return pkcs1ToRSAPrivateKey(buf);\n    }\n}\n/**\n * Converts a private key object into a protobuf serialized private key\n */\nexport function privateKeyToProtobuf(key) {\n    return pb.PrivateKey.encode({\n        Type: pb.KeyType[key.type],\n        Data: key.raw\n    });\n}\n//# sourceMappingURL=index.js.map","import { InvalidParametersError } from '@libp2p/interface';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport * as hmac from '../hmac/index.js';\nconst cipherMap = {\n    'AES-128': {\n        ivSize: 16,\n        keySize: 16\n    },\n    'AES-256': {\n        ivSize: 16,\n        keySize: 32\n    },\n    Blowfish: {\n        ivSize: 8,\n        keySize: 32\n    }\n};\n/**\n * Generates a set of keys for each party by stretching the shared key.\n * (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)\n */\nexport async function keyStretcher(cipherType, hash, secret) {\n    if (cipherType !== 'AES-128' && cipherType !== 'AES-256' && cipherType !== 'Blowfish') {\n        throw new InvalidParametersError('Cipher type was missing or unsupported');\n    }\n    if (hash !== 'SHA1' && hash !== 'SHA256' && hash !== 'SHA512') {\n        throw new InvalidParametersError('Hash type was missing or unsupported');\n    }\n    if (secret == null || !(secret instanceof Uint8Array)) {\n        throw new InvalidParametersError('Secret was missing or an incorrect type');\n    }\n    const cipher = cipherMap[cipherType];\n    const cipherKeySize = cipher.keySize;\n    const ivSize = cipher.ivSize;\n    const hmacKeySize = 20;\n    const seed = uint8ArrayFromString('key expansion');\n    const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);\n    const m = await hmac.create(hash, secret);\n    let a = await m.digest(seed);\n    const result = [];\n    let j = 0;\n    while (j < resultLength) {\n        const b = await m.digest(uint8ArrayConcat([a, seed]));\n        let todo = b.length;\n        if (j + todo > resultLength) {\n            todo = resultLength - j;\n        }\n        result.push(b);\n        j += todo;\n        a = await m.digest(a);\n    }\n    const half = resultLength / 2;\n    const resultBuffer = uint8ArrayConcat(result);\n    const r1 = resultBuffer.subarray(0, half);\n    const r2 = resultBuffer.subarray(half, resultLength);\n    const createKey = (res) => ({\n        iv: res.subarray(0, ivSize),\n        cipherKey: res.subarray(ivSize, ivSize + cipherKeySize),\n        macKey: res.subarray(ivSize + cipherKeySize)\n    });\n    return {\n        k1: createKey(r1),\n        k2: createKey(r2)\n    };\n}\n//# sourceMappingURL=key-stretcher.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { decodeMessage, encodeMessage, enumeration, message } from 'protons-runtime';\nexport var KeyType;\n(function (KeyType) {\n    KeyType[\"RSA\"] = \"RSA\";\n    KeyType[\"Ed25519\"] = \"Ed25519\";\n    KeyType[\"secp256k1\"] = \"secp256k1\";\n})(KeyType || (KeyType = {}));\nvar __KeyTypeValues;\n(function (__KeyTypeValues) {\n    __KeyTypeValues[__KeyTypeValues[\"RSA\"] = 0] = \"RSA\";\n    __KeyTypeValues[__KeyTypeValues[\"Ed25519\"] = 1] = \"Ed25519\";\n    __KeyTypeValues[__KeyTypeValues[\"secp256k1\"] = 2] = \"secp256k1\";\n})(__KeyTypeValues || (__KeyTypeValues = {}));\n(function (KeyType) {\n    KeyType.codec = () => {\n        return enumeration(__KeyTypeValues);\n    };\n})(KeyType || (KeyType = {}));\nexport var PublicKey;\n(function (PublicKey) {\n    let _codec;\n    PublicKey.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Type != null) {\n                    w.uint32(8);\n                    KeyType.codec().encode(obj.Type, w);\n                }\n                if (obj.Data != null) {\n                    w.uint32(18);\n                    w.bytes(obj.Data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length, opts = {}) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1: {\n                            obj.Type = KeyType.codec().decode(reader);\n                            break;\n                        }\n                        case 2: {\n                            obj.Data = reader.bytes();\n                            break;\n                        }\n                        default: {\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PublicKey.encode = (obj) => {\n        return encodeMessage(obj, PublicKey.codec());\n    };\n    PublicKey.decode = (buf, opts) => {\n        return decodeMessage(buf, PublicKey.codec(), opts);\n    };\n})(PublicKey || (PublicKey = {}));\nexport var PrivateKey;\n(function (PrivateKey) {\n    let _codec;\n    PrivateKey.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Type != null) {\n                    w.uint32(8);\n                    KeyType.codec().encode(obj.Type, w);\n                }\n                if (obj.Data != null) {\n                    w.uint32(18);\n                    w.bytes(obj.Data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length, opts = {}) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1: {\n                            obj.Type = KeyType.codec().decode(reader);\n                            break;\n                        }\n                        case 2: {\n                            obj.Data = reader.bytes();\n                            break;\n                        }\n                        default: {\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PrivateKey.encode = (obj) => {\n        return encodeMessage(obj, PrivateKey.codec());\n    };\n    PrivateKey.decode = (buf, opts) => {\n        return decodeMessage(buf, PrivateKey.codec(), opts);\n    };\n})(PrivateKey || (PrivateKey = {}));\n//# sourceMappingURL=keys.js.map","import { InvalidParametersError } from '@libp2p/interface';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport randomBytes from '../../random-bytes.js';\nimport webcrypto from '../../webcrypto/index.js';\nimport * as utils from './utils.js';\nexport { utils };\nexport async function generateRSAKey(bits) {\n    const pair = await webcrypto.get().subtle.generateKey({\n        name: 'RSASSA-PKCS1-v1_5',\n        modulusLength: bits,\n        publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n        hash: { name: 'SHA-256' }\n    }, true, ['sign', 'verify']);\n    const keys = await exportKey(pair);\n    return {\n        privateKey: keys[0],\n        publicKey: keys[1]\n    };\n}\nexport { randomBytes as getRandomValues };\nexport async function hashAndSign(key, msg) {\n    const privateKey = await webcrypto.get().subtle.importKey('jwk', key, {\n        name: 'RSASSA-PKCS1-v1_5',\n        hash: { name: 'SHA-256' }\n    }, false, ['sign']);\n    const sig = await webcrypto.get().subtle.sign({ name: 'RSASSA-PKCS1-v1_5' }, privateKey, msg instanceof Uint8Array ? msg : msg.subarray());\n    return new Uint8Array(sig, 0, sig.byteLength);\n}\nexport async function hashAndVerify(key, sig, msg) {\n    const publicKey = await webcrypto.get().subtle.importKey('jwk', key, {\n        name: 'RSASSA-PKCS1-v1_5',\n        hash: { name: 'SHA-256' }\n    }, false, ['verify']);\n    return webcrypto.get().subtle.verify({ name: 'RSASSA-PKCS1-v1_5' }, publicKey, sig, msg instanceof Uint8Array ? msg : msg.subarray());\n}\nasync function exportKey(pair) {\n    if (pair.privateKey == null || pair.publicKey == null) {\n        throw new InvalidParametersError('Private and public key are required');\n    }\n    return Promise.all([\n        webcrypto.get().subtle.exportKey('jwk', pair.privateKey),\n        webcrypto.get().subtle.exportKey('jwk', pair.publicKey)\n    ]);\n}\nexport function rsaKeySize(jwk) {\n    if (jwk.kty !== 'RSA') {\n        throw new InvalidParametersError('invalid key type');\n    }\n    else if (jwk.n == null) {\n        throw new InvalidParametersError('invalid key modulus');\n    }\n    const bytes = uint8ArrayFromString(jwk.n, 'base64url');\n    return bytes.length * 8;\n}\n//# sourceMappingURL=index.browser.js.map","import { base58btc } from 'multiformats/bases/base58';\nimport { CID } from 'multiformats/cid';\nimport {} from 'multiformats/hashes/digest';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { hashAndSign, utils, hashAndVerify } from './index.js';\nexport class RSAPublicKey {\n    type = 'RSA';\n    _key;\n    _raw;\n    _multihash;\n    constructor(key, digest) {\n        this._key = key;\n        this._multihash = digest;\n    }\n    get raw() {\n        if (this._raw == null) {\n            this._raw = utils.jwkToPkix(this._key);\n        }\n        return this._raw;\n    }\n    toMultihash() {\n        return this._multihash;\n    }\n    toCID() {\n        return CID.createV1(114, this._multihash);\n    }\n    toString() {\n        return base58btc.encode(this.toMultihash().bytes).substring(1);\n    }\n    equals(key) {\n        if (key == null || !(key.raw instanceof Uint8Array)) {\n            return false;\n        }\n        return uint8ArrayEquals(this.raw, key.raw);\n    }\n    verify(data, sig) {\n        return hashAndVerify(this._key, sig, data);\n    }\n}\nexport class RSAPrivateKey {\n    type = 'RSA';\n    _key;\n    _raw;\n    publicKey;\n    constructor(key, publicKey) {\n        this._key = key;\n        this.publicKey = publicKey;\n    }\n    get raw() {\n        if (this._raw == null) {\n            this._raw = utils.jwkToPkcs1(this._key);\n        }\n        return this._raw;\n    }\n    equals(key) {\n        if (key == null || !(key.raw instanceof Uint8Array)) {\n            return false;\n        }\n        return uint8ArrayEquals(this.raw, key.raw);\n    }\n    sign(message) {\n        return hashAndSign(this._key, message);\n    }\n}\n//# sourceMappingURL=rsa.js.map","import { InvalidParametersError, InvalidPublicKeyError } from '@libp2p/interface';\nimport { sha256 } from '@noble/hashes/sha256';\nimport * as asn1js from 'asn1js';\nimport { create } from 'multiformats/hashes/digest';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport * as pb from '../keys.js';\nimport { RSAPrivateKey as RSAPrivateKeyClass, RSAPublicKey as RSAPublicKeyClass } from './rsa.js';\nimport { generateRSAKey, rsaKeySize } from './index.js';\nexport const MAX_RSA_KEY_SIZE = 8192;\nconst SHA2_256_CODE = 0x12;\n/**\n * Convert a PKCS#1 in ASN1 DER format to a JWK key\n */\nexport function pkcs1ToJwk(bytes) {\n    const { result } = asn1js.fromBER(bytes);\n    // @ts-expect-error this looks fragile but DER is a canonical format so we are\n    // safe to have deeply property chains like this\n    const values = result.valueBlock.value;\n    const key = {\n        n: asn1jsIntegerToBase64(values[1]),\n        e: asn1jsIntegerToBase64(values[2]),\n        d: asn1jsIntegerToBase64(values[3]),\n        p: asn1jsIntegerToBase64(values[4]),\n        q: asn1jsIntegerToBase64(values[5]),\n        dp: asn1jsIntegerToBase64(values[6]),\n        dq: asn1jsIntegerToBase64(values[7]),\n        qi: asn1jsIntegerToBase64(values[8]),\n        kty: 'RSA',\n        alg: 'RS256'\n    };\n    return key;\n}\n/**\n * Convert a JWK key into PKCS#1 in ASN1 DER format\n */\nexport function jwkToPkcs1(jwk) {\n    if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {\n        throw new InvalidParametersError('JWK was missing components');\n    }\n    const root = new asn1js.Sequence({\n        value: [\n            new asn1js.Integer({ value: 0 }),\n            asn1js.Integer.fromBigInt(bufToBn(uint8ArrayFromString(jwk.n, 'base64url'))),\n            asn1js.Integer.fromBigInt(bufToBn(uint8ArrayFromString(jwk.e, 'base64url'))),\n            asn1js.Integer.fromBigInt(bufToBn(uint8ArrayFromString(jwk.d, 'base64url'))),\n            asn1js.Integer.fromBigInt(bufToBn(uint8ArrayFromString(jwk.p, 'base64url'))),\n            asn1js.Integer.fromBigInt(bufToBn(uint8ArrayFromString(jwk.q, 'base64url'))),\n            asn1js.Integer.fromBigInt(bufToBn(uint8ArrayFromString(jwk.dp, 'base64url'))),\n            asn1js.Integer.fromBigInt(bufToBn(uint8ArrayFromString(jwk.dq, 'base64url'))),\n            asn1js.Integer.fromBigInt(bufToBn(uint8ArrayFromString(jwk.qi, 'base64url')))\n        ]\n    });\n    const der = root.toBER();\n    return new Uint8Array(der, 0, der.byteLength);\n}\n/**\n * Convert a PKIX in ASN1 DER format to a JWK key\n */\nexport function pkixToJwk(bytes) {\n    const { result } = asn1js.fromBER(bytes);\n    // @ts-expect-error this looks fragile but DER is a canonical format so we are\n    // safe to have deeply property chains like this\n    const values = result.valueBlock.value[1].valueBlock.value[0].valueBlock.value;\n    return {\n        kty: 'RSA',\n        n: asn1jsIntegerToBase64(values[0]),\n        e: asn1jsIntegerToBase64(values[1])\n    };\n}\n/**\n * Convert a JWK key to PKIX in ASN1 DER format\n */\nexport function jwkToPkix(jwk) {\n    if (jwk.n == null || jwk.e == null) {\n        throw new InvalidParametersError('JWK was missing components');\n    }\n    const root = new asn1js.Sequence({\n        value: [\n            new asn1js.Sequence({\n                value: [\n                    // rsaEncryption\n                    new asn1js.ObjectIdentifier({\n                        value: '1.2.840.113549.1.1.1'\n                    }),\n                    new asn1js.Null()\n                ]\n            }),\n            // this appears to be a bug in asn1js.js - this should really be a Sequence\n            // and not a BitString but it generates the same bytes as node-forge so \n            new asn1js.BitString({\n                valueHex: new asn1js.Sequence({\n                    value: [\n                        asn1js.Integer.fromBigInt(bufToBn(uint8ArrayFromString(jwk.n, 'base64url'))),\n                        asn1js.Integer.fromBigInt(bufToBn(uint8ArrayFromString(jwk.e, 'base64url')))\n                    ]\n                }).toBER()\n            })\n        ]\n    });\n    const der = root.toBER();\n    return new Uint8Array(der, 0, der.byteLength);\n}\nfunction asn1jsIntegerToBase64(int) {\n    let buf = int.valueBlock.valueHexView;\n    // chrome rejects values with leading 0s\n    while (buf[0] === 0) {\n        buf = buf.subarray(1);\n    }\n    return uint8ArrayToString(buf, 'base64url');\n}\nfunction bufToBn(u8) {\n    const hex = [];\n    u8.forEach(function (i) {\n        let h = i.toString(16);\n        if (h.length % 2 > 0) {\n            h = `0${h}`;\n        }\n        hex.push(h);\n    });\n    return BigInt('0x' + hex.join(''));\n}\n/**\n * Turn PCKS#1 DER bytes to a PrivateKey\n */\nexport function pkcs1ToRSAPrivateKey(bytes) {\n    const jwk = pkcs1ToJwk(bytes);\n    return jwkToRSAPrivateKey(jwk);\n}\n/**\n * Turn PKIX bytes to a PublicKey\n */\nexport function pkixToRSAPublicKey(bytes) {\n    const jwk = pkixToJwk(bytes);\n    if (rsaKeySize(jwk) > MAX_RSA_KEY_SIZE) {\n        throw new InvalidPublicKeyError('Key size is too large');\n    }\n    const hash = sha256(pb.PublicKey.encode({\n        Type: pb.KeyType.RSA,\n        Data: bytes\n    }));\n    const digest = create(SHA2_256_CODE, hash);\n    return new RSAPublicKeyClass(jwk, digest);\n}\nexport function jwkToRSAPrivateKey(jwk) {\n    if (rsaKeySize(jwk) > MAX_RSA_KEY_SIZE) {\n        throw new InvalidParametersError('Key size is too large');\n    }\n    const keys = jwkToJWKKeyPair(jwk);\n    const hash = sha256(pb.PublicKey.encode({\n        Type: pb.KeyType.RSA,\n        Data: jwkToPkix(keys.publicKey)\n    }));\n    const digest = create(SHA2_256_CODE, hash);\n    return new RSAPrivateKeyClass(keys.privateKey, new RSAPublicKeyClass(keys.publicKey, digest));\n}\nexport async function generateRSAKeyPair(bits) {\n    if (bits > MAX_RSA_KEY_SIZE) {\n        throw new InvalidParametersError('Key size is too large');\n    }\n    const keys = await generateRSAKey(bits);\n    const hash = sha256(pb.PublicKey.encode({\n        Type: pb.KeyType.RSA,\n        Data: jwkToPkix(keys.publicKey)\n    }));\n    const digest = create(SHA2_256_CODE, hash);\n    return new RSAPrivateKeyClass(keys.privateKey, new RSAPublicKeyClass(keys.publicKey, digest));\n}\n/**\n * Takes a jwk key and returns a JWK KeyPair\n */\nexport function jwkToJWKKeyPair(key) {\n    if (key == null) {\n        throw new InvalidParametersError('Missing key parameter');\n    }\n    return {\n        privateKey: key,\n        publicKey: {\n            kty: key.kty,\n            n: key.n,\n            e: key.e\n        }\n    };\n}\n//# sourceMappingURL=utils.js.map","import { secp256k1 as secp } from '@noble/curves/secp256k1';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { SigningError, VerificationError } from '../../errors.js';\nimport { isPromise } from '../../util.js';\n/**\n * Hash and sign message with private key\n */\nexport function hashAndSign(key, msg) {\n    const p = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray());\n    if (isPromise(p)) {\n        return p.then(({ digest }) => secp.sign(digest, key).toDERRawBytes())\n            .catch(err => {\n            throw new SigningError(String(err));\n        });\n    }\n    try {\n        return secp.sign(p.digest, key).toDERRawBytes();\n    }\n    catch (err) {\n        throw new SigningError(String(err));\n    }\n}\n/**\n * Hash message and verify signature with public key\n */\nexport function hashAndVerify(key, sig, msg) {\n    const p = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray());\n    if (isPromise(p)) {\n        return p.then(({ digest }) => secp.verify(sig, digest, key))\n            .catch(err => {\n            throw new VerificationError(String(err));\n        });\n    }\n    try {\n        return secp.verify(sig, p.digest, key);\n    }\n    catch (err) {\n        throw new VerificationError(String(err));\n    }\n}\n//# sourceMappingURL=index.browser.js.map","import { base58btc } from 'multiformats/bases/base58';\nimport { CID } from 'multiformats/cid';\nimport { identity } from 'multiformats/hashes/identity';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { publicKeyToProtobuf } from '../index.js';\nimport { validateSecp256k1PublicKey, compressSecp256k1PublicKey, computeSecp256k1PublicKey, validateSecp256k1PrivateKey } from './utils.js';\nimport { hashAndVerify, hashAndSign } from './index.js';\nexport class Secp256k1PublicKey {\n    type = 'secp256k1';\n    raw;\n    _key;\n    constructor(key) {\n        this._key = validateSecp256k1PublicKey(key);\n        this.raw = compressSecp256k1PublicKey(this._key);\n    }\n    toMultihash() {\n        return identity.digest(publicKeyToProtobuf(this));\n    }\n    toCID() {\n        return CID.createV1(114, this.toMultihash());\n    }\n    toString() {\n        return base58btc.encode(this.toMultihash().bytes).substring(1);\n    }\n    equals(key) {\n        if (key == null || !(key.raw instanceof Uint8Array)) {\n            return false;\n        }\n        return uint8ArrayEquals(this.raw, key.raw);\n    }\n    verify(data, sig) {\n        return hashAndVerify(this._key, sig, data);\n    }\n}\nexport class Secp256k1PrivateKey {\n    type = 'secp256k1';\n    raw;\n    publicKey;\n    constructor(key, publicKey) {\n        this.raw = validateSecp256k1PrivateKey(key);\n        this.publicKey = new Secp256k1PublicKey(publicKey ?? computeSecp256k1PublicKey(key));\n    }\n    equals(key) {\n        if (key == null || !(key.raw instanceof Uint8Array)) {\n            return false;\n        }\n        return uint8ArrayEquals(this.raw, key.raw);\n    }\n    sign(message) {\n        return hashAndSign(this.raw, message);\n    }\n}\n//# sourceMappingURL=secp256k1.js.map","import { InvalidPrivateKeyError, InvalidPublicKeyError } from '@libp2p/interface';\nimport { secp256k1 as secp } from '@noble/curves/secp256k1';\nimport { Secp256k1PublicKey as Secp256k1PublicKeyClass, Secp256k1PrivateKey as Secp256k1PrivateKeyClass } from './secp256k1.js';\nconst PRIVATE_KEY_BYTE_LENGTH = 32;\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength };\nexport function unmarshalSecp256k1PrivateKey(bytes) {\n    return new Secp256k1PrivateKeyClass(bytes);\n}\nexport function unmarshalSecp256k1PublicKey(bytes) {\n    return new Secp256k1PublicKeyClass(bytes);\n}\nexport async function generateSecp256k1KeyPair() {\n    const privateKeyBytes = generateSecp256k1PrivateKey();\n    return new Secp256k1PrivateKeyClass(privateKeyBytes);\n}\nexport function compressSecp256k1PublicKey(key) {\n    const point = secp.ProjectivePoint.fromHex(key).toRawBytes(true);\n    return point;\n}\nexport function decompressSecp256k1PublicKey(key) {\n    const point = secp.ProjectivePoint.fromHex(key).toRawBytes(false);\n    return point;\n}\nexport function validateSecp256k1PrivateKey(key) {\n    try {\n        secp.getPublicKey(key, true);\n        return key;\n    }\n    catch (err) {\n        throw new InvalidPrivateKeyError(String(err));\n    }\n}\nexport function validateSecp256k1PublicKey(key) {\n    try {\n        secp.ProjectivePoint.fromHex(key);\n        return key;\n    }\n    catch (err) {\n        throw new InvalidPublicKeyError(String(err));\n    }\n}\nexport function computeSecp256k1PublicKey(privateKey) {\n    try {\n        return secp.getPublicKey(privateKey, true);\n    }\n    catch (err) {\n        throw new InvalidPrivateKeyError(String(err));\n    }\n}\nexport function generateSecp256k1PrivateKey() {\n    return secp.utils.randomPrivateKey();\n}\n//# sourceMappingURL=utils.js.map","import { InvalidParametersError } from '@libp2p/interface';\nimport { randomBytes as randB } from '@noble/hashes/utils';\n/**\n * Generates a Uint8Array with length `number` populated by random bytes\n */\nexport default function randomBytes(length) {\n    if (isNaN(length) || length <= 0) {\n        throw new InvalidParametersError('random bytes length must be a Number bigger than 0');\n    }\n    return randB(length);\n}\n//# sourceMappingURL=random-bytes.js.map","import { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nexport function base64urlToBuffer(str, len) {\n    let buf = uint8ArrayFromString(str, 'base64urlpad');\n    if (len != null) {\n        if (buf.length > len)\n            throw new Error('byte array longer than desired length');\n        buf = uint8ArrayConcat([new Uint8Array(len - buf.length), buf]);\n    }\n    return buf;\n}\nexport function isPromise(thing) {\n    if (thing == null) {\n        return false;\n    }\n    return typeof thing.then === 'function' &&\n        typeof thing.catch === 'function' &&\n        typeof thing.finally === 'function';\n}\n//# sourceMappingURL=util.js.map","import webcrypto from './webcrypto.js';\nexport default webcrypto;\n//# sourceMappingURL=index.js.map","/* eslint-env browser */\nimport { WebCryptoMissingError } from '../errors.js';\n// Check native crypto exists and is enabled (In insecure context `self.crypto`\n// exists but `self.crypto.subtle` does not).\nexport default {\n    get(win = globalThis) {\n        const nativeCrypto = win.crypto;\n        if (nativeCrypto?.subtle == null) {\n            throw new WebCryptoMissingError('Missing Web Crypto API. ' +\n                'The most likely cause of this error is that this page is being accessed ' +\n                'from an insecure context (i.e. not HTTPS). For more information and ' +\n                'possible resolutions see ' +\n                'https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api');\n        }\n        return nativeCrypto;\n    }\n};\n//# sourceMappingURL=webcrypto.browser.js.map","import { coerce } from '../bytes.js';\nimport basex from '../vendor/base-x.js';\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder {\n    name;\n    prefix;\n    baseEncode;\n    constructor(name, prefix, baseEncode) {\n        this.name = name;\n        this.prefix = prefix;\n        this.baseEncode = baseEncode;\n    }\n    encode(bytes) {\n        if (bytes instanceof Uint8Array) {\n            return `${this.prefix}${this.baseEncode(bytes)}`;\n        }\n        else {\n            throw Error('Unknown type, must be binary type');\n        }\n    }\n}\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder {\n    name;\n    prefix;\n    baseDecode;\n    prefixCodePoint;\n    constructor(name, prefix, baseDecode) {\n        this.name = name;\n        this.prefix = prefix;\n        const prefixCodePoint = prefix.codePointAt(0);\n        /* c8 ignore next 3 */\n        if (prefixCodePoint === undefined) {\n            throw new Error('Invalid prefix character');\n        }\n        this.prefixCodePoint = prefixCodePoint;\n        this.baseDecode = baseDecode;\n    }\n    decode(text) {\n        if (typeof text === 'string') {\n            if (text.codePointAt(0) !== this.prefixCodePoint) {\n                throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n            }\n            return this.baseDecode(text.slice(this.prefix.length));\n        }\n        else {\n            throw Error('Can only multibase decode strings');\n        }\n    }\n    or(decoder) {\n        return or(this, decoder);\n    }\n}\nclass ComposedDecoder {\n    decoders;\n    constructor(decoders) {\n        this.decoders = decoders;\n    }\n    or(decoder) {\n        return or(this, decoder);\n    }\n    decode(input) {\n        const prefix = input[0];\n        const decoder = this.decoders[prefix];\n        if (decoder != null) {\n            return decoder.decode(input);\n        }\n        else {\n            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n        }\n    }\n}\nexport function or(left, right) {\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    return new ComposedDecoder({\n        ...(left.decoders ?? { [left.prefix]: left }),\n        ...(right.decoders ?? { [right.prefix]: right })\n    });\n}\nexport class Codec {\n    name;\n    prefix;\n    baseEncode;\n    baseDecode;\n    encoder;\n    decoder;\n    constructor(name, prefix, baseEncode, baseDecode) {\n        this.name = name;\n        this.prefix = prefix;\n        this.baseEncode = baseEncode;\n        this.baseDecode = baseDecode;\n        this.encoder = new Encoder(name, prefix, baseEncode);\n        this.decoder = new Decoder(name, prefix, baseDecode);\n    }\n    encode(input) {\n        return this.encoder.encode(input);\n    }\n    decode(input) {\n        return this.decoder.decode(input);\n    }\n}\nexport function from({ name, prefix, encode, decode }) {\n    return new Codec(name, prefix, encode, decode);\n}\nexport function baseX({ name, prefix, alphabet }) {\n    const { encode, decode } = basex(alphabet, name);\n    return from({\n        prefix,\n        name,\n        encode,\n        decode: (text) => coerce(decode(text))\n    });\n}\nfunction decode(string, alphabet, bitsPerChar, name) {\n    // Build the character lookup table:\n    const codes = {};\n    for (let i = 0; i < alphabet.length; ++i) {\n        codes[alphabet[i]] = i;\n    }\n    // Count the padding bytes:\n    let end = string.length;\n    while (string[end - 1] === '=') {\n        --end;\n    }\n    // Allocate the output:\n    const out = new Uint8Array((end * bitsPerChar / 8) | 0);\n    // Parse the data:\n    let bits = 0; // Number of bits currently in the buffer\n    let buffer = 0; // Bits waiting to be written out, MSB first\n    let written = 0; // Next byte to write\n    for (let i = 0; i < end; ++i) {\n        // Read one character from the string:\n        const value = codes[string[i]];\n        if (value === undefined) {\n            throw new SyntaxError(`Non-${name} character`);\n        }\n        // Append the bits to the buffer:\n        buffer = (buffer << bitsPerChar) | value;\n        bits += bitsPerChar;\n        // Write out some bits if the buffer has a byte's worth:\n        if (bits >= 8) {\n            bits -= 8;\n            out[written++] = 0xff & (buffer >> bits);\n        }\n    }\n    // Verify that we have received just enough bits:\n    if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n        throw new SyntaxError('Unexpected end of data');\n    }\n    return out;\n}\nfunction encode(data, alphabet, bitsPerChar) {\n    const pad = alphabet[alphabet.length - 1] === '=';\n    const mask = (1 << bitsPerChar) - 1;\n    let out = '';\n    let bits = 0; // Number of bits currently in the buffer\n    let buffer = 0; // Bits waiting to be written out, MSB first\n    for (let i = 0; i < data.length; ++i) {\n        // Slurp data into the buffer:\n        buffer = (buffer << 8) | data[i];\n        bits += 8;\n        // Write out as much as we can:\n        while (bits > bitsPerChar) {\n            bits -= bitsPerChar;\n            out += alphabet[mask & (buffer >> bits)];\n        }\n    }\n    // Partial character:\n    if (bits !== 0) {\n        out += alphabet[mask & (buffer << (bitsPerChar - bits))];\n    }\n    // Add padding characters until we hit a byte boundary:\n    if (pad) {\n        while (((out.length * bitsPerChar) & 7) !== 0) {\n            out += '=';\n        }\n    }\n    return out;\n}\n/**\n * RFC4648 Factory\n */\nexport function rfc4648({ name, prefix, bitsPerChar, alphabet }) {\n    return from({\n        prefix,\n        name,\n        encode(input) {\n            return encode(input, alphabet, bitsPerChar);\n        },\n        decode(input) {\n            return decode(input, alphabet, bitsPerChar, name);\n        }\n    });\n}\n//# sourceMappingURL=base.js.map","import { rfc4648 } from './base.js';\nexport const base32 = rfc4648({\n    prefix: 'b',\n    name: 'base32',\n    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n    bitsPerChar: 5\n});\nexport const base32upper = rfc4648({\n    prefix: 'B',\n    name: 'base32upper',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n    bitsPerChar: 5\n});\nexport const base32pad = rfc4648({\n    prefix: 'c',\n    name: 'base32pad',\n    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n    bitsPerChar: 5\n});\nexport const base32padupper = rfc4648({\n    prefix: 'C',\n    name: 'base32padupper',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n    bitsPerChar: 5\n});\nexport const base32hex = rfc4648({\n    prefix: 'v',\n    name: 'base32hex',\n    alphabet: '0123456789abcdefghijklmnopqrstuv',\n    bitsPerChar: 5\n});\nexport const base32hexupper = rfc4648({\n    prefix: 'V',\n    name: 'base32hexupper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n    bitsPerChar: 5\n});\nexport const base32hexpad = rfc4648({\n    prefix: 't',\n    name: 'base32hexpad',\n    alphabet: '0123456789abcdefghijklmnopqrstuv=',\n    bitsPerChar: 5\n});\nexport const base32hexpadupper = rfc4648({\n    prefix: 'T',\n    name: 'base32hexpadupper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n    bitsPerChar: 5\n});\nexport const base32z = rfc4648({\n    prefix: 'h',\n    name: 'base32z',\n    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n    bitsPerChar: 5\n});\n//# sourceMappingURL=base32.js.map","import { baseX } from './base.js';\nexport const base36 = baseX({\n    prefix: 'k',\n    name: 'base36',\n    alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n});\nexport const base36upper = baseX({\n    prefix: 'K',\n    name: 'base36upper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n});\n//# sourceMappingURL=base36.js.map","import { baseX } from './base.js';\nexport const base58btc = baseX({\n    name: 'base58btc',\n    prefix: 'z',\n    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n});\nexport const base58flickr = baseX({\n    name: 'base58flickr',\n    prefix: 'Z',\n    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n});\n//# sourceMappingURL=base58.js.map","export const empty = new Uint8Array(0);\nexport function toHex(d) {\n    return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');\n}\nexport function fromHex(hex) {\n    const hexes = hex.match(/../g);\n    return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;\n}\nexport function equals(aa, bb) {\n    if (aa === bb)\n        return true;\n    if (aa.byteLength !== bb.byteLength) {\n        return false;\n    }\n    for (let ii = 0; ii < aa.byteLength; ii++) {\n        if (aa[ii] !== bb[ii]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function coerce(o) {\n    if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')\n        return o;\n    if (o instanceof ArrayBuffer)\n        return new Uint8Array(o);\n    if (ArrayBuffer.isView(o)) {\n        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n    }\n    throw new Error('Unknown type, must be binary type');\n}\nexport function isBinary(o) {\n    return o instanceof ArrayBuffer || ArrayBuffer.isView(o);\n}\nexport function fromString(str) {\n    return new TextEncoder().encode(str);\n}\nexport function toString(b) {\n    return new TextDecoder().decode(b);\n}\n//# sourceMappingURL=bytes.js.map","import { base32 } from './bases/base32.js';\nimport { base36 } from './bases/base36.js';\nimport { base58btc } from './bases/base58.js';\nimport { coerce } from './bytes.js';\nimport * as Digest from './hashes/digest.js';\nimport * as varint from './varint.js';\n// This way TS will also expose all the types from module\nexport * from './link/interface.js';\nexport function format(link, base) {\n    const { bytes, version } = link;\n    switch (version) {\n        case 0:\n            return toStringV0(bytes, baseCache(link), base ?? base58btc.encoder);\n        default:\n            return toStringV1(bytes, baseCache(link), (base ?? base32.encoder));\n    }\n}\nexport function toJSON(link) {\n    return {\n        '/': format(link)\n    };\n}\nexport function fromJSON(json) {\n    return CID.parse(json['/']);\n}\nconst cache = new WeakMap();\nfunction baseCache(cid) {\n    const baseCache = cache.get(cid);\n    if (baseCache == null) {\n        const baseCache = new Map();\n        cache.set(cid, baseCache);\n        return baseCache;\n    }\n    return baseCache;\n}\nexport class CID {\n    code;\n    version;\n    multihash;\n    bytes;\n    '/';\n    /**\n     * @param version - Version of the CID\n     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n     * @param multihash - (Multi)hash of the of the content.\n     */\n    constructor(version, code, multihash, bytes) {\n        this.code = code;\n        this.version = version;\n        this.multihash = multihash;\n        this.bytes = bytes;\n        // flag to serializers that this is a CID and\n        // should be treated specially\n        this['/'] = bytes;\n    }\n    /**\n     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n     * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n     *\n     * @deprecated\n     */\n    get asCID() {\n        return this;\n    }\n    // ArrayBufferView\n    get byteOffset() {\n        return this.bytes.byteOffset;\n    }\n    // ArrayBufferView\n    get byteLength() {\n        return this.bytes.byteLength;\n    }\n    toV0() {\n        switch (this.version) {\n            case 0: {\n                return this;\n            }\n            case 1: {\n                const { code, multihash } = this;\n                if (code !== DAG_PB_CODE) {\n                    throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n                }\n                // sha2-256\n                if (multihash.code !== SHA_256_CODE) {\n                    throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n                }\n                return (CID.createV0(multihash));\n            }\n            default: {\n                throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);\n            }\n        }\n    }\n    toV1() {\n        switch (this.version) {\n            case 0: {\n                const { code, digest } = this.multihash;\n                const multihash = Digest.create(code, digest);\n                return (CID.createV1(this.code, multihash));\n            }\n            case 1: {\n                return this;\n            }\n            default: {\n                throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);\n            }\n        }\n    }\n    equals(other) {\n        return CID.equals(this, other);\n    }\n    static equals(self, other) {\n        const unknown = other;\n        return (unknown != null &&\n            self.code === unknown.code &&\n            self.version === unknown.version &&\n            Digest.equals(self.multihash, unknown.multihash));\n    }\n    toString(base) {\n        return format(this, base);\n    }\n    toJSON() {\n        return { '/': format(this) };\n    }\n    link() {\n        return this;\n    }\n    [Symbol.toStringTag] = 'CID';\n    // Legacy\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return `CID(${this.toString()})`;\n    }\n    /**\n     * Takes any input `value` and returns a `CID` instance if it was\n     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n     * it will return value back. If `value` is not instance of this CID\n     * class, but is compatible CID it will return new instance of this\n     * `CID` class. Otherwise returns null.\n     *\n     * This allows two different incompatible versions of CID library to\n     * co-exist and interop as long as binary interface is compatible.\n     */\n    static asCID(input) {\n        if (input == null) {\n            return null;\n        }\n        const value = input;\n        if (value instanceof CID) {\n            // If value is instance of CID then we're all set.\n            return value;\n        }\n        else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n            // If value isn't instance of this CID class but `this.asCID === this` or\n            // `value['/'] === value.bytes` is true it is CID instance coming from a\n            // different implementation (diff version or duplicate). In that case we\n            // rebase it to this `CID` implementation so caller is guaranteed to get\n            // instance with expected API.\n            const { version, code, multihash, bytes } = value;\n            return new CID(version, code, multihash, bytes ?? encodeCID(version, code, multihash.bytes));\n        }\n        else if (value[cidSymbol] === true) {\n            // If value is a CID from older implementation that used to be tagged via\n            // symbol we still rebase it to the this `CID` implementation by\n            // delegating that to a constructor.\n            const { version, multihash, code } = value;\n            const digest = Digest.decode(multihash);\n            return CID.create(version, code, digest);\n        }\n        else {\n            // Otherwise value is not a CID (or an incompatible version of it) in\n            // which case we return `null`.\n            return null;\n        }\n    }\n    /**\n     * @param version - Version of the CID\n     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n     * @param digest - (Multi)hash of the of the content.\n     */\n    static create(version, code, digest) {\n        if (typeof code !== 'number') {\n            throw new Error('String codecs are no longer supported');\n        }\n        if (!(digest.bytes instanceof Uint8Array)) {\n            throw new Error('Invalid digest');\n        }\n        switch (version) {\n            case 0: {\n                if (code !== DAG_PB_CODE) {\n                    throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);\n                }\n                else {\n                    return new CID(version, code, digest, digest.bytes);\n                }\n            }\n            case 1: {\n                const bytes = encodeCID(version, code, digest.bytes);\n                return new CID(version, code, digest, bytes);\n            }\n            default: {\n                throw new Error('Invalid version');\n            }\n        }\n    }\n    /**\n     * Simplified version of `create` for CIDv0.\n     */\n    static createV0(digest) {\n        return CID.create(0, DAG_PB_CODE, digest);\n    }\n    /**\n     * Simplified version of `create` for CIDv1.\n     *\n     * @param code - Content encoding format code.\n     * @param digest - Multihash of the content.\n     */\n    static createV1(code, digest) {\n        return CID.create(1, code, digest);\n    }\n    /**\n     * Decoded a CID from its binary representation. The byte array must contain\n     * only the CID with no additional bytes.\n     *\n     * An error will be thrown if the bytes provided do not contain a valid\n     * binary representation of a CID.\n     */\n    static decode(bytes) {\n        const [cid, remainder] = CID.decodeFirst(bytes);\n        if (remainder.length !== 0) {\n            throw new Error('Incorrect length');\n        }\n        return cid;\n    }\n    /**\n     * Decoded a CID from its binary representation at the beginning of a byte\n     * array.\n     *\n     * Returns an array with the first element containing the CID and the second\n     * element containing the remainder of the original byte array. The remainder\n     * will be a zero-length byte array if the provided bytes only contained a\n     * binary CID representation.\n     */\n    static decodeFirst(bytes) {\n        const specs = CID.inspectBytes(bytes);\n        const prefixSize = specs.size - specs.multihashSize;\n        const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));\n        if (multihashBytes.byteLength !== specs.multihashSize) {\n            throw new Error('Incorrect length');\n        }\n        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n        const digest = new Digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n        const cid = specs.version === 0\n            ? CID.createV0(digest)\n            : CID.createV1(specs.codec, digest);\n        return [cid, bytes.subarray(specs.size)];\n    }\n    /**\n     * Inspect the initial bytes of a CID to determine its properties.\n     *\n     * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n     * bytes but for larger multicodec code values and larger multihash digest\n     * lengths these varints can be quite large. It is recommended that at least\n     * 10 bytes be made available in the `initialBytes` argument for a complete\n     * inspection.\n     */\n    static inspectBytes(initialBytes) {\n        let offset = 0;\n        const next = () => {\n            const [i, length] = varint.decode(initialBytes.subarray(offset));\n            offset += length;\n            return i;\n        };\n        let version = next();\n        let codec = DAG_PB_CODE;\n        if (version === 18) {\n            // CIDv0\n            version = 0;\n            offset = 0;\n        }\n        else {\n            codec = next();\n        }\n        if (version !== 0 && version !== 1) {\n            throw new RangeError(`Invalid CID version ${version}`);\n        }\n        const prefixSize = offset;\n        const multihashCode = next(); // multihash code\n        const digestSize = next(); // multihash length\n        const size = offset + digestSize;\n        const multihashSize = size - prefixSize;\n        return { version, codec, multihashCode, digestSize, multihashSize, size };\n    }\n    /**\n     * Takes cid in a string representation and creates an instance. If `base`\n     * decoder is not provided will use a default from the configuration. It will\n     * throw an error if encoding of the CID is not compatible with supplied (or\n     * a default decoder).\n     */\n    static parse(source, base) {\n        const [prefix, bytes] = parseCIDtoBytes(source, base);\n        const cid = CID.decode(bytes);\n        if (cid.version === 0 && source[0] !== 'Q') {\n            throw Error('Version 0 CID string must not include multibase prefix');\n        }\n        // Cache string representation to avoid computing it on `this.toString()`\n        baseCache(cid).set(prefix, source);\n        return cid;\n    }\n}\nfunction parseCIDtoBytes(source, base) {\n    switch (source[0]) {\n        // CIDv0 is parsed differently\n        case 'Q': {\n            const decoder = base ?? base58btc;\n            return [\n                base58btc.prefix,\n                decoder.decode(`${base58btc.prefix}${source}`)\n            ];\n        }\n        case base58btc.prefix: {\n            const decoder = base ?? base58btc;\n            return [base58btc.prefix, decoder.decode(source)];\n        }\n        case base32.prefix: {\n            const decoder = base ?? base32;\n            return [base32.prefix, decoder.decode(source)];\n        }\n        case base36.prefix: {\n            const decoder = base ?? base36;\n            return [base36.prefix, decoder.decode(source)];\n        }\n        default: {\n            if (base == null) {\n                throw Error('To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided');\n            }\n            return [source[0], base.decode(source)];\n        }\n    }\n}\nfunction toStringV0(bytes, cache, base) {\n    const { prefix } = base;\n    if (prefix !== base58btc.prefix) {\n        throw Error(`Cannot string encode V0 in ${base.name} encoding`);\n    }\n    const cid = cache.get(prefix);\n    if (cid == null) {\n        const cid = base.encode(bytes).slice(1);\n        cache.set(prefix, cid);\n        return cid;\n    }\n    else {\n        return cid;\n    }\n}\nfunction toStringV1(bytes, cache, base) {\n    const { prefix } = base;\n    const cid = cache.get(prefix);\n    if (cid == null) {\n        const cid = base.encode(bytes);\n        cache.set(prefix, cid);\n        return cid;\n    }\n    else {\n        return cid;\n    }\n}\nconst DAG_PB_CODE = 0x70;\nconst SHA_256_CODE = 0x12;\nfunction encodeCID(version, code, multihash) {\n    const codeOffset = varint.encodingLength(version);\n    const hashOffset = codeOffset + varint.encodingLength(code);\n    const bytes = new Uint8Array(hashOffset + multihash.byteLength);\n    varint.encodeTo(version, bytes, 0);\n    varint.encodeTo(code, bytes, codeOffset);\n    bytes.set(multihash, hashOffset);\n    return bytes;\n}\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID');\n//# sourceMappingURL=cid.js.map","import { coerce, equals as equalBytes } from '../bytes.js';\nimport * as varint from '../varint.js';\n/**\n * Creates a multihash digest.\n */\nexport function create(code, digest) {\n    const size = digest.byteLength;\n    const sizeOffset = varint.encodingLength(code);\n    const digestOffset = sizeOffset + varint.encodingLength(size);\n    const bytes = new Uint8Array(digestOffset + size);\n    varint.encodeTo(code, bytes, 0);\n    varint.encodeTo(size, bytes, sizeOffset);\n    bytes.set(digest, digestOffset);\n    return new Digest(code, size, digest, bytes);\n}\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nexport function decode(multihash) {\n    const bytes = coerce(multihash);\n    const [code, sizeOffset] = varint.decode(bytes);\n    const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset));\n    const digest = bytes.subarray(sizeOffset + digestOffset);\n    if (digest.byteLength !== size) {\n        throw new Error('Incorrect length');\n    }\n    return new Digest(code, size, digest, bytes);\n}\nexport function equals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    else {\n        const data = b;\n        return (a.code === data.code &&\n            a.size === data.size &&\n            data.bytes instanceof Uint8Array &&\n            equalBytes(a.bytes, data.bytes));\n    }\n}\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nexport class Digest {\n    code;\n    size;\n    digest;\n    bytes;\n    /**\n     * Creates a multihash digest.\n     */\n    constructor(code, size, digest, bytes) {\n        this.code = code;\n        this.size = size;\n        this.digest = digest;\n        this.bytes = bytes;\n    }\n}\n/**\n * Used to check that the passed multihash has the passed code\n */\nexport function hasCode(digest, code) {\n    return digest.code === code;\n}\n//# sourceMappingURL=digest.js.map","import * as Digest from './digest.js';\nexport function from({ name, code, encode }) {\n    return new Hasher(name, code, encode);\n}\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nexport class Hasher {\n    name;\n    code;\n    encode;\n    constructor(name, code, encode) {\n        this.name = name;\n        this.code = code;\n        this.encode = encode;\n    }\n    digest(input) {\n        if (input instanceof Uint8Array) {\n            const result = this.encode(input);\n            return result instanceof Uint8Array\n                ? Digest.create(this.code, result)\n                /* c8 ignore next 1 */\n                : result.then(digest => Digest.create(this.code, digest));\n        }\n        else {\n            throw Error('Unknown type, must be binary type');\n            /* c8 ignore next 1 */\n        }\n    }\n}\n//# sourceMappingURL=hasher.js.map","import { coerce } from '../bytes.js';\nimport * as Digest from './digest.js';\nconst code = 0x0;\nconst name = 'identity';\nconst encode = coerce;\nfunction digest(input) {\n    return Digest.create(code, encode(input));\n}\nexport const identity = { code, name, encode, digest };\n//# sourceMappingURL=identity.js.map","/* global crypto */\nimport { from } from './hasher.js';\nfunction sha(name) {\n    return async (data) => new Uint8Array(await crypto.subtle.digest(name, data));\n}\nexport const sha256 = from({\n    name: 'sha2-256',\n    code: 0x12,\n    encode: sha('SHA-256')\n});\nexport const sha512 = from({\n    name: 'sha2-512',\n    code: 0x13,\n    encode: sha('SHA-512')\n});\n//# sourceMappingURL=sha2-browser.js.map","/* eslint-disable @typescript-eslint/no-unnecessary-type-constraint */\n/* eslint-disable no-use-before-define */\nexport {};\n//# sourceMappingURL=interface.js.map","import varint from './vendor/varint.js';\nexport function decode(data, offset = 0) {\n    const code = varint.decode(data, offset);\n    return [code, varint.decode.bytes];\n}\nexport function encodeTo(int, target, offset = 0) {\n    varint.encode(int, target, offset);\n    return target;\n}\nexport function encodingLength(int) {\n    return varint.encodingLength(int);\n}\n//# sourceMappingURL=varint.js.map","/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base(ALPHABET, name) {\n    if (ALPHABET.length >= 255) {\n        throw new TypeError('Alphabet too long');\n    }\n    var BASE_MAP = new Uint8Array(256);\n    for (var j = 0; j < BASE_MAP.length; j++) {\n        BASE_MAP[j] = 255;\n    }\n    for (var i = 0; i < ALPHABET.length; i++) {\n        var x = ALPHABET.charAt(i);\n        var xc = x.charCodeAt(0);\n        if (BASE_MAP[xc] !== 255) {\n            throw new TypeError(x + ' is ambiguous');\n        }\n        BASE_MAP[xc] = i;\n    }\n    var BASE = ALPHABET.length;\n    var LEADER = ALPHABET.charAt(0);\n    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n    /**\n     * @param {any[] | Iterable<number>} source\n     */\n    function encode(source) {\n        // @ts-ignore\n        if (source instanceof Uint8Array)\n            ;\n        else if (ArrayBuffer.isView(source)) {\n            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n        }\n        else if (Array.isArray(source)) {\n            source = Uint8Array.from(source);\n        }\n        if (!(source instanceof Uint8Array)) {\n            throw new TypeError('Expected Uint8Array');\n        }\n        if (source.length === 0) {\n            return '';\n        }\n        // Skip & count leading zeroes.\n        var zeroes = 0;\n        var length = 0;\n        var pbegin = 0;\n        var pend = source.length;\n        while (pbegin !== pend && source[pbegin] === 0) {\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n        var b58 = new Uint8Array(size);\n        // Process the bytes.\n        while (pbegin !== pend) {\n            var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            var i = 0;\n            for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n                carry += (256 * b58[it1]) >>> 0;\n                b58[it1] = (carry % BASE) >>> 0;\n                carry = (carry / BASE) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('Non-zero carry');\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        var it2 = size - length;\n        while (it2 !== size && b58[it2] === 0) {\n            it2++;\n        }\n        // Translate the result into a string.\n        var str = LEADER.repeat(zeroes);\n        for (; it2 < size; ++it2) {\n            str += ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    /**\n     * @param {string | string[]} source\n     */\n    function decodeUnsafe(source) {\n        if (typeof source !== 'string') {\n            throw new TypeError('Expected String');\n        }\n        if (source.length === 0) {\n            return new Uint8Array();\n        }\n        var psz = 0;\n        // Skip leading spaces.\n        if (source[psz] === ' ') {\n            return;\n        }\n        // Skip and count leading '1's.\n        var zeroes = 0;\n        var length = 0;\n        while (source[psz] === LEADER) {\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n        var b256 = new Uint8Array(size);\n        // Process the characters.\n        while (source[psz]) {\n            // Decode character\n            var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n            if (carry === 255) {\n                return;\n            }\n            var i = 0;\n            for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n                carry += (BASE * b256[it3]) >>> 0;\n                b256[it3] = (carry % 256) >>> 0;\n                carry = (carry / 256) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('Non-zero carry');\n            }\n            length = i;\n            psz++;\n        }\n        // Skip trailing spaces.\n        if (source[psz] === ' ') {\n            return;\n        }\n        // Skip leading zeroes in b256.\n        var it4 = size - length;\n        while (it4 !== size && b256[it4] === 0) {\n            it4++;\n        }\n        var vch = new Uint8Array(zeroes + (size - it4));\n        var j = zeroes;\n        while (it4 !== size) {\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n    /**\n     * @param {string | string[]} string\n     */\n    function decode(string) {\n        var buffer = decodeUnsafe(string);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error(`Non-${name} character`);\n    }\n    return {\n        encode: encode,\n        decodeUnsafe: decodeUnsafe,\n        decode: decode\n    };\n}\nvar src = base;\nvar _brrp__multiformats_scope_baseX = src;\nexport default _brrp__multiformats_scope_baseX;\n//# sourceMappingURL=base-x.js.map","/* eslint-disable */\nvar encode_1 = encode;\nvar MSB = 0x80, REST = 0x7F, MSBALL = ~REST, INT = Math.pow(2, 31);\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n    out = out || [];\n    offset = offset || 0;\n    var oldOffset = offset;\n    while (num >= INT) {\n        out[offset++] = (num & 0xFF) | MSB;\n        num /= 128;\n    }\n    while (num & MSBALL) {\n        out[offset++] = (num & 0xFF) | MSB;\n        num >>>= 7;\n    }\n    out[offset] = num | 0;\n    // @ts-ignore\n    encode.bytes = offset - oldOffset + 1;\n    return out;\n}\nvar decode = read;\nvar MSB$1 = 0x80, REST$1 = 0x7F;\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n    do {\n        if (counter >= l) {\n            // @ts-ignore\n            read.bytes = 0;\n            throw new RangeError('Could not decode varint');\n        }\n        b = buf[counter++];\n        res += shift < 28\n            ? (b & REST$1) << shift\n            : (b & REST$1) * Math.pow(2, shift);\n        shift += 7;\n    } while (b >= MSB$1);\n    // @ts-ignore\n    read.bytes = counter - offset;\n    return res;\n}\nvar N1 = Math.pow(2, 7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\nvar length = function (/** @type {number} */ value) {\n    return (value < N1 ? 1\n        : value < N2 ? 2\n            : value < N3 ? 3\n                : value < N4 ? 4\n                    : value < N5 ? 5\n                        : value < N6 ? 6\n                            : value < N7 ? 7\n                                : value < N8 ? 8\n                                    : value < N9 ? 9\n                                        : 10);\n};\nvar varint = {\n    encode: encode_1,\n    decode: decode,\n    encodingLength: length\n};\nvar _brrp_varint = varint;\nexport default _brrp_varint;\n//# sourceMappingURL=varint.js.map","/**\n * When this error is thrown it means an operation was aborted,\n * usually in response to the `abort` event being emitted by an\n * AbortSignal.\n */\nexport class AbortError extends Error {\n    static name = 'AbortError';\n    constructor(message = 'The operation was aborted') {\n        super(message);\n        this.name = 'AbortError';\n    }\n}\n/**\n * Thrown when a remote Peer ID does not match the expected one\n */\nexport class UnexpectedPeerError extends Error {\n    static name = 'UnexpectedPeerError';\n    constructor(message = 'Unexpected Peer') {\n        super(message);\n        this.name = 'UnexpectedPeerError';\n    }\n}\n/**\n * Thrown when a crypto exchange fails\n */\nexport class InvalidCryptoExchangeError extends Error {\n    static name = 'InvalidCryptoExchangeError';\n    constructor(message = 'Invalid crypto exchange') {\n        super(message);\n        this.name = 'InvalidCryptoExchangeError';\n    }\n}\n/**\n * Thrown when invalid parameters are passed to a function or method call\n */\nexport class InvalidParametersError extends Error {\n    static name = 'InvalidParametersError';\n    constructor(message = 'Invalid parameters') {\n        super(message);\n        this.name = 'InvalidParametersError';\n    }\n}\n/**\n * Thrown when a public key is invalid\n */\nexport class InvalidPublicKeyError extends Error {\n    static name = 'InvalidPublicKeyError';\n    constructor(message = 'Invalid public key') {\n        super(message);\n        this.name = 'InvalidPublicKeyError';\n    }\n}\n/**\n * Thrown when a private key is invalid\n */\nexport class InvalidPrivateKeyError extends Error {\n    static name = 'InvalidPrivateKeyError';\n    constructor(message = 'Invalid private key') {\n        super(message);\n        this.name = 'InvalidPrivateKeyError';\n    }\n}\n/**\n * Thrown when a operation is unsupported\n */\nexport class UnsupportedOperationError extends Error {\n    static name = 'UnsupportedOperationError';\n    constructor(message = 'Unsupported operation') {\n        super(message);\n        this.name = 'UnsupportedOperationError';\n    }\n}\n/**\n * Thrown when a connection is closing\n */\nexport class ConnectionClosingError extends Error {\n    static name = 'ConnectionClosingError';\n    constructor(message = 'The connection is closing') {\n        super(message);\n        this.name = 'ConnectionClosingError';\n    }\n}\n/**\n * Thrown when a connection is closed\n */\nexport class ConnectionClosedError extends Error {\n    static name = 'ConnectionClosedError';\n    constructor(message = 'The connection is closed') {\n        super(message);\n        this.name = 'ConnectionClosedError';\n    }\n}\n/**\n * Thrown when a connection fails\n */\nexport class ConnectionFailedError extends Error {\n    static name = 'ConnectionFailedError';\n    constructor(message = 'Connection failed') {\n        super(message);\n        this.name = 'ConnectionFailedError';\n    }\n}\n/**\n * Thrown when the muxer is closed and an attempt to open a stream occurs\n */\nexport class MuxerClosedError extends Error {\n    static name = 'MuxerClosedError';\n    constructor(message = 'The muxer is closed') {\n        super(message);\n        this.name = 'MuxerClosedError';\n    }\n}\n/**\n * Thrown when a protocol stream is reset by the remote muxer\n */\nexport class StreamResetError extends Error {\n    static name = 'StreamResetError';\n    constructor(message = 'The stream has been reset') {\n        super(message);\n        this.name = 'StreamResetError';\n    }\n}\n/**\n * Thrown when a stream is in an invalid state\n */\nexport class StreamStateError extends Error {\n    static name = 'StreamStateError';\n    constructor(message = 'The stream is in an invalid state') {\n        super(message);\n        this.name = 'StreamStateError';\n    }\n}\n/**\n * Thrown when a value could not be found\n */\nexport class NotFoundError extends Error {\n    static name = 'NotFoundError';\n    constructor(message = 'Not found') {\n        super(message);\n        this.name = 'NotFoundError';\n    }\n}\n/**\n * Thrown when an invalid peer ID is encountered\n */\nexport class InvalidPeerIdError extends Error {\n    static name = 'InvalidPeerIdError';\n    constructor(message = 'Invalid PeerID') {\n        super(message);\n        this.name = 'InvalidPeerIdError';\n    }\n}\n/**\n * Thrown when an invalid multiaddr is encountered\n */\nexport class InvalidMultiaddrError extends Error {\n    static name = 'InvalidMultiaddrError';\n    constructor(message = 'Invalid multiaddr') {\n        super(message);\n        this.name = 'InvalidMultiaddrError';\n    }\n}\n/**\n * Thrown when an invalid CID is encountered\n */\nexport class InvalidCIDError extends Error {\n    static name = 'InvalidCIDError';\n    constructor(message = 'Invalid CID') {\n        super(message);\n        this.name = 'InvalidCIDError';\n    }\n}\n/**\n * Thrown when an invalid multihash is encountered\n */\nexport class InvalidMultihashError extends Error {\n    static name = 'InvalidMultihashError';\n    constructor(message = 'Invalid Multihash') {\n        super(message);\n        this.name = 'InvalidMultihashError';\n    }\n}\n/**\n * Thrown when a protocol is not supported\n */\nexport class UnsupportedProtocolError extends Error {\n    static name = 'UnsupportedProtocolError';\n    constructor(message = 'Unsupported protocol error') {\n        super(message);\n        this.name = 'UnsupportedProtocolError';\n    }\n}\n/**\n * An invalid or malformed message was encountered during a protocol exchange\n */\nexport class InvalidMessageError extends Error {\n    static name = 'InvalidMessageError';\n    constructor(message = 'Invalid message') {\n        super(message);\n        this.name = 'InvalidMessageError';\n    }\n}\n/**\n * Thrown when a remote peer sends a structurally valid message that does not\n * comply with the protocol\n */\nexport class ProtocolError extends Error {\n    static name = 'ProtocolError';\n    constructor(message = 'Protocol error') {\n        super(message);\n        this.name = 'ProtocolError';\n    }\n}\n/**\n * Throw when an operation times out\n */\nexport class TimeoutError extends Error {\n    static name = 'TimeoutError';\n    constructor(message = 'Timed out') {\n        super(message);\n        this.name = 'TimeoutError';\n    }\n}\n/**\n * Thrown when a startable component is interacted with but it has not been\n * started yet\n */\nexport class NotStartedError extends Error {\n    static name = 'NotStartedError';\n    constructor(message = 'Not started') {\n        super(message);\n        this.name = 'NotStartedError';\n    }\n}\n/**\n * Thrown when a component is started that has already been started\n */\nexport class AlreadyStartedError extends Error {\n    static name = 'AlreadyStartedError';\n    constructor(message = 'Already started') {\n        super(message);\n        this.name = 'AlreadyStartedError';\n    }\n}\n/**\n * Thrown when dialing an address failed\n */\nexport class DialError extends Error {\n    static name = 'DialError';\n    constructor(message = 'Dial error') {\n        super(message);\n        this.name = 'DialError';\n    }\n}\n/**\n * Thrown when listening on an address failed\n */\nexport class ListenError extends Error {\n    static name = 'ListenError';\n    constructor(message = 'Listen error') {\n        super(message);\n        this.name = 'ListenError';\n    }\n}\n/**\n * This error is thrown when a limited connection is encountered, i.e. if the\n * user tried to open a stream on a connection for a protocol that is not\n * configured to run over limited connections.\n */\nexport class LimitedConnectionError extends Error {\n    static name = 'LimitedConnectionError';\n    constructor(message = 'Limited connection') {\n        super(message);\n        this.name = 'LimitedConnectionError';\n    }\n}\n/**\n * This error is thrown where there are too many inbound protocols streams open\n */\nexport class TooManyInboundProtocolStreamsError extends Error {\n    static name = 'TooManyInboundProtocolStreamsError';\n    constructor(message = 'Too many inbound protocol streams') {\n        super(message);\n        this.name = 'TooManyInboundProtocolStreamsError';\n    }\n}\n/**\n * This error is thrown where there are too many outbound protocols streams open\n */\nexport class TooManyOutboundProtocolStreamsError extends Error {\n    static name = 'TooManyOutboundProtocolStreamsError';\n    constructor(message = 'Too many outbound protocol streams') {\n        super(message);\n        this.name = 'TooManyOutboundProtocolStreamsError';\n    }\n}\n/**\n * Thrown when and attempt to operate on an unsupported key was made\n */\nexport class UnsupportedKeyTypeError extends Error {\n    static name = 'UnsupportedKeyTypeError';\n    constructor(message = 'Unsupported key type') {\n        super(message);\n        this.name = 'UnsupportedKeyTypeError';\n    }\n}\n//# sourceMappingURL=errors.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { concatBytes, randomBytes } from '@noble/hashes/utils';\nimport { weierstrass } from './abstract/weierstrass.js';\n// connects noble-curves to noble-hashes\nexport function getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => hmac(hash, key, concatBytes(...msgs)),\n        randomBytes,\n    };\n}\nexport function createCurve(curveDef, defHash) {\n    const create = (hash) => weierstrass({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nimport { validateField, nLength } from './modular.js';\nimport { validateObject } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nexport function wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(1) * (Math.ceil( / ) + 1), where:\n         * -  is the window size\n         * -  is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nexport function validateBasic(curve) {\n    validateField(curve.Fp);\n    validateObject(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...nLength(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Twisted Edwards curve. The formula is: ax + y = 1 + dxy\nimport { mod } from './modular.js';\nimport * as ut from './utils.js';\nimport { ensureBytes } from './utils.js';\nimport { wNAF, validateBasic } from './curve.js';\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\nfunction validateOpts(curve) {\n    const opts = validateBasic(curve);\n    ut.validateObject(curve, {\n        hash: 'function',\n        a: 'bigint',\n        d: 'bigint',\n        randomBytes: 'function',\n    }, {\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        uvRatio: 'function',\n        mapToCurve: 'function',\n    });\n    // Set defaults\n    return Object.freeze({ ...opts });\n}\n// It is not generic twisted curve for now, but ed25519/ed448 generic implementation\nexport function twistedEdwards(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER, prehash: prehash, hash: cHash, randomBytes, nByteLength, h: cofactor, } = CURVE;\n    const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n    const modP = Fp.create; // Function overrides\n    // sqrt(u/v)\n    const uvRatio = CURVE.uvRatio ||\n        ((u, v) => {\n            try {\n                return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n            }\n            catch (e) {\n                return { isValid: false, value: _0n };\n            }\n        });\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes); // NOOP\n    const domain = CURVE.domain ||\n        ((data, ctx, phflag) => {\n            if (ctx.length || phflag)\n                throw new Error('Contexts/pre-hash are not supported');\n            return data;\n        }); // NOOP\n    const inBig = (n) => typeof n === 'bigint' && _0n < n; // n in [1..]\n    const inRange = (n, max) => inBig(n) && inBig(max) && n < max; // n in [1..max-1]\n    const in0MaskRange = (n) => n === _0n || inRange(n, MASK); // n in [0..MASK-1]\n    function assertInRange(n, max) {\n        // n in [1..max-1]\n        if (inRange(n, max))\n            return n;\n        throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`);\n    }\n    function assertGE0(n) {\n        // n in [0..CURVE_ORDER-1]\n        return n === _0n ? n : assertInRange(n, CURVE_ORDER); // GE = prime subgroup, not full group\n    }\n    const pointPrecomputes = new Map();\n    function isPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ExtendedPoint expected');\n    }\n    // Extended Point works in extended coordinates: (x, y, z, t)  (x=x/z, y=y/z, t=xy).\n    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n    class Point {\n        constructor(ex, ey, ez, et) {\n            this.ex = ex;\n            this.ey = ey;\n            this.ez = ez;\n            this.et = et;\n            if (!in0MaskRange(ex))\n                throw new Error('x required');\n            if (!in0MaskRange(ey))\n                throw new Error('y required');\n            if (!in0MaskRange(ez))\n                throw new Error('z required');\n            if (!in0MaskRange(et))\n                throw new Error('t required');\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        static fromAffine(p) {\n            if (p instanceof Point)\n                throw new Error('extended point not allowed');\n            const { x, y } = p || {};\n            if (!in0MaskRange(x) || !in0MaskRange(y))\n                throw new Error('invalid affine point');\n            return new Point(x, y, _1n, modP(x * y));\n        }\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.ez));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // Not required for fromHex(), which always creates valid points.\n        // Could be useful for fromAffine().\n        assertValidity() {\n            const { a, d } = CURVE;\n            if (this.is0())\n                throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n            // Equation in affine coordinates: ax + y = 1 + dxy\n            // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX + Y)Z = Z + dXY\n            const { ex: X, ey: Y, ez: Z, et: T } = this;\n            const X2 = modP(X * X); // X\n            const Y2 = modP(Y * Y); // Y\n            const Z2 = modP(Z * Z); // Z\n            const Z4 = modP(Z2 * Z2); // Z\n            const aX2 = modP(X2 * a); // aX\n            const left = modP(Z2 * modP(aX2 + Y2)); // (aX + Y)Z\n            const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z + dXY\n            if (left !== right)\n                throw new Error('bad point: equation left != right (1)');\n            // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n            const XY = modP(X * Y);\n            const ZT = modP(Z * T);\n            if (XY !== ZT)\n                throw new Error('bad point: equation left != right (2)');\n        }\n        // Compare one point to another.\n        equals(other) {\n            isPoint(other);\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2 } = other;\n            const X1Z2 = modP(X1 * Z2);\n            const X2Z1 = modP(X2 * Z1);\n            const Y1Z2 = modP(Y1 * Z2);\n            const Y2Z1 = modP(Y2 * Z1);\n            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        negate() {\n            // Flips point sign to a negative one (-x, y in affine coords)\n            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n        }\n        // Fast algo for doubling Extended Point.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n        double() {\n            const { a } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const A = modP(X1 * X1); // A = X12\n            const B = modP(Y1 * Y1); // B = Y12\n            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n            const D = modP(a * A); // D = a*A\n            const x1y1 = X1 + Y1;\n            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n            const G = D + B; // G = D+B\n            const F = G - C; // F = G-C\n            const H = D - B; // H = D-B\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        // Fast algo for adding 2 Extended Points.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n        // Cost: 9M + 1*a + 1*d + 7add.\n        add(other) {\n            isPoint(other);\n            const { a, d } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n            // Faster algo for adding 2 Extended Points when curve's a=-1.\n            // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4\n            // Cost: 8M + 8add + 2*2.\n            // Note: It does not check whether the `other` point is valid.\n            if (a === BigInt(-1)) {\n                const A = modP((Y1 - X1) * (Y2 + X2));\n                const B = modP((Y1 + X1) * (Y2 - X2));\n                const F = modP(B - A);\n                if (F === _0n)\n                    return this.double(); // Same point. Tests say it doesn't affect timing\n                const C = modP(Z1 * _2n * T2);\n                const D = modP(T1 * _2n * Z2);\n                const E = D + C;\n                const G = B + A;\n                const H = D - C;\n                const X3 = modP(E * F);\n                const Y3 = modP(G * H);\n                const T3 = modP(E * H);\n                const Z3 = modP(F * G);\n                return new Point(X3, Y3, Z3, T3);\n            }\n            const A = modP(X1 * X2); // A = X1*X2\n            const B = modP(Y1 * Y2); // B = Y1*Y2\n            const C = modP(T1 * d * T2); // C = T1*d*T2\n            const D = modP(Z1 * Z2); // D = Z1*Z2\n            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n            const F = D - C; // F = D-C\n            const G = D + C; // G = D+C\n            const H = modP(B - a * A); // H = B-a*A\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);\n        }\n        // Constant-time multiplication.\n        multiply(scalar) {\n            const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));\n            return Point.normalizeZ([p, f])[0];\n        }\n        // Non-constant-time multiplication. Uses double-and-add algorithm.\n        // It's faster, but should only be used when you don't care about\n        // an exposed private key e.g. sig verification.\n        // Does NOT allow scalars higher than CURVE.n.\n        multiplyUnsafe(scalar) {\n            let n = assertGE0(scalar); // 0 <= scalar < CURVE.n\n            if (n === _0n)\n                return I;\n            if (this.equals(I) || n === _1n)\n                return this;\n            if (this.equals(G))\n                return this.wNAF(n).p;\n            return wnaf.unsafeLadder(this, n);\n        }\n        // Checks if point is of small order.\n        // If you add something to small order point, you will have \"dirty\"\n        // point with torsion component.\n        // Multiplies point by cofactor and checks if the result is 0.\n        isSmallOrder() {\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        // Multiplies point by curve order and checks if the result is 0.\n        // Returns `false` is the point is dirty.\n        isTorsionFree() {\n            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n        }\n        // Converts Extended point to default (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        toAffine(iz) {\n            const { ex: x, ey: y, ez: z } = this;\n            const is0 = this.is0();\n            if (iz == null)\n                iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily\n            const ax = modP(x * iz);\n            const ay = modP(y * iz);\n            const zz = modP(z * iz);\n            if (is0)\n                return { x: _0n, y: _1n };\n            if (zz !== _1n)\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        clearCofactor() {\n            const { h: cofactor } = CURVE;\n            if (cofactor === _1n)\n                return this;\n            return this.multiplyUnsafe(cofactor);\n        }\n        // Converts hash string or Uint8Array to Point.\n        // Uses algo from RFC8032 5.1.3.\n        static fromHex(hex, zip215 = false) {\n            const { d, a } = CURVE;\n            const len = Fp.BYTES;\n            hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n            const normed = hex.slice(); // copy again, we'll manipulate it\n            const lastByte = hex[len - 1]; // select last byte\n            normed[len - 1] = lastByte & ~0x80; // clear last bit\n            const y = ut.bytesToNumberLE(normed);\n            if (y === _0n) {\n                // y=0 is allowed\n            }\n            else {\n                // RFC8032 prohibits >= p, but ZIP215 doesn't\n                if (zip215)\n                    assertInRange(y, MASK); // zip215=true [1..P-1] (2^255-19-1 for ed25519)\n                else\n                    assertInRange(y, Fp.ORDER); // zip215=false [1..MASK-1] (2^256-1 for ed25519)\n            }\n            // Ed25519: x = (y-1)/(dy+1) mod p. Ed448: x = (y-1)/(dy-1) mod p. Generic case:\n            // ax+y=1+dxy => y-1=dxy-ax => y-1=x(dy-a) => x=(y-1)/(dy-a)\n            const y2 = modP(y * y); // denominator is always non-0 mod p.\n            const u = modP(y2 - _1n); // u = y - 1\n            const v = modP(d * y2 - a); // v = d y + 1.\n            let { isValid, value: x } = uvRatio(u, v); // (u/v)\n            if (!isValid)\n                throw new Error('Point.fromHex: invalid y coordinate');\n            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n            if (!zip215 && x === _0n && isLastByteOdd)\n                // if x=0 and x_0 = 1, fail\n                throw new Error('Point.fromHex: x=0 and x_0=1');\n            if (isLastByteOdd !== isXOdd)\n                x = modP(-x); // if x_0 != x mod 2, set x = p-x\n            return Point.fromAffine({ x, y });\n        }\n        static fromPrivateKey(privKey) {\n            return getExtendedPublicKey(privKey).point;\n        }\n        toRawBytes() {\n            const { x, y } = this.toAffine();\n            const bytes = ut.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n            return bytes; // and use the last byte to encode sign of x\n        }\n        toHex() {\n            return ut.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    const { BASE: G, ZERO: I } = Point;\n    const wnaf = wNAF(Point, nByteLength * 8);\n    function modN(a) {\n        return mod(a, CURVE_ORDER);\n    }\n    // Little-endian SHA512 with modulo n\n    function modN_LE(hash) {\n        return modN(ut.bytesToNumberLE(hash));\n    }\n    /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */\n    function getExtendedPublicKey(key) {\n        const len = nByteLength;\n        key = ensureBytes('private key', key, len);\n        // Hash private key with curve's hash function to produce uniformingly random input\n        // Check byte lengths: ensure(64, h(ensure(32, key)))\n        const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n        const scalar = modN_LE(head); // The actual private scalar\n        const point = G.multiply(scalar); // Point on Edwards curve aka public key\n        const pointBytes = point.toRawBytes(); // Uint8Array representation\n        return { head, prefix, scalar, point, pointBytes };\n    }\n    // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n    function getPublicKey(privKey) {\n        return getExtendedPublicKey(privKey).pointBytes;\n    }\n    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n    function hashDomainToScalar(context = new Uint8Array(), ...msgs) {\n        const msg = ut.concatBytes(...msgs);\n        return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n    }\n    /** Signs message with privateKey. RFC8032 5.1.6 */\n    function sign(msg, privKey, options = {}) {\n        msg = ensureBytes('message', msg);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph etc.\n        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n        const R = G.multiply(r).toRawBytes(); // R = rG\n        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n        const s = modN(r + k * scalar); // S = (r + k * s) mod L\n        assertGE0(s); // 0 <= s < l\n        const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));\n        return ensureBytes('result', res, nByteLength * 2); // 64-byte signature\n    }\n    const verifyOpts = VERIFY_DEFAULT;\n    function verify(sig, msg, publicKey, options = verifyOpts) {\n        const { context, zip215 } = options;\n        const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n        sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n        msg = ensureBytes('message', msg);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph, etc\n        const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));\n        // zip215: true is good for consensus-critical apps and allows points < 2^256\n        // zip215: false follows RFC8032 / NIST186-5 and restricts points to CURVE.p\n        let A, R, SB;\n        try {\n            A = Point.fromHex(publicKey, zip215);\n            R = Point.fromHex(sig.slice(0, len), zip215);\n            SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n        }\n        catch (error) {\n            return false;\n        }\n        if (!zip215 && A.isSmallOrder())\n            return false;\n        const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n        const RkA = R.add(A.multiplyUnsafe(k));\n        // [8][S]B = [8]R + [8][k]A'\n        return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n    }\n    G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    const utils = {\n        getExtendedPublicKey,\n        // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.\n        randomPrivateKey: () => randomBytes(Fp.BYTES),\n        /**\n         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n         * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n         * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n         * @param windowSize 2, 4, 8, 16\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3));\n            return point;\n        },\n    };\n    return {\n        CURVE,\n        getPublicKey,\n        sign,\n        verify,\n        ExtendedPoint: Point,\n        utils,\n    };\n}\n//# sourceMappingURL=edwards.js.map","import { mod } from './modular.js';\nimport { bytesToNumberBE, abytes, concatBytes, utf8ToBytes, validateObject } from './utils.js';\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nexport function expand_message_xmd(msg, DST, lenInBytes, H) {\n    abytes(msg);\n    abytes(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H(concatBytes(utf8ToBytes('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = concatBytes(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H(concatBytes(...args));\n    }\n    const pseudo_random_bytes = concatBytes(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nexport function expand_message_xof(msg, DST, lenInBytes, k, H) {\n    abytes(msg);\n    abytes(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update(utf8ToBytes('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nexport function hash_to_field(msg, count, options) {\n    validateObject(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    abytes(msg);\n    anum(count);\n    const DST = typeof _DST === 'string' ? utf8ToBytes(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = mod(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nexport function isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nexport function createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nimport { bitMask, numberToBytesBE, numberToBytesLE, bytesToNumberBE, bytesToNumberLE, ensureBytes, validateObject, } from './utils.js';\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nexport function mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nexport function pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nexport function pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nexport function invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p)  1    if a is a square (mod p)\n    // (a | p)  -1   if a is not a square (mod p)\n    // (a | p)  0    if a  0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be  -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nexport function FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P  3 (mod 4)\n    // n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P  9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nexport function validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return validateObject(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nexport function FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nexport function FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nexport function nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: bitMask(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nexport function FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexport function FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nexport function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = ensureBytes('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { mod, pow } from './modular.js';\nimport { bytesToNumberLE, ensureBytes, numberToBytesLE, validateObject } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction validateOpts(curve) {\n    validateObject(curve, {\n        a: 'bigint',\n    }, {\n        montgomeryBits: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        powPminus2: 'function',\n        Gu: 'bigint',\n    });\n    // Set defaults\n    return Object.freeze({ ...curve });\n}\n// NOTE: not really montgomery curve, just bunch of very specific methods for X25519/X448 (RFC 7748, https://www.rfc-editor.org/rfc/rfc7748)\n// Uses only one coordinate instead of two\nexport function montgomery(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { P } = CURVE;\n    const modP = (n) => mod(n, P);\n    const montgomeryBits = CURVE.montgomeryBits;\n    const montgomeryBytes = Math.ceil(montgomeryBits / 8);\n    const fieldLen = CURVE.nByteLength;\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);\n    const powPminus2 = CURVE.powPminus2 || ((x) => pow(x, P - BigInt(2), P));\n    // cswap from RFC7748. But it is not from RFC7748!\n    /*\n      cswap(swap, x_2, x_3):\n           dummy = mask(swap) AND (x_2 XOR x_3)\n           x_2 = x_2 XOR dummy\n           x_3 = x_3 XOR dummy\n           Return (x_2, x_3)\n    Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n     and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    */\n    function cswap(swap, x_2, x_3) {\n        const dummy = modP(swap * (x_2 - x_3));\n        x_2 = modP(x_2 - dummy);\n        x_3 = modP(x_3 + dummy);\n        return [x_2, x_3];\n    }\n    // Accepts 0 as well\n    function assertFieldElement(n) {\n        if (typeof n === 'bigint' && _0n <= n && n < P)\n            return n;\n        throw new Error('Expected valid scalar 0 < scalar < CURVE.P');\n    }\n    // x25519 from 4\n    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n    const a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n    /**\n     *\n     * @param pointU u coordinate (x) on Montgomery Curve 25519\n     * @param scalar by which the point would be multiplied\n     * @returns new Point on Montgomery curve\n     */\n    function montgomeryLadder(pointU, scalar) {\n        const u = assertFieldElement(pointU);\n        // Section 5: Implementations MUST accept non-canonical values and process them as\n        // if they had been reduced modulo the field prime.\n        const k = assertFieldElement(scalar);\n        const x_1 = u;\n        let x_2 = _1n;\n        let z_2 = _0n;\n        let x_3 = u;\n        let z_3 = _1n;\n        let swap = _0n;\n        let sw;\n        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n            const k_t = (k >> t) & _1n;\n            swap ^= k_t;\n            sw = cswap(swap, x_2, x_3);\n            x_2 = sw[0];\n            x_3 = sw[1];\n            sw = cswap(swap, z_2, z_3);\n            z_2 = sw[0];\n            z_3 = sw[1];\n            swap = k_t;\n            const A = x_2 + z_2;\n            const AA = modP(A * A);\n            const B = x_2 - z_2;\n            const BB = modP(B * B);\n            const E = AA - BB;\n            const C = x_3 + z_3;\n            const D = x_3 - z_3;\n            const DA = modP(D * A);\n            const CB = modP(C * B);\n            const dacb = DA + CB;\n            const da_cb = DA - CB;\n            x_3 = modP(dacb * dacb);\n            z_3 = modP(x_1 * modP(da_cb * da_cb));\n            x_2 = modP(AA * BB);\n            z_2 = modP(E * (AA + modP(a24 * E)));\n        }\n        // (x_2, x_3) = cswap(swap, x_2, x_3)\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        // (z_2, z_3) = cswap(swap, z_2, z_3)\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        // z_2^(p - 2)\n        const z2 = powPminus2(z_2);\n        // Return x_2 * (z_2^(p - 2))\n        return modP(x_2 * z2);\n    }\n    function encodeUCoordinate(u) {\n        return numberToBytesLE(modP(u), montgomeryBytes);\n    }\n    function decodeUCoordinate(uEnc) {\n        // Section 5: When receiving such an array, implementations of X25519\n        // MUST mask the most significant bit in the final byte.\n        const u = ensureBytes('u coordinate', uEnc, montgomeryBytes);\n        if (fieldLen === 32)\n            u[31] &= 127; // 0b0111_1111\n        return bytesToNumberLE(u);\n    }\n    function decodeScalar(n) {\n        const bytes = ensureBytes('scalar', n);\n        const len = bytes.length;\n        if (len !== montgomeryBytes && len !== fieldLen)\n            throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${len}`);\n        return bytesToNumberLE(adjustScalarBytes(bytes));\n    }\n    function scalarMult(scalar, u) {\n        const pointU = decodeUCoordinate(u);\n        const _scalar = decodeScalar(scalar);\n        const pu = montgomeryLadder(pointU, _scalar);\n        // The result was not contributory\n        // https://cr.yp.to/ecdh.html#validate\n        if (pu === _0n)\n            throw new Error('Invalid private or public key received');\n        return encodeUCoordinate(pu);\n    }\n    // Computes public key from private. By doing scalar multiplication of base point.\n    const GuBytes = encodeUCoordinate(CURVE.Gu);\n    function scalarMultBase(scalar) {\n        return scalarMult(scalar, GuBytes);\n    }\n    return {\n        scalarMult,\n        scalarMultBase,\n        getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),\n        getPublicKey: (privateKey) => scalarMultBase(privateKey),\n        utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },\n        GuBytes: GuBytes,\n    };\n}\n//# sourceMappingURL=montgomery.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nexport function abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexport function numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexport function numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nexport function validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y = x + ax + b\nimport * as mod from './modular.js';\nimport * as ut from './utils.js';\nimport { ensureBytes } from './utils.js';\nimport { wNAF, validateBasic } from './curve.js';\nfunction validatePointOpts(curve) {\n    const opts = validateBasic(curve);\n    ut.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nexport const DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        ut.abytes(data);\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nexport function weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y = x + ax + b: Short weierstrass curve formula\n     * @returns y\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (ut.isBytes(key))\n                key = ut.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : ut.bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = mod.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y\n            const right = weierstrassEquation(x); // x + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z)  (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return ut.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = validateBasic(curve);\n    ut.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nexport function weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return mod.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return mod.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = ut.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = ut.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y = x + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n                }\n                catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                    throw new Error('Point is not on curve' + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = ensureBytes('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig(ensureBytes('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return ut.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return ut.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = mod.getMinHashLength(CURVE.n);\n            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = ut.isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return ut.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = ensureBytes('msgHash', msgHash);\n        if (prehash)\n            msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n        }\n        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1G - U2P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = ensureBytes('msgHash', msgHash);\n        publicKey = ensureBytes('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || ut.isBytes(sg)) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU(Fp, opts) {\n    mod.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha512 } from '@noble/hashes/sha512';\nimport { concatBytes, randomBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { twistedEdwards } from './abstract/edwards.js';\nimport { montgomery } from './abstract/montgomery.js';\nimport { Field, FpSqrtEven, isNegativeLE, mod, pow2 } from './abstract/modular.js';\nimport { bytesToHex, bytesToNumberLE, ensureBytes, equalBytes, numberToBytesLE, } from './abstract/utils.js';\nimport { createHasher, expand_message_xmd } from './abstract/hash-to-curve.js';\n/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n */\nconst ED25519_P = BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949');\n// (-1) aka (a) aka 2^((p-1)/4)\nconst ED25519_SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _5n = BigInt(5);\n// prettier-ignore\nconst _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\nfunction ed25519_pow_2_252_3(x) {\n    const P = ED25519_P;\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P; // x^3, 11\n    const b4 = (pow2(b2, _2n, P) * b2) % P; // x^15, 1111\n    const b5 = (pow2(b4, _1n, P) * x) % P; // x^31\n    const b10 = (pow2(b5, _5n, P) * b5) % P;\n    const b20 = (pow2(b10, _10n, P) * b10) % P;\n    const b40 = (pow2(b20, _20n, P) * b20) % P;\n    const b80 = (pow2(b40, _40n, P) * b40) % P;\n    const b160 = (pow2(b80, _80n, P) * b80) % P;\n    const b240 = (pow2(b160, _80n, P) * b80) % P;\n    const b250 = (pow2(b240, _10n, P) * b10) % P;\n    const pow_p_5_8 = (pow2(b250, _2n, P) * x) % P;\n    // ^ To pow to (p+3)/8, multiply it by x.\n    return { pow_p_5_8, b2 };\n}\nfunction adjustScalarBytes(bytes) {\n    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n    // set the three least significant bits of the first byte\n    bytes[0] &= 248; // 0b1111_1000\n    // and the most significant bit of the last to zero,\n    bytes[31] &= 127; // 0b0111_1111\n    // set the second most significant bit of the last byte to 1\n    bytes[31] |= 64; // 0b0100_0000\n    return bytes;\n}\n// sqrt(u/v)\nfunction uvRatio(u, v) {\n    const P = ED25519_P;\n    const v3 = mod(v * v * v, P); // v\n    const v7 = mod(v3 * v3 * v, P); // v\n    // (p+3)/8 and (p-5)/8\n    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n    let x = mod(u * v3 * pow, P); // (uv)(uv)^(p-5)/8\n    const vx2 = mod(v * x * x, P); // vx\n    const root1 = x; // First root candidate\n    const root2 = mod(x * ED25519_SQRT_M1, P); // Second root candidate\n    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root\n    const useRoot2 = vx2 === mod(-u, P); // If vx = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P); // There is no valid root, vx = -u(-1)\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2; // We return root2 anyway, for const-time\n    if (isNegativeLE(x, P))\n        x = mod(-x, P);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\n// Just in case\nexport const ED25519_TORSION_SUBGROUP = [\n    '0100000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n    '0000000000000000000000000000000000000000000000000000000000000080',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n    'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n    '0000000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\nconst Fp = Field(ED25519_P, undefined, true);\nconst ed25519Defaults = {\n    // Param: a\n    a: BigInt(-1), // Fp.create(-1) is proper; our way still works and is faster\n    // d is equal to -121665/121666 over finite field.\n    // Negative number is P - number, and division is invert(number, P)\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    // Finite field p over which we'll do calculations; 2n**255n - 19n\n    Fp,\n    // Subgroup order: how many points curve has\n    // 2n**252n + 27742317777372353535851937790883648493n;\n    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),\n    // Cofactor\n    h: BigInt(8),\n    // Base point (x, y) aka generator point\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n    hash: sha512,\n    randomBytes,\n    adjustScalarBytes,\n    // dom2\n    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n    // Constant-time, u/v\n    uvRatio,\n};\nexport const ed25519 = /* @__PURE__ */ twistedEdwards(ed25519Defaults);\nfunction ed25519_domain(data, ctx, phflag) {\n    if (ctx.length > 255)\n        throw new Error('Context is too big');\n    return concatBytes(utf8ToBytes('SigEd25519 no Ed25519 collisions'), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);\n}\nexport const ed25519ctx = /* @__PURE__ */ twistedEdwards({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n});\nexport const ed25519ph = /* @__PURE__ */ twistedEdwards({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n    prehash: sha512,\n});\nexport const x25519 = /* @__PURE__ */ (() => montgomery({\n    P: ED25519_P,\n    a: BigInt(486662),\n    montgomeryBits: 255, // n is 253 bits\n    nByteLength: 32,\n    Gu: BigInt(9),\n    powPminus2: (x) => {\n        const P = ED25519_P;\n        // x^(p-2) aka x^(2^255-21)\n        const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n        return mod(pow2(pow_p_5_8, BigInt(3), P) * b2, P);\n    },\n    adjustScalarBytes,\n    randomBytes,\n}))();\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */\nexport function edwardsToMontgomeryPub(edwardsPub) {\n    const { y } = ed25519.ExtendedPoint.fromHex(edwardsPub);\n    const _1n = BigInt(1);\n    return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nexport const edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */\nexport function edwardsToMontgomeryPriv(edwardsPriv) {\n    const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n    return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = Fp.pow(_2n, ELL2_C1); // 2. c2 = 2^c1\nconst ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE)); // 3. c3 = sqrt(-1)\nconst ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8); // 4. c4 = (q - 5) / 8       # Integer arithmetic\nconst ELL2_J = BigInt(486662);\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u) {\n    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1\n    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2\n    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3\n    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2\n    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4\n    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3\n    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2\n    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd\n    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u\n    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2\n    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2\n    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd\n    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2\n    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd\n    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n    return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\nconst ELL2_C1_EDWARDS = FpSqrtEven(Fp, Fp.neg(BigInt(486664))); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u) {\n    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n    // map_to_curve_elligator2_curve25519(u)\n    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n    const inv = Fp.invertBatch([xd, yd]); // batch division\n    return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) }; //  13. return (xn, xd, yn, yd)\n}\nconst htf = /* @__PURE__ */ (() => createHasher(ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {\n    DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n    encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha512,\n}))();\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistPoint))\n        throw new Error('RistrettoPoint expected');\n}\n// (-1) aka (a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// (ad - 1)\nconst SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\n// 1 / (a-d)\nconst INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\n// 1-d\nconst ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\n// (d-1)\nconst D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\n// Calculates 1/(number)\nconst invertSqrt = (number) => uvRatio(_1n, number);\nconst MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nconst bytes255ToNumberLE = (bytes) => ed25519.CURVE.Fp.create(bytesToNumberLE(bytes) & MAX_255B);\n// Computes Elligator map for Ristretto\n// https://ristretto.group/formulas/elligator.html\nfunction calcElligatorRistrettoMap(r0) {\n    const { d } = ed25519.CURVE;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const r = mod(SQRT_M1 * r0 * r0); // 1\n    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n    let c = BigInt(-1); // 3\n    const D = mod((c - d * r) * mod(r + d)); // 4\n    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n    let s_ = mod(s * r0); // 6\n    if (!isNegativeLE(s_, P))\n        s_ = mod(-s_);\n    if (!Ns_D_is_sq)\n        s = s_; // 7\n    if (!Ns_D_is_sq)\n        c = r; // 8\n    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n    const s2 = s * s;\n    const W0 = mod((s + s) * D); // 10\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n    const W2 = mod(_1n - s2); // 12\n    const W3 = mod(_1n + s2); // 13\n    return new ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448\n */\nclass RistPoint {\n    // Private property to discourage combining ExtendedPoint + RistrettoPoint\n    // Always use Ristretto encoding/decoding instead.\n    constructor(ep) {\n        this.ep = ep;\n    }\n    static fromAffine(ap) {\n        return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));\n    }\n    /**\n     * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n     * The hash-to-group operation applies Elligator twice and adds the results.\n     * **Note:** this is one-way map, there is no conversion from point to hash.\n     * https://ristretto.group/formulas/elligator.html\n     * @param hex 64-byte output of a hash function\n     */\n    static hashToCurve(hex) {\n        hex = ensureBytes('ristrettoHash', hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = calcElligatorRistrettoMap(r2);\n        return new RistPoint(R1.add(R2));\n    }\n    /**\n     * Converts ristretto-encoded string to ristretto point.\n     * https://ristretto.group/formulas/decoding.html\n     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n     */\n    static fromHex(hex) {\n        hex = ensureBytes('ristrettoHex', hex, 32);\n        const { a, d } = ed25519.CURVE;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n        const s = bytes255ToNumberLE(hex);\n        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n        // 3. Check that s is non-negative, or else abort\n        if (!equalBytes(numberToBytesLE(s, 32), hex) || isNegativeLE(s, P))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2); // 4 (a is -1)\n        const u2 = mod(_1n - a * s2); // 5\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2); // 6\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n        const Dx = mod(I * u2); // 8\n        const Dy = mod(I * Dx * v); // 9\n        let x = mod((s + s) * Dx); // 10\n        if (isNegativeLE(x, P))\n            x = mod(-x); // 10\n        const y = mod(u1 * Dy); // 11\n        const t = mod(x * y); // 12\n        if (!isValid || isNegativeLE(t, P) || y === _0n)\n            throw new Error(emsg);\n        return new RistPoint(new ed25519.ExtendedPoint(x, y, _1n, t));\n    }\n    /**\n     * Encodes ristretto point to Uint8Array.\n     * https://ristretto.group/formulas/encoding.html\n     */\n    toRawBytes() {\n        let { ex: x, ey: y, ez: z, et: t } = this.ep;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const u1 = mod(mod(z + y) * mod(z - y)); // 1\n        const u2 = mod(x * y); // 2\n        // Square root always exists\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n        const D1 = mod(invsqrt * u1); // 4\n        const D2 = mod(invsqrt * u2); // 5\n        const zInv = mod(D1 * D2 * t); // 6\n        let D; // 7\n        if (isNegativeLE(t * zInv, P)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2; // 8\n        }\n        if (isNegativeLE(x * zInv, P))\n            y = mod(-y); // 9\n        let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n        if (isNegativeLE(s, P))\n            s = mod(-s);\n        return numberToBytesLE(s, 32); // 11\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    // Compare one point to another.\n    equals(other) {\n        assertRstPoint(other);\n        const { ex: X1, ey: Y1 } = this.ep;\n        const { ex: X2, ey: Y2 } = other.ep;\n        const mod = ed25519.CURVE.Fp.create;\n        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n        const one = mod(X1 * Y2) === mod(Y1 * X2);\n        const two = mod(Y1 * Y2) === mod(X1 * X2);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistPoint(this.ep.multiplyUnsafe(scalar));\n    }\n    double() {\n        return new RistPoint(this.ep.double());\n    }\n    negate() {\n        return new RistPoint(this.ep.negate());\n    }\n}\nexport const RistrettoPoint = /* @__PURE__ */ (() => {\n    if (!RistPoint.BASE)\n        RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);\n    if (!RistPoint.ZERO)\n        RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);\n    return RistPoint;\n})();\n// Hashing to ristretto255. https://www.rfc-editor.org/rfc/rfc9380#appendix-B\nexport const hashToRistretto255 = (msg, options) => {\n    const d = options.DST;\n    const DST = typeof d === 'string' ? utf8ToBytes(d) : d;\n    const uniform_bytes = expand_message_xmd(msg, DST, 64, sha512);\n    const P = RistPoint.hashToCurve(uniform_bytes);\n    return P;\n};\nexport const hash_to_ristretto255 = hashToRistretto255; // legacy\n//# sourceMappingURL=ed25519.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha256';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { Field, mod, pow2 } from './abstract/modular.js';\nimport { mapToCurveSimpleSWU } from './abstract/weierstrass.js';\nimport { bytesToNumberBE, concatBytes, ensureBytes, numberToBytesBE } from './abstract/utils.js';\nimport { createHasher, isogenyMap } from './abstract/hash-to-curve.js';\nimport { createCurve } from './_shortw_utils.js';\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = (pow2(b3, _3n, P) * b3) % P;\n    const b9 = (pow2(b6, _3n, P) * b3) % P;\n    const b11 = (pow2(b9, _2n, P) * b2) % P;\n    const b22 = (pow2(b11, _11n, P) * b11) % P;\n    const b44 = (pow2(b22, _22n, P) * b22) % P;\n    const b88 = (pow2(b44, _44n, P) * b44) % P;\n    const b176 = (pow2(b88, _88n, P) * b88) % P;\n    const b220 = (pow2(b176, _44n, P) * b44) % P;\n    const b223 = (pow2(b220, _3n, P) * b3) % P;\n    const t1 = (pow2(b223, _23n, P) * b22) % P;\n    const t2 = (pow2(t1, _6n, P) * b2) % P;\n    const root = pow2(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nexport const secp256k1 = createCurve({\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7), // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975\n    Fp, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = mod(k - c1 * a1 - c2 * a2, n);\n            let k2 = mod(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = concatBytes(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return sha256(concatBytes(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => numberToBytesBE(n, 32);\nconst modP = (x) => mod(x, secp256k1P);\nconst modN = (x) => mod(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x  p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN(bytesToNumberBE(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = randomBytes(32)) {\n    const m = ensureBytes('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ bytesToNumberBE(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(bytesToNumberBE(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = ensureBytes('signature', signature, 64);\n    const m = ensureBytes('message', message);\n    const pub = ensureBytes('publicKey', publicKey, 32);\n    try {\n        const P = lift_x(bytesToNumberBE(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = bytesToNumberBE(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n        if (!fe(r))\n            return false;\n        const s = bytesToNumberBE(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = sG - eP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nexport const schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE,\n        bytesToNumberBE,\n        taggedHash,\n        mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => isogenyMap(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256,\n}))();\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map","function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n//# sourceMappingURL=_assert.js.map","import { exists, output } from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Choice: a ? b : c\nexport const Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nexport const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        exists(this);\n        output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_md.js.map","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { fromBig, split, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add, add3L, add3H, add4L, add4H, add5H, add5L, };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","export const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","import { hash as assertHash, bytes as assertBytes, exists as assertExists } from './_assert.js';\nimport { Hash, toBytes } from './utils.js';\n// HMAC (RFC 2104)\nexport class HMAC extends Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        assertHash(hash);\n        const key = toBytes(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        assertExists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        assertExists(this);\n        assertBytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nexport const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","import { HashMD, Chi, Maj } from './_md.js';\nimport { rotr, wrapConstructor } from './utils.js';\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n//# sourceMappingURL=sha256.js.map","import { HashMD } from './_md.js';\nimport u64 from './_u64.js';\nimport { wrapConstructor } from './utils.js';\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends HashMD {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nexport const sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());\nexport const sha512_224 = /* @__PURE__ */ wrapConstructor(() => new SHA512_224());\nexport const sha512_256 = /* @__PURE__ */ wrapConstructor(() => new SHA512_256());\nexport const sha384 = /* @__PURE__ */ wrapConstructor(() => new SHA384());\n//# sourceMappingURL=sha512.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { bytes as abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nexport const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nexport const byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nexport const byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","import { encode } from './lib/encode.js'\nimport { decode, decodeFirst, Tokeniser, tokensToObject } from './lib/decode.js'\nimport { Token, Type } from './lib/token.js'\n\n/**\n * Export the types that were present in the original manual cborg.d.ts\n * @typedef {import('./interface').TagDecoder} TagDecoder\n * There was originally just `TypeEncoder` so don't break types by renaming or not exporting\n * @typedef {import('./interface').OptionalTypeEncoder} TypeEncoder\n * @typedef {import('./interface').DecodeOptions} DecodeOptions\n * @typedef {import('./interface').EncodeOptions} EncodeOptions\n */\n\nexport {\n  decode,\n  decodeFirst,\n  Tokeniser as Tokenizer,\n  tokensToObject,\n  encode,\n  Token,\n  Type\n}\n","/* globals BigInt */\n\nimport { Token, Type } from './token.js'\nimport { decodeErrPrefix, assertEnoughData } from './common.js'\n\nexport const uintBoundaries = [24, 256, 65536, 4294967296, BigInt('18446744073709551616')]\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint8 (data, offset, options) {\n  assertEnoughData(data, offset, 1)\n  const value = data[offset]\n  if (options.strict === true && value < uintBoundaries[0]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint16 (data, offset, options) {\n  assertEnoughData(data, offset, 2)\n  const value = (data[offset] << 8) | data[offset + 1]\n  if (options.strict === true && value < uintBoundaries[1]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint32 (data, offset, options) {\n  assertEnoughData(data, offset, 4)\n  const value = (data[offset] * 16777216 /* 2 ** 24 */) + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3]\n  if (options.strict === true && value < uintBoundaries[2]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number|bigint}\n */\nexport function readUint64 (data, offset, options) {\n  // assume BigInt, convert back to Number if within safe range\n  assertEnoughData(data, offset, 8)\n  const hi = (data[offset] * 16777216 /* 2 ** 24 */) + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3]\n  const lo = (data[offset + 4] * 16777216 /* 2 ** 24 */) + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7]\n  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo)\n  if (options.strict === true && value < uintBoundaries[3]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  if (value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value)\n  }\n  if (options.allowBigInt === true) {\n    return value\n  }\n  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)\n}\n\n/* not required thanks to quick[] list\nconst oneByteTokens = new Array(24).fill(0).map((v, i) => new Token(Type.uint, i, 1))\nexport function decodeUintCompact (data, pos, minor, options) {\n  return oneByteTokens[minor]\n}\n*/\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint8 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint16 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint32 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint32(data, pos + 1, options), 5)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint64 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint64(data, pos + 1, options), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeUint (buf, token) {\n  return encodeUintValue(buf, 0, token.value)\n}\n\n/**\n * @param {Bl} buf\n * @param {number} major\n * @param {number|bigint} uint\n */\nexport function encodeUintValue (buf, major, uint) {\n  if (uint < uintBoundaries[0]) {\n    const nuint = Number(uint)\n    // pack into one byte, minor=0, additional=value\n    buf.push([major | nuint])\n  } else if (uint < uintBoundaries[1]) {\n    const nuint = Number(uint)\n    // pack into two byte, minor=0, additional=24\n    buf.push([major | 24, nuint])\n  } else if (uint < uintBoundaries[2]) {\n    const nuint = Number(uint)\n    // pack into three byte, minor=0, additional=25\n    buf.push([major | 25, nuint >>> 8, nuint & 0xff])\n  } else if (uint < uintBoundaries[3]) {\n    const nuint = Number(uint)\n    // pack into five byte, minor=0, additional=26\n    buf.push([major | 26, (nuint >>> 24) & 0xff, (nuint >>> 16) & 0xff, (nuint >>> 8) & 0xff, nuint & 0xff])\n  } else {\n    const buint = BigInt(uint)\n    if (buint < uintBoundaries[4]) {\n      // pack into nine byte, minor=0, additional=27\n      const set = [major | 27, 0, 0, 0, 0, 0, 0, 0]\n      // simulate bitwise above 32 bits\n      let lo = Number(buint & BigInt(0xffffffff))\n      let hi = Number(buint >> BigInt(32) & BigInt(0xffffffff))\n      set[8] = lo & 0xff\n      lo = lo >> 8\n      set[7] = lo & 0xff\n      lo = lo >> 8\n      set[6] = lo & 0xff\n      lo = lo >> 8\n      set[5] = lo & 0xff\n      set[4] = hi & 0xff\n      hi = hi >> 8\n      set[3] = hi & 0xff\n      hi = hi >> 8\n      set[2] = hi & 0xff\n      hi = hi >> 8\n      set[1] = hi & 0xff\n      buf.push(set)\n    } else {\n      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`)\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeUint.encodedSize = function encodedSize (token) {\n  return encodeUintValue.encodedSize(token.value)\n}\n\n/**\n * @param {number} uint\n * @returns {number}\n */\nencodeUintValue.encodedSize = function encodedSize (uint) {\n  if (uint < uintBoundaries[0]) {\n    return 1\n  }\n  if (uint < uintBoundaries[1]) {\n    return 2\n  }\n  if (uint < uintBoundaries[2]) {\n    return 3\n  }\n  if (uint < uintBoundaries[3]) {\n    return 5\n  }\n  return 9\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeUint.compareTokens = function compareTokens (tok1, tok2) {\n  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : /* c8 ignore next */ 0\n}\n","/* eslint-env es2020 */\n\nimport { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint8 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint16 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint32 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint32(data, pos + 1, options), 5)\n}\n\nconst neg1b = BigInt(-1)\nconst pos1b = BigInt(1)\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint64 (data, pos, _minor, options) {\n  const int = uint.readUint64(data, pos + 1, options)\n  if (typeof int !== 'bigint') {\n    const value = -1 - int\n    if (value >= Number.MIN_SAFE_INTEGER) {\n      return new Token(Type.negint, value, 9)\n    }\n  }\n  if (options.allowBigInt !== true) {\n    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)\n  }\n  return new Token(Type.negint, neg1b - BigInt(int), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeNegint (buf, token) {\n  const negint = token.value\n  const unsigned = (typeof negint === 'bigint' ? (negint * neg1b - pos1b) : (negint * -1 - 1))\n  uint.encodeUintValue(buf, token.type.majorEncoded, unsigned)\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeNegint.encodedSize = function encodedSize (token) {\n  const negint = token.value\n  const unsigned = (typeof negint === 'bigint' ? (negint * neg1b - pos1b) : (negint * -1 - 1))\n  /* c8 ignore next 4 */\n  // handled by quickEncode, we shouldn't get here but it's included for completeness\n  if (unsigned < uint.uintBoundaries[0]) {\n    return 1\n  }\n  if (unsigned < uint.uintBoundaries[1]) {\n    return 2\n  }\n  if (unsigned < uint.uintBoundaries[2]) {\n    return 3\n  }\n  if (unsigned < uint.uintBoundaries[3]) {\n    return 5\n  }\n  return 9\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeNegint.compareTokens = function compareTokens (tok1, tok2) {\n  // opposite of the uint comparison since we store the uint version in bytes\n  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : /* c8 ignore next */ 0\n}\n","import { Token, Type } from './token.js'\nimport { assertEnoughData, decodeErrPrefix } from './common.js'\nimport * as uint from './0uint.js'\nimport { compare, fromString, slice } from './byte-utils.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (data, pos, prefix, length) {\n  assertEnoughData(data, pos, prefix + length)\n  const buf = slice(data, pos + prefix, pos + prefix + length)\n  return new Token(Type.bytes, buf, prefix + length)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeBytesCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * `encodedBytes` allows for caching when we do a byte version of a string\n * for key sorting purposes\n * @param {Token} token\n * @returns {Uint8Array}\n */\nfunction tokenBytes (token) {\n  if (token.encodedBytes === undefined) {\n    token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value\n  }\n  // @ts-ignore c'mon\n  return token.encodedBytes\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeBytes (buf, token) {\n  const bytes = tokenBytes(token)\n  uint.encodeUintValue(buf, token.type.majorEncoded, bytes.length)\n  buf.push(bytes)\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeBytes.encodedSize = function encodedSize (token) {\n  const bytes = tokenBytes(token)\n  return uint.encodeUintValue.encodedSize(bytes.length) + bytes.length\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeBytes.compareTokens = function compareTokens (tok1, tok2) {\n  return compareBytes(tokenBytes(tok1), tokenBytes(tok2))\n}\n\n/**\n * @param {Uint8Array} b1\n * @param {Uint8Array} b2\n * @returns {number}\n */\nexport function compareBytes (b1, b2) {\n  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2)\n}\n","import { Token, Type } from './token.js'\nimport { assertEnoughData, decodeErrPrefix } from './common.js'\nimport * as uint from './0uint.js'\nimport { encodeBytes } from './2bytes.js'\nimport { toString, slice } from './byte-utils.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} prefix\n * @param {number} length\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction toToken (data, pos, prefix, length, options) {\n  const totLength = prefix + length\n  assertEnoughData(data, pos, totLength)\n  const tok = new Token(Type.string, toString(data, pos + prefix, pos + totLength), totLength)\n  if (options.retainStringBytes === true) {\n    tok.byteValue = slice(data, pos + prefix, pos + totLength)\n  }\n  return tok\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeStringCompact (data, pos, minor, options) {\n  return toToken(data, pos, 1, minor, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options), options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options), options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options), options)\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`)\n  }\n  return toToken(data, pos, 9, l, options)\n}\n\nexport const encodeString = encodeBytes\n","import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (_data, _pos, prefix, length) {\n  return new Token(Type.array, length, prefix)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeArrayCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArrayIndefinite (data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return toToken(data, pos, 1, Infinity)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeArray (buf, token) {\n  uint.encodeUintValue(buf, Type.array.majorEncoded, token.value)\n}\n\n// using an array as a map key, are you sure about this? we can only sort\n// by map length here, it's up to the encoder to decide to look deeper\nencodeArray.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeArray.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n","import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (_data, _pos, prefix, length) {\n  return new Token(Type.map, length, prefix)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeMapCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMapIndefinite (data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return toToken(data, pos, 1, Infinity)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeMap (buf, token) {\n  uint.encodeUintValue(buf, Type.map.majorEncoded, token.value)\n}\n\n// using a map as a map key, are you sure about this? we can only sort\n// by map length here, it's up to the encoder to decide to look deeper\nencodeMap.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeMap.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n","import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeTagCompact (_data, _pos, minor, _options) {\n  return new Token(Type.tag, minor, 1)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag8 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag16 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag32 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint32(data, pos + 1, options), 5)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag64 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint64(data, pos + 1, options), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeTag (buf, token) {\n  uint.encodeUintValue(buf, Type.tag.majorEncoded, token.value)\n}\n\nencodeTag.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeTag.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n","// TODO: shift some of the bytes logic to bytes-utils so we can use Buffer\n// where possible\n\nimport { Token, Type } from './token.js'\nimport { decodeErrPrefix } from './common.js'\nimport { encodeUint } from './0uint.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n */\n\nconst MINOR_FALSE = 20\nconst MINOR_TRUE = 21\nconst MINOR_NULL = 22\nconst MINOR_UNDEFINED = 23\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUndefined (_data, _pos, _minor, options) {\n  if (options.allowUndefined === false) {\n    throw new Error(`${decodeErrPrefix} undefined values are not supported`)\n  } else if (options.coerceUndefinedToNull === true) {\n    return new Token(Type.null, null, 1)\n  }\n  return new Token(Type.undefined, undefined, 1)\n}\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBreak (_data, _pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return new Token(Type.break, undefined, 1)\n}\n\n/**\n * @param {number} value\n * @param {number} bytes\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction createToken (value, bytes, options) {\n  if (options) {\n    if (options.allowNaN === false && Number.isNaN(value)) {\n      throw new Error(`${decodeErrPrefix} NaN values are not supported`)\n    }\n    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {\n      throw new Error(`${decodeErrPrefix} Infinity values are not supported`)\n    }\n  }\n  return new Token(Type.float, value, bytes)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat16 (data, pos, _minor, options) {\n  return createToken(readFloat16(data, pos + 1), 3, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat32 (data, pos, _minor, options) {\n  return createToken(readFloat32(data, pos + 1), 5, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat64 (data, pos, _minor, options) {\n  return createToken(readFloat64(data, pos + 1), 9, options)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n * @param {EncodeOptions} options\n */\nexport function encodeFloat (buf, token, options) {\n  const float = token.value\n\n  if (float === false) {\n    buf.push([Type.float.majorEncoded | MINOR_FALSE])\n  } else if (float === true) {\n    buf.push([Type.float.majorEncoded | MINOR_TRUE])\n  } else if (float === null) {\n    buf.push([Type.float.majorEncoded | MINOR_NULL])\n  } else if (float === undefined) {\n    buf.push([Type.float.majorEncoded | MINOR_UNDEFINED])\n  } else {\n    let decoded\n    let success = false\n    if (!options || options.float64 !== true) {\n      encodeFloat16(float)\n      decoded = readFloat16(ui8a, 1)\n      if (float === decoded || Number.isNaN(float)) {\n        ui8a[0] = 0xf9\n        buf.push(ui8a.slice(0, 3))\n        success = true\n      } else {\n        encodeFloat32(float)\n        decoded = readFloat32(ui8a, 1)\n        if (float === decoded) {\n          ui8a[0] = 0xfa\n          buf.push(ui8a.slice(0, 5))\n          success = true\n        }\n      }\n    }\n    if (!success) {\n      encodeFloat64(float)\n      decoded = readFloat64(ui8a, 1)\n      ui8a[0] = 0xfb\n      buf.push(ui8a.slice(0, 9))\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @param {EncodeOptions} options\n * @returns {number}\n */\nencodeFloat.encodedSize = function encodedSize (token, options) {\n  const float = token.value\n\n  if (float === false || float === true || float === null || float === undefined) {\n    return 1\n  }\n\n  if (!options || options.float64 !== true) {\n    encodeFloat16(float)\n    let decoded = readFloat16(ui8a, 1)\n    if (float === decoded || Number.isNaN(float)) {\n      return 3\n    }\n    encodeFloat32(float)\n    decoded = readFloat32(ui8a, 1)\n    if (float === decoded) {\n      return 5\n    }\n  }\n  return 9\n}\n\nconst buffer = new ArrayBuffer(9)\nconst dataView = new DataView(buffer, 1)\nconst ui8a = new Uint8Array(buffer, 0)\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat16 (inp) {\n  if (inp === Infinity) {\n    dataView.setUint16(0, 0x7c00, false)\n  } else if (inp === -Infinity) {\n    dataView.setUint16(0, 0xfc00, false)\n  } else if (Number.isNaN(inp)) {\n    dataView.setUint16(0, 0x7e00, false)\n  } else {\n    dataView.setFloat32(0, inp)\n    const valu32 = dataView.getUint32(0)\n    const exponent = (valu32 & 0x7f800000) >> 23\n    const mantissa = valu32 & 0x7fffff\n\n    /* c8 ignore next 6 */\n    if (exponent === 0xff) {\n      // too big, Infinity, but this should be hard (impossible?) to trigger\n      dataView.setUint16(0, 0x7c00, false)\n    } else if (exponent === 0x00) {\n      // 0.0, -0.0 and subnormals, shouldn't be possible to get here because 0.0 should be counted as an int\n      dataView.setUint16(0, ((inp & 0x80000000) >> 16) | (mantissa >> 13), false)\n    } else { // standard numbers\n      // chunks of logic here borrowed from https://github.com/PJK/libcbor/blob/c78f437182533e3efa8d963ff4b945bb635c2284/src/cbor/encoding.c#L127\n      const logicalExponent = exponent - 127\n      // Now we know that 2^exponent <= 0 logically\n      /* c8 ignore next 6 */\n      if (logicalExponent < -24) {\n        /* No unambiguous representation exists, this float is not a half float\n          and is too small to be represented using a half, round off to zero.\n          Consistent with the reference implementation. */\n        // should be difficult (impossible?) to get here in JS\n        dataView.setUint16(0, 0)\n      } else if (logicalExponent < -14) {\n        /* Offset the remaining decimal places by shifting the significand, the\n          value is lost. This is an implementation decision that works around the\n          absence of standard half-float in the language. */\n        dataView.setUint16(0, ((valu32 & 0x80000000) >> 16) | /* sign bit */ (1 << (24 + logicalExponent)), false)\n      } else {\n        dataView.setUint16(0, ((valu32 & 0x80000000) >> 16) | ((logicalExponent + 15) << 10) | (mantissa >> 13), false)\n      }\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat16 (ui8a, pos) {\n  if (ui8a.length - pos < 2) {\n    throw new Error(`${decodeErrPrefix} not enough data for float16`)\n  }\n\n  const half = (ui8a[pos] << 8) + ui8a[pos + 1]\n  if (half === 0x7c00) {\n    return Infinity\n  }\n  if (half === 0xfc00) {\n    return -Infinity\n  }\n  if (half === 0x7e00) {\n    return NaN\n  }\n  const exp = (half >> 10) & 0x1f\n  const mant = half & 0x3ff\n  let val\n  if (exp === 0) {\n    val = mant * (2 ** -24)\n  } else if (exp !== 31) {\n    val = (mant + 1024) * (2 ** (exp - 25))\n  /* c8 ignore next 4 */\n  } else {\n    // may not be possible to get here\n    val = mant === 0 ? Infinity : NaN\n  }\n  return (half & 0x8000) ? -val : val\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat32 (inp) {\n  dataView.setFloat32(0, inp, false)\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat32 (ui8a, pos) {\n  if (ui8a.length - pos < 4) {\n    throw new Error(`${decodeErrPrefix} not enough data for float32`)\n  }\n  const offset = (ui8a.byteOffset || 0) + pos\n  return new DataView(ui8a.buffer, offset, 4).getFloat32(0, false)\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat64 (inp) {\n  dataView.setFloat64(0, inp, false)\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat64 (ui8a, pos) {\n  if (ui8a.length - pos < 8) {\n    throw new Error(`${decodeErrPrefix} not enough data for float64`)\n  }\n  const offset = (ui8a.byteOffset || 0) + pos\n  return new DataView(ui8a.buffer, offset, 8).getFloat64(0, false)\n}\n\n/**\n * @param {Token} _tok1\n * @param {Token} _tok2\n * @returns {number}\n */\nencodeFloat.compareTokens = encodeUint.compareTokens\n/*\nencodeFloat.compareTokens = function compareTokens (_tok1, _tok2) {\n  return _tok1\n  throw new Error(`${encodeErrPrefix} cannot use floats as map keys`)\n}\n*/\n","/**\n * Bl is a list of byte chunks, similar to https://github.com/rvagg/bl but for\n * writing rather than reading.\n * A Bl object accepts set() operations for individual bytes and copyTo() for\n * inserting byte arrays. These write operations don't automatically increment\n * the internal cursor so its \"length\" won't be changed. Instead, increment()\n * must be called to extend its length to cover the inserted data.\n * The toBytes() call will convert all internal memory to a single Uint8Array of\n * the correct length, truncating any data that is stored but hasn't been\n * included by an increment().\n * get() can retrieve a single byte.\n * All operations (except toBytes()) take an \"offset\" argument that will perform\n * the write at the offset _from the current cursor_. For most operations this\n * will be `0` to write at the current cursor position but it can be ahead of\n * the current cursor. Negative offsets probably work but are untested.\n */\n\n// TODO: ipjs doesn't support this, only for test files: https://github.com/mikeal/ipjs/blob/master/src/package/testFile.js#L39\nimport { alloc, concat, slice } from './byte-utils.js'\n\n// the ts-ignores in this file are almost all for the `Uint8Array|number[]` duality that exists\n// for perf reasons. Consider better approaches to this or removing it entirely, it is quite\n// risky because of some assumptions about small chunks === number[] and everything else === Uint8Array.\n\nconst defaultChunkSize = 256\n\nexport class Bl {\n  /**\n   * @param {number} [chunkSize]\n   */\n  constructor (chunkSize = defaultChunkSize) {\n    this.chunkSize = chunkSize\n    /** @type {number} */\n    this.cursor = 0\n    /** @type {number} */\n    this.maxCursor = -1\n    /** @type {(Uint8Array|number[])[]} */\n    this.chunks = []\n    // keep the first chunk around if we can to save allocations for future encodes\n    /** @type {Uint8Array|number[]|null} */\n    this._initReuseChunk = null\n  }\n\n  reset () {\n    this.cursor = 0\n    this.maxCursor = -1\n    if (this.chunks.length) {\n      this.chunks = []\n    }\n    if (this._initReuseChunk !== null) {\n      this.chunks.push(this._initReuseChunk)\n      this.maxCursor = this._initReuseChunk.length - 1\n    }\n  }\n\n  /**\n   * @param {Uint8Array|number[]} bytes\n   */\n  push (bytes) {\n    let topChunk = this.chunks[this.chunks.length - 1]\n    const newMax = this.cursor + bytes.length\n    if (newMax <= this.maxCursor + 1) {\n      // we have at least one chunk and we can fit these bytes into that chunk\n      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1\n      // @ts-ignore\n      topChunk.set(bytes, chunkPos)\n    } else {\n      // can't fit it in\n      if (topChunk) {\n        // trip the last chunk to `cursor` if we need to\n        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1\n        if (chunkPos < topChunk.length) {\n          // @ts-ignore\n          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos)\n          this.maxCursor = this.cursor - 1\n        }\n      }\n      if (bytes.length < 64 && bytes.length < this.chunkSize) {\n        // make a new chunk and copy the new one into it\n        topChunk = alloc(this.chunkSize)\n        this.chunks.push(topChunk)\n        this.maxCursor += topChunk.length\n        if (this._initReuseChunk === null) {\n          this._initReuseChunk = topChunk\n        }\n        // @ts-ignore\n        topChunk.set(bytes, 0)\n      } else {\n        // push the new bytes in as its own chunk\n        this.chunks.push(bytes)\n        this.maxCursor += bytes.length\n      }\n    }\n    this.cursor += bytes.length\n  }\n\n  /**\n   * @param {boolean} [reset]\n   * @returns {Uint8Array}\n   */\n  toBytes (reset = false) {\n    let byts\n    if (this.chunks.length === 1) {\n      const chunk = this.chunks[0]\n      if (reset && this.cursor > chunk.length / 2) {\n        /* c8 ignore next 2 */\n        // @ts-ignore\n        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor)\n        this._initReuseChunk = null\n        this.chunks = []\n      } else {\n        // @ts-ignore\n        byts = slice(chunk, 0, this.cursor)\n      }\n    } else {\n      // @ts-ignore\n      byts = concat(this.chunks, this.cursor)\n    }\n    if (reset) {\n      this.reset()\n    }\n    return byts\n  }\n}\n","// Use Uint8Array directly in the browser, use Buffer in Node.js but don't\n// speak its name directly to avoid bundlers pulling in the `Buffer` polyfill\n\n// @ts-ignore\nexport const useBuffer = globalThis.process &&\n  // @ts-ignore\n  !globalThis.process.browser &&\n  // @ts-ignore\n  globalThis.Buffer &&\n  // @ts-ignore\n  typeof globalThis.Buffer.isBuffer === 'function'\n\nconst textDecoder = new TextDecoder()\nconst textEncoder = new TextEncoder()\n\n/**\n * @param {Uint8Array} buf\n * @returns {boolean}\n */\nfunction isBuffer (buf) {\n  // @ts-ignore\n  return useBuffer && globalThis.Buffer.isBuffer(buf)\n}\n\n/**\n * @param {Uint8Array|number[]} buf\n * @returns {Uint8Array}\n */\nexport function asU8A (buf) {\n  /* c8 ignore next */\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf)\n  }\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf\n}\n\nexport const toString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8')\n        : utf8Slice(bytes, start, end)\n    }\n  /* c8 ignore next 11 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? textDecoder.decode(bytes.subarray(start, end))\n        : utf8Slice(bytes, start, end)\n    }\n\nexport const fromString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(string)\n        : utf8ToBytes(string)\n    }\n  /* c8 ignore next 7 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string)\n    }\n\n/**\n * Buffer variant not fast enough for what we need\n * @param {number[]} arr\n * @returns {Uint8Array}\n */\nexport const fromArray = (arr) => {\n  return Uint8Array.from(arr)\n}\n\nexport const slice = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      if (isBuffer(bytes)) {\n        return new Uint8Array(bytes.subarray(start, end))\n      }\n      return bytes.slice(start, end)\n    }\n  /* c8 ignore next 9 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return bytes.slice(start, end)\n    }\n\nexport const concat = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      // might get a stray plain Array here\n      /* c8 ignore next 1 */\n      chunks = chunks.map((c) => c instanceof Uint8Array\n        ? c\n        // this case is occasionally missed during test runs so becomes coverage-flaky\n        /* c8 ignore next 4 */\n        : // eslint-disable-line operator-linebreak\n        // @ts-ignore\n        globalThis.Buffer.from(c))\n      // @ts-ignore\n      return asU8A(globalThis.Buffer.concat(chunks, length))\n    }\n  /* c8 ignore next 19 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      const out = new Uint8Array(length)\n      let off = 0\n      for (let b of chunks) {\n        if (off + b.length > out.length) {\n          // final chunk that's bigger than we need\n          b = b.subarray(0, out.length - off)\n        }\n        out.set(b, off)\n        off += b.length\n      }\n      return out\n    }\n\nexport const alloc = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      // we always write over the contents we expose so this should be safe\n      // @ts-ignore\n      return globalThis.Buffer.allocUnsafe(size)\n    }\n  /* c8 ignore next 8 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      return new Uint8Array(size)\n    }\n\nexport const toHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(toBytes(d)).toString('hex')\n    }\n  /* c8 ignore next 12 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore not smart enough to figure this out\n      return Array.prototype.reduce.call(toBytes(d), (p, c) => `${p}${c.toString(16).padStart(2, '0')}`, '')\n    }\n\nexport const fromHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(hex, 'hex')\n    }\n  /* c8 ignore next 17 */\n  : // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      if (!hex.length) {\n        return new Uint8Array(0)\n      }\n      return new Uint8Array(hex.split('')\n        .map((/** @type {string} */ c, /** @type {number} */ i, /** @type {string[]} */ d) => i % 2 === 0 ? `0x${c}${d[i + 1]}` : '')\n        .filter(Boolean)\n        .map((/** @type {string} */ e) => parseInt(e, 16)))\n    }\n\n/**\n * @param {Uint8Array|ArrayBuffer|ArrayBufferView} obj\n * @returns {Uint8Array}\n */\nfunction toBytes (obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj\n  }\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj)\n  }\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength)\n  }\n  /* c8 ignore next */\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {Uint8Array} b1\n * @param {Uint8Array} b2\n * @returns {number}\n */\nexport function compare (b1, b2) {\n  /* c8 ignore next 5 */\n  if (isBuffer(b1) && isBuffer(b2)) {\n    // probably not possible to get here in the current API\n    // @ts-ignore Buffer\n    return b1.compare(b2)\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue\n    }\n    return b1[i] < b2[i] ? -1 : 1\n  } /* c8 ignore next 3 */\n  return 0\n}\n\n// The below code is taken from https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143\n// Licensed Apache-2.0.\n\n/**\n * @param {string} str\n * @returns {number[]}\n */\nfunction utf8ToBytes (str) {\n  const out = []\n  let p = 0\n  for (let i = 0; i < str.length; i++) {\n    let c = str.charCodeAt(i)\n    if (c < 128) {\n      out[p++] = c\n    } else if (c < 2048) {\n      out[p++] = (c >> 6) | 192\n      out[p++] = (c & 63) | 128\n    } else if (\n      ((c & 0xFC00) === 0xD800) && (i + 1) < str.length &&\n      ((str.charCodeAt(i + 1) & 0xFC00) === 0xDC00)) {\n      // Surrogate Pair\n      c = 0x10000 + ((c & 0x03FF) << 10) + (str.charCodeAt(++i) & 0x03FF)\n      out[p++] = (c >> 18) | 240\n      out[p++] = ((c >> 12) & 63) | 128\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    } else {\n      out[p++] = (c >> 12) | 224\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    }\n  }\n  return out\n}\n\n// The below code is mostly taken from https://github.com/feross/buffer\n// Licensed MIT. Copyright (c) Feross Aboukhadijeh\n\n/**\n * @param {Uint8Array} buf\n * @param {number} offset\n * @param {number} end\n * @returns {string}\n */\nfunction utf8Slice (buf, offset, end) {\n  const res = []\n\n  while (offset < end) {\n    const firstByte = buf[offset]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xef) ? 4 : (firstByte > 0xdf) ? 3 : (firstByte > 0xbf) ? 2 : 1\n\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[offset + 1]\n          if ((secondByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1f) << 0x6 | (secondByte & 0x3f)\n            if (tempCodePoint > 0x7f) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0xc | (secondByte & 0x3f) << 0x6 | (thirdByte & 0x3f)\n            /* c8 ignore next 3 */\n            if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          fourthByte = buf[offset + 3]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0x12 | (secondByte & 0x3f) << 0xc | (thirdByte & 0x3f) << 0x6 | (fourthByte & 0x3f)\n            if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    /* c8 ignore next 5 */\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xfffd\n      bytesPerSequence = 1\n    } else if (codePoint > 0xffff) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3ff | 0xd800)\n      codePoint = 0xdc00 | codePoint & 0x3ff\n    }\n\n    res.push(codePoint)\n    offset += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\n/**\n * @param {number[]} codePoints\n * @returns {string}\n */\nexport function decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n  /* c8 ignore next 10 */\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n","const decodeErrPrefix = 'CBOR decode error:'\nconst encodeErrPrefix = 'CBOR encode error:'\n\nconst uintMinorPrefixBytes = []\nuintMinorPrefixBytes[23] = 1\nuintMinorPrefixBytes[24] = 2\nuintMinorPrefixBytes[25] = 3\nuintMinorPrefixBytes[26] = 5\nuintMinorPrefixBytes[27] = 9\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} need\n */\nfunction assertEnoughData (data, pos, need) {\n  if (data.length - pos < need) {\n    throw new Error(`${decodeErrPrefix} not enough data for type`)\n  }\n}\n\nexport {\n  decodeErrPrefix,\n  encodeErrPrefix,\n  uintMinorPrefixBytes,\n  assertEnoughData\n}\n","import { decodeErrPrefix } from './common.js'\nimport { Type } from './token.js'\nimport { jump, quick } from './jump.js'\n\n/**\n * @typedef {import('./token.js').Token} Token\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').DecodeTokenizer} DecodeTokenizer\n */\n\nconst defaultDecodeOptions = {\n  strict: false,\n  allowIndefinite: true,\n  allowUndefined: true,\n  allowBigInt: true\n}\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass Tokeniser {\n  /**\n   * @param {Uint8Array} data\n   * @param {DecodeOptions} options\n   */\n  constructor (data, options = {}) {\n    this._pos = 0\n    this.data = data\n    this.options = options\n  }\n\n  pos () {\n    return this._pos\n  }\n\n  done () {\n    return this._pos >= this.data.length\n  }\n\n  next () {\n    const byt = this.data[this._pos]\n    let token = quick[byt]\n    if (token === undefined) {\n      const decoder = jump[byt]\n      /* c8 ignore next 4 */\n      // if we're here then there's something wrong with our jump or quick lists!\n      if (!decoder) {\n        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, '0')})`)\n      }\n      const minor = byt & 31\n      token = decoder(this.data, this._pos, minor, this.options)\n    }\n    // @ts-ignore we get to assume encodedLength is set (crossing fingers slightly)\n    this._pos += token.encodedLength\n    return token\n  }\n}\n\nconst DONE = Symbol.for('DONE')\nconst BREAK = Symbol.for('BREAK')\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToArray (token, tokeniser, options) {\n  const arr = []\n  for (let i = 0; i < token.value; i++) {\n    const value = tokensToObject(tokeniser, options)\n    if (value === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length array\n        break\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`)\n    }\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`)\n    }\n    arr[i] = value\n  }\n  return arr\n}\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToMap (token, tokeniser, options) {\n  const useMaps = options.useMaps === true\n  const obj = useMaps ? undefined : {}\n  const m = useMaps ? new Map() : undefined\n  for (let i = 0; i < token.value; i++) {\n    const key = tokensToObject(tokeniser, options)\n    if (key === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length map\n        break\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`)\n    }\n    if (key === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`)\n    }\n    if (useMaps !== true && typeof key !== 'string') {\n      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`)\n    }\n    if (options.rejectDuplicateMapKeys === true) {\n      // @ts-ignore\n      if ((useMaps && m.has(key)) || (!useMaps && (key in obj))) {\n        throw new Error(`${decodeErrPrefix} found repeat map key \"${key}\"`)\n      }\n    }\n    const value = tokensToObject(tokeniser, options)\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`)\n    }\n    if (useMaps) {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      m.set(key, value)\n    } else {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      obj[key] = value\n    }\n  }\n  // @ts-ignore c'mon man\n  return useMaps ? m : obj\n}\n\n/**\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokensToObject (tokeniser, options) {\n  // should we support array as an argument?\n  // check for tokenIter[Symbol.iterator] and replace tokenIter with what that returns?\n  if (tokeniser.done()) {\n    return DONE\n  }\n\n  const token = tokeniser.next()\n\n  if (token.type === Type.break) {\n    return BREAK\n  }\n\n  if (token.type.terminal) {\n    return token.value\n  }\n\n  if (token.type === Type.array) {\n    return tokenToArray(token, tokeniser, options)\n  }\n\n  if (token.type === Type.map) {\n    return tokenToMap(token, tokeniser, options)\n  }\n\n  if (token.type === Type.tag) {\n    if (options.tags && typeof options.tags[token.value] === 'function') {\n      const tagged = tokensToObject(tokeniser, options)\n      return options.tags[token.value](tagged)\n    }\n    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`)\n  }\n  /* c8 ignore next */\n  throw new Error('unsupported')\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {[any, Uint8Array]}\n */\nfunction decodeFirst (data, options) {\n  if (!(data instanceof Uint8Array)) {\n    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`)\n  }\n  options = Object.assign({}, defaultDecodeOptions, options)\n  const tokeniser = options.tokenizer || new Tokeniser(data, options)\n  const decoded = tokensToObject(tokeniser, options)\n  if (decoded === DONE) {\n    throw new Error(`${decodeErrPrefix} did not find any content to decode`)\n  }\n  if (decoded === BREAK) {\n    throw new Error(`${decodeErrPrefix} got unexpected break`)\n  }\n  return [decoded, data.subarray(tokeniser.pos())]\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {any}\n */\nfunction decode (data, options) {\n  const [decoded, remainder] = decodeFirst(data, options)\n  if (remainder.length > 0) {\n    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`)\n  }\n  return decoded\n}\n\nexport { Tokeniser, tokensToObject, decode, decodeFirst }\n","import { is } from './is.js'\nimport { Token, Type } from './token.js'\nimport { Bl } from './bl.js'\nimport { encodeErrPrefix } from './common.js'\nimport { quickEncodeToken } from './jump.js'\nimport { asU8A } from './byte-utils.js'\n\nimport { encodeUint } from './0uint.js'\nimport { encodeNegint } from './1negint.js'\nimport { encodeBytes } from './2bytes.js'\nimport { encodeString } from './3string.js'\nimport { encodeArray } from './4array.js'\nimport { encodeMap } from './5map.js'\nimport { encodeTag } from './6tag.js'\nimport { encodeFloat } from './7float.js'\n\n/**\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../interface').OptionalTypeEncoder} OptionalTypeEncoder\n * @typedef {import('../interface').Reference} Reference\n * @typedef {import('../interface').StrictTypeEncoder} StrictTypeEncoder\n * @typedef {import('../interface').TokenTypeEncoder} TokenTypeEncoder\n * @typedef {import('../interface').TokenOrNestedTokens} TokenOrNestedTokens\n */\n\n/** @type {EncodeOptions} */\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n}\n\n/** @returns {TokenTypeEncoder[]} */\nexport function makeCborEncoders () {\n  const encoders = []\n  encoders[Type.uint.major] = encodeUint\n  encoders[Type.negint.major] = encodeNegint\n  encoders[Type.bytes.major] = encodeBytes\n  encoders[Type.string.major] = encodeString\n  encoders[Type.array.major] = encodeArray\n  encoders[Type.map.major] = encodeMap\n  encoders[Type.tag.major] = encodeTag\n  encoders[Type.float.major] = encodeFloat\n  return encoders\n}\n\nconst cborEncoders = makeCborEncoders()\n\nconst buf = new Bl()\n\n/** @implements {Reference} */\nclass Ref {\n  /**\n   * @param {object|any[]} obj\n   * @param {Reference|undefined} parent\n   */\n  constructor (obj, parent) {\n    this.obj = obj\n    this.parent = parent\n  }\n\n  /**\n   * @param {object|any[]} obj\n   * @returns {boolean}\n   */\n  includes (obj) {\n    /** @type {Reference|undefined} */\n    let p = this\n    do {\n      if (p.obj === obj) {\n        return true\n      }\n    } while (p = p.parent) // eslint-disable-line\n    return false\n  }\n\n  /**\n   * @param {Reference|undefined} stack\n   * @param {object|any[]} obj\n   * @returns {Reference}\n   */\n  static createCheck (stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${encodeErrPrefix} object contains circular references`)\n    }\n    return new Ref(obj, stack)\n  }\n}\n\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n}\n\n/** @type {{[typeName: string]: StrictTypeEncoder}} */\nconst typeEncoders = {\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  number (obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj)\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj)\n    } else {\n      return new Token(Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  bigint (obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj)\n    } else {\n      return new Token(Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Uint8Array (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  string (obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  boolean (obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  null (_obj, _typ, _options, _refStack) {\n    return simpleTokens.null\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  undefined (_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  ArrayBuffer (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  DataView (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Array (obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyArray, new Token(Type.break)]\n      }\n      return simpleTokens.emptyArray\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    const entries = []\n    let i = 0\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack)\n    }\n    if (options.addBreakTokens) {\n      return [new Token(Type.array, obj.length), entries, new Token(Type.break)]\n    }\n    return [new Token(Type.array, obj.length), entries]\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Object (obj, typ, options, refStack) {\n    // could be an Object or a Map\n    const isMap = typ !== 'Object'\n    // it's slightly quicker to use Object.keys() than Object.entries()\n    const keys = isMap ? obj.keys() : Object.keys(obj)\n    const length = isMap ? obj.size : keys.length\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyMap, new Token(Type.break)]\n      }\n      return simpleTokens.emptyMap\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    /** @type {TokenOrNestedTokens[]} */\n    const entries = []\n    let i = 0\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ]\n    }\n    sortMapEntries(entries, options)\n    if (options.addBreakTokens) {\n      return [new Token(Type.map, length), entries, new Token(Type.break)]\n    }\n    return [new Token(Type.map, length), entries]\n  }\n}\n\ntypeEncoders.Map = typeEncoders.Object\ntypeEncoders.Buffer = typeEncoders.Uint8Array\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${typ}Array`] = typeEncoders.DataView\n}\n\n/**\n * @param {any} obj\n * @param {EncodeOptions} [options]\n * @param {Reference} [refStack]\n * @returns {TokenOrNestedTokens}\n */\nfunction objectToTokens (obj, options = {}, refStack) {\n  const typ = is(obj)\n  const customTypeEncoder = (options && options.typeEncoders && /** @type {OptionalTypeEncoder} */ options.typeEncoders[typ]) || typeEncoders[typ]\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack)\n    if (tokens != null) {\n      return tokens\n    }\n  }\n  const typeEncoder = typeEncoders[typ]\n  if (!typeEncoder) {\n    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`)\n  }\n  return typeEncoder(obj, typ, options, refStack)\n}\n\n/*\nCBOR key sorting is a mess.\n\nThe canonicalisation recommendation from https://tools.ietf.org/html/rfc7049#section-3.9\nincludes the wording:\n\n> The keys in every map must be sorted lowest value to highest.\n> Sorting is performed on the bytes of the representation of the key\n> data items without paying attention to the 3/5 bit splitting for\n> major types.\n> ...\n>  *  If two keys have different lengths, the shorter one sorts\n      earlier;\n>  *  If two keys have the same length, the one with the lower value\n      in (byte-wise) lexical order sorts earlier.\n\n1. It is not clear what \"bytes of the representation of the key\" means: is it\n   the CBOR representation, or the binary representation of the object itself?\n   Consider the int and uint difference here.\n2. It is not clear what \"without paying attention to\" means: do we include it\n   and compare on that? Or do we omit the special prefix byte, (mostly) treating\n   the key in its plain binary representation form.\n\nThe FIDO 2.0: Client To Authenticator Protocol spec takes the original CBOR\nwording and clarifies it according to their understanding.\nhttps://fidoalliance.org/specs/fido-v2.0-rd-20170927/fido-client-to-authenticator-protocol-v2.0-rd-20170927.html#message-encoding\n\n> The keys in every map must be sorted lowest value to highest. Sorting is\n> performed on the bytes of the representation of the key data items without\n> paying attention to the 3/5 bit splitting for major types. The sorting rules\n> are:\n>  * If the major types are different, the one with the lower value in numerical\n>    order sorts earlier.\n>  * If two keys have different lengths, the shorter one sorts earlier;\n>  * If two keys have the same length, the one with the lower value in\n>    (byte-wise) lexical order sorts earlier.\n\nSome other implementations, such as borc, do a full encode then do a\nlength-first, byte-wise-second comparison:\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/encoder.js#L358\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/utils.js#L143-L151\n\nThis has the benefit of being able to easily handle arbitrary keys, including\ncomplex types (maps and arrays).\n\nWe'll opt for the FIDO approach, since it affords some efficies since we don't\nneed a full encode of each key to determine order and can defer to the types\nto determine how to most efficiently order their values (i.e. int and uint\nordering can be done on the numbers, no need for byte-wise, for example).\n\nRecommendation: stick to single key types or you'll get into trouble, and prefer\nstring keys because it's much simpler that way.\n*/\n\n/*\n(UPDATE, Dec 2020)\nhttps://tools.ietf.org/html/rfc8949 is the updated CBOR spec and clarifies some\nof the questions above with a new recommendation for sorting order being much\ncloser to what would be expected in other environments (i.e. no length-first\nweirdness).\nThis new sorting order is not yet implemented here but could be added as an\noption. \"Determinism\" (canonicity) is system dependent and it's difficult to\nchange existing systems that are built with existing expectations. So if a new\nordering is introduced here, the old needs to be kept as well with the user\nhaving the option.\n*/\n\n/**\n * @param {TokenOrNestedTokens[]} entries\n * @param {EncodeOptions} options\n */\nfunction sortMapEntries (entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter)\n  }\n}\n\n/**\n * @param {(Token|Token[])[]} e1\n * @param {(Token|Token[])[]} e2\n * @returns {number}\n */\nfunction mapSorter (e1, e2) {\n  // the key position ([0]) could have a single token or an array\n  // almost always it'll be a single token but complex key might get involved\n  /* c8 ignore next 2 */\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0]\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0]\n\n  // different key types\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type)\n  }\n\n  const major = keyToken1.type.major\n  // TODO: handle case where cmp === 0 but there are more keyToken e. complex type)\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2)\n  /* c8 ignore next 5 */\n  if (tcmp === 0) {\n    // duplicate key or complex type where the first token matched,\n    // i.e. a map or array and we're only comparing the opening token\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone')\n  }\n  return tcmp\n}\n\n/**\n * @param {Bl} buf\n * @param {TokenOrNestedTokens} tokens\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n */\nfunction tokensToEncoded (buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options)\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options)\n  }\n}\n\n/**\n * @param {any} data\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n * @returns {Uint8Array}\n */\nfunction encodeCustom (data, encoders, options) {\n  const tokens = objectToTokens(data, options)\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens)\n    if (quickBytes) {\n      return quickBytes\n    }\n    const encoder = encoders[tokens.type.major]\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options)\n      const buf = new Bl(size)\n      encoder(buf, tokens, options)\n      /* c8 ignore next 4 */\n      // this would be a problem with encodedSize() functions\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`)\n      }\n      return asU8A(buf.chunks[0])\n    }\n  }\n  buf.reset()\n  tokensToEncoded(buf, tokens, encoders, options)\n  return buf.toBytes(true)\n}\n\n/**\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {Uint8Array}\n */\nfunction encode (data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options)\n  return encodeCustom(data, cborEncoders, options)\n}\n\nexport { objectToTokens, encode, encodeCustom, Ref }\n","// This is an unfortunate replacement for @sindresorhus/is that we need to\n// re-implement for performance purposes. In particular the is.observable()\n// check is expensive, and unnecessary for our purposes. The values returned\n// are compatible with @sindresorhus/is, however.\n\nconst typeofs = [\n  'string',\n  'number',\n  'bigint',\n  'symbol'\n]\n\nconst objectTypeNames = [\n  'Function',\n  'Generator',\n  'AsyncGenerator',\n  'GeneratorFunction',\n  'AsyncGeneratorFunction',\n  'AsyncFunction',\n  'Observable',\n  'Array',\n  'Buffer',\n  'Object',\n  'RegExp',\n  'Date',\n  'Error',\n  'Map',\n  'Set',\n  'WeakMap',\n  'WeakSet',\n  'ArrayBuffer',\n  'SharedArrayBuffer',\n  'DataView',\n  'Promise',\n  'URL',\n  'HTMLElement',\n  'Int8Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Int16Array',\n  'Uint16Array',\n  'Int32Array',\n  'Uint32Array',\n  'Float32Array',\n  'Float64Array',\n  'BigInt64Array',\n  'BigUint64Array'\n]\n\n/**\n * @param {any} value\n * @returns {string}\n */\nexport function is (value) {\n  if (value === null) {\n    return 'null'\n  }\n  if (value === undefined) {\n    return 'undefined'\n  }\n  if (value === true || value === false) {\n    return 'boolean'\n  }\n  const typeOf = typeof value\n  if (typeofs.includes(typeOf)) {\n    return typeOf\n  }\n  /* c8 ignore next 4 */\n  // not going to bother testing this, it's not going to be valid anyway\n  if (typeOf === 'function') {\n    return 'Function'\n  }\n  if (Array.isArray(value)) {\n    return 'Array'\n  }\n  if (isBuffer(value)) {\n    return 'Buffer'\n  }\n  const objectType = getObjectType(value)\n  if (objectType) {\n    return objectType\n  }\n  /* c8 ignore next */\n  return 'Object'\n}\n\n/**\n * @param {any} value\n * @returns {boolean}\n */\nfunction isBuffer (value) {\n  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value)\n}\n\n/**\n * @param {any} value\n * @returns {string|undefined}\n */\nfunction getObjectType (value) {\n  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1)\n  if (objectTypeNames.includes(objectTypeName)) {\n    return objectTypeName\n  }\n  /* c8 ignore next */\n  return undefined\n}\n","import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport * as negint from './1negint.js'\nimport * as bytes from './2bytes.js'\nimport * as string from './3string.js'\nimport * as array from './4array.js'\nimport * as map from './5map.js'\nimport * as tag from './6tag.js'\nimport * as float from './7float.js'\nimport { decodeErrPrefix } from './common.js'\nimport { fromArray } from './byte-utils.js'\n\n/**\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n */\nfunction invalidMinor (data, pos, minor) {\n  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`)\n}\n\n/**\n * @param {string} msg\n * @returns {()=>any}\n */\nfunction errorer (msg) {\n  return () => { throw new Error(`${decodeErrPrefix} ${msg}`) }\n}\n\n/** @type {((data:Uint8Array, pos:number, minor:number, options?:DecodeOptions) => any)[]} */\nexport const jump = []\n\n// unsigned integer, 0x00..0x17 (0..23)\nfor (let i = 0; i <= 0x17; i++) {\n  jump[i] = invalidMinor // uint.decodeUintCompact, handled by quick[]\n}\njump[0x18] = uint.decodeUint8 // unsigned integer, one-byte uint8_t follows\njump[0x19] = uint.decodeUint16 // unsigned integer, two-byte uint16_t follows\njump[0x1a] = uint.decodeUint32 // unsigned integer, four-byte uint32_t follows\njump[0x1b] = uint.decodeUint64 // unsigned integer, eight-byte uint64_t follows\njump[0x1c] = invalidMinor\njump[0x1d] = invalidMinor\njump[0x1e] = invalidMinor\njump[0x1f] = invalidMinor\n// negative integer, -1-0x00..-1-0x17 (-1..-24)\nfor (let i = 0x20; i <= 0x37; i++) {\n  jump[i] = invalidMinor // negintDecode, handled by quick[]\n}\njump[0x38] = negint.decodeNegint8 // negative integer, -1-n one-byte uint8_t for n follows\njump[0x39] = negint.decodeNegint16 // negative integer, -1-n two-byte uint16_t for n follows\njump[0x3a] = negint.decodeNegint32 // negative integer, -1-n four-byte uint32_t for follows\njump[0x3b] = negint.decodeNegint64 // negative integer, -1-n eight-byte uint64_t for follows\njump[0x3c] = invalidMinor\njump[0x3d] = invalidMinor\njump[0x3e] = invalidMinor\njump[0x3f] = invalidMinor\n// byte string, 0x00..0x17 bytes follow\nfor (let i = 0x40; i <= 0x57; i++) {\n  jump[i] = bytes.decodeBytesCompact\n}\njump[0x58] = bytes.decodeBytes8 // byte string, one-byte uint8_t for n, and then n bytes follow\njump[0x59] = bytes.decodeBytes16 // byte string, two-byte uint16_t for n, and then n bytes follow\njump[0x5a] = bytes.decodeBytes32 // byte string, four-byte uint32_t for n, and then n bytes follow\njump[0x5b] = bytes.decodeBytes64 // byte string, eight-byte uint64_t for n, and then n bytes follow\njump[0x5c] = invalidMinor\njump[0x5d] = invalidMinor\njump[0x5e] = invalidMinor\njump[0x5f] = errorer('indefinite length bytes/strings are not supported') // byte string, byte strings follow, terminated by \"break\"\n// UTF-8 string 0x00..0x17 bytes follow\nfor (let i = 0x60; i <= 0x77; i++) {\n  jump[i] = string.decodeStringCompact\n}\njump[0x78] = string.decodeString8 // UTF-8 string, one-byte uint8_t for n, and then n bytes follow\njump[0x79] = string.decodeString16 // UTF-8 string, two-byte uint16_t for n, and then n bytes follow\njump[0x7a] = string.decodeString32 // UTF-8 string, four-byte uint32_t for n, and then n bytes follow\njump[0x7b] = string.decodeString64 // UTF-8 string, eight-byte uint64_t for n, and then n bytes follow\njump[0x7c] = invalidMinor\njump[0x7d] = invalidMinor\njump[0x7e] = invalidMinor\njump[0x7f] = errorer('indefinite length bytes/strings are not supported') // UTF-8 strings follow, terminated by \"break\"\n// array, 0x00..0x17 data items follow\nfor (let i = 0x80; i <= 0x97; i++) {\n  jump[i] = array.decodeArrayCompact\n}\njump[0x98] = array.decodeArray8 // array, one-byte uint8_t for n, and then n data items follow\njump[0x99] = array.decodeArray16 // array, two-byte uint16_t for n, and then n data items follow\njump[0x9a] = array.decodeArray32 // array, four-byte uint32_t for n, and then n data items follow\njump[0x9b] = array.decodeArray64 // array, eight-byte uint64_t for n, and then n data items follow\njump[0x9c] = invalidMinor\njump[0x9d] = invalidMinor\njump[0x9e] = invalidMinor\njump[0x9f] = array.decodeArrayIndefinite // array, data items follow, terminated by \"break\"\n// map, 0x00..0x17 pairs of data items follow\nfor (let i = 0xa0; i <= 0xb7; i++) {\n  jump[i] = map.decodeMapCompact\n}\njump[0xb8] = map.decodeMap8 // map, one-byte uint8_t for n, and then n pairs of data items follow\njump[0xb9] = map.decodeMap16 // map, two-byte uint16_t for n, and then n pairs of data items follow\njump[0xba] = map.decodeMap32 // map, four-byte uint32_t for n, and then n pairs of data items follow\njump[0xbb] = map.decodeMap64 // map, eight-byte uint64_t for n, and then n pairs of data items follow\njump[0xbc] = invalidMinor\njump[0xbd] = invalidMinor\njump[0xbe] = invalidMinor\njump[0xbf] = map.decodeMapIndefinite // map, pairs of data items follow, terminated by \"break\"\n// tags\nfor (let i = 0xc0; i <= 0xd7; i++) {\n  jump[i] = tag.decodeTagCompact\n}\njump[0xd8] = tag.decodeTag8\njump[0xd9] = tag.decodeTag16\njump[0xda] = tag.decodeTag32\njump[0xdb] = tag.decodeTag64\njump[0xdc] = invalidMinor\njump[0xdd] = invalidMinor\njump[0xde] = invalidMinor\njump[0xdf] = invalidMinor\n// 0xe0..0xf3 simple values, unsupported\nfor (let i = 0xe0; i <= 0xf3; i++) {\n  jump[i] = errorer('simple values are not supported')\n}\njump[0xf4] = invalidMinor // false, handled by quick[]\njump[0xf5] = invalidMinor // true, handled by quick[]\njump[0xf6] = invalidMinor // null, handled by quick[]\njump[0xf7] = float.decodeUndefined // undefined\njump[0xf8] = errorer('simple values are not supported') // simple value, one byte follows, unsupported\njump[0xf9] = float.decodeFloat16 // half-precision float (two-byte IEEE 754)\njump[0xfa] = float.decodeFloat32 // single-precision float (four-byte IEEE 754)\njump[0xfb] = float.decodeFloat64 // double-precision float (eight-byte IEEE 754)\njump[0xfc] = invalidMinor\njump[0xfd] = invalidMinor\njump[0xfe] = invalidMinor\njump[0xff] = float.decodeBreak // \"break\" stop code\n\n/** @type {Token[]} */\nexport const quick = []\n// ints <24\nfor (let i = 0; i < 24; i++) {\n  quick[i] = new Token(Type.uint, i, 1)\n}\n// negints >= -24\nfor (let i = -1; i >= -24; i--) {\n  quick[31 - i] = new Token(Type.negint, i, 1)\n}\n// empty bytes\nquick[0x40] = new Token(Type.bytes, new Uint8Array(0), 1)\n// empty string\nquick[0x60] = new Token(Type.string, '', 1)\n// empty list\nquick[0x80] = new Token(Type.array, 0, 1)\n// empty map\nquick[0xa0] = new Token(Type.map, 0, 1)\n// false\nquick[0xf4] = new Token(Type.false, false, 1)\n// true\nquick[0xf5] = new Token(Type.true, true, 1)\n// null\nquick[0xf6] = new Token(Type.null, null, 1)\n\n/**\n * @param {Token} token\n * @returns {Uint8Array|undefined}\n */\nexport function quickEncodeToken (token) {\n  switch (token.type) {\n    case Type.false:\n      return fromArray([0xf4])\n    case Type.true:\n      return fromArray([0xf5])\n    case Type.null:\n      return fromArray([0xf6])\n    case Type.bytes:\n      if (!token.value.length) {\n        return fromArray([0x40])\n      }\n      return\n    case Type.string:\n      if (token.value === '') {\n        return fromArray([0x60])\n      }\n      return\n    case Type.array:\n      if (token.value === 0) {\n        return fromArray([0x80])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case Type.map:\n      if (token.value === 0) {\n        return fromArray([0xa0])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case Type.uint:\n      if (token.value < 24) {\n        return fromArray([Number(token.value)])\n      }\n      return\n    case Type.negint:\n      if (token.value >= -24) {\n        return fromArray([31 - Number(token.value)])\n      }\n  }\n}\n","class Type {\n  /**\n   * @param {number} major\n   * @param {string} name\n   * @param {boolean} terminal\n   */\n  constructor (major, name, terminal) {\n    this.major = major\n    this.majorEncoded = major << 5\n    this.name = name\n    this.terminal = terminal\n  }\n\n  /* c8 ignore next 3 */\n  toString () {\n    return `Type[${this.major}].${this.name}`\n  }\n\n  /**\n   * @param {Type} typ\n   * @returns {number}\n   */\n  compare (typ) {\n    /* c8 ignore next 1 */\n    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0\n  }\n}\n\n// convert to static fields when better supported\nType.uint = new Type(0, 'uint', true)\nType.negint = new Type(1, 'negint', true)\nType.bytes = new Type(2, 'bytes', true)\nType.string = new Type(3, 'string', true)\nType.array = new Type(4, 'array', false)\nType.map = new Type(5, 'map', false)\nType.tag = new Type(6, 'tag', false) // terminal?\nType.float = new Type(7, 'float', true)\nType.false = new Type(7, 'false', true)\nType.true = new Type(7, 'true', true)\nType.null = new Type(7, 'null', true)\nType.undefined = new Type(7, 'undefined', true)\nType.break = new Type(7, 'break', true)\n// Type.indefiniteLength = new Type(0, 'indefiniteLength', true)\n\nclass Token {\n  /**\n   * @param {Type} type\n   * @param {any} [value]\n   * @param {number} [encodedLength]\n   */\n  constructor (type, value, encodedLength) {\n    this.type = type\n    this.value = value\n    this.encodedLength = encodedLength\n    /** @type {Uint8Array|undefined} */\n    this.encodedBytes = undefined\n    /** @type {Uint8Array|undefined} */\n    this.byteValue = undefined\n  }\n\n  /* c8 ignore next 3 */\n  toString () {\n    return `Token[${this.type}].${this.value}`\n  }\n}\n\nexport { Type, Token }\n","import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n","/**\n * @packageDocumentation\n *\n * Mostly useful for tests or when you want to be explicit about consuming an iterable without doing anything with any yielded values.\n *\n * @example\n *\n * ```javascript\n * import drain from 'it-drain'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * drain(values)\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import drain from 'it-drain'\n *\n * const values = async function * {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * await drain(values())\n * ```\n */\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\nfunction drain(source) {\n    if (isAsyncIterable(source)) {\n        return (async () => {\n            for await (const _ of source) { } // eslint-disable-line no-unused-vars,no-empty,@typescript-eslint/no-unused-vars\n        })();\n    }\n    else {\n        for (const _ of source) { } // eslint-disable-line no-unused-vars,no-empty,@typescript-eslint/no-unused-vars\n    }\n}\nexport default drain;\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * Merge several (async)iterables into one, yield values as they arrive.\n *\n * Nb. sources are iterated over in parallel so the order of emitted items is not guaranteed.\n *\n * @example\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values1 = [0, 1, 2, 3, 4]\n * const values2 = [5, 6, 7, 8, 9]\n *\n * const arr = all(merge(values1, values2))\n *\n * console.info(arr) // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const values1 = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n * const values2 = async function * () {\n *   yield * [5, 6, 7, 8, 9]\n * }\n *\n * const arr = await all(merge(values1(), values2()))\n *\n * console.info(arr) // 0, 1, 5, 6, 2, 3, 4, 7, 8, 9  <- nb. order is not guaranteed\n * ```\n */\nimport { pushable } from 'it-pushable';\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\nfunction merge(...sources) {\n    const syncSources = [];\n    for (const source of sources) {\n        if (!isAsyncIterable(source)) {\n            syncSources.push(source);\n        }\n    }\n    if (syncSources.length === sources.length) {\n        // all sources are synchronous\n        return (function* () {\n            for (const source of syncSources) {\n                yield* source;\n            }\n        })();\n    }\n    return (async function* () {\n        const output = pushable({\n            objectMode: true\n        });\n        void Promise.resolve().then(async () => {\n            try {\n                await Promise.all(sources.map(async (source) => {\n                    for await (const item of source) {\n                        output.push(item);\n                    }\n                }));\n                output.end();\n            }\n            catch (err) {\n                output.end(err);\n            }\n        });\n        yield* output;\n    })();\n}\nexport default merge;\n//# sourceMappingURL=index.js.map","import { pushable } from 'it-pushable';\nimport merge from 'it-merge';\nexport function pipe(first, ...rest) {\n    if (first == null) {\n        throw new Error('Empty pipeline');\n    }\n    // Duplex at start: wrap in function and return duplex source\n    if (isDuplex(first)) {\n        const duplex = first;\n        first = () => duplex.source;\n        // Iterable at start: wrap in function\n    }\n    else if (isIterable(first) || isAsyncIterable(first)) {\n        const source = first;\n        first = () => source;\n    }\n    const fns = [first, ...rest];\n    if (fns.length > 1) {\n        // Duplex at end: use duplex sink\n        if (isDuplex(fns[fns.length - 1])) {\n            fns[fns.length - 1] = fns[fns.length - 1].sink;\n        }\n    }\n    if (fns.length > 2) {\n        // Duplex in the middle, consume source with duplex sink and return duplex source\n        for (let i = 1; i < fns.length - 1; i++) {\n            if (isDuplex(fns[i])) {\n                fns[i] = duplexPipelineFn(fns[i]);\n            }\n        }\n    }\n    return rawPipe(...fns);\n}\nexport const rawPipe = (...fns) => {\n    let res;\n    while (fns.length > 0) {\n        res = fns.shift()(res);\n    }\n    return res;\n};\nconst isAsyncIterable = (obj) => {\n    return obj?.[Symbol.asyncIterator] != null;\n};\nconst isIterable = (obj) => {\n    return obj?.[Symbol.iterator] != null;\n};\nconst isDuplex = (obj) => {\n    if (obj == null) {\n        return false;\n    }\n    return obj.sink != null && obj.source != null;\n};\nconst duplexPipelineFn = (duplex) => {\n    return (source) => {\n        const p = duplex.sink(source);\n        if (p?.then != null) {\n            const stream = pushable({\n                objectMode: true\n            });\n            p.then(() => {\n                stream.end();\n            }, (err) => {\n                stream.end(err);\n            });\n            let sourceWrap;\n            const source = duplex.source;\n            if (isAsyncIterable(source)) {\n                sourceWrap = async function* () {\n                    yield* source;\n                    stream.end();\n                };\n            }\n            else if (isIterable(source)) {\n                sourceWrap = function* () {\n                    yield* source;\n                    stream.end();\n                };\n            }\n            else {\n                throw new Error('Unknown duplex source type - must be Iterable or AsyncIterable');\n            }\n            return merge(stream, sourceWrap());\n        }\n        return duplex.source;\n    };\n};\n//# sourceMappingURL=index.js.map","// ported from https://www.npmjs.com/package/fast-fifo\nclass FixedFIFO {\n    buffer;\n    mask;\n    top;\n    btm;\n    next;\n    constructor(hwm) {\n        if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) {\n            throw new Error('Max size for a FixedFIFO should be a power of two');\n        }\n        this.buffer = new Array(hwm);\n        this.mask = hwm - 1;\n        this.top = 0;\n        this.btm = 0;\n        this.next = null;\n    }\n    push(data) {\n        if (this.buffer[this.top] !== undefined) {\n            return false;\n        }\n        this.buffer[this.top] = data;\n        this.top = (this.top + 1) & this.mask;\n        return true;\n    }\n    shift() {\n        const last = this.buffer[this.btm];\n        if (last === undefined) {\n            return undefined;\n        }\n        this.buffer[this.btm] = undefined;\n        this.btm = (this.btm + 1) & this.mask;\n        return last;\n    }\n    isEmpty() {\n        return this.buffer[this.btm] === undefined;\n    }\n}\nexport class FIFO {\n    size;\n    hwm;\n    head;\n    tail;\n    constructor(options = {}) {\n        this.hwm = options.splitLimit ?? 16;\n        this.head = new FixedFIFO(this.hwm);\n        this.tail = this.head;\n        this.size = 0;\n    }\n    calculateSize(obj) {\n        if (obj?.byteLength != null) {\n            return obj.byteLength;\n        }\n        return 1;\n    }\n    push(val) {\n        if (val?.value != null) {\n            this.size += this.calculateSize(val.value);\n        }\n        if (!this.head.push(val)) {\n            const prev = this.head;\n            this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);\n            this.head.push(val);\n        }\n    }\n    shift() {\n        let val = this.tail.shift();\n        if (val === undefined && (this.tail.next != null)) {\n            const next = this.tail.next;\n            this.tail.next = null;\n            this.tail = next;\n            val = this.tail.shift();\n        }\n        if (val?.value != null) {\n            this.size -= this.calculateSize(val.value);\n        }\n        return val;\n    }\n    isEmpty() {\n        return this.head.isEmpty();\n    }\n}\n//# sourceMappingURL=fifo.js.map","/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\nimport deferred from 'p-defer';\nimport { FIFO } from './fifo.js';\nexport class AbortError extends Error {\n    type;\n    code;\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\nexport function pushable(options = {}) {\n    const getNext = (buffer) => {\n        const next = buffer.shift();\n        if (next == null) {\n            return { done: true };\n        }\n        if (next.error != null) {\n            throw next.error;\n        }\n        return {\n            done: next.done === true,\n            // @ts-expect-error if done is false, value will be present\n            value: next.value\n        };\n    };\n    return _pushable(getNext, options);\n}\nexport function pushableV(options = {}) {\n    const getNext = (buffer) => {\n        let next;\n        const values = [];\n        while (!buffer.isEmpty()) {\n            next = buffer.shift();\n            if (next == null) {\n                break;\n            }\n            if (next.error != null) {\n                throw next.error;\n            }\n            if (next.done === false) {\n                // @ts-expect-error if done is false value should be pushed\n                values.push(next.value);\n            }\n        }\n        if (next == null) {\n            return { done: true };\n        }\n        return {\n            done: next.done === true,\n            value: values\n        };\n    };\n    return _pushable(getNext, options);\n}\nfunction _pushable(getNext, options) {\n    options = options ?? {};\n    let onEnd = options.onEnd;\n    let buffer = new FIFO();\n    let pushable;\n    let onNext;\n    let ended;\n    let drain = deferred();\n    const waitNext = async () => {\n        try {\n            if (!buffer.isEmpty()) {\n                return getNext(buffer);\n            }\n            if (ended) {\n                return { done: true };\n            }\n            return await new Promise((resolve, reject) => {\n                onNext = (next) => {\n                    onNext = null;\n                    buffer.push(next);\n                    try {\n                        resolve(getNext(buffer));\n                    }\n                    catch (err) {\n                        reject(err);\n                    }\n                    return pushable;\n                };\n            });\n        }\n        finally {\n            if (buffer.isEmpty()) {\n                // settle promise in the microtask queue to give consumers a chance to\n                // await after calling .push\n                queueMicrotask(() => {\n                    drain.resolve();\n                    drain = deferred();\n                });\n            }\n        }\n    };\n    const bufferNext = (next) => {\n        if (onNext != null) {\n            return onNext(next);\n        }\n        buffer.push(next);\n        return pushable;\n    };\n    const bufferError = (err) => {\n        buffer = new FIFO();\n        if (onNext != null) {\n            return onNext({ error: err });\n        }\n        buffer.push({ error: err });\n        return pushable;\n    };\n    const push = (value) => {\n        if (ended) {\n            return pushable;\n        }\n        // @ts-expect-error `byteLength` is not declared on PushType\n        if (options?.objectMode !== true && value?.byteLength == null) {\n            throw new Error('objectMode was not true but tried to push non-Uint8Array value');\n        }\n        return bufferNext({ done: false, value });\n    };\n    const end = (err) => {\n        if (ended)\n            return pushable;\n        ended = true;\n        return (err != null) ? bufferError(err) : bufferNext({ done: true });\n    };\n    const _return = () => {\n        buffer = new FIFO();\n        end();\n        return { done: true };\n    };\n    const _throw = (err) => {\n        end(err);\n        return { done: true };\n    };\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next: waitNext,\n        return: _return,\n        throw: _throw,\n        push,\n        end,\n        get readableLength() {\n            return buffer.size;\n        },\n        onEmpty: async (options) => {\n            const signal = options?.signal;\n            signal?.throwIfAborted();\n            if (buffer.isEmpty()) {\n                return;\n            }\n            let cancel;\n            let listener;\n            if (signal != null) {\n                cancel = new Promise((resolve, reject) => {\n                    listener = () => {\n                        reject(new AbortError());\n                    };\n                    signal.addEventListener('abort', listener);\n                });\n            }\n            try {\n                await Promise.race([\n                    drain.promise,\n                    cancel\n                ]);\n            }\n            finally {\n                if (listener != null && signal != null) {\n                    signal?.removeEventListener('abort', listener);\n                }\n            }\n        }\n    };\n    if (onEnd == null) {\n        return pushable;\n    }\n    const _pushable = pushable;\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next() {\n            return _pushable.next();\n        },\n        throw(err) {\n            _pushable.throw(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        return() {\n            _pushable.return();\n            if (onEnd != null) {\n                onEnd();\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        push,\n        end(err) {\n            _pushable.end(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return pushable;\n        },\n        get readableLength() {\n            return _pushable.readableLength;\n        },\n        onEmpty: (opts) => {\n            return _pushable.onEmpty(opts);\n        }\n    };\n    return pushable;\n}\n//# sourceMappingURL=index.js.map","import basex from '../../vendor/base-x.js'\nimport { coerce } from '../bytes.js'\n// Linter can't see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.BaseEncoder}\n */\nclass Encoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   */\n  constructor (name, prefix, baseEncode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {API.Multibase<Prefix>}\n   */\n  encode (bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * @template {string} Prefix\n */\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.UnibaseDecoder<Prefix>}\n * @implements {API.BaseDecoder}\n */\nclass Decoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    /* c8 ignore next 3 */\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    /** @private */\n    this.prefixCodePoint = /** @type {number} */ (prefix.codePointAt(0))\n    this.baseDecode = baseDecode\n  }\n\n  /**\n   * @param {string} text\n   */\n  decode (text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n}\n\n/**\n * @template {string} Prefix\n * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders\n */\n\n/**\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.CombobaseDecoder<Prefix>}\n */\nclass ComposedDecoder {\n  /**\n   * @param {Decoders<Prefix>} decoders\n   */\n  constructor (decoders) {\n    this.decoders = decoders\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n\n  /**\n   * @param {string} input\n   * @returns {Uint8Array}\n   */\n  decode (input) {\n    const prefix = /** @type {Prefix} */ (input[0])\n    const decoder = this.decoders[prefix]\n    if (decoder) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\n/**\n * @template {string} L\n * @template {string} R\n * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left\n * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right\n * @returns {ComposedDecoder<L|R>}\n */\nexport const or = (left, right) => new ComposedDecoder(/** @type {Decoders<L|R>} */({\n  ...(left.decoders || { [/** @type API.UnibaseDecoder<L> */(left).prefix]: left }),\n  ...(right.decoders || { [/** @type API.UnibaseDecoder<R> */(right).prefix]: right })\n}))\n\n/**\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseCodec<Prefix>}\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.BaseCodec}\n * @implements {API.BaseEncoder}\n * @implements {API.BaseDecoder}\n */\nexport class Codec {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseEncode, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  /**\n   * @param {Uint8Array} input\n   */\n  encode (input) {\n    return this.encoder.encode(input)\n  }\n\n  /**\n   * @param {string} input\n   */\n  decode (input) {\n    return this.decoder.decode(input)\n  }\n}\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {(bytes:Uint8Array) => string} options.encode\n * @param {(input:string) => Uint8Array} options.decode\n * @returns {Codec<Base, Prefix>}\n */\nexport const from = ({ name, prefix, encode, decode }) =>\n  new Codec(name, prefix, encode, decode)\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @returns {Codec<Base, Prefix>}\n */\nexport const baseX = ({ prefix, name, alphabet }) => {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    /**\n     * @param {string} text\n     */\n    decode: text => coerce(decode(text))\n  })\n}\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @param {string} name\n * @returns {Uint8Array}\n */\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  const codes = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * bitsPerChar) & 7) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n *\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @param {number} options.bitsPerChar\n */\nexport const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {\n  return from({\n    prefix,\n    name,\n    encode (input) {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input) {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n","import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n","import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n","// this is dummy module overlayed by interface.ts\n","import { bytes as binary, CID } from './index.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\nfunction readonly ({ enumerable = true, configurable = false } = {}) {\n  return { enumerable, configurable, writable: false }\n}\n\n/**\n * @param {[string|number, string]} path\n * @param {any} value\n * @returns {Iterable<[string, CID]>}\n */\nfunction * linksWithin (path, value) {\n  if (value != null && typeof value === 'object') {\n    if (Array.isArray(value)) {\n      for (const [index, element] of value.entries()) {\n        const elementPath = [...path, index]\n        const cid = CID.asCID(element)\n        if (cid) {\n          yield [elementPath.join('/'), cid]\n        } else if (typeof element === 'object') {\n          yield * links(element, elementPath)\n        }\n      }\n    } else {\n      const cid = CID.asCID(value)\n      if (cid) {\n        yield [path.join('/'), cid]\n      } else {\n        yield * links(value, path)\n      }\n    }\n  }\n}\n\n/**\n * @template T\n * @param {T} source\n * @param {Array<string|number>} base\n * @returns {Iterable<[string, CID]>}\n */\nfunction * links (source, base) {\n  if (source == null || source instanceof Uint8Array) {\n    return\n  }\n  const cid = CID.asCID(source)\n  if (cid) {\n    yield [base.join('/'), cid]\n  }\n  for (const [key, value] of Object.entries(source)) {\n    const path = /** @type {[string|number, string]} */ ([...base, key])\n    yield * linksWithin(path, value)\n  }\n}\n\n/**\n * @param {[string|number, string]} path\n * @param {any} value\n * @returns {Iterable<string>}\n */\nfunction * treeWithin (path, value) {\n  if (Array.isArray(value)) {\n    for (const [index, element] of value.entries()) {\n      const elementPath = [...path, index]\n      yield elementPath.join('/')\n      if (typeof element === 'object' && !CID.asCID(element)) {\n        yield * tree(element, elementPath)\n      }\n    }\n  } else {\n    yield * tree(value, path)\n  }\n}\n\n/**\n * @template T\n * @param {T} source\n * @param {Array<string|number>} base\n * @returns {Iterable<string>}\n */\nfunction * tree (source, base) {\n  if (source == null || typeof source !== 'object') {\n    return\n  }\n  for (const [key, value] of Object.entries(source)) {\n    const path = /** @type {[string|number, string]} */ ([...base, key])\n    yield path.join('/')\n    if (value != null && !(value instanceof Uint8Array) && typeof value === 'object' && !CID.asCID(value)) {\n      yield * treeWithin(path, value)\n    }\n  }\n}\n\n/**\n *\n * @template T\n * @param {T} source\n * @param {string[]} path\n * @returns {API.BlockCursorView<unknown>}\n */\nfunction get (source, path) {\n  let node = /** @type {Record<string, any>} */(source)\n  for (const [index, key] of path.entries()) {\n    node = node[key]\n    if (node == null) {\n      throw new Error(`Object has no property at ${path.slice(0, index + 1).map(part => `[${JSON.stringify(part)}]`).join('')}`)\n    }\n    const cid = CID.asCID(node)\n    if (cid) {\n      return { value: cid, remaining: path.slice(index + 1).join('/') }\n    }\n  }\n  return { value: node }\n}\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} C - multicodec code corresponding to codec used to encode the block\n * @template {number} A - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template {API.Version} V - CID version\n * @implements {API.BlockView<T, C, A, V>}\n */\nclass Block {\n  /**\n   * @param {object} options\n   * @param {CID<T, C, A, V>} options.cid\n   * @param {API.ByteView<T>} options.bytes\n   * @param {T} options.value\n   */\n  constructor ({ cid, bytes, value }) {\n    if (!cid || !bytes || typeof value === 'undefined') { throw new Error('Missing required argument') }\n\n    this.cid = cid\n    this.bytes = bytes\n    this.value = value\n    this.asBlock = this\n\n    // Mark all the properties immutable\n    Object.defineProperties(this, {\n      cid: readonly(),\n      bytes: readonly(),\n      value: readonly(),\n      asBlock: readonly()\n    })\n  }\n\n  links () {\n    return links(this.value, [])\n  }\n\n  tree () {\n    return tree(this.value, [])\n  }\n\n  /**\n   *\n   * @param {string} [path]\n   * @returns {API.BlockCursorView<unknown>}\n   */\n  get (path = '/') {\n    return get(this.value, path.split('/').filter(Boolean))\n  }\n}\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @param {object} options\n * @param {T} options.value\n * @param {API.BlockEncoder<Code, T>} options.codec\n * @param {API.MultihashHasher<Alg>} options.hasher\n * @returns {Promise<API.BlockView<T, Code, Alg>>}\n */\nasync function encode ({ value, codec, hasher }) {\n  if (typeof value === 'undefined') throw new Error('Missing required argument \"value\"')\n  if (!codec || !hasher) throw new Error('Missing required argument: codec or hasher')\n\n  const bytes = codec.encode(value)\n  const hash = await hasher.digest(bytes)\n  /** @type {CID<T, Code, Alg, 1>} */\n  const cid = CID.create(\n    1,\n    codec.code,\n    hash\n  )\n\n  return new Block({ value, bytes, cid })\n}\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @param {object} options\n * @param {API.ByteView<T>} options.bytes\n * @param {API.BlockDecoder<Code, T>} options.codec\n * @param {API.MultihashHasher<Alg>} options.hasher\n * @returns {Promise<API.BlockView<T, Code, Alg>>}\n */\nasync function decode ({ bytes, codec, hasher }) {\n  if (!bytes) throw new Error('Missing required argument \"bytes\"')\n  if (!codec || !hasher) throw new Error('Missing required argument: codec or hasher')\n\n  const value = codec.decode(bytes)\n  const hash = await hasher.digest(bytes)\n  /** @type {CID<T, Code, Alg, 1>} */\n  const cid = CID.create(1, codec.code, hash)\n\n  return new Block({ value, bytes, cid })\n}\n\n/**\n * @typedef {object} RequiredCreateOptions\n * @property {CID} options.cid\n */\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template {API.Version} V - CID version\n * @param {{ cid: API.Link<T, Code, Alg, V>, value:T, codec?: API.BlockDecoder<Code, T>, bytes: API.ByteView<T> }|{cid:API.Link<T, Code, Alg, V>, bytes:API.ByteView<T>, value?:void, codec:API.BlockDecoder<Code, T>}} options\n * @returns {API.BlockView<T, Code, Alg, V>}\n */\nfunction createUnsafe ({ bytes, cid, value: maybeValue, codec }) {\n  const value = maybeValue !== undefined\n    ? maybeValue\n    : (codec && codec.decode(bytes))\n\n  if (value === undefined) throw new Error('Missing required argument, must either provide \"value\" or \"codec\"')\n\n  return new Block({\n    // eslint-disable-next-line object-shorthand\n    cid: /** @type {CID<T, Code, Alg, V>} */ (cid),\n    bytes,\n    value\n  })\n}\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template {API.Version} V - CID version\n * @param {object} options\n * @param {API.Link<T, Code, Alg, V>} options.cid\n * @param {API.ByteView<T>} options.bytes\n * @param {API.BlockDecoder<Code, T>} options.codec\n * @param {API.MultihashHasher<Alg>} options.hasher\n * @returns {Promise<API.BlockView<T, Code, Alg, V>>}\n */\nasync function create ({ bytes, cid, hasher, codec }) {\n  if (!bytes) throw new Error('Missing required argument \"bytes\"')\n  if (!hasher) throw new Error('Missing required argument \"hasher\"')\n  const value = codec.decode(bytes)\n  const hash = await hasher.digest(bytes)\n  if (!binary.equals(cid.multihash.bytes, hash.bytes)) {\n    throw new Error('CID hash does not match bytes')\n  }\n\n  return createUnsafe({\n    bytes,\n    cid,\n    value,\n    codec\n  })\n}\n\nexport { encode, decode, create, createUnsafe, Block }\n","const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n","import { base32 } from './bases/base32.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport * as varint from './varint.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  /**\n   * @returns {API.LinkJSON<this>}\n   */\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n","import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n","import * as Digest from './digest.js'\n\n/**\n * @template {string} Name\n * @template {number} Code\n * @param {object} options\n * @param {Name} options.name\n * @param {Code} options.code\n * @param {(input: Uint8Array) => Await<Uint8Array>} options.encode\n */\nexport const from = ({ name, code, encode }) => new Hasher(name, code, encode)\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n *\n * @template {string} Name\n * @template {number} Code\n * @class\n * @implements {MultihashHasher<Code>}\n */\nexport class Hasher {\n  /**\n   *\n   * @param {Name} name\n   * @param {Code} code\n   * @param {(input: Uint8Array) => Await<Uint8Array>} encode\n   */\n  constructor (name, code, encode) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n  }\n\n  /**\n   * @param {Uint8Array} input\n   * @returns {Await<Digest.Digest<Code, number>>}\n   */\n  digest (input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n      return result instanceof Uint8Array\n        ? Digest.create(this.code, result)\n        /* c8 ignore next 1 */\n        : result.then(digest => Digest.create(this.code, digest))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n\n/**\n * @template {number} Alg\n * @typedef {import('./interface.js').MultihashHasher} MultihashHasher\n */\n\n/**\n * @template T\n * @typedef {Promise<T>|T} Await\n */\n","/* global crypto */\n\nimport { from } from './hasher.js'\n\n/**\n * @param {AlgorithmIdentifier} name\n */\nconst sha = name =>\n  /**\n   * @param {Uint8Array} data\n   */\n  async data => new Uint8Array(await crypto.subtle.digest(name, data))\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n","import * as bytes from './bytes.js'\nimport { CID } from './cid.js'\nimport * as digest from './hashes/digest.js'\nimport * as hasher from './hashes/hasher.js'\nimport * as varint from './varint.js'\n\n// This way TS will also expose all the types from module\nexport * from './interface.js'\n\nexport { CID, hasher, digest, varint, bytes }\n","// this is dummy module overlayed by interface.ts\n","// this is dummy module overlayed by interface.ts\n","import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n","// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n","var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n","export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n","import { EventEmitter } from 'eventemitter3';\nimport pTimeout, { TimeoutError } from 'p-timeout';\nimport PriorityQueue from './priority-queue.js';\n/**\nPromise queue with concurrency control.\n*/\nexport default class PQueue extends EventEmitter {\n    #carryoverConcurrencyCount;\n    #isIntervalIgnored;\n    #intervalCount = 0;\n    #intervalCap;\n    #interval;\n    #intervalEnd = 0;\n    #intervalId;\n    #timeoutId;\n    #queue;\n    #queueClass;\n    #pending = 0;\n    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n    #concurrency;\n    #isPaused;\n    #throwOnTimeout;\n    /**\n    Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.\n\n    Applies to each future operation.\n    */\n    timeout;\n    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`\n    constructor(options) {\n        super();\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = {\n            carryoverConcurrencyCount: false,\n            intervalCap: Number.POSITIVE_INFINITY,\n            interval: 0,\n            concurrency: Number.POSITIVE_INFINITY,\n            autoStart: true,\n            queueClass: PriorityQueue,\n            ...options,\n        };\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${options.intervalCap?.toString() ?? ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${options.interval?.toString() ?? ''}\\` (${typeof options.interval})`);\n        }\n        this.#carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n        this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;\n        this.#intervalCap = options.intervalCap;\n        this.#interval = options.interval;\n        this.#queue = new options.queueClass();\n        this.#queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        this.timeout = options.timeout;\n        this.#throwOnTimeout = options.throwOnTimeout === true;\n        this.#isPaused = options.autoStart === false;\n    }\n    get #doesIntervalAllowAnother() {\n        return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;\n    }\n    get #doesConcurrentAllowAnother() {\n        return this.#pending < this.#concurrency;\n    }\n    #next() {\n        this.#pending--;\n        this.#tryToStartAnother();\n        this.emit('next');\n    }\n    #onResumeInterval() {\n        this.#onInterval();\n        this.#initializeIntervalIfNeeded();\n        this.#timeoutId = undefined;\n    }\n    get #isIntervalPaused() {\n        const now = Date.now();\n        if (this.#intervalId === undefined) {\n            const delay = this.#intervalEnd - now;\n            if (delay < 0) {\n                // Act as the interval was done\n                // We don't need to resume it here because it will be resumed on line 160\n                this.#intervalCount = (this.#carryoverConcurrencyCount) ? this.#pending : 0;\n            }\n            else {\n                // Act as the interval is pending\n                if (this.#timeoutId === undefined) {\n                    this.#timeoutId = setTimeout(() => {\n                        this.#onResumeInterval();\n                    }, delay);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    #tryToStartAnother() {\n        if (this.#queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            if (this.#intervalId) {\n                clearInterval(this.#intervalId);\n            }\n            this.#intervalId = undefined;\n            this.emit('empty');\n            if (this.#pending === 0) {\n                this.emit('idle');\n            }\n            return false;\n        }\n        if (!this.#isPaused) {\n            const canInitializeInterval = !this.#isIntervalPaused;\n            if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {\n                const job = this.#queue.dequeue();\n                if (!job) {\n                    return false;\n                }\n                this.emit('active');\n                job();\n                if (canInitializeInterval) {\n                    this.#initializeIntervalIfNeeded();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    #initializeIntervalIfNeeded() {\n        if (this.#isIntervalIgnored || this.#intervalId !== undefined) {\n            return;\n        }\n        this.#intervalId = setInterval(() => {\n            this.#onInterval();\n        }, this.#interval);\n        this.#intervalEnd = Date.now() + this.#interval;\n    }\n    #onInterval() {\n        if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {\n            clearInterval(this.#intervalId);\n            this.#intervalId = undefined;\n        }\n        this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;\n        this.#processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    #processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this.#tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this.#concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this.#concurrency = newConcurrency;\n        this.#processQueue();\n    }\n    async #throwOnAbort(signal) {\n        return new Promise((_resolve, reject) => {\n            signal.addEventListener('abort', () => {\n                reject(signal.reason);\n            }, { once: true });\n        });\n    }\n    async add(function_, options = {}) {\n        options = {\n            timeout: this.timeout,\n            throwOnTimeout: this.#throwOnTimeout,\n            ...options,\n        };\n        return new Promise((resolve, reject) => {\n            this.#queue.enqueue(async () => {\n                this.#pending++;\n                this.#intervalCount++;\n                try {\n                    options.signal?.throwIfAborted();\n                    let operation = function_({ signal: options.signal });\n                    if (options.timeout) {\n                        operation = pTimeout(Promise.resolve(operation), { milliseconds: options.timeout });\n                    }\n                    if (options.signal) {\n                        operation = Promise.race([operation, this.#throwOnAbort(options.signal)]);\n                    }\n                    const result = await operation;\n                    resolve(result);\n                    this.emit('completed', result);\n                }\n                catch (error) {\n                    if (error instanceof TimeoutError && !options.throwOnTimeout) {\n                        resolve();\n                        return;\n                    }\n                    reject(error);\n                    this.emit('error', error);\n                }\n                finally {\n                    this.#next();\n                }\n            }, options);\n            this.emit('add');\n            this.#tryToStartAnother();\n        });\n    }\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this.#isPaused) {\n            return this;\n        }\n        this.#isPaused = false;\n        this.#processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this.#isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this.#queue = new this.#queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('empty');\n    }\n    /**\n    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n\n    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n\n    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n    */\n    async onSizeLessThan(limit) {\n        // Instantly resolve if the queue is empty.\n        if (this.#queue.size < limit) {\n            return;\n        }\n        await this.#onEvent('next', () => this.#queue.size < limit);\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this.#pending === 0 && this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('idle');\n    }\n    async #onEvent(event, filter) {\n        return new Promise(resolve => {\n            const listener = () => {\n                if (filter && !filter()) {\n                    return;\n                }\n                this.off(event, listener);\n                resolve();\n            };\n            this.on(event, listener);\n        });\n    }\n    /**\n    Size of the queue, the number of queued items waiting to run.\n    */\n    get size() {\n        return this.#queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference\n        return this.#queue.filter(options).length;\n    }\n    /**\n    Number of running items (no longer in the queue).\n    */\n    get pending() {\n        return this.#pending;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this.#isPaused;\n    }\n}\n","// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nexport default function lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while (count > 0) {\n        const step = Math.trunc(count / 2);\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\n","import lowerBound from './lower-bound.js';\nexport default class PriorityQueue {\n    #queue = [];\n    enqueue(run, options) {\n        options = {\n            priority: 0,\n            ...options,\n        };\n        const element = {\n            priority: options.priority,\n            run,\n        };\n        if (this.size && this.#queue[this.size - 1].priority >= options.priority) {\n            this.#queue.push(element);\n            return;\n        }\n        const index = lowerBound(this.#queue, element, (a, b) => b.priority - a.priority);\n        this.#queue.splice(index, 0, element);\n    }\n    dequeue() {\n        const item = this.#queue.shift();\n        return item?.run;\n    }\n    filter(options) {\n        return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);\n    }\n    get size() {\n        return this.#queue.length;\n    }\n}\n","export class TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\n/**\nAn error to be thrown when the request is aborted by AbortController.\nDOMException is thrown instead of this Error when DOMException is available.\n*/\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\n/**\nTODO: Remove AbortError and just throw DOMException when targeting Node 18.\n*/\nconst getDOMException = errorMessage => globalThis.DOMException === undefined\n\t? new AbortError(errorMessage)\n\t: new DOMException(errorMessage);\n\n/**\nTODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.\n*/\nconst getAbortedReason = signal => {\n\tconst reason = signal.reason === undefined\n\t\t? getDOMException('This operation was aborted.')\n\t\t: signal.reason;\n\n\treturn reason instanceof Error ? reason : getDOMException(reason);\n};\n\nexport default function pTimeout(promise, options) {\n\tconst {\n\t\tmilliseconds,\n\t\tfallback,\n\t\tmessage,\n\t\tcustomTimers = {setTimeout, clearTimeout},\n\t} = options;\n\n\tlet timer;\n\n\tconst wrappedPromise = new Promise((resolve, reject) => {\n\t\tif (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n\t\t\tthrow new TypeError(`Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``);\n\t\t}\n\n\t\tif (options.signal) {\n\t\t\tconst {signal} = options;\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t}\n\n\t\t\tsignal.addEventListener('abort', () => {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t});\n\t\t}\n\n\t\tif (milliseconds === Number.POSITIVE_INFINITY) {\n\t\t\tpromise.then(resolve, reject);\n\t\t\treturn;\n\t\t}\n\n\t\t// We create the error outside of `setTimeout` to preserve the stack trace.\n\t\tconst timeoutError = new TimeoutError();\n\n\t\ttimer = customTimers.setTimeout.call(undefined, () => {\n\t\t\tif (fallback) {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(fallback());\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\n\t\t\tif (message === false) {\n\t\t\t\tresolve();\n\t\t\t} else if (message instanceof Error) {\n\t\t\t\treject(message);\n\t\t\t} else {\n\t\t\t\ttimeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;\n\t\t\t\treject(timeoutError);\n\t\t\t}\n\t\t}, milliseconds);\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tresolve(await promise);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t})();\n\t});\n\n\tconst cancelablePromise = wrappedPromise.finally(() => {\n\t\tcancelablePromise.clear();\n\t});\n\n\tcancelablePromise.clear = () => {\n\t\tcustomTimers.clearTimeout.call(undefined, timer);\n\t\ttimer = undefined;\n\t};\n\n\treturn cancelablePromise;\n}\n","// https://developers.google.com/protocol-buffers/docs/encoding#structure\nexport var CODEC_TYPES;\n(function (CODEC_TYPES) {\n    CODEC_TYPES[CODEC_TYPES[\"VARINT\"] = 0] = \"VARINT\";\n    CODEC_TYPES[CODEC_TYPES[\"BIT64\"] = 1] = \"BIT64\";\n    CODEC_TYPES[CODEC_TYPES[\"LENGTH_DELIMITED\"] = 2] = \"LENGTH_DELIMITED\";\n    CODEC_TYPES[CODEC_TYPES[\"START_GROUP\"] = 3] = \"START_GROUP\";\n    CODEC_TYPES[CODEC_TYPES[\"END_GROUP\"] = 4] = \"END_GROUP\";\n    CODEC_TYPES[CODEC_TYPES[\"BIT32\"] = 5] = \"BIT32\";\n})(CODEC_TYPES || (CODEC_TYPES = {}));\nexport function createCodec(name, type, encode, decode) {\n    return {\n        name,\n        type,\n        encode,\n        decode\n    };\n}\n//# sourceMappingURL=codec.js.map","import { createCodec, CODEC_TYPES } from '../codec.js';\nexport function enumeration(v) {\n    function findValue(val) {\n        // Use the reverse mapping to look up the enum key for the stored value\n        // https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings\n        if (v[val.toString()] == null) {\n            throw new Error('Invalid enum value');\n        }\n        return v[val];\n    }\n    const encode = function enumEncode(val, writer) {\n        const enumValue = findValue(val);\n        writer.int32(enumValue);\n    };\n    const decode = function enumDecode(reader) {\n        const val = reader.int32();\n        return findValue(val);\n    };\n    // @ts-expect-error yeah yeah\n    return createCodec('enum', CODEC_TYPES.VARINT, encode, decode);\n}\n//# sourceMappingURL=enum.js.map","import { createCodec, CODEC_TYPES } from '../codec.js';\nexport function message(encode, decode) {\n    return createCodec('message', CODEC_TYPES.LENGTH_DELIMITED, encode, decode);\n}\n//# sourceMappingURL=message.js.map","import { createReader } from './utils/reader.js';\nexport function decodeMessage(buf, codec, opts) {\n    const reader = createReader(buf);\n    return codec.decode(reader, undefined, opts);\n}\n//# sourceMappingURL=decode.js.map","import { createWriter } from './utils/writer.js';\nexport function encodeMessage(message, codec) {\n    const w = createWriter();\n    codec.encode(message, w, {\n        lengthDelimited: false\n    });\n    return w.finish();\n}\n//# sourceMappingURL=encode.js.map","/**\n * @packageDocumentation\n *\n * This module contains serialization/deserialization code used when encoding/decoding protobufs.\n *\n * It should be declared as a dependency of your project:\n *\n * ```console\n * npm i protons-runtime\n * ```\n */\nexport { decodeMessage } from './decode.js';\nexport { encodeMessage } from './encode.js';\nexport { enumeration } from './codecs/enum.js';\nexport { message } from './codecs/message.js';\nexport { createReader as reader } from './utils/reader.js';\nexport { createWriter as writer } from './utils/writer.js';\n/**\n * This will be removed in a future release\n *\n * @deprecated\n */\nexport class CodeError extends Error {\n    code;\n    constructor(message, code) {\n        super(message);\n        this.code = code;\n    }\n}\n/**\n * Thrown when a repeated field has too many elements\n */\nexport class MaxLengthError extends Error {\n    /**\n     * This will be removed in a future release\n     *\n     * @deprecated use the `.name` property instead\n     */\n    code = 'ERR_MAX_LENGTH';\n    name = 'MaxLengthError';\n}\n/**\n * Thrown when a map has too many elements\n */\nexport class MaxSizeError extends Error {\n    /**\n     * This will be removed in a future release\n     *\n     * @deprecated use the `.name` property instead\n     */\n    code = 'ERR_MAX_SIZE';\n    name = 'MaxSizeError';\n}\nexport class ParseError extends Error {\n    /**\n     * This will be removed in a future release\n     *\n     * @deprecated use the `.name` property instead\n     */\n    code = 'ERR_PARSE_ERROR';\n    name = 'ParseError';\n}\nexport class NoMessagesFoundError extends Error {\n    /**\n     * This will be removed in a future release\n     *\n     * @deprecated use the `.name` property instead\n     */\n    code = 'ERR_NO_MESSAGES_FOUND';\n    name = 'NoMessagesFoundError';\n}\n//# sourceMappingURL=index.js.map","const f32 = new Float32Array([-0]);\nconst f8b = new Uint8Array(f32.buffer);\n/**\n * Writes a 32 bit float to a buffer using little endian byte order\n */\nexport function writeFloatLE(val, buf, pos) {\n    f32[0] = val;\n    buf[pos] = f8b[0];\n    buf[pos + 1] = f8b[1];\n    buf[pos + 2] = f8b[2];\n    buf[pos + 3] = f8b[3];\n}\n/**\n * Writes a 32 bit float to a buffer using big endian byte order\n */\nexport function writeFloatBE(val, buf, pos) {\n    f32[0] = val;\n    buf[pos] = f8b[3];\n    buf[pos + 1] = f8b[2];\n    buf[pos + 2] = f8b[1];\n    buf[pos + 3] = f8b[0];\n}\n/**\n * Reads a 32 bit float from a buffer using little endian byte order\n */\nexport function readFloatLE(buf, pos) {\n    f8b[0] = buf[pos];\n    f8b[1] = buf[pos + 1];\n    f8b[2] = buf[pos + 2];\n    f8b[3] = buf[pos + 3];\n    return f32[0];\n}\n/**\n * Reads a 32 bit float from a buffer using big endian byte order\n */\nexport function readFloatBE(buf, pos) {\n    f8b[3] = buf[pos];\n    f8b[2] = buf[pos + 1];\n    f8b[1] = buf[pos + 2];\n    f8b[0] = buf[pos + 3];\n    return f32[0];\n}\nconst f64 = new Float64Array([-0]);\nconst d8b = new Uint8Array(f64.buffer);\n/**\n * Writes a 64 bit double to a buffer using little endian byte order\n */\nexport function writeDoubleLE(val, buf, pos) {\n    f64[0] = val;\n    buf[pos] = d8b[0];\n    buf[pos + 1] = d8b[1];\n    buf[pos + 2] = d8b[2];\n    buf[pos + 3] = d8b[3];\n    buf[pos + 4] = d8b[4];\n    buf[pos + 5] = d8b[5];\n    buf[pos + 6] = d8b[6];\n    buf[pos + 7] = d8b[7];\n}\n/**\n * Writes a 64 bit double to a buffer using big endian byte order\n */\nexport function writeDoubleBE(val, buf, pos) {\n    f64[0] = val;\n    buf[pos] = d8b[7];\n    buf[pos + 1] = d8b[6];\n    buf[pos + 2] = d8b[5];\n    buf[pos + 3] = d8b[4];\n    buf[pos + 4] = d8b[3];\n    buf[pos + 5] = d8b[2];\n    buf[pos + 6] = d8b[1];\n    buf[pos + 7] = d8b[0];\n}\n/**\n * Reads a 64 bit double from a buffer using little endian byte order\n */\nexport function readDoubleLE(buf, pos) {\n    d8b[0] = buf[pos];\n    d8b[1] = buf[pos + 1];\n    d8b[2] = buf[pos + 2];\n    d8b[3] = buf[pos + 3];\n    d8b[4] = buf[pos + 4];\n    d8b[5] = buf[pos + 5];\n    d8b[6] = buf[pos + 6];\n    d8b[7] = buf[pos + 7];\n    return f64[0];\n}\n/**\n * Reads a 64 bit double from a buffer using big endian byte order\n */\nexport function readDoubleBE(buf, pos) {\n    d8b[7] = buf[pos];\n    d8b[6] = buf[pos + 1];\n    d8b[5] = buf[pos + 2];\n    d8b[4] = buf[pos + 3];\n    d8b[3] = buf[pos + 4];\n    d8b[2] = buf[pos + 5];\n    d8b[1] = buf[pos + 6];\n    d8b[0] = buf[pos + 7];\n    return f64[0];\n}\n//# sourceMappingURL=float.js.map","// the largest BigInt we can safely downcast to a Number\nconst MAX_SAFE_NUMBER_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);\nconst MIN_SAFE_NUMBER_INTEGER = BigInt(Number.MIN_SAFE_INTEGER);\n/**\n * Constructs new long bits.\n *\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @function Object() { [native code] }\n * @param {number} lo - Low 32 bits, unsigned\n * @param {number} hi - High 32 bits, unsigned\n */\nexport class LongBits {\n    lo;\n    hi;\n    constructor(lo, hi) {\n        // note that the casts below are theoretically unnecessary as of today, but older statically\n        // generated converter code might still call the ctor with signed 32bits. kept for compat.\n        /**\n         * Low bits\n         */\n        this.lo = lo | 0;\n        /**\n         * High bits\n         */\n        this.hi = hi | 0;\n    }\n    /**\n     * Converts this long bits to a possibly unsafe JavaScript number\n     */\n    toNumber(unsigned = false) {\n        if (!unsigned && (this.hi >>> 31) > 0) {\n            const lo = ~this.lo + 1 >>> 0;\n            let hi = ~this.hi >>> 0;\n            if (lo === 0) {\n                hi = hi + 1 >>> 0;\n            }\n            return -(lo + hi * 4294967296);\n        }\n        return this.lo + this.hi * 4294967296;\n    }\n    /**\n     * Converts this long bits to a bigint\n     */\n    toBigInt(unsigned = false) {\n        if (unsigned) {\n            return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);\n        }\n        if ((this.hi >>> 31) !== 0) {\n            const lo = ~this.lo + 1 >>> 0;\n            let hi = ~this.hi >>> 0;\n            if (lo === 0) {\n                hi = hi + 1 >>> 0;\n            }\n            return -(BigInt(lo) + (BigInt(hi) << 32n));\n        }\n        return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);\n    }\n    /**\n     * Converts this long bits to a string\n     */\n    toString(unsigned = false) {\n        return this.toBigInt(unsigned).toString();\n    }\n    /**\n     * Zig-zag encodes this long bits\n     */\n    zzEncode() {\n        const mask = this.hi >> 31;\n        this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n        this.lo = (this.lo << 1 ^ mask) >>> 0;\n        return this;\n    }\n    /**\n     * Zig-zag decodes this long bits\n     */\n    zzDecode() {\n        const mask = -(this.lo & 1);\n        this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n        this.hi = (this.hi >>> 1 ^ mask) >>> 0;\n        return this;\n    }\n    /**\n     * Calculates the length of this longbits when encoded as a varint.\n     */\n    length() {\n        const part0 = this.lo;\n        const part1 = (this.lo >>> 28 | this.hi << 4) >>> 0;\n        const part2 = this.hi >>> 24;\n        return part2 === 0\n            ? part1 === 0\n                ? part0 < 16384\n                    ? part0 < 128 ? 1 : 2\n                    : part0 < 2097152 ? 3 : 4\n                : part1 < 16384\n                    ? part1 < 128 ? 5 : 6\n                    : part1 < 2097152 ? 7 : 8\n            : part2 < 128 ? 9 : 10;\n    }\n    /**\n     * Constructs new long bits from the specified number\n     */\n    static fromBigInt(value) {\n        if (value === 0n) {\n            return zero;\n        }\n        if (value < MAX_SAFE_NUMBER_INTEGER && value > MIN_SAFE_NUMBER_INTEGER) {\n            return this.fromNumber(Number(value));\n        }\n        const negative = value < 0n;\n        if (negative) {\n            value = -value;\n        }\n        let hi = value >> 32n;\n        let lo = value - (hi << 32n);\n        if (negative) {\n            hi = ~hi | 0n;\n            lo = ~lo | 0n;\n            if (++lo > TWO_32) {\n                lo = 0n;\n                if (++hi > TWO_32) {\n                    hi = 0n;\n                }\n            }\n        }\n        return new LongBits(Number(lo), Number(hi));\n    }\n    /**\n     * Constructs new long bits from the specified number\n     */\n    static fromNumber(value) {\n        if (value === 0) {\n            return zero;\n        }\n        const sign = value < 0;\n        if (sign) {\n            value = -value;\n        }\n        let lo = value >>> 0;\n        let hi = (value - lo) / 4294967296 >>> 0;\n        if (sign) {\n            hi = ~hi >>> 0;\n            lo = ~lo >>> 0;\n            if (++lo > 4294967295) {\n                lo = 0;\n                if (++hi > 4294967295) {\n                    hi = 0;\n                }\n            }\n        }\n        return new LongBits(lo, hi);\n    }\n    /**\n     * Constructs new long bits from a number, long or string\n     */\n    static from(value) {\n        if (typeof value === 'number') {\n            return LongBits.fromNumber(value);\n        }\n        if (typeof value === 'bigint') {\n            return LongBits.fromBigInt(value);\n        }\n        if (typeof value === 'string') {\n            return LongBits.fromBigInt(BigInt(value));\n        }\n        return value.low != null || value.high != null ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n    }\n}\nconst zero = new LongBits(0, 0);\nzero.toBigInt = function () { return 0n; };\nzero.zzEncode = zero.zzDecode = function () { return this; };\nzero.length = function () { return 1; };\nconst TWO_32 = 4294967296n;\n//# sourceMappingURL=longbits.js.map","import { allocUnsafe } from 'uint8arrays/alloc';\n/**\n * A general purpose buffer pool\n */\nexport default function pool(size) {\n    const SIZE = size ?? 8192;\n    const MAX = SIZE >>> 1;\n    let slab;\n    let offset = SIZE;\n    return function poolAlloc(size) {\n        if (size < 1 || size > MAX) {\n            return allocUnsafe(size);\n        }\n        if (offset + size > SIZE) {\n            slab = allocUnsafe(SIZE);\n            offset = 0;\n        }\n        const buf = slab.subarray(offset, offset += size);\n        if ((offset & 7) !== 0) {\n            // align to 32 bit\n            offset = (offset | 7) + 1;\n        }\n        return buf;\n    };\n}\n//# sourceMappingURL=pool.js.map","import { decodeUint8Array, encodingLength } from 'uint8-varint';\nimport { readFloatLE, readDoubleLE } from './float.js';\nimport { LongBits } from './longbits.js';\nimport * as utf8 from './utf8.js';\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(`index out of range: ${reader.pos} + ${writeLength ?? 1} > ${reader.len}`);\n}\nfunction readFixed32End(buf, end) {\n    return (buf[end - 4] |\n        buf[end - 3] << 8 |\n        buf[end - 2] << 16 |\n        buf[end - 1] << 24) >>> 0;\n}\n/**\n * Constructs a new reader instance using the specified buffer.\n */\nexport class Uint8ArrayReader {\n    buf;\n    pos;\n    len;\n    _slice = Uint8Array.prototype.subarray;\n    constructor(buffer) {\n        /**\n         * Read buffer\n         */\n        this.buf = buffer;\n        /**\n         * Read buffer position\n         */\n        this.pos = 0;\n        /**\n         * Read buffer length\n         */\n        this.len = buffer.length;\n    }\n    /**\n     * Reads a varint as an unsigned 32 bit value\n     */\n    uint32() {\n        let value = 4294967295;\n        value = (this.buf[this.pos] & 127) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return value;\n        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return value;\n        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return value;\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    }\n    /**\n     * Reads a varint as a signed 32 bit value\n     */\n    int32() {\n        return this.uint32() | 0;\n    }\n    /**\n     * Reads a zig-zag encoded varint as a signed 32 bit value\n     */\n    sint32() {\n        const value = this.uint32();\n        return value >>> 1 ^ -(value & 1) | 0;\n    }\n    /**\n     * Reads a varint as a boolean\n     */\n    bool() {\n        return this.uint32() !== 0;\n    }\n    /**\n     * Reads fixed 32 bits as an unsigned 32 bit integer\n     */\n    fixed32() {\n        if (this.pos + 4 > this.len) {\n            throw indexOutOfRange(this, 4);\n        }\n        const res = readFixed32End(this.buf, this.pos += 4);\n        return res;\n    }\n    /**\n     * Reads fixed 32 bits as a signed 32 bit integer\n     */\n    sfixed32() {\n        if (this.pos + 4 > this.len) {\n            throw indexOutOfRange(this, 4);\n        }\n        const res = readFixed32End(this.buf, this.pos += 4) | 0;\n        return res;\n    }\n    /**\n     * Reads a float (32 bit) as a number\n     */\n    float() {\n        if (this.pos + 4 > this.len) {\n            throw indexOutOfRange(this, 4);\n        }\n        const value = readFloatLE(this.buf, this.pos);\n        this.pos += 4;\n        return value;\n    }\n    /**\n     * Reads a double (64 bit float) as a number\n     */\n    double() {\n        /* istanbul ignore if */\n        if (this.pos + 8 > this.len) {\n            throw indexOutOfRange(this, 4);\n        }\n        const value = readDoubleLE(this.buf, this.pos);\n        this.pos += 8;\n        return value;\n    }\n    /**\n     * Reads a sequence of bytes preceded by its length as a varint\n     */\n    bytes() {\n        const length = this.uint32();\n        const start = this.pos;\n        const end = this.pos + length;\n        /* istanbul ignore if */\n        if (end > this.len) {\n            throw indexOutOfRange(this, length);\n        }\n        this.pos += length;\n        return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\n            ? new Uint8Array(0)\n            : this.buf.subarray(start, end);\n    }\n    /**\n     * Reads a string preceded by its byte length as a varint\n     */\n    string() {\n        const bytes = this.bytes();\n        return utf8.read(bytes, 0, bytes.length);\n    }\n    /**\n     * Skips the specified number of bytes if specified, otherwise skips a varint\n     */\n    skip(length) {\n        if (typeof length === 'number') {\n            /* istanbul ignore if */\n            if (this.pos + length > this.len) {\n                throw indexOutOfRange(this, length);\n            }\n            this.pos += length;\n        }\n        else {\n            do {\n                /* istanbul ignore if */\n                if (this.pos >= this.len) {\n                    throw indexOutOfRange(this);\n                }\n            } while ((this.buf[this.pos++] & 128) !== 0);\n        }\n        return this;\n    }\n    /**\n     * Skips the next element of the specified wire type\n     */\n    skipType(wireType) {\n        switch (wireType) {\n            case 0:\n                this.skip();\n                break;\n            case 1:\n                this.skip(8);\n                break;\n            case 2:\n                this.skip(this.uint32());\n                break;\n            case 3:\n                while ((wireType = this.uint32() & 7) !== 4) {\n                    this.skipType(wireType);\n                }\n                break;\n            case 5:\n                this.skip(4);\n                break;\n            /* istanbul ignore next */\n            default:\n                throw Error(`invalid wire type ${wireType} at offset ${this.pos}`);\n        }\n        return this;\n    }\n    readLongVarint() {\n        // tends to deopt with local vars for octet etc.\n        const bits = new LongBits(0, 0);\n        let i = 0;\n        if (this.len - this.pos > 4) { // fast route (lo)\n            for (; i < 4; ++i) {\n                // 1st..4th\n                bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n                if (this.buf[this.pos++] < 128) {\n                    return bits;\n                }\n            }\n            // 5th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;\n            if (this.buf[this.pos++] < 128) {\n                return bits;\n            }\n            i = 0;\n        }\n        else {\n            for (; i < 3; ++i) {\n                /* istanbul ignore if */\n                if (this.pos >= this.len) {\n                    throw indexOutOfRange(this);\n                }\n                // 1st..3th\n                bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n                if (this.buf[this.pos++] < 128) {\n                    return bits;\n                }\n            }\n            // 4th\n            bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n            return bits;\n        }\n        if (this.len - this.pos > 4) { // fast route (hi)\n            for (; i < 5; ++i) {\n                // 6th..10th\n                bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n                if (this.buf[this.pos++] < 128) {\n                    return bits;\n                }\n            }\n        }\n        else {\n            for (; i < 5; ++i) {\n                if (this.pos >= this.len) {\n                    throw indexOutOfRange(this);\n                }\n                // 6th..10th\n                bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n                if (this.buf[this.pos++] < 128) {\n                    return bits;\n                }\n            }\n        }\n        throw Error('invalid varint encoding');\n    }\n    readFixed64() {\n        if (this.pos + 8 > this.len) {\n            throw indexOutOfRange(this, 8);\n        }\n        const lo = readFixed32End(this.buf, this.pos += 4);\n        const hi = readFixed32End(this.buf, this.pos += 4);\n        return new LongBits(lo, hi);\n    }\n    /**\n     * Reads a varint as a signed 64 bit value\n     */\n    int64() {\n        return this.readLongVarint().toBigInt();\n    }\n    /**\n     * Reads a varint as a signed 64 bit value returned as a possibly unsafe\n     * JavaScript number\n     */\n    int64Number() {\n        return this.readLongVarint().toNumber();\n    }\n    /**\n     * Reads a varint as a signed 64 bit value returned as a string\n     */\n    int64String() {\n        return this.readLongVarint().toString();\n    }\n    /**\n     * Reads a varint as an unsigned 64 bit value\n     */\n    uint64() {\n        return this.readLongVarint().toBigInt(true);\n    }\n    /**\n     * Reads a varint as an unsigned 64 bit value returned as a possibly unsafe\n     * JavaScript number\n     */\n    uint64Number() {\n        const value = decodeUint8Array(this.buf, this.pos);\n        this.pos += encodingLength(value);\n        return value;\n    }\n    /**\n     * Reads a varint as an unsigned 64 bit value returned as a string\n     */\n    uint64String() {\n        return this.readLongVarint().toString(true);\n    }\n    /**\n     * Reads a zig-zag encoded varint as a signed 64 bit value\n     */\n    sint64() {\n        return this.readLongVarint().zzDecode().toBigInt();\n    }\n    /**\n     * Reads a zig-zag encoded varint as a signed 64 bit value returned as a\n     * possibly unsafe JavaScript number\n     */\n    sint64Number() {\n        return this.readLongVarint().zzDecode().toNumber();\n    }\n    /**\n     * Reads a zig-zag encoded varint as a signed 64 bit value returned as a\n     * string\n     */\n    sint64String() {\n        return this.readLongVarint().zzDecode().toString();\n    }\n    /**\n     * Reads fixed 64 bits\n     */\n    fixed64() {\n        return this.readFixed64().toBigInt();\n    }\n    /**\n     * Reads fixed 64 bits returned as a possibly unsafe JavaScript number\n     */\n    fixed64Number() {\n        return this.readFixed64().toNumber();\n    }\n    /**\n     * Reads fixed 64 bits returned as a string\n     */\n    fixed64String() {\n        return this.readFixed64().toString();\n    }\n    /**\n     * Reads zig-zag encoded fixed 64 bits\n     */\n    sfixed64() {\n        return this.readFixed64().toBigInt();\n    }\n    /**\n     * Reads zig-zag encoded fixed 64 bits returned as a possibly unsafe\n     * JavaScript number\n     */\n    sfixed64Number() {\n        return this.readFixed64().toNumber();\n    }\n    /**\n     * Reads zig-zag encoded fixed 64 bits returned as a string\n     */\n    sfixed64String() {\n        return this.readFixed64().toString();\n    }\n}\nexport function createReader(buf) {\n    return new Uint8ArrayReader(buf instanceof Uint8Array ? buf : buf.subarray());\n}\n//# sourceMappingURL=reader.js.map","/**\n * Calculates the UTF8 byte length of a string\n */\nexport function length(string) {\n    let len = 0;\n    let c = 0;\n    for (let i = 0; i < string.length; ++i) {\n        c = string.charCodeAt(i);\n        if (c < 128) {\n            len += 1;\n        }\n        else if (c < 2048) {\n            len += 2;\n        }\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\n            ++i;\n            len += 4;\n        }\n        else {\n            len += 3;\n        }\n    }\n    return len;\n}\n/**\n * Reads UTF8 bytes as a string\n */\nexport function read(buffer, start, end) {\n    const len = end - start;\n    if (len < 1) {\n        return '';\n    }\n    let parts;\n    const chunk = [];\n    let i = 0; // char offset\n    let t; // temporary\n    while (start < end) {\n        t = buffer[start++];\n        if (t < 128) {\n            chunk[i++] = t;\n        }\n        else if (t > 191 && t < 224) {\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\n        }\n        else if (t > 239 && t < 365) {\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\n            chunk[i++] = 0xD800 + (t >> 10);\n            chunk[i++] = 0xDC00 + (t & 1023);\n        }\n        else {\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\n        }\n        if (i > 8191) {\n            (parts ?? (parts = [])).push(String.fromCharCode.apply(String, chunk));\n            i = 0;\n        }\n    }\n    if (parts != null) {\n        if (i > 0) {\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n        }\n        return parts.join('');\n    }\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\n}\n/**\n * Writes a string as UTF8 bytes\n */\nexport function write(string, buffer, offset) {\n    const start = offset;\n    let c1; // character 1\n    let c2; // character 2\n    for (let i = 0; i < string.length; ++i) {\n        c1 = string.charCodeAt(i);\n        if (c1 < 128) {\n            buffer[offset++] = c1;\n        }\n        else if (c1 < 2048) {\n            buffer[offset++] = c1 >> 6 | 192;\n            buffer[offset++] = c1 & 63 | 128;\n        }\n        else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\n            ++i;\n            buffer[offset++] = c1 >> 18 | 240;\n            buffer[offset++] = c1 >> 12 & 63 | 128;\n            buffer[offset++] = c1 >> 6 & 63 | 128;\n            buffer[offset++] = c1 & 63 | 128;\n        }\n        else {\n            buffer[offset++] = c1 >> 12 | 224;\n            buffer[offset++] = c1 >> 6 & 63 | 128;\n            buffer[offset++] = c1 & 63 | 128;\n        }\n    }\n    return offset - start;\n}\n//# sourceMappingURL=utf8.js.map","import { encodeUint8Array, encodingLength } from 'uint8-varint';\nimport { allocUnsafe } from 'uint8arrays/alloc';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { writeFloatLE, writeDoubleLE } from './float.js';\nimport { LongBits } from './longbits.js';\nimport pool from './pool.js';\nimport * as utf8 from './utf8.js';\n/**\n * Constructs a new writer operation instance.\n *\n * @classdesc Scheduled writer operation\n */\nclass Op {\n    /**\n     * Function to call\n     */\n    fn;\n    /**\n     * Value byte length\n     */\n    len;\n    /**\n     * Next operation\n     */\n    next;\n    /**\n     * Value to write\n     */\n    val;\n    constructor(fn, len, val) {\n        this.fn = fn;\n        this.len = len;\n        this.next = undefined;\n        this.val = val; // type varies\n    }\n}\n/* istanbul ignore next */\nfunction noop() { } // eslint-disable-line no-empty-function\n/**\n * Constructs a new writer state instance\n */\nclass State {\n    /**\n     * Current head\n     */\n    head;\n    /**\n     * Current tail\n     */\n    tail;\n    /**\n     * Current buffer length\n     */\n    len;\n    /**\n     * Next state\n     */\n    next;\n    constructor(writer) {\n        this.head = writer.head;\n        this.tail = writer.tail;\n        this.len = writer.len;\n        this.next = writer.states;\n    }\n}\nconst bufferPool = pool();\n/**\n * Allocates a buffer of the specified size\n */\nfunction alloc(size) {\n    if (globalThis.Buffer != null) {\n        return allocUnsafe(size);\n    }\n    return bufferPool(size);\n}\n/**\n * When a value is written, the writer calculates its byte length and puts it into a linked\n * list of operations to perform when finish() is called. This both allows us to allocate\n * buffers of the exact required size and reduces the amount of work we have to do compared\n * to first calculating over objects and then encoding over objects. In our case, the encoding\n * part is just a linked list walk calling operations with already prepared values.\n */\nclass Uint8ArrayWriter {\n    /**\n     * Current length\n     */\n    len;\n    /**\n     * Operations head\n     */\n    head;\n    /**\n     * Operations tail\n     */\n    tail;\n    /**\n     * Linked forked states\n     */\n    states;\n    constructor() {\n        this.len = 0;\n        this.head = new Op(noop, 0, 0);\n        this.tail = this.head;\n        this.states = null;\n    }\n    /**\n     * Pushes a new operation to the queue\n     */\n    _push(fn, len, val) {\n        this.tail = this.tail.next = new Op(fn, len, val);\n        this.len += len;\n        return this;\n    }\n    /**\n     * Writes an unsigned 32 bit value as a varint\n     */\n    uint32(value) {\n        // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n        // uint32 is by far the most frequently used operation and benefits significantly from this.\n        this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) <\n            128\n            ? 1\n            : value < 16384\n                ? 2\n                : value < 2097152\n                    ? 3\n                    : value < 268435456\n                        ? 4\n                        : 5, value)).len;\n        return this;\n    }\n    /**\n     * Writes a signed 32 bit value as a varint`\n     */\n    int32(value) {\n        return value < 0\n            ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n            : this.uint32(value);\n    }\n    /**\n     * Writes a 32 bit value as a varint, zig-zag encoded\n     */\n    sint32(value) {\n        return this.uint32((value << 1 ^ value >> 31) >>> 0);\n    }\n    /**\n     * Writes an unsigned 64 bit value as a varint\n     */\n    uint64(value) {\n        const bits = LongBits.fromBigInt(value);\n        return this._push(writeVarint64, bits.length(), bits);\n    }\n    /**\n     * Writes an unsigned 64 bit value as a varint\n     */\n    uint64Number(value) {\n        return this._push(encodeUint8Array, encodingLength(value), value);\n    }\n    /**\n     * Writes an unsigned 64 bit value as a varint\n     */\n    uint64String(value) {\n        return this.uint64(BigInt(value));\n    }\n    /**\n     * Writes a signed 64 bit value as a varint\n     */\n    int64(value) {\n        return this.uint64(value);\n    }\n    /**\n     * Writes a signed 64 bit value as a varint\n     */\n    int64Number(value) {\n        return this.uint64Number(value);\n    }\n    /**\n     * Writes a signed 64 bit value as a varint\n     */\n    int64String(value) {\n        return this.uint64String(value);\n    }\n    /**\n     * Writes a signed 64 bit value as a varint, zig-zag encoded\n     */\n    sint64(value) {\n        const bits = LongBits.fromBigInt(value).zzEncode();\n        return this._push(writeVarint64, bits.length(), bits);\n    }\n    /**\n     * Writes a signed 64 bit value as a varint, zig-zag encoded\n     */\n    sint64Number(value) {\n        const bits = LongBits.fromNumber(value).zzEncode();\n        return this._push(writeVarint64, bits.length(), bits);\n    }\n    /**\n     * Writes a signed 64 bit value as a varint, zig-zag encoded\n     */\n    sint64String(value) {\n        return this.sint64(BigInt(value));\n    }\n    /**\n     * Writes a boolish value as a varint\n     */\n    bool(value) {\n        return this._push(writeByte, 1, value ? 1 : 0);\n    }\n    /**\n     * Writes an unsigned 32 bit value as fixed 32 bits\n     */\n    fixed32(value) {\n        return this._push(writeFixed32, 4, value >>> 0);\n    }\n    /**\n     * Writes a signed 32 bit value as fixed 32 bits\n     */\n    sfixed32(value) {\n        return this.fixed32(value);\n    }\n    /**\n     * Writes an unsigned 64 bit value as fixed 64 bits\n     */\n    fixed64(value) {\n        const bits = LongBits.fromBigInt(value);\n        return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n    }\n    /**\n     * Writes an unsigned 64 bit value as fixed 64 bits\n     */\n    fixed64Number(value) {\n        const bits = LongBits.fromNumber(value);\n        return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n    }\n    /**\n     * Writes an unsigned 64 bit value as fixed 64 bits\n     */\n    fixed64String(value) {\n        return this.fixed64(BigInt(value));\n    }\n    /**\n     * Writes a signed 64 bit value as fixed 64 bits\n     */\n    sfixed64(value) {\n        return this.fixed64(value);\n    }\n    /**\n     * Writes a signed 64 bit value as fixed 64 bits\n     */\n    sfixed64Number(value) {\n        return this.fixed64Number(value);\n    }\n    /**\n     * Writes a signed 64 bit value as fixed 64 bits\n     */\n    sfixed64String(value) {\n        return this.fixed64String(value);\n    }\n    /**\n     * Writes a float (32 bit)\n     */\n    float(value) {\n        return this._push(writeFloatLE, 4, value);\n    }\n    /**\n     * Writes a double (64 bit float).\n     *\n     * @function\n     * @param {number} value - Value to write\n     * @returns {Writer} `this`\n     */\n    double(value) {\n        return this._push(writeDoubleLE, 8, value);\n    }\n    /**\n     * Writes a sequence of bytes\n     */\n    bytes(value) {\n        const len = value.length >>> 0;\n        if (len === 0) {\n            return this._push(writeByte, 1, 0);\n        }\n        return this.uint32(len)._push(writeBytes, len, value);\n    }\n    /**\n     * Writes a string\n     */\n    string(value) {\n        const len = utf8.length(value);\n        return len !== 0\n            ? this.uint32(len)._push(utf8.write, len, value)\n            : this._push(writeByte, 1, 0);\n    }\n    /**\n     * Forks this writer's state by pushing it to a stack.\n     * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n     */\n    fork() {\n        this.states = new State(this);\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len = 0;\n        return this;\n    }\n    /**\n     * Resets this instance to the last state\n     */\n    reset() {\n        if (this.states != null) {\n            this.head = this.states.head;\n            this.tail = this.states.tail;\n            this.len = this.states.len;\n            this.states = this.states.next;\n        }\n        else {\n            this.head = this.tail = new Op(noop, 0, 0);\n            this.len = 0;\n        }\n        return this;\n    }\n    /**\n     * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n     */\n    ldelim() {\n        const head = this.head;\n        const tail = this.tail;\n        const len = this.len;\n        this.reset().uint32(len);\n        if (len !== 0) {\n            this.tail.next = head.next; // skip noop\n            this.tail = tail;\n            this.len += len;\n        }\n        return this;\n    }\n    /**\n     * Finishes the write operation\n     */\n    finish() {\n        let head = this.head.next; // skip noop\n        const buf = alloc(this.len);\n        let pos = 0;\n        while (head != null) {\n            head.fn(head.val, buf, pos);\n            pos += head.len;\n            head = head.next;\n        }\n        // this.head = this.tail = null;\n        return buf;\n    }\n}\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n/**\n * Constructs a new varint writer operation instance.\n *\n * @classdesc Scheduled varint writer operation\n */\nclass VarintOp extends Op {\n    next;\n    constructor(len, val) {\n        super(writeVarint32, len, val);\n        this.next = undefined;\n    }\n}\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi !== 0) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\nfunction writeFixed32(val, buf, pos) {\n    buf[pos] = val & 255;\n    buf[pos + 1] = val >>> 8 & 255;\n    buf[pos + 2] = val >>> 16 & 255;\n    buf[pos + 3] = val >>> 24;\n}\nfunction writeBytes(val, buf, pos) {\n    buf.set(val, pos);\n}\nif (globalThis.Buffer != null) {\n    Uint8ArrayWriter.prototype.bytes = function (value) {\n        const len = value.length >>> 0;\n        this.uint32(len);\n        if (len > 0) {\n            this._push(writeBytesBuffer, len, value);\n        }\n        return this;\n    };\n    Uint8ArrayWriter.prototype.string = function (value) {\n        const len = globalThis.Buffer.byteLength(value);\n        this.uint32(len);\n        if (len > 0) {\n            this._push(writeStringBuffer, len, value);\n        }\n        return this;\n    };\n}\nfunction writeBytesBuffer(val, buf, pos) {\n    buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n    // also works for plain array values\n}\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) {\n        // plain js is faster for short strings (probably due to redundant assertions)\n        utf8.write(val, buf, pos);\n        // @ts-expect-error buf isn't a Uint8Array?\n    }\n    else if (buf.utf8Write != null) {\n        // @ts-expect-error buf isn't a Uint8Array?\n        buf.utf8Write(val, pos);\n    }\n    else {\n        buf.set(uint8ArrayFromString(val), pos);\n    }\n}\n/**\n * Creates a new writer\n */\nexport function createWriter() {\n    return new Uint8ArrayWriter();\n}\n//# sourceMappingURL=writer.js.map","/* eslint-disable no-fallthrough */\nimport { allocUnsafe } from 'uint8arrays/alloc';\nconst N1 = Math.pow(2, 7);\nconst N2 = Math.pow(2, 14);\nconst N3 = Math.pow(2, 21);\nconst N4 = Math.pow(2, 28);\nconst N5 = Math.pow(2, 35);\nconst N6 = Math.pow(2, 42);\nconst N7 = Math.pow(2, 49);\n/** Most significant bit of a byte */\nconst MSB = 0x80;\n/** Rest of the bits in a byte */\nconst REST = 0x7f;\nexport function encodingLength(value) {\n    if (value < N1) {\n        return 1;\n    }\n    if (value < N2) {\n        return 2;\n    }\n    if (value < N3) {\n        return 3;\n    }\n    if (value < N4) {\n        return 4;\n    }\n    if (value < N5) {\n        return 5;\n    }\n    if (value < N6) {\n        return 6;\n    }\n    if (value < N7) {\n        return 7;\n    }\n    if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {\n        throw new RangeError('Could not encode varint');\n    }\n    return 8;\n}\nexport function encodeUint8Array(value, buf, offset = 0) {\n    switch (encodingLength(value)) {\n        case 8: {\n            buf[offset++] = (value & 0xFF) | MSB;\n            value /= 128;\n        }\n        case 7: {\n            buf[offset++] = (value & 0xFF) | MSB;\n            value /= 128;\n        }\n        case 6: {\n            buf[offset++] = (value & 0xFF) | MSB;\n            value /= 128;\n        }\n        case 5: {\n            buf[offset++] = (value & 0xFF) | MSB;\n            value /= 128;\n        }\n        case 4: {\n            buf[offset++] = (value & 0xFF) | MSB;\n            value >>>= 7;\n        }\n        case 3: {\n            buf[offset++] = (value & 0xFF) | MSB;\n            value >>>= 7;\n        }\n        case 2: {\n            buf[offset++] = (value & 0xFF) | MSB;\n            value >>>= 7;\n        }\n        case 1: {\n            buf[offset++] = (value & 0xFF);\n            value >>>= 7;\n            break;\n        }\n        default: throw new Error('unreachable');\n    }\n    return buf;\n}\nexport function encodeUint8ArrayList(value, buf, offset = 0) {\n    switch (encodingLength(value)) {\n        case 8: {\n            buf.set(offset++, (value & 0xFF) | MSB);\n            value /= 128;\n        }\n        case 7: {\n            buf.set(offset++, (value & 0xFF) | MSB);\n            value /= 128;\n        }\n        case 6: {\n            buf.set(offset++, (value & 0xFF) | MSB);\n            value /= 128;\n        }\n        case 5: {\n            buf.set(offset++, (value & 0xFF) | MSB);\n            value /= 128;\n        }\n        case 4: {\n            buf.set(offset++, (value & 0xFF) | MSB);\n            value >>>= 7;\n        }\n        case 3: {\n            buf.set(offset++, (value & 0xFF) | MSB);\n            value >>>= 7;\n        }\n        case 2: {\n            buf.set(offset++, (value & 0xFF) | MSB);\n            value >>>= 7;\n        }\n        case 1: {\n            buf.set(offset++, (value & 0xFF));\n            value >>>= 7;\n            break;\n        }\n        default: throw new Error('unreachable');\n    }\n    return buf;\n}\nexport function decodeUint8Array(buf, offset) {\n    let b = buf[offset];\n    let res = 0;\n    res += b & REST;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf[offset + 1];\n    res += (b & REST) << 7;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf[offset + 2];\n    res += (b & REST) << 14;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf[offset + 3];\n    res += (b & REST) << 21;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf[offset + 4];\n    res += (b & REST) * N4;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf[offset + 5];\n    res += (b & REST) * N5;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf[offset + 6];\n    res += (b & REST) * N6;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf[offset + 7];\n    res += (b & REST) * N7;\n    if (b < MSB) {\n        return res;\n    }\n    throw new RangeError('Could not decode varint');\n}\nexport function decodeUint8ArrayList(buf, offset) {\n    let b = buf.get(offset);\n    let res = 0;\n    res += b & REST;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf.get(offset + 1);\n    res += (b & REST) << 7;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf.get(offset + 2);\n    res += (b & REST) << 14;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf.get(offset + 3);\n    res += (b & REST) << 21;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf.get(offset + 4);\n    res += (b & REST) * N4;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf.get(offset + 5);\n    res += (b & REST) * N5;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf.get(offset + 6);\n    res += (b & REST) * N6;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf.get(offset + 7);\n    res += (b & REST) * N7;\n    if (b < MSB) {\n        return res;\n    }\n    throw new RangeError('Could not decode varint');\n}\nexport function encode(value, buf, offset = 0) {\n    if (buf == null) {\n        buf = allocUnsafe(encodingLength(value));\n    }\n    if (buf instanceof Uint8Array) {\n        return encodeUint8Array(value, buf, offset);\n    }\n    else {\n        return encodeUint8ArrayList(value, buf, offset);\n    }\n}\nexport function decode(buf, offset = 0) {\n    if (buf instanceof Uint8Array) {\n        return decodeUint8Array(buf, offset);\n    }\n    else {\n        return decodeUint8ArrayList(buf, offset);\n    }\n}\n//# sourceMappingURL=index.js.map","/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc(size = 0) {\n    return new Uint8Array(size);\n}\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe(size = 0) {\n    return new Uint8Array(size);\n}\n//# sourceMappingURL=alloc.js.map","/**\n * Can be used with Array.sort to sort and array with Uint8Array entries\n */\nexport function compare(a, b) {\n    for (let i = 0; i < a.byteLength; i++) {\n        if (a[i] < b[i]) {\n            return -1;\n        }\n        if (a[i] > b[i]) {\n            return 1;\n        }\n    }\n    if (a.byteLength > b.byteLength) {\n        return 1;\n    }\n    if (a.byteLength < b.byteLength) {\n        return -1;\n    }\n    return 0;\n}\n//# sourceMappingURL=compare.js.map","import { allocUnsafe } from '#alloc';\nimport { asUint8Array } from '#util/as-uint8array';\n/**\n * Returns a new Uint8Array created by concatenating the passed Uint8Arrays\n */\nexport function concat(arrays, length) {\n    if (length == null) {\n        length = arrays.reduce((acc, curr) => acc + curr.length, 0);\n    }\n    const output = allocUnsafe(length);\n    let offset = 0;\n    for (const arr of arrays) {\n        output.set(arr, offset);\n        offset += arr.length;\n    }\n    return asUint8Array(output);\n}\n//# sourceMappingURL=concat.js.map","/**\n * Returns true if the two passed Uint8Arrays have the same content\n */\nexport function equals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a.byteLength !== b.byteLength) {\n        return false;\n    }\n    for (let i = 0; i < a.byteLength; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=equals.js.map","import bases, {} from './util/bases.js';\n/**\n * Create a `Uint8Array` from the passed string\n *\n * Supports `utf8`, `utf-8`, `hex`, and any encoding supported by the multiformats module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function fromString(string, encoding = 'utf8') {\n    const base = bases[encoding];\n    if (base == null) {\n        throw new Error(`Unsupported encoding \"${encoding}\"`);\n    }\n    // add multibase prefix\n    return base.decoder.decode(`${base.prefix}${string}`); // eslint-disable-line @typescript-eslint/restrict-template-expressions\n}\n//# sourceMappingURL=from-string.js.map","import bases, {} from './util/bases.js';\n/**\n * Turns a `Uint8Array` into a string.\n *\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function toString(array, encoding = 'utf8') {\n    const base = bases[encoding];\n    if (base == null) {\n        throw new Error(`Unsupported encoding \"${encoding}\"`);\n    }\n    // strip multibase prefix\n    return base.encoder.encode(array).substring(1);\n}\n//# sourceMappingURL=to-string.js.map","/**\n * To guarantee Uint8Array semantics, convert nodejs Buffers\n * into vanilla Uint8Arrays\n */\nexport function asUint8Array(buf) {\n    return buf;\n}\n//# sourceMappingURL=as-uint8array.js.map","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '#alloc';\nfunction createCodec(name, prefix, encode, decode) {\n    return {\n        name,\n        prefix,\n        encoder: {\n            name,\n            prefix,\n            encode\n        },\n        decoder: {\n            decode\n        }\n    };\n}\nconst string = createCodec('utf8', 'u', (buf) => {\n    const decoder = new TextDecoder('utf8');\n    return 'u' + decoder.decode(buf);\n}, (str) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', (buf) => {\n    let string = 'a';\n    for (let i = 0; i < buf.length; i++) {\n        string += String.fromCharCode(buf[i]);\n    }\n    return string;\n}, (str) => {\n    str = str.substring(1);\n    const buf = allocUnsafe(str.length);\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n});\nconst BASES = {\n    utf8: string,\n    'utf-8': string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii,\n    binary: ascii,\n    ...bases\n};\nexport default BASES;\n//# sourceMappingURL=bases.js.map","import { coerce } from '../bytes.js';\nimport basex from '../vendor/base-x.js';\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder {\n    name;\n    prefix;\n    baseEncode;\n    constructor(name, prefix, baseEncode) {\n        this.name = name;\n        this.prefix = prefix;\n        this.baseEncode = baseEncode;\n    }\n    encode(bytes) {\n        if (bytes instanceof Uint8Array) {\n            return `${this.prefix}${this.baseEncode(bytes)}`;\n        }\n        else {\n            throw Error('Unknown type, must be binary type');\n        }\n    }\n}\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder {\n    name;\n    prefix;\n    baseDecode;\n    prefixCodePoint;\n    constructor(name, prefix, baseDecode) {\n        this.name = name;\n        this.prefix = prefix;\n        /* c8 ignore next 3 */\n        if (prefix.codePointAt(0) === undefined) {\n            throw new Error('Invalid prefix character');\n        }\n        this.prefixCodePoint = prefix.codePointAt(0);\n        this.baseDecode = baseDecode;\n    }\n    decode(text) {\n        if (typeof text === 'string') {\n            if (text.codePointAt(0) !== this.prefixCodePoint) {\n                throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n            }\n            return this.baseDecode(text.slice(this.prefix.length));\n        }\n        else {\n            throw Error('Can only multibase decode strings');\n        }\n    }\n    or(decoder) {\n        return or(this, decoder);\n    }\n}\nclass ComposedDecoder {\n    decoders;\n    constructor(decoders) {\n        this.decoders = decoders;\n    }\n    or(decoder) {\n        return or(this, decoder);\n    }\n    decode(input) {\n        const prefix = input[0];\n        const decoder = this.decoders[prefix];\n        if (decoder != null) {\n            return decoder.decode(input);\n        }\n        else {\n            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n        }\n    }\n}\nexport function or(left, right) {\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    return new ComposedDecoder({\n        ...(left.decoders ?? { [left.prefix]: left }),\n        ...(right.decoders ?? { [right.prefix]: right })\n    });\n}\nexport class Codec {\n    name;\n    prefix;\n    baseEncode;\n    baseDecode;\n    encoder;\n    decoder;\n    constructor(name, prefix, baseEncode, baseDecode) {\n        this.name = name;\n        this.prefix = prefix;\n        this.baseEncode = baseEncode;\n        this.baseDecode = baseDecode;\n        this.encoder = new Encoder(name, prefix, baseEncode);\n        this.decoder = new Decoder(name, prefix, baseDecode);\n    }\n    encode(input) {\n        return this.encoder.encode(input);\n    }\n    decode(input) {\n        return this.decoder.decode(input);\n    }\n}\nexport function from({ name, prefix, encode, decode }) {\n    return new Codec(name, prefix, encode, decode);\n}\nexport function baseX({ name, prefix, alphabet }) {\n    const { encode, decode } = basex(alphabet, name);\n    return from({\n        prefix,\n        name,\n        encode,\n        decode: (text) => coerce(decode(text))\n    });\n}\nfunction decode(string, alphabet, bitsPerChar, name) {\n    // Build the character lookup table:\n    const codes = {};\n    for (let i = 0; i < alphabet.length; ++i) {\n        codes[alphabet[i]] = i;\n    }\n    // Count the padding bytes:\n    let end = string.length;\n    while (string[end - 1] === '=') {\n        --end;\n    }\n    // Allocate the output:\n    const out = new Uint8Array((end * bitsPerChar / 8) | 0);\n    // Parse the data:\n    let bits = 0; // Number of bits currently in the buffer\n    let buffer = 0; // Bits waiting to be written out, MSB first\n    let written = 0; // Next byte to write\n    for (let i = 0; i < end; ++i) {\n        // Read one character from the string:\n        const value = codes[string[i]];\n        if (value === undefined) {\n            throw new SyntaxError(`Non-${name} character`);\n        }\n        // Append the bits to the buffer:\n        buffer = (buffer << bitsPerChar) | value;\n        bits += bitsPerChar;\n        // Write out some bits if the buffer has a byte's worth:\n        if (bits >= 8) {\n            bits -= 8;\n            out[written++] = 0xff & (buffer >> bits);\n        }\n    }\n    // Verify that we have received just enough bits:\n    if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n        throw new SyntaxError('Unexpected end of data');\n    }\n    return out;\n}\nfunction encode(data, alphabet, bitsPerChar) {\n    const pad = alphabet[alphabet.length - 1] === '=';\n    const mask = (1 << bitsPerChar) - 1;\n    let out = '';\n    let bits = 0; // Number of bits currently in the buffer\n    let buffer = 0; // Bits waiting to be written out, MSB first\n    for (let i = 0; i < data.length; ++i) {\n        // Slurp data into the buffer:\n        buffer = (buffer << 8) | data[i];\n        bits += 8;\n        // Write out as much as we can:\n        while (bits > bitsPerChar) {\n            bits -= bitsPerChar;\n            out += alphabet[mask & (buffer >> bits)];\n        }\n    }\n    // Partial character:\n    if (bits !== 0) {\n        out += alphabet[mask & (buffer << (bitsPerChar - bits))];\n    }\n    // Add padding characters until we hit a byte boundary:\n    if (pad) {\n        while (((out.length * bitsPerChar) & 7) !== 0) {\n            out += '=';\n        }\n    }\n    return out;\n}\n/**\n * RFC4648 Factory\n */\nexport function rfc4648({ name, prefix, bitsPerChar, alphabet }) {\n    return from({\n        prefix,\n        name,\n        encode(input) {\n            return encode(input, alphabet, bitsPerChar);\n        },\n        decode(input) {\n            return decode(input, alphabet, bitsPerChar, name);\n        }\n    });\n}\n//# sourceMappingURL=base.js.map","import { baseX } from './base.js';\nexport const base10 = baseX({\n    prefix: '9',\n    name: 'base10',\n    alphabet: '0123456789'\n});\n//# sourceMappingURL=base10.js.map","import { rfc4648 } from './base.js';\nexport const base16 = rfc4648({\n    prefix: 'f',\n    name: 'base16',\n    alphabet: '0123456789abcdef',\n    bitsPerChar: 4\n});\nexport const base16upper = rfc4648({\n    prefix: 'F',\n    name: 'base16upper',\n    alphabet: '0123456789ABCDEF',\n    bitsPerChar: 4\n});\n//# sourceMappingURL=base16.js.map","import { rfc4648 } from './base.js';\nexport const base2 = rfc4648({\n    prefix: '0',\n    name: 'base2',\n    alphabet: '01',\n    bitsPerChar: 1\n});\n//# sourceMappingURL=base2.js.map","import { from } from './base.js';\nconst alphabet = Array.from('');\nconst alphabetBytesToChars = (alphabet.reduce((p, c, i) => { p[i] = c; return p; }, ([])));\nconst alphabetCharsToBytes = (alphabet.reduce((p, c, i) => { p[c.codePointAt(0)] = i; return p; }, ([])));\nfunction encode(data) {\n    return data.reduce((p, c) => {\n        p += alphabetBytesToChars[c];\n        return p;\n    }, '');\n}\nfunction decode(str) {\n    const byts = [];\n    for (const char of str) {\n        const byt = alphabetCharsToBytes[char.codePointAt(0)];\n        if (byt === undefined) {\n            throw new Error(`Non-base256emoji character: ${char}`);\n        }\n        byts.push(byt);\n    }\n    return new Uint8Array(byts);\n}\nexport const base256emoji = from({\n    prefix: '',\n    name: 'base256emoji',\n    encode,\n    decode\n});\n//# sourceMappingURL=base256emoji.js.map","import { rfc4648 } from './base.js';\nexport const base32 = rfc4648({\n    prefix: 'b',\n    name: 'base32',\n    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n    bitsPerChar: 5\n});\nexport const base32upper = rfc4648({\n    prefix: 'B',\n    name: 'base32upper',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n    bitsPerChar: 5\n});\nexport const base32pad = rfc4648({\n    prefix: 'c',\n    name: 'base32pad',\n    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n    bitsPerChar: 5\n});\nexport const base32padupper = rfc4648({\n    prefix: 'C',\n    name: 'base32padupper',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n    bitsPerChar: 5\n});\nexport const base32hex = rfc4648({\n    prefix: 'v',\n    name: 'base32hex',\n    alphabet: '0123456789abcdefghijklmnopqrstuv',\n    bitsPerChar: 5\n});\nexport const base32hexupper = rfc4648({\n    prefix: 'V',\n    name: 'base32hexupper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n    bitsPerChar: 5\n});\nexport const base32hexpad = rfc4648({\n    prefix: 't',\n    name: 'base32hexpad',\n    alphabet: '0123456789abcdefghijklmnopqrstuv=',\n    bitsPerChar: 5\n});\nexport const base32hexpadupper = rfc4648({\n    prefix: 'T',\n    name: 'base32hexpadupper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n    bitsPerChar: 5\n});\nexport const base32z = rfc4648({\n    prefix: 'h',\n    name: 'base32z',\n    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n    bitsPerChar: 5\n});\n//# sourceMappingURL=base32.js.map","import { baseX } from './base.js';\nexport const base36 = baseX({\n    prefix: 'k',\n    name: 'base36',\n    alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n});\nexport const base36upper = baseX({\n    prefix: 'K',\n    name: 'base36upper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n});\n//# sourceMappingURL=base36.js.map","import { baseX } from './base.js';\nexport const base58btc = baseX({\n    name: 'base58btc',\n    prefix: 'z',\n    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n});\nexport const base58flickr = baseX({\n    name: 'base58flickr',\n    prefix: 'Z',\n    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n});\n//# sourceMappingURL=base58.js.map","import { rfc4648 } from './base.js';\nexport const base64 = rfc4648({\n    prefix: 'm',\n    name: 'base64',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n    bitsPerChar: 6\n});\nexport const base64pad = rfc4648({\n    prefix: 'M',\n    name: 'base64pad',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n    bitsPerChar: 6\n});\nexport const base64url = rfc4648({\n    prefix: 'u',\n    name: 'base64url',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n    bitsPerChar: 6\n});\nexport const base64urlpad = rfc4648({\n    prefix: 'U',\n    name: 'base64urlpad',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n    bitsPerChar: 6\n});\n//# sourceMappingURL=base64.js.map","import { rfc4648 } from './base.js';\nexport const base8 = rfc4648({\n    prefix: '7',\n    name: 'base8',\n    alphabet: '01234567',\n    bitsPerChar: 3\n});\n//# sourceMappingURL=base8.js.map","import { fromString, toString } from '../bytes.js';\nimport { from } from './base.js';\nexport const identity = from({\n    prefix: '\\x00',\n    name: 'identity',\n    encode: (buf) => toString(buf),\n    decode: (str) => fromString(str)\n});\n//# sourceMappingURL=identity.js.map","// Base encoders / decoders just base encode / decode between binary and\n// textual representation. They are unaware of multibase.\nexport {};\n//# sourceMappingURL=interface.js.map","import * as base10 from './bases/base10.js';\nimport * as base16 from './bases/base16.js';\nimport * as base2 from './bases/base2.js';\nimport * as base256emoji from './bases/base256emoji.js';\nimport * as base32 from './bases/base32.js';\nimport * as base36 from './bases/base36.js';\nimport * as base58 from './bases/base58.js';\nimport * as base64 from './bases/base64.js';\nimport * as base8 from './bases/base8.js';\nimport * as identityBase from './bases/identity.js';\nimport * as json from './codecs/json.js';\nimport * as raw from './codecs/raw.js';\nimport * as identity from './hashes/identity.js';\nimport * as sha2 from './hashes/sha2.js';\nimport { CID, hasher, digest, varint, bytes } from './index.js';\nexport const bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji };\nexport const hashes = { ...sha2, ...identity };\nexport const codecs = { raw, json };\nexport { CID, hasher, digest, varint, bytes };\n//# sourceMappingURL=basics.js.map","export {};\n//# sourceMappingURL=interface.js.map","export const empty = new Uint8Array(0);\nexport function toHex(d) {\n    return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');\n}\nexport function fromHex(hex) {\n    const hexes = hex.match(/../g);\n    return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;\n}\nexport function equals(aa, bb) {\n    if (aa === bb)\n        return true;\n    if (aa.byteLength !== bb.byteLength) {\n        return false;\n    }\n    for (let ii = 0; ii < aa.byteLength; ii++) {\n        if (aa[ii] !== bb[ii]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function coerce(o) {\n    if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')\n        return o;\n    if (o instanceof ArrayBuffer)\n        return new Uint8Array(o);\n    if (ArrayBuffer.isView(o)) {\n        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n    }\n    throw new Error('Unknown type, must be binary type');\n}\nexport function isBinary(o) {\n    return o instanceof ArrayBuffer || ArrayBuffer.isView(o);\n}\nexport function fromString(str) {\n    return new TextEncoder().encode(str);\n}\nexport function toString(b) {\n    return new TextDecoder().decode(b);\n}\n//# sourceMappingURL=bytes.js.map","import { base32 } from './bases/base32.js';\nimport { base58btc } from './bases/base58.js';\nimport { coerce } from './bytes.js';\nimport * as Digest from './hashes/digest.js';\nimport * as varint from './varint.js';\n// This way TS will also expose all the types from module\nexport * from './link/interface.js';\nexport function format(link, base) {\n    const { bytes, version } = link;\n    switch (version) {\n        case 0:\n            return toStringV0(bytes, baseCache(link), base ?? base58btc.encoder);\n        default:\n            return toStringV1(bytes, baseCache(link), (base ?? base32.encoder));\n    }\n}\nexport function toJSON(link) {\n    return {\n        '/': format(link)\n    };\n}\nexport function fromJSON(json) {\n    return CID.parse(json['/']);\n}\nconst cache = new WeakMap();\nfunction baseCache(cid) {\n    const baseCache = cache.get(cid);\n    if (baseCache == null) {\n        const baseCache = new Map();\n        cache.set(cid, baseCache);\n        return baseCache;\n    }\n    return baseCache;\n}\nexport class CID {\n    code;\n    version;\n    multihash;\n    bytes;\n    '/';\n    /**\n     * @param version - Version of the CID\n     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n     * @param multihash - (Multi)hash of the of the content.\n     */\n    constructor(version, code, multihash, bytes) {\n        this.code = code;\n        this.version = version;\n        this.multihash = multihash;\n        this.bytes = bytes;\n        // flag to serializers that this is a CID and\n        // should be treated specially\n        this['/'] = bytes;\n    }\n    /**\n     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n     * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n     *\n     * @deprecated\n     */\n    get asCID() {\n        return this;\n    }\n    // ArrayBufferView\n    get byteOffset() {\n        return this.bytes.byteOffset;\n    }\n    // ArrayBufferView\n    get byteLength() {\n        return this.bytes.byteLength;\n    }\n    toV0() {\n        switch (this.version) {\n            case 0: {\n                return this;\n            }\n            case 1: {\n                const { code, multihash } = this;\n                if (code !== DAG_PB_CODE) {\n                    throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n                }\n                // sha2-256\n                if (multihash.code !== SHA_256_CODE) {\n                    throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n                }\n                return (CID.createV0(multihash));\n            }\n            default: {\n                throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);\n            }\n        }\n    }\n    toV1() {\n        switch (this.version) {\n            case 0: {\n                const { code, digest } = this.multihash;\n                const multihash = Digest.create(code, digest);\n                return (CID.createV1(this.code, multihash));\n            }\n            case 1: {\n                return this;\n            }\n            default: {\n                throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);\n            }\n        }\n    }\n    equals(other) {\n        return CID.equals(this, other);\n    }\n    static equals(self, other) {\n        const unknown = other;\n        return (unknown != null &&\n            self.code === unknown.code &&\n            self.version === unknown.version &&\n            Digest.equals(self.multihash, unknown.multihash));\n    }\n    toString(base) {\n        return format(this, base);\n    }\n    toJSON() {\n        return { '/': format(this) };\n    }\n    link() {\n        return this;\n    }\n    [Symbol.toStringTag] = 'CID';\n    // Legacy\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return `CID(${this.toString()})`;\n    }\n    /**\n     * Takes any input `value` and returns a `CID` instance if it was\n     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n     * it will return value back. If `value` is not instance of this CID\n     * class, but is compatible CID it will return new instance of this\n     * `CID` class. Otherwise returns null.\n     *\n     * This allows two different incompatible versions of CID library to\n     * co-exist and interop as long as binary interface is compatible.\n     */\n    static asCID(input) {\n        if (input == null) {\n            return null;\n        }\n        const value = input;\n        if (value instanceof CID) {\n            // If value is instance of CID then we're all set.\n            return value;\n        }\n        else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n            // If value isn't instance of this CID class but `this.asCID === this` or\n            // `value['/'] === value.bytes` is true it is CID instance coming from a\n            // different implementation (diff version or duplicate). In that case we\n            // rebase it to this `CID` implementation so caller is guaranteed to get\n            // instance with expected API.\n            const { version, code, multihash, bytes } = value;\n            return new CID(version, code, multihash, bytes ?? encodeCID(version, code, multihash.bytes));\n        }\n        else if (value[cidSymbol] === true) {\n            // If value is a CID from older implementation that used to be tagged via\n            // symbol we still rebase it to the this `CID` implementation by\n            // delegating that to a constructor.\n            const { version, multihash, code } = value;\n            const digest = Digest.decode(multihash);\n            return CID.create(version, code, digest);\n        }\n        else {\n            // Otherwise value is not a CID (or an incompatible version of it) in\n            // which case we return `null`.\n            return null;\n        }\n    }\n    /**\n     * @param version - Version of the CID\n     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n     * @param digest - (Multi)hash of the of the content.\n     */\n    static create(version, code, digest) {\n        if (typeof code !== 'number') {\n            throw new Error('String codecs are no longer supported');\n        }\n        if (!(digest.bytes instanceof Uint8Array)) {\n            throw new Error('Invalid digest');\n        }\n        switch (version) {\n            case 0: {\n                if (code !== DAG_PB_CODE) {\n                    throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);\n                }\n                else {\n                    return new CID(version, code, digest, digest.bytes);\n                }\n            }\n            case 1: {\n                const bytes = encodeCID(version, code, digest.bytes);\n                return new CID(version, code, digest, bytes);\n            }\n            default: {\n                throw new Error('Invalid version');\n            }\n        }\n    }\n    /**\n     * Simplified version of `create` for CIDv0.\n     */\n    static createV0(digest) {\n        return CID.create(0, DAG_PB_CODE, digest);\n    }\n    /**\n     * Simplified version of `create` for CIDv1.\n     *\n     * @param code - Content encoding format code.\n     * @param digest - Multihash of the content.\n     */\n    static createV1(code, digest) {\n        return CID.create(1, code, digest);\n    }\n    /**\n     * Decoded a CID from its binary representation. The byte array must contain\n     * only the CID with no additional bytes.\n     *\n     * An error will be thrown if the bytes provided do not contain a valid\n     * binary representation of a CID.\n     */\n    static decode(bytes) {\n        const [cid, remainder] = CID.decodeFirst(bytes);\n        if (remainder.length !== 0) {\n            throw new Error('Incorrect length');\n        }\n        return cid;\n    }\n    /**\n     * Decoded a CID from its binary representation at the beginning of a byte\n     * array.\n     *\n     * Returns an array with the first element containing the CID and the second\n     * element containing the remainder of the original byte array. The remainder\n     * will be a zero-length byte array if the provided bytes only contained a\n     * binary CID representation.\n     */\n    static decodeFirst(bytes) {\n        const specs = CID.inspectBytes(bytes);\n        const prefixSize = specs.size - specs.multihashSize;\n        const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));\n        if (multihashBytes.byteLength !== specs.multihashSize) {\n            throw new Error('Incorrect length');\n        }\n        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n        const digest = new Digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n        const cid = specs.version === 0\n            ? CID.createV0(digest)\n            : CID.createV1(specs.codec, digest);\n        return [cid, bytes.subarray(specs.size)];\n    }\n    /**\n     * Inspect the initial bytes of a CID to determine its properties.\n     *\n     * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n     * bytes but for larger multicodec code values and larger multihash digest\n     * lengths these varints can be quite large. It is recommended that at least\n     * 10 bytes be made available in the `initialBytes` argument for a complete\n     * inspection.\n     */\n    static inspectBytes(initialBytes) {\n        let offset = 0;\n        const next = () => {\n            const [i, length] = varint.decode(initialBytes.subarray(offset));\n            offset += length;\n            return i;\n        };\n        let version = next();\n        let codec = DAG_PB_CODE;\n        if (version === 18) {\n            // CIDv0\n            version = 0;\n            offset = 0;\n        }\n        else {\n            codec = next();\n        }\n        if (version !== 0 && version !== 1) {\n            throw new RangeError(`Invalid CID version ${version}`);\n        }\n        const prefixSize = offset;\n        const multihashCode = next(); // multihash code\n        const digestSize = next(); // multihash length\n        const size = offset + digestSize;\n        const multihashSize = size - prefixSize;\n        return { version, codec, multihashCode, digestSize, multihashSize, size };\n    }\n    /**\n     * Takes cid in a string representation and creates an instance. If `base`\n     * decoder is not provided will use a default from the configuration. It will\n     * throw an error if encoding of the CID is not compatible with supplied (or\n     * a default decoder).\n     */\n    static parse(source, base) {\n        const [prefix, bytes] = parseCIDtoBytes(source, base);\n        const cid = CID.decode(bytes);\n        if (cid.version === 0 && source[0] !== 'Q') {\n            throw Error('Version 0 CID string must not include multibase prefix');\n        }\n        // Cache string representation to avoid computing it on `this.toString()`\n        baseCache(cid).set(prefix, source);\n        return cid;\n    }\n}\nfunction parseCIDtoBytes(source, base) {\n    switch (source[0]) {\n        // CIDv0 is parsed differently\n        case 'Q': {\n            const decoder = base ?? base58btc;\n            return [\n                base58btc.prefix,\n                decoder.decode(`${base58btc.prefix}${source}`)\n            ];\n        }\n        case base58btc.prefix: {\n            const decoder = base ?? base58btc;\n            return [base58btc.prefix, decoder.decode(source)];\n        }\n        case base32.prefix: {\n            const decoder = base ?? base32;\n            return [base32.prefix, decoder.decode(source)];\n        }\n        default: {\n            if (base == null) {\n                throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');\n            }\n            return [source[0], base.decode(source)];\n        }\n    }\n}\nfunction toStringV0(bytes, cache, base) {\n    const { prefix } = base;\n    if (prefix !== base58btc.prefix) {\n        throw Error(`Cannot string encode V0 in ${base.name} encoding`);\n    }\n    const cid = cache.get(prefix);\n    if (cid == null) {\n        const cid = base.encode(bytes).slice(1);\n        cache.set(prefix, cid);\n        return cid;\n    }\n    else {\n        return cid;\n    }\n}\nfunction toStringV1(bytes, cache, base) {\n    const { prefix } = base;\n    const cid = cache.get(prefix);\n    if (cid == null) {\n        const cid = base.encode(bytes);\n        cache.set(prefix, cid);\n        return cid;\n    }\n    else {\n        return cid;\n    }\n}\nconst DAG_PB_CODE = 0x70;\nconst SHA_256_CODE = 0x12;\nfunction encodeCID(version, code, multihash) {\n    const codeOffset = varint.encodingLength(version);\n    const hashOffset = codeOffset + varint.encodingLength(code);\n    const bytes = new Uint8Array(hashOffset + multihash.byteLength);\n    varint.encodeTo(version, bytes, 0);\n    varint.encodeTo(code, bytes, codeOffset);\n    bytes.set(multihash, hashOffset);\n    return bytes;\n}\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID');\n//# sourceMappingURL=cid.js.map","export {};\n//# sourceMappingURL=interface.js.map","const textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\nexport const name = 'json';\nexport const code = 0x0200;\nexport function encode(node) {\n    return textEncoder.encode(JSON.stringify(node));\n}\nexport function decode(data) {\n    return JSON.parse(textDecoder.decode(data));\n}\n//# sourceMappingURL=json.js.map","import { coerce } from '../bytes.js';\nexport const name = 'raw';\nexport const code = 0x55;\nexport function encode(node) {\n    return coerce(node);\n}\nexport function decode(data) {\n    return coerce(data);\n}\n//# sourceMappingURL=raw.js.map","import { coerce, equals as equalBytes } from '../bytes.js';\nimport * as varint from '../varint.js';\n/**\n * Creates a multihash digest.\n */\nexport function create(code, digest) {\n    const size = digest.byteLength;\n    const sizeOffset = varint.encodingLength(code);\n    const digestOffset = sizeOffset + varint.encodingLength(size);\n    const bytes = new Uint8Array(digestOffset + size);\n    varint.encodeTo(code, bytes, 0);\n    varint.encodeTo(size, bytes, sizeOffset);\n    bytes.set(digest, digestOffset);\n    return new Digest(code, size, digest, bytes);\n}\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nexport function decode(multihash) {\n    const bytes = coerce(multihash);\n    const [code, sizeOffset] = varint.decode(bytes);\n    const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset));\n    const digest = bytes.subarray(sizeOffset + digestOffset);\n    if (digest.byteLength !== size) {\n        throw new Error('Incorrect length');\n    }\n    return new Digest(code, size, digest, bytes);\n}\nexport function equals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    else {\n        const data = b;\n        return (a.code === data.code &&\n            a.size === data.size &&\n            data.bytes instanceof Uint8Array &&\n            equalBytes(a.bytes, data.bytes));\n    }\n}\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nexport class Digest {\n    code;\n    size;\n    digest;\n    bytes;\n    /**\n     * Creates a multihash digest.\n     */\n    constructor(code, size, digest, bytes) {\n        this.code = code;\n        this.size = size;\n        this.digest = digest;\n        this.bytes = bytes;\n    }\n}\n//# sourceMappingURL=digest.js.map","import * as Digest from './digest.js';\nexport function from({ name, code, encode }) {\n    return new Hasher(name, code, encode);\n}\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nexport class Hasher {\n    name;\n    code;\n    encode;\n    constructor(name, code, encode) {\n        this.name = name;\n        this.code = code;\n        this.encode = encode;\n    }\n    digest(input) {\n        if (input instanceof Uint8Array) {\n            const result = this.encode(input);\n            return result instanceof Uint8Array\n                ? Digest.create(this.code, result)\n                /* c8 ignore next 1 */\n                : result.then(digest => Digest.create(this.code, digest));\n        }\n        else {\n            throw Error('Unknown type, must be binary type');\n            /* c8 ignore next 1 */\n        }\n    }\n}\n//# sourceMappingURL=hasher.js.map","import { coerce } from '../bytes.js';\nimport * as Digest from './digest.js';\nconst code = 0x0;\nconst name = 'identity';\nconst encode = coerce;\nfunction digest(input) {\n    return Digest.create(code, encode(input));\n}\nexport const identity = { code, name, encode, digest };\n//# sourceMappingURL=identity.js.map","// # Multihash\nexport {};\n//# sourceMappingURL=interface.js.map","/* global crypto */\nimport { from } from './hasher.js';\nfunction sha(name) {\n    return async (data) => new Uint8Array(await crypto.subtle.digest(name, data));\n}\nexport const sha256 = from({\n    name: 'sha2-256',\n    code: 0x12,\n    encode: sha('SHA-256')\n});\nexport const sha512 = from({\n    name: 'sha2-512',\n    code: 0x13,\n    encode: sha('SHA-512')\n});\n//# sourceMappingURL=sha2-browser.js.map","/**\n * @packageDocumentation\n *\n * This library defines common interfaces and low level building blocks for various interrelated multiformat technologies (multicodec, multihash, multibase, and CID). They can be used to implement custom base encoders / decoders / codecs, codec encoders /decoders and multihash hashers that comply to the interface that layers above assume.\n *\n * This library provides implementations for most basics and many others can be found in linked repositories.\n *\n * ```TypeScript\n * import { CID } from 'multiformats/cid'\n * import * as json from 'multiformats/codecs/json'\n * import { sha256 } from 'multiformats/hashes/sha2'\n *\n * const bytes = json.encode({ hello: 'world' })\n *\n * const hash = await sha256.digest(bytes)\n * const cid = CID.create(1, json.code, hash)\n * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)\n * ```\n *\n * ## Creating Blocks\n *\n * ```TypeScript\n * import * as Block from 'multiformats/block'\n * import * as codec from '@ipld/dag-cbor'\n * import { sha256 as hasher } from 'multiformats/hashes/sha2'\n *\n * const value = { hello: 'world' }\n *\n * // encode a block\n * let block = await Block.encode({ value, codec, hasher })\n *\n * block.value // { hello: 'world' }\n * block.bytes // Uint8Array\n * block.cid   // CID() w/ sha2-256 hash address and dag-cbor codec\n *\n * // you can also decode blocks from their binary state\n * block = await Block.decode({ bytes: block.bytes, codec, hasher })\n *\n * // if you have the cid you can also verify the hash on decode\n * block = await Block.create({ bytes: block.bytes, cid: block.cid, codec, hasher })\n * ```\n *\n * ## Multibase Encoders / Decoders / Codecs\n *\n * CIDs can be serialized to string representation using multibase encoders that implement [`MultibaseEncoder`](https://github.com/multiformats/js-multiformats/blob/master/src/bases/interface.ts) interface. This library provides quite a few implementations that can be imported:\n *\n * ```TypeScript\n * import { base64 } from \"multiformats/bases/base64\"\n * cid.toString(base64.encoder)\n * //> 'mAYAEEiCTojlxqRTl6svwqNJRVM2jCcPBxy+7mRTUfGDzy2gViA'\n * ```\n *\n * Parsing CID string serialized CIDs requires multibase decoder that implements [`MultibaseDecoder`](https://github.com/multiformats/js-multiformats/blob/master/src/bases/interface.ts) interface. This library provides a decoder for every encoder it provides:\n *\n * ```TypeScript\n * CID.parse('mAYAEEiCTojlxqRTl6svwqNJRVM2jCcPBxy+7mRTUfGDzy2gViA', base64.decoder)\n * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)\n * ```\n *\n * Dual of multibase encoder & decoder is defined as multibase codec and it exposes\n * them as `encoder` and `decoder` properties. For added convenience codecs also\n * implement `MultibaseEncoder` and `MultibaseDecoder` interfaces so they could be\n * used as either or both:\n *\n * ```TypeScript\n * cid.toString(base64)\n * CID.parse(cid.toString(base64), base64)\n * ```\n *\n * **Note:** CID implementation comes bundled with `base32` and `base58btc`\n * multibase codecs so that CIDs can be base serialized to (version specific)\n * default base encoding and parsed without having to supply base encoders/decoders:\n *\n * ```TypeScript\n * const v1 = CID.parse('bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea')\n * v1.toString()\n * //> 'bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea'\n *\n * const v0 = CID.parse('QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n')\n * v0.toString()\n * //> 'QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n'\n * v0.toV1().toString()\n * //> 'bafybeihdwdcefgh4dqkjv67uzcmw7ojee6xedzdetojuzjevtenxquvyku'\n * ```\n *\n * ## Multicodec Encoders / Decoders / Codecs\n *\n * This library defines [`BlockEncoder`, `BlockDecoder` and `BlockCodec` interfaces](https://github.com/multiformats/js-multiformats/blob/master/src/codecs/interface.ts).\n * Codec implementations should conform to the `BlockCodec` interface which implements both `BlockEncoder` and `BlockDecoder`.\n * Here is an example implementation of JSON `BlockCodec`.\n *\n * ```TypeScript\n * export const { name, code, encode, decode } = {\n *   name: 'json',\n *   code: 0x0200,\n *   encode: json => new TextEncoder().encode(JSON.stringify(json)),\n *   decode: bytes => JSON.parse(new TextDecoder().decode(bytes))\n * }\n * ```\n *\n * ## Multihash Hashers\n *\n * This library defines [`MultihashHasher` and `MultihashDigest` interfaces](https://github.com/multiformats/js-multiformats/blob/master/src/hashes/interface.ts) and convinient function for implementing them:\n *\n * ```TypeScript\n * import * as hasher from 'multiformats/hashes/hasher'\n *\n * const sha256 = hasher.from({\n *   // As per multiformats table\n *   // https://github.com/multiformats/multicodec/blob/master/table.csv#L9\n *   name: 'sha2-256',\n *   code: 0x12,\n *\n *   encode: (input) => new Uint8Array(crypto.createHash('sha256').update(input).digest())\n * })\n *\n * const hash = await sha256.digest(json.encode({ hello: 'world' }))\n * CID.create(1, json.code, hash)\n *\n * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)\n * ```\n *\n * ## Traversal\n *\n * This library contains higher-order functions for traversing graphs of data easily.\n *\n * `walk()` walks through the links in each block of a DAG calling a user-supplied loader function for each one, in depth-first order with no duplicate block visits. The loader should return a `Block` object and can be used to inspect and collect block ordering for a full DAG walk. The loader should `throw` on error, and return `null` if a block should be skipped by `walk()`.\n *\n * ```TypeScript\n * import { walk } from 'multiformats/traversal'\n * import * as Block from 'multiformats/block'\n * import * as codec from 'multiformats/codecs/json'\n * import { sha256 as hasher } from 'multiformats/hashes/sha2'\n *\n * // build a DAG (a single block for this simple example)\n * const value = { hello: 'world' }\n * const block = await Block.encode({ value, codec, hasher })\n * const { cid } = block\n * console.log(cid)\n * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)\n *\n * // create a loader function that also collects CIDs of blocks in\n * // their traversal order\n * const load = (cid, blocks) => async (cid) => {\n *   // fetch a block using its cid\n *   // e.g.: const block = await fetchBlockByCID(cid)\n *   blocks.push(cid)\n *   return block\n * }\n *\n * // collect blocks in this DAG starting from the root `cid`\n * const blocks = []\n * await walk({ cid, load: load(cid, blocks) })\n *\n * console.log(blocks)\n * //> [CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)]\n * ```\n *\n * ## Legacy interface\n *\n * [`blockcodec-to-ipld-format`](https://github.com/ipld/js-blockcodec-to-ipld-format) converts a multiformats [`BlockCodec`](https://github.com/multiformats/js-multiformats/blob/master/src/codecs/interface.ts#L21) into an\n * [`interface-ipld-format`](https://github.com/ipld/interface-ipld-format) for use with the [`ipld`](https://github.com/ipld/ipld) package. This can help bridge IPLD codecs implemented using the structure and interfaces defined here to existing code that assumes, or requires `interface-ipld-format`. This bridge also includes the relevant TypeScript definitions.\n *\n * ## Implementations\n *\n * By default, no base encodings (other than base32 & base58btc), hash functions,\n * or codec implementations are exposed by `multiformats`, you need to\n * import the ones you need yourself.\n *\n * ### Multibase codecs\n *\n * | bases                                                         | import                      | repo                                                                                              |\n * | ------------------------------------------------------------- | --------------------------- | ------------------------------------------------------------------------------------------------- |\n * | `base16`                                                      | `multiformats/bases/base16` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |\n * | `base32`, `base32pad`, `base32hex`, `base32hexpad`, `base32z` | `multiformats/bases/base32` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |\n * | `base64`, `base64pad`, `base64url`, `base64urlpad`            | `multiformats/bases/base64` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |\n * | `base58btc`, `base58flick4`                                   | `multiformats/bases/base58` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |\n *\n * Other (less useful) bases implemented in [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) include: `base2`, `base8`, `base10`, `base36` and `base256emoji`.\n *\n * ### Multihash hashers\n *\n * | hashes                                                                                                                          | import                         | repo                                                                                                               |\n * | ------------------------------------------------------------------------------------------------------------------------------- | ------------------------------ | ------------------------------------------------------------------------------------------------------------------ |\n * | `sha2-256`, `sha2-512`                                                                                                          | `multiformats/hashes/sha2`     | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/hashes)             |\n * | `sha3-224`, `sha3-256`, `sha3-384`,`sha3-512`, `shake-128`, `shake-256`, `keccak-224`, `keccak-256`, `keccak-384`, `keccak-512` | `@multiformats/sha3`           | [multiformats/js-sha3](https://github.com/multiformats/js-sha3)                                                    |\n * | `identity`                                                                                                                      | `multiformats/hashes/identity` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/hashes/identity.js) |\n * | `murmur3-128`, `murmur3-32`                                                                                                     | `@multiformats/murmur3`        | [multiformats/js-murmur3](https://github.com/multiformats/js-murmur3)                                              |\n * | `blake2b-*`, `blake2s-*`                                                                                                        | `@multiformats/blake2`         | [multiformats/js-blake2](https://github.com/multiformats/js-blake2)                                                |\n *\n * ### IPLD codecs (multicodec)\n *\n * | codec      | import                     | repo                                                                                                   |\n * | ---------- | -------------------------- | ------------------------------------------------------------------------------------------------------ |\n * | `raw`      | `multiformats/codecs/raw`  | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/codecs) |\n * | `json`     | `multiformats/codecs/json` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/codecs) |\n * | `dag-cbor` | `@ipld/dag-cbor`           | [ipld/js-dag-cbor](https://github.com/ipld/js-dag-cbor)                                                |\n * | `dag-json` | `@ipld/dag-json`           | [ipld/js-dag-json](https://github.com/ipld/js-dag-json)                                                |\n * | `dag-pb`   | `@ipld/dag-pb`             | [ipld/js-dag-pb](https://github.com/ipld/js-dag-pb)                                                    |\n * | `dag-jose` | `dag-jose`                 | [ceramicnetwork/js-dag-jose](https://github.com/ceramicnetwork/js-dag-jose)                            |\n */\nimport * as bytes from './bytes.js';\nimport { CID } from './cid.js';\nimport * as digest from './hashes/digest.js';\nimport * as hasher from './hashes/hasher.js';\nimport * as varint from './varint.js';\n// This way TS will also expose all the types from module\nexport * from './interface.js';\nexport { CID, hasher, digest, varint, bytes };\n//# sourceMappingURL=index.js.map","export * from './bases/interface.js';\nexport * from './hashes/interface.js';\nexport * from './codecs/interface.js';\nexport * from './link/interface.js';\nexport * from './block/interface.js';\n//# sourceMappingURL=interface.js.map","/* eslint-disable @typescript-eslint/no-unnecessary-type-constraint */\n/* eslint-disable no-use-before-define */\nexport {};\n//# sourceMappingURL=interface.js.map","import varint from './vendor/varint.js';\nexport function decode(data, offset = 0) {\n    const code = varint.decode(data, offset);\n    return [code, varint.decode.bytes];\n}\nexport function encodeTo(int, target, offset = 0) {\n    varint.encode(int, target, offset);\n    return target;\n}\nexport function encodingLength(int) {\n    return varint.encodingLength(int);\n}\n//# sourceMappingURL=varint.js.map","/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base(ALPHABET, name) {\n    if (ALPHABET.length >= 255) {\n        throw new TypeError('Alphabet too long');\n    }\n    var BASE_MAP = new Uint8Array(256);\n    for (var j = 0; j < BASE_MAP.length; j++) {\n        BASE_MAP[j] = 255;\n    }\n    for (var i = 0; i < ALPHABET.length; i++) {\n        var x = ALPHABET.charAt(i);\n        var xc = x.charCodeAt(0);\n        if (BASE_MAP[xc] !== 255) {\n            throw new TypeError(x + ' is ambiguous');\n        }\n        BASE_MAP[xc] = i;\n    }\n    var BASE = ALPHABET.length;\n    var LEADER = ALPHABET.charAt(0);\n    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n    /**\n     * @param {any[] | Iterable<number>} source\n     */\n    function encode(source) {\n        // @ts-ignore\n        if (source instanceof Uint8Array)\n            ;\n        else if (ArrayBuffer.isView(source)) {\n            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n        }\n        else if (Array.isArray(source)) {\n            source = Uint8Array.from(source);\n        }\n        if (!(source instanceof Uint8Array)) {\n            throw new TypeError('Expected Uint8Array');\n        }\n        if (source.length === 0) {\n            return '';\n        }\n        // Skip & count leading zeroes.\n        var zeroes = 0;\n        var length = 0;\n        var pbegin = 0;\n        var pend = source.length;\n        while (pbegin !== pend && source[pbegin] === 0) {\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n        var b58 = new Uint8Array(size);\n        // Process the bytes.\n        while (pbegin !== pend) {\n            var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            var i = 0;\n            for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n                carry += (256 * b58[it1]) >>> 0;\n                b58[it1] = (carry % BASE) >>> 0;\n                carry = (carry / BASE) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('Non-zero carry');\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        var it2 = size - length;\n        while (it2 !== size && b58[it2] === 0) {\n            it2++;\n        }\n        // Translate the result into a string.\n        var str = LEADER.repeat(zeroes);\n        for (; it2 < size; ++it2) {\n            str += ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    /**\n     * @param {string | string[]} source\n     */\n    function decodeUnsafe(source) {\n        if (typeof source !== 'string') {\n            throw new TypeError('Expected String');\n        }\n        if (source.length === 0) {\n            return new Uint8Array();\n        }\n        var psz = 0;\n        // Skip leading spaces.\n        if (source[psz] === ' ') {\n            return;\n        }\n        // Skip and count leading '1's.\n        var zeroes = 0;\n        var length = 0;\n        while (source[psz] === LEADER) {\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n        var b256 = new Uint8Array(size);\n        // Process the characters.\n        while (source[psz]) {\n            // Decode character\n            var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n            if (carry === 255) {\n                return;\n            }\n            var i = 0;\n            for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n                carry += (BASE * b256[it3]) >>> 0;\n                b256[it3] = (carry % 256) >>> 0;\n                carry = (carry / 256) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('Non-zero carry');\n            }\n            length = i;\n            psz++;\n        }\n        // Skip trailing spaces.\n        if (source[psz] === ' ') {\n            return;\n        }\n        // Skip leading zeroes in b256.\n        var it4 = size - length;\n        while (it4 !== size && b256[it4] === 0) {\n            it4++;\n        }\n        var vch = new Uint8Array(zeroes + (size - it4));\n        var j = zeroes;\n        while (it4 !== size) {\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n    /**\n     * @param {string | string[]} string\n     */\n    function decode(string) {\n        var buffer = decodeUnsafe(string);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error(`Non-${name} character`);\n    }\n    return {\n        encode: encode,\n        decodeUnsafe: decodeUnsafe,\n        decode: decode\n    };\n}\nvar src = base;\nvar _brrp__multiformats_scope_baseX = src;\nexport default _brrp__multiformats_scope_baseX;\n//# sourceMappingURL=base-x.js.map","/* eslint-disable */\nvar encode_1 = encode;\nvar MSB = 0x80, REST = 0x7F, MSBALL = ~REST, INT = Math.pow(2, 31);\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n    out = out || [];\n    offset = offset || 0;\n    var oldOffset = offset;\n    while (num >= INT) {\n        out[offset++] = (num & 0xFF) | MSB;\n        num /= 128;\n    }\n    while (num & MSBALL) {\n        out[offset++] = (num & 0xFF) | MSB;\n        num >>>= 7;\n    }\n    out[offset] = num | 0;\n    // @ts-ignore\n    encode.bytes = offset - oldOffset + 1;\n    return out;\n}\nvar decode = read;\nvar MSB$1 = 0x80, REST$1 = 0x7F;\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n    do {\n        if (counter >= l) {\n            // @ts-ignore\n            read.bytes = 0;\n            throw new RangeError('Could not decode varint');\n        }\n        b = buf[counter++];\n        res += shift < 28\n            ? (b & REST$1) << shift\n            : (b & REST$1) * Math.pow(2, shift);\n        shift += 7;\n    } while (b >= MSB$1);\n    // @ts-ignore\n    read.bytes = counter - offset;\n    return res;\n}\nvar N1 = Math.pow(2, 7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\nvar length = function (/** @type {number} */ value) {\n    return (value < N1 ? 1\n        : value < N2 ? 2\n            : value < N3 ? 3\n                : value < N4 ? 4\n                    : value < N5 ? 5\n                        : value < N6 ? 6\n                            : value < N7 ? 7\n                                : value < N8 ? 8\n                                    : value < N9 ? 9\n                                        : 10);\n};\nvar varint = {\n    encode: encode_1,\n    decode: decode,\n    encodingLength: length\n};\nvar _brrp_varint = varint;\nexport default _brrp_varint;\n//# sourceMappingURL=varint.js.map","/**\n * @module AccessControllers\n * @description\n * Provides a system for managing access controllers. Supported access\n * controllers can be added and removed from the access controller list, and\n * can load the associated module if they are supported.\n */\nimport IPFSAccessController from './ipfs.js'\nimport OrbitDBAccessController from './orbitdb.js'\n\nconst accessControllers = {}\n\n/**\n * Gets an access controller module specified by type.\n * @param {string} type A valid access controller type.\n * @return {AccessController} The access controller module.\n * @private\n */\nconst getAccessController = (type) => {\n  if (!accessControllers[type]) {\n    throw new Error(`AccessController type '${type}' is not supported`)\n  }\n  return accessControllers[type]\n}\n\n/**\n * Adds an access controller module to the list of supported access controller.\n * @param {AccessController} accessController A compatible access controller\n * module.\n * @throws AccessController does not contain required field \\'type\\'.\n * @throws AccessController '${accessController.type}' already added.\n * @static\n */\nconst useAccessController = (accessController) => {\n  if (!accessController.type) {\n    throw new Error('AccessController does not contain required field \\'type\\'.')\n  }\n\n  accessControllers[accessController.type] = accessController\n}\n\nuseAccessController(IPFSAccessController)\nuseAccessController(OrbitDBAccessController)\n\nexport {\n  getAccessController,\n  useAccessController,\n  IPFSAccessController,\n  OrbitDBAccessController\n}\n","/**\n * @namespace AccessControllers-IPFS\n * @memberof module:AccessControllers\n */\nimport { IPFSBlockStorage, LRUStorage, ComposedStorage } from '../storage/index.js'\nimport * as Block from 'multiformats/block'\nimport * as dagCbor from '@ipld/dag-cbor'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { base58btc } from 'multiformats/bases/base58'\nimport pathJoin from '../utils/path-join.js'\n\nconst codec = dagCbor\nconst hasher = sha256\nconst hashStringEncoding = base58btc\n\nconst AccessControlList = async ({ storage, type, params }) => {\n  const manifest = {\n    type,\n    ...params\n  }\n  const { cid, bytes } = await Block.encode({ value: manifest, codec, hasher })\n  const hash = cid.toString(hashStringEncoding)\n  await storage.put(hash, bytes)\n  return hash\n}\n\nconst type = 'ipfs'\n\n/**\n * Creates an instance of IPFSAccessController.\n * @callback IPFSAccessController\n * @param {Object} params Various parameters for configuring the access\n * controller.\n * @param {module:OrbitDB} params.orbitdb An OrbitDB instance.\n * @param {module:Identities} params.identities An Identities instance.\n * @param {string} [params.address] The address of the database.\n * @function\n * @instance\n * @async\n * @memberof module:AccessControllers.AccessControllers-IPFS\n * @private\n */\n\n/**\n * Defines an IPFS access controller.\n * @param {Object} options Various options for configuring the\n * IPFSAccessController.\n * @param {Array} [params.write] An array of identity ids who can write to the\n * database.\n * @param {module:Storage} [params.storage] An instance of a compatible storage.\n * @return {module:AccessControllers.AccessControllers-IPFS} An\n * IPFSAccessController function.\n * @memberof module:AccessControllers\n */\nconst IPFSAccessController = ({ write, storage } = {}) => async ({ orbitdb, identities, address }) => {\n  storage = storage || await ComposedStorage(\n    await LRUStorage({ size: 1000 }),\n    await IPFSBlockStorage({ ipfs: orbitdb.ipfs, pin: true })\n  )\n  write = write || [orbitdb.identity.id]\n\n  if (address) {\n    const manifestBytes = await storage.get(address.replaceAll('/ipfs/', ''))\n    const { value } = await Block.decode({ bytes: manifestBytes, codec, hasher })\n    write = value.write\n  } else {\n    address = await AccessControlList({ storage, type, params: { write } })\n    address = pathJoin('/', type, address)\n  }\n\n  /**\n   * Verifies the write permission of an entry.\n   * @param {module:Log~Entry} entry An entry to verify.\n   * @return {boolean} True if the entry's identity has write permission,\n   * false otherwise.\n   * @memberof module:AccessControllers.AccessControllers-IPFS\n   */\n  const canAppend = async (entry) => {\n    const writerIdentity = await identities.getIdentity(entry.identity)\n    if (!writerIdentity) {\n      return false\n    }\n    const { id } = writerIdentity\n    // Allow if the write access list contain the writer's id or is '*'\n    if (write.includes(id) || write.includes('*')) {\n      // Check that the identity is valid\n      return await identities.verifyIdentity(writerIdentity)\n    }\n    return false\n  }\n\n  return {\n    type,\n    address,\n    write,\n    canAppend\n  }\n}\n\nIPFSAccessController.type = type\n\nexport default IPFSAccessController\n","/**\n * @namespace AccessControllers-OrbitDB\n * @memberof module:AccessControllers\n */\nimport IPFSAccessController from './ipfs.js'\nimport { createId } from '../utils/index.js'\n\nconst type = 'orbitdb'\n\n/**\n * Creates an instance of OrbitDBAccessController.\n * @callback OrbitDBAccessController\n * @param {Object} params Various parameters for configuring the access\n * controller.\n * @param {module:OrbitDB} params.orbitdb An OrbitDB instance.\n * @param {module:Identities} params.identities An Identities instance.\n * @param {string} [params.address] The address of the database.\n * @function\n * @instance\n * @async\n * @memberof module:AccessControllers.AccessControllers-OrbitDB\n * @private\n */\n\n/**\n * Defines an OrbitDB access controller.\n * @param {Object} options Various options for configuring the\n * IPFSAccessController.\n * @param {Array} [params.write] An array of ids of identities who can write to the\n * database.\n * @return {module:AccessControllers.AccessControllers-OrbitDB} An\n * IPFSAccessController function.\n * @memberof module:AccessControllers\n */\nconst OrbitDBAccessController = ({ write } = {}) => async ({ orbitdb, identities, address, name }) => {\n  address = address || name || await createId(64)\n  write = write || [orbitdb.identity.id]\n\n  // Open the database used for access information\n  const db = await orbitdb.open(address, { type: 'keyvalue', AccessController: IPFSAccessController({ write }) })\n  address = db.address\n\n  /**\n   * Verifies the write permission of an entry.\n   * @param {module:Log~Entry} entry An entry to verify.\n   * @return {boolean} True if the entry's identity has write permission,\n   * false otherwise.\n   * @memberof module:AccessControllers.AccessControllers-OrbitDB\n   * @instance\n   */\n  const canAppend = async (entry) => {\n    const writerIdentity = await identities.getIdentity(entry.identity)\n    if (!writerIdentity) {\n      return false\n    }\n\n    const { id } = writerIdentity\n    // If the ACL contains the writer's public key or it contains '*'\n    const hasWriteAccess = await hasCapability('write', id) || await hasCapability('admin', id)\n    if (hasWriteAccess) {\n      return await identities.verifyIdentity(writerIdentity)\n    }\n\n    return false\n  }\n\n  /**\n   * Gets the access capabilities of the OrbitDB access controller.\n   *\n   * The returned capabilities will be a mixture of admin and write access\n   * addresses.\n   * @return {Array} A list of ids of identities with admin and write access.\n   * @memberof module:AccessControllers.AccessControllers-OrbitDB\n   * @instance\n   */\n  const capabilities = async () => {\n    const _capabilities = []\n    for await (const entry of db.iterator()) {\n      _capabilities[entry.key] = entry.value\n    }\n\n    const toSet = (e) => {\n      const key = e[0]\n      _capabilities[key] = new Set([...(_capabilities[key] || []), ...e[1]])\n    }\n\n    // Merge with the access controller of the database\n    // and make sure all values are Sets\n    Object.entries({\n      ..._capabilities,\n      // Add the root access controller's 'write' access list\n      // as admins on this controller\n      ...{ admin: new Set([...(_capabilities.admin || []), ...db.access.write]) }\n    }).forEach(toSet)\n\n    return _capabilities\n  }\n\n  /**\n   * Gets a list of identities with the specified capability.\n   * @param {string} capability A capability (e.g. write).\n   * @return {Array} One or more addresses with the spcified capability.\n   * @memberof module:AccessControllers.AccessControllers-OrbitDB\n   * @instance\n   */\n  const get = async (capability) => {\n    const _capabilities = await capabilities()\n    return _capabilities[capability] || new Set([])\n  }\n\n  /**\n   * Close the underlying access control database.\n   * @memberof module:AccessControllers.AccessControllers-OrbitDB\n   * @instance\n   */\n  const close = async () => {\n    await db.close()\n  }\n\n  /**\n   * Drop the underlying access control database.\n   * @memberof module:AccessControllers.AccessControllers-OrbitDB\n   * @instance\n   */\n  const drop = async () => {\n    await db.drop()\n  }\n\n  /**\n   * Checks whether an identity has a capability.\n   * @param {string} capability A capability (e.g. write).\n   * @param {string} key An id of an identity.\n   * @return {boolean} True if the identity has the capability, false\n   * otherwise.\n   * @memberof module:AccessControllers.AccessControllers-OrbitDB\n   * @instance\n   */\n  const hasCapability = async (capability, key) => {\n    // Write keys and admins keys are allowed\n    const access = new Set(await get(capability))\n    return access.has(key) || access.has('*')\n  }\n\n  /**\n   * Grants a capability to an identity, storing it to the access control\n   * database.\n   * @param {string} capability A capability (e.g. write).\n   * @param {string} key An id of an identity.\n   * @memberof module:AccessControllers.AccessControllers-OrbitDB\n   * @instance\n   */\n  const grant = async (capability, key) => {\n    // Merge current keys with the new key\n    const capabilities = new Set([...(await db.get(capability) || []), ...[key]])\n    await db.put(capability, Array.from(capabilities.values()))\n  }\n\n  /**\n   * Revokes a capability from an identity, removing it from the access control\n   * database.\n   * @param {string} capability A capability (e.g. write).\n   * @param {string} key An id of an identity.\n   * @memberof module:AccessControllers.AccessControllers-OrbitDB\n   * @instance\n   */\n  const revoke = async (capability, key) => {\n    const capabilities = new Set(await db.get(capability) || [])\n    capabilities.delete(key)\n    if (capabilities.size > 0) {\n      await db.put(capability, Array.from(capabilities.values()))\n    } else {\n      await db.del(capability)\n    }\n  }\n\n  return {\n    type,\n    address,\n    write,\n    canAppend,\n    capabilities,\n    get,\n    grant,\n    revoke,\n    close,\n    drop,\n    events: db.events\n  }\n}\n\nOrbitDBAccessController.type = type\n\nexport default OrbitDBAccessController\n","/**\n * @module Address\n * @description OrbitDB database address verification.\n */\nimport { CID } from 'multiformats/cid'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { posixJoin } from './utils/path-join.js'\n\n/**\n * Validates an OrbitDB database address.\n * @function\n * @param {module:Address~OrbitDBAddress|string} address An OrbitDB database address.\n * @return {boolean} True if the address is a valid OrbitDB database address,\n * false otherwise.\n * @static\n */\nconst isValidAddress = (address) => {\n  address = address.toString()\n\n  if (!address.startsWith('/orbitdb') && !address.startsWith('\\\\orbitdb')) {\n    return false\n  }\n\n  address = address.replaceAll('/orbitdb/', '')\n  address = address.replaceAll('\\\\orbitdb\\\\', '')\n  address = address.replaceAll('/', '')\n  address = address.replaceAll('\\\\', '')\n\n  let cid\n  try {\n    cid = CID.parse(address, base58btc)\n  } catch (e) {\n    return false\n  }\n\n  return cid !== undefined\n}\n\n/**\n * Parses an OrbitDB database address.\n * @function\n * @param {module:Address~OrbitDBAddress|string} address A valid OrbitDB database address.\n * @return {module:Address~OrbitDBAddress} An instance of OrbitDBAddress.\n * @throws Not a valid OrbitDB address if no address if provided.\n * @throws Not a valid OrbitDB address if address is invalid.\n * @static\n */\nconst parseAddress = (address) => {\n  if (!address) {\n    throw new Error(`Not a valid OrbitDB address: ${address}`)\n  }\n\n  if (!isValidAddress(address)) {\n    throw new Error(`Not a valid OrbitDB address: ${address}`)\n  }\n\n  return OrbitDBAddress(address)\n}\n\n/**\n * @typedef {Object} OrbitDBAddress\n * @property {string} protocol Protocol prefix \"/orbitdb/\".\n * @property {string} hash The hash of the database manifest.\n * @property {string} address The full database address.\n */\nconst OrbitDBAddress = (address) => {\n  if (address && address.protocol === 'orbitdb' && address.hash) {\n    return address\n  }\n\n  const protocol = 'orbitdb'\n\n  const hash = address.replace('/orbitdb/', '').replace('\\\\orbitdb\\\\', '')\n\n  /**\n   * Returns address as a string.\n   * @typedef {Function} toString\n   * @returns {string} Address as a string.\n   */\n  const toString = () => {\n    return posixJoin('/', protocol, hash)\n  }\n\n  return {\n    protocol,\n    hash,\n    address,\n    toString\n  }\n}\n\nexport { OrbitDBAddress as default, isValidAddress, parseAddress }\n","/**\n * @module Database\n * @description\n * Database is the base class for OrbitDB data stores and handles all lower\n * level add operations and database sync-ing using IPFS.\n */\nimport { EventEmitter } from 'events'\nimport PQueue from 'p-queue'\nimport Sync from './sync.js'\nimport { Log, Entry } from './oplog/index.js'\nimport { ComposedStorage, LRUStorage, IPFSBlockStorage, LevelStorage } from './storage/index.js'\nimport pathJoin from './utils/path-join.js'\n\nconst defaultReferencesCount = 16\nconst defaultCacheSize = 1000\n\n/**\n * Creates an instance of Database.\n * @function\n * @param {Object} params One or more parameters for configuring Database.\n * @param {IPFS} params.ipfs An IPFS instance.\n * @param {Identity} [params.identity] An Identity instance.\n * @param {string} [params.address] The address of the database.\n * @param {string} [params.name] The name of the database.\n * @param {module:AccessControllers} [params.access] An AccessController\n * instance.\n * @param {string} [params.directory] A location for storing Database-related\n * data. Defaults to ./orbitdb/[params.address].\n * @param {*} [params.meta={}] The database's metadata.\n * @param {module:Storage} [params.headsStorage] A compatible storage\n * instance for storing log heads. Defaults to ComposedStorage.\n * @param {module:Storage} [params.entryStorage] A compatible storage instance\n * for storing log entries. Defaults to ComposedStorage.\n * @param {module:Storage} [params.indexStorage] A compatible storage\n * instance for storing an index of log entries. Defaults to ComposedStorage.\n * @param {number} [params.referencesCount=16]  The maximum distance between\n * references to other entries.\n * @param {boolean} [params.syncAutomatically=false] If true, sync databases\n * automatically. Otherwise, false.\n * @param {function} [params.onUpdate] A function callback. Fired when an\n * entry is added to the oplog.\n * @return {module:Databases~Database} An instance of Database.\n * @instance\n */\nconst Database = async ({ ipfs, identity, address, name, access, directory, meta, headsStorage, entryStorage, indexStorage, referencesCount, syncAutomatically, onUpdate }) => {\n  /**\n   * @namespace module:Databases~Database\n   * @description The instance returned by {@link module:Database~Database}.\n   */\n\n  /**\n   * Event fired when an update occurs.\n   * @event module:Databases~Database#update\n   * @param {module:Entry} entry An entry.\n   * @example\n   * database.events.on('update', (entry) => ...)\n   */\n\n  /**\n   * Event fired when a close occurs.\n   * @event module:Databases~Database#close\n   * @example\n   * database.events.on('close', () => ...)\n   */\n\n  /**\n   * Event fired when a drop occurs.\n   * @event module:Databases~Database#drop\n   * @example\n   * database.events.on('drop', () => ...)\n   */\n\n  /** Events inherited from Sync */\n\n  /**\n   * Event fired when when a peer has connected to the database.\n   * @event module:Databases~Database#join\n   * @param {PeerID} peerId PeerID of the peer who connected\n   * @param {Entry[]} heads An array of Log entries\n   * @example\n   * database.events.on('join', (peerID, heads) => ...)\n   */\n\n  /**\n   * Event fired when a peer has disconnected from the database.\n   * @event module:Databases~Database#leave\n   * @param {PeerID} peerId PeerID of the peer who disconnected\n   * @example\n   * database.events.on('leave', (peerID) => ...)\n   */\n\n  directory = pathJoin(directory || './orbitdb', `./${address}/`)\n  meta = meta || {}\n  referencesCount = Number(referencesCount) > -1 ? referencesCount : defaultReferencesCount\n\n  entryStorage = entryStorage || await ComposedStorage(\n    await LRUStorage({ size: defaultCacheSize }),\n    await IPFSBlockStorage({ ipfs, pin: true })\n  )\n\n  headsStorage = headsStorage || await ComposedStorage(\n    await LRUStorage({ size: defaultCacheSize }),\n    await LevelStorage({ path: pathJoin(directory, '/log/_heads/') })\n  )\n\n  indexStorage = indexStorage || await ComposedStorage(\n    await LRUStorage({ size: defaultCacheSize }),\n    await LevelStorage({ path: pathJoin(directory, '/log/_index/') })\n  )\n\n  const log = await Log(identity, { logId: address, access, entryStorage, headsStorage, indexStorage })\n\n  const events = new EventEmitter()\n\n  const queue = new PQueue({ concurrency: 1 })\n\n  /**\n   * Adds an operation to the oplog.\n   * @function addOperation\n   * @param {*} op Some operation to add to the oplog.\n   * @return {string} The hash of the operation.\n   * @memberof module:Databases~Database\n   * @instance\n   * @async\n   */\n  const addOperation = async (op) => {\n    const task = async () => {\n      const entry = await log.append(op, { referencesCount })\n      await sync.add(entry)\n      if (onUpdate) {\n        await onUpdate(log, entry)\n      }\n      events.emit('update', entry)\n      return entry.hash\n    }\n    const hash = await queue.add(task)\n    await queue.onIdle()\n    return hash\n  }\n\n  const applyOperation = async (bytes) => {\n    const task = async () => {\n      const entry = await Entry.decode(bytes)\n      if (entry) {\n        const updated = await log.joinEntry(entry)\n        if (updated) {\n          if (onUpdate) {\n            await onUpdate(log, entry)\n          }\n          events.emit('update', entry)\n        }\n      }\n    }\n    await queue.add(task)\n  }\n\n  /**\n   * Closes the database, stopping sync and closing the oplog.\n   * @memberof module:Databases~Database\n   * @instance\n   * @async\n   */\n  const close = async () => {\n    await sync.stop()\n    await queue.onIdle()\n    await log.close()\n    if (access && access.close) {\n      await access.close()\n    }\n    events.emit('close')\n  }\n\n  /**\n   * Drops the database, clearing the oplog.\n   * @memberof module:Databases~Database\n   * @instance\n   * @async\n   */\n  const drop = async () => {\n    await queue.onIdle()\n    await log.clear()\n    if (access && access.drop) {\n      await access.drop()\n    }\n    events.emit('drop')\n  }\n\n  const sync = await Sync({ ipfs, log, events, onSynced: applyOperation, start: syncAutomatically })\n\n  return {\n    /**\n     * The address of the database.\n     * @ype string\n     * @memberof module:Databases~Database\n     * @instance\n     */\n    address,\n    /**\n     * The name of the database.\n     * @ype string\n     * @memberof module:Databases~Database\n     * @instance\n     */\n    name,\n    identity,\n    meta,\n    close,\n    drop,\n    addOperation,\n    /**\n     * The underlying [operations log]{@link module:Log~Log} of the database.\n     * @ype {module:Log~Log}\n     * @memberof module:Databases~Database\n     * @instance\n     */\n    log,\n    /**\n     * A [sync]{@link module:Sync~Sync} instance of the database.\n     * @ype {module:Sync~Sync}\n     * @memberof module:Databases~Database\n     * @instance\n     */\n    sync,\n    /**\n     * Set of currently connected peers for this Database instance.\n     * @ype Set\n     * @memberof module:Databases~Database\n     * @instance\n     */\n    peers: sync.peers,\n    /**\n     * Event emitter that emits Database changes. See Events section for details.\n     * @ype EventEmitter\n     * @memberof module:Databases~Database\n     * @instance\n     */\n    events,\n    /**\n     * The [access controller]{@link module:AccessControllers} instance of the database.\n     * @memberof module:Databases~Database\n     * @instance\n     */\n    access\n  }\n}\n\nexport default Database\n","/**\n * @namespace Databases-Documents\n * @memberof module:Databases\n * @description Documents database.\n * @example <caption>Create documents db with custom index</caption>\n * import { createHelia } from 'helia'\n * import { createOrbitDB, Documents } from 'orbitdb'\n *\n * const ipfs = createHelia()\n * const orbitdb = await createOrbitDB({ ipfs })\n * const db = await orbitdb.open('my-docs', { Database: Documents({ indexBy: 'myCustomId'} ) }\n *\n * @augments module:Databases~Database\n */\nimport Database from '../database.js'\n\nconst type = 'documents'\n\nconst DefaultOptions = { indexBy: '_id' }\n\n/**\n * Defines a Documents database.\n * @param {Object} options Various options for configuring the Document store.\n * @param {string} [options.indexBy=_id] An index.\n * @return {module:Databases.Databases-Documents} A Documents function.\n * @memberof module:Databases\n */\nconst Documents = ({ indexBy } = DefaultOptions) => async ({ ipfs, identity, address, name, access, directory, meta, headsStorage, entryStorage, indexStorage, referencesCount, syncAutomatically, onUpdate }) => {\n  const database = await Database({ ipfs, identity, address, name, access, directory, meta, headsStorage, entryStorage, indexStorage, referencesCount, syncAutomatically })\n\n  const { addOperation, log } = database\n\n  /**\n   * Stores a document to the store.\n   * @function\n   * @param {Object} doc An object representing a key/value list of fields.\n   * @return {string} The hash of the new oplog entry.\n   * @memberof module:Databases.Databases-Documents\n   * @instance\n   */\n  const put = async (doc) => {\n    const key = doc[indexBy]\n\n    if (!key) { throw new Error(`The provided document doesn't contain field '${indexBy}'`) }\n\n    return addOperation({ op: 'PUT', key, value: doc })\n  }\n\n  /**\n   * Deletes a document from the store.\n   * @function\n   * @param {string} key The key of the doc to delete.\n   * @return {string} The hash of the new oplog entry.\n   * @memberof module:Databases.Databases-Documents\n   * @instance\n   */\n  const del = async (key) => {\n    if (!await get(key)) { throw new Error(`No document with key '${key}' in the database`) }\n\n    return addOperation({ op: 'DEL', key, value: null })\n  }\n\n  /**\n   * Gets a document from the store by key.\n   * @function\n   * @param {string} key The key of the doc to get.\n   * @return {Object} The doc corresponding to key or null.\n   * @memberof module:Databases.Databases-Documents\n   * @instance\n   */\n  const get = async (key) => {\n    for await (const doc of iterator()) {\n      if (key === doc.key) {\n        return doc\n      }\n    }\n  }\n\n  /**\n   * Queries the document store for documents matching mapper filters.\n   * @function\n   * @param {function(Object)} findFn A function for querying for specific\n   * results.\n   *\n   * The findFn function's signature takes the form `function(doc)` where doc\n   * is a document's value property. The function should return true if the\n   * document should be included in the results, false otherwise.\n   * @return {Array} Found documents.\n   * @memberof module:Databases.Databases-Documents\n   * @instance\n   */\n  const query = async (findFn) => {\n    const results = []\n\n    for await (const doc of iterator()) {\n      if (findFn(doc.value)) {\n        results.push(doc.value)\n      }\n    }\n\n    return results\n  }\n\n  /**\n   * Iterates over documents.\n   * @function\n   * @param {Object} [filters={}] Various filters to apply to the iterator.\n   * @param {string} [filters.amount=-1] The number of results to fetch.\n   * @yields [string, string, string] The next document as hash/key/value.\n   * @memberof module:Databases.Databases-Documents\n   * @instance\n   */\n  const iterator = async function * ({ amount } = {}) {\n    const keys = {}\n    let count = 0\n    for await (const entry of log.iterator()) {\n      const { op, key, value } = entry.payload\n      if (op === 'PUT' && !keys[key]) {\n        keys[key] = true\n        count++\n        const hash = entry.hash\n        yield { hash, key, value }\n      } else if (op === 'DEL' && !keys[key]) {\n        keys[key] = true\n      }\n      if (count >= amount) {\n        break\n      }\n    }\n  }\n\n  /**\n   * Returns all documents.\n   * @function\n   * @return [][string, string, string] An array of documents as hash/key\n   * value entries.\n   * @memberof module:Databases.Databases-Documents\n   * @instance\n   */\n  const all = async () => {\n    const values = []\n    for await (const entry of iterator()) {\n      values.unshift(entry)\n    }\n    return values\n  }\n\n  return {\n    ...database,\n    type,\n    put,\n    del,\n    get,\n    iterator,\n    query,\n    indexBy,\n    all\n  }\n}\n\nDocuments.type = type\n\nexport default Documents\n","/**\n * @namespace Databases-Events\n * @memberof module:Databases\n * @description\n * Events database is an immutable, append-only event log database.\n *\n * @augments module:Databases~Database\n */\nimport Database from '../database.js'\n\nconst type = 'events'\n\n/**\n * Defines an Events database.\n * @return {module:Databases.Databases-Events} A Events function.\n * @memberof module:Databases\n */\nconst Events = () => async ({ ipfs, identity, address, name, access, directory, meta, headsStorage, entryStorage, indexStorage, referencesCount, syncAutomatically, onUpdate }) => {\n  const database = await Database({ ipfs, identity, address, name, access, directory, meta, headsStorage, entryStorage, indexStorage, referencesCount, syncAutomatically, onUpdate })\n\n  const { addOperation, log } = database\n\n  /**\n   * Adds an event to the store.\n   * @function\n   * @param {*} value The event to be added.\n   * @return {string} The hash of the new oplog entry.\n   * @memberof module:Databases.Databases-Events\n   * @instance\n   */\n  const add = async (value) => {\n    return addOperation({ op: 'ADD', key: null, value })\n  }\n\n  /**\n   * Gets an event from the store by hash.\n   * @function\n   * @param {string} hash The hash of the event to get.\n   * @return {*} The value corresponding to hash or null.\n   * @memberof module:Databases.Databases-Events\n   * @instance\n   */\n  const get = async (hash) => {\n    const entry = await log.get(hash)\n    return entry.payload.value\n  }\n\n  /**\n   * Iterates over events.\n   * @function\n   * @param {Object} [filters={}] Various filters to apply to the iterator.\n   * @param {string} [filters.gt] All events which are greater than the\n   * given hash.\n   * @param {string} [filters.gte] All events which are greater than or equal\n   * to the given hash.\n   * @param {string} [filters.lt] All events which are less than the given\n   * hash.\n   * @param {string} [filters.lte] All events which are less than or equal to\n   * the given hash.\n   * @param {string} [filters.amount=-1] The number of results to fetch.\n   * @yields [string, string] The next event as hash/value.\n   * @memberof module:Databases.Databases-Events\n   * @instance\n   */\n  const iterator = async function * ({ gt, gte, lt, lte, amount } = {}) {\n    const it = log.iterator({ gt, gte, lt, lte, amount })\n    for await (const event of it) {\n      const hash = event.hash\n      const value = event.payload.value\n      yield { hash, value }\n    }\n  }\n\n  /**\n   * Returns all events.\n   * @function\n   * @return [][string, string] An array of events as hash/value entries.\n   * @memberof module:Databases.Databases-Events\n   * @instance\n   */\n  const all = async () => {\n    const values = []\n    for await (const entry of iterator()) {\n      values.unshift(entry)\n    }\n    return values\n  }\n\n  return {\n    ...database,\n    type,\n    add,\n    get,\n    iterator,\n    all\n  }\n}\n\nEvents.type = type\n\nexport default Events\n","/**\n * @module Databases\n * @description\n * Provides various database structures for storing data.\n */\nimport Documents from './documents.js'\nimport Events from './events.js'\nimport KeyValue from './keyvalue.js'\nimport KeyValueIndexed from './keyvalue-indexed.js'\n/**\n\n * An array of available database types.\n * @name databaseTypes\n * @ype []\n * @return [] An array of database types.\n * @memberof module:Databases\n */\nconst databaseTypes = {}\n\n/**\n * Add a new database type.\n * @example\n * import { useDatabaseType } from 'orbitdb'\n * const CustomDBTypeModule = async (params) => {\n *   const database = await Database(...params)\n *   ...\n * }\n * useDatabaseType(CustomDBTypeModule)\n * @function useDatabaseType\n * @param {module:Databases} database A Database-compatible module.\n * @throws Database type does not contain required field \\'type\\'.\n * @throws Database type '${store.type}' already added.\n * @memberof module:Databases\n */\nconst useDatabaseType = (database) => {\n  if (!database.type) {\n    throw new Error('Database type does not contain required field \\'type\\'.')\n  }\n\n  databaseTypes[database.type] = database\n}\n\nconst getDatabaseType = (type) => {\n  if (!type) {\n    throw new Error('Type not specified')\n  }\n\n  if (!databaseTypes[type]) {\n    throw new Error(`Unsupported database type: '${type}'`)\n  }\n\n  return databaseTypes[type]\n}\n\nuseDatabaseType(Events)\nuseDatabaseType(Documents)\nuseDatabaseType(KeyValue)\n\nexport { useDatabaseType, getDatabaseType, Documents, Events, KeyValue, KeyValueIndexed }\n","/**\n * @namespace Databases-KeyValueIndexed\n * @memberof module:Databases\n * @description\n * Key-Value database that uses an index in order to provide fast queries.\n *\n * Key-value pairs are stored to the configured storage.\n * @example <caption>Specify a custom storage</caption>\n * import { createHelia } from 'helia'\n * import { createOrbitDB, KeyValueIndexed, IPFSBlockStorage } from 'orbitdb'\n *\n * const ipfs = createHelia()\n * const storage = await IPFSBlockStorage({ ipfs })\n * const orbitdb = await createOrbitDB({ ipfs })\n * const db = await orbitdb.open('my-kv', { Database: KeyValueIndexed({ storage }) })\n *\n * @augments module:Databases~Database\n * @augments module:Databases.Databases-KeyValue\n */\nimport KeyValue from './keyvalue.js'\nimport LevelStorage from '../storage/level.js'\nimport pathJoin from '../utils/path-join.js'\n\nconst valueEncoding = 'json'\n\n/**\n * Defines an index for a KeyValue database.\n * @param {string} [directory] A location for storing the index-related data\n * @return {Index} A Index function.\n */\nconst Index = ({ directory } = {}) => async () => {\n  const index = await LevelStorage({ path: directory, valueEncoding })\n  const indexedEntries = await LevelStorage({ path: pathJoin(directory, '/_indexedEntries/'), valueEncoding })\n\n  const update = async (log, entry) => {\n    const keys = new Set()\n    const toBeIndexed = new Set()\n    const latest = entry.hash\n\n    // Function to check if a hash is in the entry index\n    const isIndexed = async (hash) => (await indexedEntries.get(hash)) === true\n    const isNotIndexed = async (hash) => !(await isIndexed(hash))\n\n    // Function to decide when the log traversal should be stopped\n    const shoudStopTraverse = async (entry) => {\n      // Go through the nexts of an entry and if any is not yet\n      // indexed, add it to the list of entries-to-be-indexed\n      for await (const hash of entry.next) {\n        if (await isNotIndexed(hash)) {\n          toBeIndexed.add(hash)\n        }\n      }\n      // If the latest entry and all its nexts are indexed and to-be-indexed list is empty,\n      // we don't have anything more to process, so return true to stop the traversal\n      return await isIndexed(latest) && toBeIndexed.size === 0\n    }\n\n    // Traverse the log and stop when everything has been processed\n    for await (const entry of log.traverse(null, shoudStopTraverse)) {\n      const { hash, payload } = entry\n      // If an entry is not yet indexed, process it\n      if (await isNotIndexed(hash)) {\n        const { op, key } = payload\n        if (op === 'PUT' && !keys.has(key)) {\n          keys.add(key)\n          await index.put(key, entry)\n          await indexedEntries.put(hash, true)\n        } else if (op === 'DEL' && !keys.has(key)) {\n          keys.add(key)\n          await index.del(key)\n          await indexedEntries.put(hash, true)\n        }\n        // Remove the entry (hash) from the list of to-be-indexed entries\n        toBeIndexed.delete(hash)\n      }\n    }\n  }\n\n  /**\n   * Closes the index and its storages.\n   */\n  const close = async () => {\n    await index.close()\n    await indexedEntries.close()\n  }\n\n  /**\n   * Drops all records from the index and its storages.\n   */\n  const drop = async () => {\n    await index.clear()\n    await indexedEntries.clear()\n  }\n\n  return {\n    get: index.get,\n    iterator: index.iterator,\n    update,\n    close,\n    drop\n  }\n}\n\n/**\n * Defines a KeyValueIndexed database.\n * @param {module:Storage} [storage=LevelStorage] A compatible storage where\n * the key/value pairs are indexed.\n * @return {module:Databases.Databases-KeyValueIndexed} A KeyValueIndexed\n * function.\n * @memberof module:Databases\n */\nconst KeyValueIndexed = () => async ({ ipfs, identity, address, name, access, directory, meta, headsStorage, entryStorage, indexStorage, referencesCount, syncAutomatically, onUpdate }) => {\n  // Set up the directory for an index\n  directory = pathJoin(directory || './orbitdb', `./${address}/_index/`)\n\n  // Set up the index\n  const index = await Index({ directory })()\n\n  // Set up the underlying KeyValue database\n  const keyValueStore = await KeyValue()({ ipfs, identity, address, name, access, directory, meta, headsStorage, entryStorage, indexStorage, referencesCount, syncAutomatically, onUpdate: index.update })\n\n  /**\n   * Gets a value from the store by key.\n   * @function\n   * @param {string} key The key of the value to get.\n   * @return {*} The value corresponding to key or null.\n   * @memberof module:Databases.Databases-KeyValueIndexed\n   * @instance\n   */\n  const get = async (key) => {\n    const entry = await index.get(key)\n    if (entry) {\n      return entry.payload.value\n    }\n  }\n\n  /**\n   * Iterates over keyvalue pairs.\n   * @function\n   * @param {Object} [filters={}] Various filters to apply to the iterator.\n   * @param {string} [filters.amount=-1] The number of results to fetch.\n   * @yields [string, string, string] The next key/value as key/value/hash.\n   * @memberof module:Databases.Databases-KeyValueIndexed\n   * @instance\n   */\n  const iterator = async function * ({ amount } = {}) {\n    const it = index.iterator({ amount, reverse: true })\n    for await (const record of it) {\n      // 'index' is a LevelStorage that returns a [key, value] pair\n      const entry = record[1]\n      const { key, value } = entry.payload\n      const hash = entry.hash\n      yield { key, value, hash }\n    }\n  }\n\n  /**\n   * Closes the index and underlying storage.\n   */\n  const close = async () => {\n    await keyValueStore.close()\n    await index.close()\n  }\n\n  /**\n   * Drops all records from the index and underlying storage.\n   */\n  const drop = async () => {\n    await keyValueStore.drop()\n    await index.drop()\n  }\n\n  return {\n    ...keyValueStore,\n    get,\n    iterator,\n    close,\n    drop\n  }\n}\n\nKeyValueIndexed.type = 'keyvalue'\n\nexport default KeyValueIndexed\n","/**\n * @namespace Databases-KeyValue\n * @memberof module:Databases\n * @description\n * Key-Value database.\n *\n * @augments module:Databases~Database\n */\nimport Database from '../database.js'\n\nconst type = 'keyvalue'\n\n/**\n * Defines a KeyValue database.\n * @return {module:Databases.Databases-KeyValue} A KeyValue function.\n * @memberof module:Databases\n */\nconst KeyValue = () => async ({ ipfs, identity, address, name, access, directory, meta, headsStorage, entryStorage, indexStorage, referencesCount, syncAutomatically, onUpdate }) => {\n  const database = await Database({ ipfs, identity, address, name, access, directory, meta, headsStorage, entryStorage, indexStorage, referencesCount, syncAutomatically, onUpdate })\n\n  const { addOperation, log } = database\n\n  /**\n   * Stores a key/value pair to the store.\n   * @function\n   * @param {string} key The key to store.\n   * @param {*} value The value to store.\n   * @return {string} The hash of the new oplog entry.\n   * @memberof module:Databases.Databases-KeyValue\n   * @instance\n   */\n  const put = async (key, value) => {\n    return addOperation({ op: 'PUT', key, value })\n  }\n\n  /**\n   * Deletes a key/value pair from the store.\n   * @function\n   * @param {string} key The key of the key/value pair to delete.\n   * @memberof module:Databases.Databases-KeyValue\n   * @instance\n   */\n  const del = async (key) => {\n    return addOperation({ op: 'DEL', key, value: null })\n  }\n\n  /**\n   * Gets a value from the store by key.\n   * @function\n   * @param {string} key The key of the value to get.\n   * @return {*} The value corresponding to key or null.\n   * @memberof module:Databases.Databases-KeyValue\n   * @instance\n   */\n  const get = async (key) => {\n    for await (const entry of log.traverse()) {\n      const { op, key: k, value } = entry.payload\n      if (op === 'PUT' && k === key) {\n        return value\n      } else if (op === 'DEL' && k === key) {\n        return\n      }\n    }\n  }\n\n  /**\n   * Iterates over keyvalue pairs.\n   * @function\n   * @param {Object} [filters={}] Various filters to apply to the iterator.\n   * @param {string} [filters.amount=-1] The number of results to fetch.\n   * @yields [string, string, string] The next key/value as key/value/hash.\n   * @memberof module:Databases.Databases-KeyValue\n   * @instance\n   */\n  const iterator = async function * ({ amount } = {}) {\n    const keys = {}\n    let count = 0\n    for await (const entry of log.traverse()) {\n      const { op, key, value } = entry.payload\n      if (op === 'PUT' && !keys[key]) {\n        keys[key] = true\n        count++\n        const hash = entry.hash\n        yield { key, value, hash }\n      } else if (op === 'DEL' && !keys[key]) {\n        keys[key] = true\n      }\n      if (count >= amount) {\n        break\n      }\n    }\n  }\n\n  /**\n   * Returns all key/value pairs.\n   * @function\n   * @return [][string, string, string] An array of key/value pairs as\n   * key/value/hash entries.\n   * @memberof module:Databases.Databases-KeyValue\n   * @instance\n   */\n  const all = async () => {\n    const values = []\n    for await (const entry of iterator()) {\n      values.unshift(entry)\n    }\n    return values\n  }\n\n  return {\n    ...database,\n    type,\n    put,\n    set: put, // Alias for put()\n    del,\n    get,\n    iterator,\n    all\n  }\n}\n\nKeyValue.type = type\n\nexport default KeyValue\n","/**\n * @module Identities\n * @description\n * Identities provides a framework for generating and managing identity\n * details and providers.\n */\nimport Identity, { isIdentity, isEqual, decodeIdentity } from './identity.js'\nimport { getIdentityProvider } from './providers/index.js'\n// import DIDIdentityProvider from './identity-providers/did.js'\n// import EthIdentityProvider from './identity-providers/ethereum.js'\nimport KeyStore, { signMessage, verifyMessage } from '../key-store.js'\nimport { LRUStorage, IPFSBlockStorage, MemoryStorage, ComposedStorage } from '../storage/index.js'\nimport pathJoin from '../utils/path-join.js'\n\nconst DefaultIdentityKeysPath = pathJoin('./orbitdb', 'identities')\n\n/**\n * Creates an instance of Identities.\n * @function\n * @param {Object} params One or more parameters for configuring Identities.\n * @param {module:KeyStore} [params.keystore] A preconfigured KeyStore.\n * A KeyStore will be created in the path defined by the path param. If neither\n * Keystore nor path are defined, a new KeyStore is stored in ./orbitdb\n * identities.\n * @param {string} [params.path] The path to a KeyStore. If no path is\n * provided, the default is ./orbitdb/identities.\n * @param {module:Storage} [params.storage] An instance of a compatible storage\n * module.\n * @param {IPFS} [params.ipfs] An instance of IPFS. This param is not required\n * if storage is provided.\n * @return {module:Identities~Identities} An instance of Identities.\n * @instance\n */\nconst Identities = async ({ keystore, path, storage, ipfs } = {}) => {\n  /**\n   * @namespace module:Identities~Identities\n   * @description The instance returned by {@link module:Identities}.\n   */\n\n  keystore = keystore || await KeyStore({ path: path || DefaultIdentityKeysPath })\n\n  if (!storage) {\n    storage = ipfs\n      ? await ComposedStorage(await LRUStorage({ size: 1000 }), await IPFSBlockStorage({ ipfs, pin: true }))\n      : await MemoryStorage()\n  }\n\n  const verifiedIdentitiesCache = await LRUStorage({ size: 1000 })\n\n  /**\n   * Gets an identity by hash.\n   * @param {string} hash An identity hash.\n   * @return {module:Identities~Identity} An instance of identity.\n   * @memberof module:Identities~Identities\n   * @instance\n   */\n  const getIdentity = async (hash) => {\n    const bytes = await storage.get(hash)\n    if (bytes) {\n      return decodeIdentity(bytes)\n    }\n  }\n\n  /**\n   * Creates an identity, adding it to storage.\n   * @param {Object} options Various options for configuring a new identity.\n   * @param {Function} [options.provider=PublicKeyIdentityProvider()] An instance of the Provider to use for generating an identity, e.g. PublicKeyIdentityProvider({ keystore })\n   * @return {module:Identities~Identity} An instance of identity.\n   * @memberof module:Identities~Identities\n   * @instance\n   */\n  const createIdentity = async (options = {}) => {\n    options.keystore = keystore\n    const DefaultIdentityProvider = getIdentityProvider('publickey')\n    const identityProviderInit = options.provider || DefaultIdentityProvider({ keystore })\n\n    const identityProvider = await identityProviderInit()\n\n    if (!getIdentityProvider(identityProvider.type)) {\n      throw new Error('Identity provider is unknown. Use useIdentityProvider(provider) to register the identity provider')\n    }\n\n    const id = await identityProvider.getId(options)\n    const privateKey = await keystore.getKey(id) || await keystore.createKey(id)\n    const publicKey = keystore.getPublic(privateKey)\n    const idSignature = await signMessage(privateKey, id)\n    const publicKeyAndIdSignature = await identityProvider.signIdentity(publicKey + idSignature, options)\n    const signatures = {\n      id: idSignature,\n      publicKey: publicKeyAndIdSignature\n    }\n\n    const identity = await Identity({ id, publicKey, signatures, type: identityProvider.type, sign, verify })\n\n    await storage.put(identity.hash, identity.bytes)\n\n    return identity\n  }\n\n  /**\n   * Verifies an identity using the identity's provider.\n   * @param {module:Identities~Identity} identity The identity to verify.\n   * @return {boolean} True the identity is valid, false otherwise.\n   * @memberof module:Identities~Identities\n   */\n  const verifyIdentity = async (identity) => {\n    if (!isIdentity(identity)) {\n      return false\n    }\n\n    const { id, publicKey, signatures } = identity\n\n    const idSignatureVerified = await verify(signatures.id, publicKey, id)\n    if (!idSignatureVerified) {\n      return false\n    }\n\n    const verifiedIdentity = await verifiedIdentitiesCache.get(signatures.id)\n    if (verifiedIdentity) {\n      return isEqual(identity, verifiedIdentity)\n    }\n\n    const Provider = getIdentityProvider(identity.type)\n\n    const identityVerified = await Provider.verifyIdentity(identity)\n    if (identityVerified) {\n      await verifiedIdentitiesCache.put(signatures.id, identity)\n    }\n\n    return identityVerified\n  }\n\n  /**\n   * Signs data using an identity.\n   * @param {module:Identities~Identity} identity The identity to use for\n   * signing.\n   * @param {string} data The data to sign.\n   * @return {string} The signed data.\n   * @throws Private signing key not found from KeyStore when no signing key can\n   * be retrieved.\n   * @memberof module:Identities~Identities\n   * @instance\n   * @private\n   */\n  const sign = async (identity, data) => {\n    const signingKey = await keystore.getKey(identity.id)\n\n    if (!signingKey) {\n      throw new Error('Private signing key not found from KeyStore')\n    }\n\n    return await signMessage(signingKey, data)\n  }\n\n  /**\n   * Verifies data using a valid signature and publicKey.\n   * @param {string} signature A signature.\n   * @param {string} publicKey A public key.\n   * @param {string} data The data to be verified.\n   * @return {boolean} True if the the data is signed by the publicKey, false\n   * otherwise.\n   * @memberof module:Identities~Identities\n   * @instance\n   * @private\n   */\n  const verify = async (signature, publicKey, data) => {\n    return await verifyMessage(signature, publicKey, data)\n  }\n\n  return {\n    createIdentity,\n    verifyIdentity,\n    getIdentity,\n    sign,\n    verify,\n    keystore\n  }\n}\n\nexport {\n  Identities as default\n}\n","import * as Block from 'multiformats/block'\nimport * as dagCbor from '@ipld/dag-cbor'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { base58btc } from 'multiformats/bases/base58'\n\nconst codec = dagCbor\nconst hasher = sha256\nconst hashStringEncoding = base58btc\n\n/**\n * @typedef {Object} module:Identities~Identity\n * @property {string} id A unique identifer for the identity.\n * @property {object} publicKey A public key.\n * @property {object} signatures A signed identity id and public key.\n * @property {string} type The type of identity provider.\n * @property {function} sign A sign function to sign data using this identity.\n * @property {function} verify A verify function to verify data signed by this identity.\n */\nconst Identity = async ({ id, publicKey, signatures, type, sign, verify } = {}) => {\n  /**\n   * @description The Identity instance. Returned by\n   * [Identities.createIdentity()]{@link module:Identities~Identities#createIdentity}.\n   */\n  if (!id) throw new Error('Identity id is required')\n  if (!publicKey) throw new Error('Invalid public key')\n  if (!signatures) throw new Error('Signatures object is required')\n  if (!signatures.id) throw new Error('Signature of id is required')\n  if (!signatures.publicKey) throw new Error('Signature of publicKey+id is required')\n  if (!type) throw new Error('Identity type is required')\n\n  signatures = Object.assign({}, signatures)\n\n  const identity = {\n    id,\n    publicKey,\n    signatures,\n    type,\n    sign,\n    verify\n  }\n\n  const { hash, bytes } = await _encodeIdentity(identity)\n  identity.hash = hash\n  identity.bytes = bytes\n\n  return identity\n}\n\nconst _encodeIdentity = async (identity) => {\n  const { id, publicKey, signatures, type } = identity\n  const value = { id, publicKey, signatures, type }\n  const { cid, bytes } = await Block.encode({ value, codec, hasher })\n  const hash = cid.toString(hashStringEncoding)\n  return { hash, bytes: Uint8Array.from(bytes) }\n}\n\nconst decodeIdentity = async (bytes) => {\n  const { value } = await Block.decode({ bytes, codec, hasher })\n  return Identity({ ...value })\n}\n\n/**\n * Verifies whether an identity is valid.\n * @param {Identity} identity The identity to verify.\n * @return {boolean} True if the identity is valid, false otherwise.\n * @static\n * @private\n */\nconst isIdentity = (identity) => {\n  return Boolean(identity.id &&\n    identity.hash &&\n    identity.bytes &&\n    identity.publicKey &&\n    identity.signatures &&\n    identity.signatures.id &&\n    identity.signatures.publicKey &&\n    identity.type)\n}\n\n/**\n * Evaluates whether two identities are equal.\n * @param {Identity} a First identity.\n * @param {Identity} b Second identity.\n * @return {boolean} True if identity a and b are equal, false otherwise.\n * @static\n * @private\n */\nconst isEqual = (a, b) => {\n  return a.id === b.id &&\n    a.hash === b.hash &&\n    a.type === b.type &&\n    a.publicKey === b.publicKey &&\n    a.signatures.id === b.signatures.id &&\n    a.signatures.publicKey === b.signatures.publicKey\n}\n\nexport { Identity as default, isEqual, isIdentity, decodeIdentity }\n","export { default as Identities } from './identities.js'\n\nexport {\n  default as Identity,\n  isIdentity,\n  isEqual\n} from './identity.js'\n\nexport {\n  useIdentityProvider,\n  getIdentityProvider,\n  PublicKeyIdentityProvider\n} from './providers/index.js'\n","import PublicKeyIdentityProvider from './publickey.js'\n\nconst identityProviders = {}\n\nconst isProviderSupported = (type) => {\n  return Object.keys(identityProviders).includes(type)\n}\n\nconst getIdentityProvider = (type) => {\n  if (!isProviderSupported(type)) {\n    throw new Error(`IdentityProvider type '${type}' is not supported`)\n  }\n\n  return identityProviders[type]\n}\n\n/**\n  * Adds an identity provider.\n  * @param {IdentityProvider} identityProvider The identity provider to add.\n  * @throws Given IdentityProvider doesn\\'t have a field \\'type\\'.\n  * @throws Given IdentityProvider doesn\\'t have a function \\'verifyIdentity\\'.\n  * @throws IdentityProvider ${IdentityProvider.type} already added.\n  * @static\n  * @memberof module:Identities\n  */\nconst useIdentityProvider = (identityProvider) => {\n  if (!identityProvider.type ||\n     typeof identityProvider.type !== 'string') {\n    throw new Error('Given IdentityProvider doesn\\'t have a field \\'type\\'.')\n  }\n\n  if (!identityProvider.verifyIdentity) {\n    throw new Error('Given IdentityProvider doesn\\'t have a function \\'verifyIdentity\\'.')\n  }\n\n  identityProviders[identityProvider.type] = identityProvider\n}\n\nuseIdentityProvider(PublicKeyIdentityProvider)\n\nexport { useIdentityProvider, getIdentityProvider, PublicKeyIdentityProvider }\n","/**\n * @memberof module:IdentityProviders\n * @description\n * The PublicKey Identity Provider signs and verifies an identity using the\n * public key of a private/public key pair.\n */\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { signMessage, verifyMessage } from '../../key-store.js'\n\nconst type = 'publickey'\n\n/**\n * Verifies an identity using the identity's id.\n * @param {module:Identity} identity\n * @return {boolean} True if the identity is valid, false otherwise.\n * @static\n * @private\n */\nconst verifyIdentity = async identity => {\n  const { id, publicKey, signatures } = identity\n  return verifyMessage(signatures.publicKey, id, publicKey + signatures.id)\n}\n\n/**\n * Instantiates the publickey identity provider.\n * @return {module:IdentityProviders.IdentityProvider-PublicKey} A public key\n * identity provider function.\n * @private\n */\nconst PublicKeyIdentityProvider = ({ keystore }) => async () => {\n  /**\n   * @namespace module:IdentityProviders.IdentityProvider-PublicKey\n   * @memberof module:IdentityProviders\n   * @description The instance returned by {@link module:IdentityProviders.IdentityProvider-PublicKey}.\n   * @private\n   */\n\n  if (!keystore) {\n    throw new Error('PublicKeyIdentityProvider requires a keystore parameter')\n  }\n\n  /**\n   * Gets the id.\n   * @memberof module:IdentityProviders.IdentityProvider-PublicKey\n   * @param {string} id The id to retrieve.\n   * @return {string} The identity's id.\n   * @instance\n   */\n  const getId = async ({ id } = {}) => {\n    if (!id) {\n      throw new Error('id is required')\n    }\n\n    const key = await keystore.getKey(id) || await keystore.createKey(id)\n    return uint8ArrayToString(key.publicKey.raw, 'base16')\n  }\n\n  /**\n   * Signs an identity using the identity's id.\n   * @memberof module:IdentityProviders.IdentityProvider-PublicKey\n   * @param {*} data The identity data to sign.\n   * @param {Object} params One or more parameters for configuring Database.\n   * @param {string} [params.id] The identity's id.\n   * @return {string} A signature.\n   * @instance\n   */\n  const signIdentity = async (data, { id } = {}) => {\n    if (!id) {\n      throw new Error('id is required')\n    }\n\n    const key = await keystore.getKey(id)\n    if (!key) {\n      throw new Error(`Signing key for '${id}' not found`)\n    }\n\n    return signMessage(key, data)\n  }\n\n  return {\n    type,\n    getId,\n    signIdentity\n  }\n}\n\nPublicKeyIdentityProvider.verifyIdentity = verifyIdentity\nPublicKeyIdentityProvider.type = type\n\nexport default PublicKeyIdentityProvider\n","/**\n* @module KeyStore\n* @description\n* Provides a local key manager for OrbitDB.\n* @example <caption>Create a keystore with defaults.</caption>\n* const keystore = await KeyStore()\n* @example <caption>Create a keystore with custom storage.</caption>\n* const storage = await MemoryStorage()\n* const keystore = await KeyStore({ storage })\n*/\nimport { privateKeyFromRaw, publicKeyFromRaw, generateKeyPair } from '@libp2p/crypto/keys'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { compare as uint8ArrayCompare } from 'uint8arrays/compare'\nimport ComposedStorage from './storage/composed.js'\nimport LevelStorage from './storage/level.js'\nimport LRUStorage from './storage/lru.js'\n\nconst verifySignature = async (signature, publicKey, data) => {\n  if (!signature) {\n    throw new Error('No signature given')\n  }\n  if (!publicKey) {\n    throw new Error('Given publicKey was undefined')\n  }\n  if (!data) {\n    throw new Error('Given input data was undefined')\n  }\n\n  if (!(data instanceof Uint8Array)) {\n    data = typeof data === 'string' ? uint8ArrayFromString(data) : new Uint8Array(data)\n  }\n\n  const isValid = (key, msg, sig) => key.verify(msg, sig)\n\n  let res = false\n  try {\n    const pubKey = publicKeyFromRaw(uint8ArrayFromString(publicKey, 'base16'))\n    res = await isValid(pubKey, data, uint8ArrayFromString(signature, 'base16'))\n  } catch (e) {\n    // Catch error: sig length wrong\n  }\n\n  return Promise.resolve(res)\n}\n\n/**\n * Signs data using a key pair.\n * @param {Secp256k1PrivateKey} key The key to use for signing data.\n * @param {string|Uint8Array} data The data to sign.\n * @return {string} A signature.\n * @throws No signing key given if no key is provided.\n * @throws Given input data was undefined if no data is provided.\n * @static\n * @private\n */\nconst signMessage = async (key, data) => {\n  if (!key) {\n    throw new Error('No signing key given')\n  }\n\n  if (!data) {\n    throw new Error('Given input data was undefined')\n  }\n\n  if (!(data instanceof Uint8Array)) {\n    data = typeof data === 'string' ? uint8ArrayFromString(data) : new Uint8Array(data)\n  }\n\n  return uint8ArrayToString(await key.sign(data), 'base16')\n}\n\nconst verifiedCachePromise = LRUStorage({ size: 1000 })\n\n/**\n * Verifies input data against a cached version of the signed message.\n * @param {string} signature The generated signature.\n * @param {string} publicKey The derived public key of the key pair.\n * @param {string} data The data to be verified.\n * @return {boolean} True if the the data and cache match, false otherwise.\n * @static\n * @private\n */\nconst verifyMessage = async (signature, publicKey, data) => {\n  const verifiedCache = await verifiedCachePromise\n  const cached = await verifiedCache.get(signature)\n\n  let res = false\n\n  if (!cached) {\n    const verified = await verifySignature(signature, publicKey, data)\n    res = verified\n    if (verified) {\n      await verifiedCache.put(signature, { publicKey, data })\n    }\n  } else {\n    const compare = (cached, data) => {\n      const match = data instanceof Uint8Array ? uint8ArrayCompare(cached, data) === 0 : cached.toString() === data.toString()\n      return match\n    }\n    res = cached.publicKey === publicKey && compare(cached.data, data)\n  }\n  return res\n}\n\nconst defaultPath = './keystore'\n\n/**\n * Creates an instance of KeyStore.\n * @param {Object} params One or more parameters for configuring KeyStore.\n * @param {Object} [params.storage] An instance of a storage class. Can be one\n * of ComposedStorage, IPFSBlockStorage, LevelStorage, etc. Defaults to\n * ComposedStorage.\n * @param {string} [params.path=./keystore] The path to a valid storage.\n * @return {module:KeyStore~KeyStore} An instance of KeyStore.\n * @instance\n */\nconst KeyStore = async ({ storage, path } = {}) => {\n  /**\n   * @namespace module:KeyStore~KeyStore\n   * @description The instance returned by {@link module:KeyStore}.\n   */\n\n  // Persistent storage for keys\n  storage = storage || await ComposedStorage(await LRUStorage({ size: 1000 }), await LevelStorage({ path: path || defaultPath }))\n\n  // Cache for deserialized/unmarshaled keys\n  const keyCache = await LRUStorage({ size: 1000 })\n\n  /**\n   * Closes the KeyStore's underlying storage.\n   * @memberof module:KeyStore~KeyStore\n   * @async\n   * @instance\n   */\n  const close = async () => {\n    await storage.close()\n    await keyCache.close()\n  }\n\n  /**\n   * Clears the KeyStore's underlying storage.\n   * @memberof module:KeyStore~KeyStore\n   * @async\n   * @instance\n   */\n  const clear = async () => {\n    await storage.clear()\n    await keyCache.clear()\n  }\n\n  /**\n   * Checks if a key exists in the key store .\n   * @param {string} id The id of an [Identity]{@link module:Identities~Identity} to check the key for.\n   * @return {boolean} True if the key exists, false otherwise.\n   * @throws id needed to check a key if no id is specified.\n   * @memberof module:KeyStore~KeyStore\n   * @async\n   * @instance\n   */\n  const hasKey = async (id) => {\n    if (!id) {\n      throw new Error('id needed to check a key')\n    }\n\n    let hasKey = false\n    let key = await keyCache.get(id)\n    if (key) {\n      hasKey = true\n    } else {\n      try {\n        key = await storage.get('private_' + id)\n        hasKey = key !== undefined && key !== null\n      } catch (e) {\n        // Catches 'Error: ENOENT: no such file or directory, open <path>'\n        console.error('Error: ENOENT: no such file or directory')\n      }\n    }\n\n    return hasKey\n  }\n\n  /**\n   * Adds a private key to the keystore.\n   * @param {string} id An id of the [Identity]{@link module:Identities~Identity} to whom the key belongs to.\n   * @param {Uint8Array} key The private key to store.\n   * @memberof module:KeyStore~KeyStore\n   * @async\n   * @instance\n   */\n  const addKey = async (id, key) => {\n    const { privateKey } = key\n    await storage.put('private_' + id, privateKey)\n    // Unmarshal the key and add it to the cache\n    const unmarshaledPrivateKey = privateKeyFromRaw(privateKey)\n    await keyCache.put(id, unmarshaledPrivateKey)\n  }\n\n  /**\n   * Creates a key pair and stores it to the keystore.\n   * @param {string} id An id of the [Identity]{@link module:Identities~Identity} to generate the key pair for.\n   * @throws id needed to create a key if no id is specified.\n   * @memberof module:KeyStore~KeyStore\n   * @async\n   * @instance\n   */\n  const createKey = async (id) => {\n    if (!id) {\n      throw new Error('id needed to create a key')\n    }\n\n    // Generate a private key\n    const keyPair = await generateKeyPair('secp256k1')\n\n    const key = {\n      publicKey: keyPair.publicKey.raw,\n      privateKey: keyPair.raw\n    }\n\n    await addKey(id, key)\n\n    return keyPair\n  }\n\n  /**\n   * Gets a key from keystore.\n   * @param {string} id An id of the [Identity]{@link module:Identities~Identity} whose key to retrieve.\n   * @return {Uint8Array} The key specified by id.\n   * @throws id needed to get a key if no id is specified.\n   * @memberof module:KeyStore~KeyStore\n   * @async\n   * @instance\n   */\n  const getKey = async (id) => {\n    if (!id) {\n      throw new Error('id needed to get a key')\n    }\n\n    let key = await keyCache.get(id)\n\n    if (!key) {\n      let storedKey\n      try {\n        storedKey = await storage.get('private_' + id)\n      } catch (e) {\n        // ignore ENOENT error\n      }\n\n      if (!storedKey) {\n        return\n      }\n\n      key = privateKeyFromRaw(storedKey)\n\n      await keyCache.put(id, key)\n    }\n\n    return key\n  }\n\n  /**\n   * Gets the serialized public key from a key pair.\n   * @param {*} keys A key pair.\n   * @param {Object} options One or more options.\n   * @param {Object} [options.format=hex] The format the public key should be\n   * returned in.\n   * @return {Uint8Array|String} The public key.\n   * @throws Supported formats are `hex` and `buffer` if an invalid format is\n   * passed in options.\n   * @memberof module:KeyStore~KeyStore\n   * @async\n   * @instance\n   */\n  const getPublic = (keys, options = {}) => {\n    const formats = ['hex', 'buffer']\n    const format = options.format || 'hex'\n    if (formats.indexOf(format) === -1) {\n      throw new Error('Supported formats are `hex` and `buffer`')\n    }\n\n    const pubKey = keys.publicKey.raw\n\n    return format === 'buffer' ? pubKey : uint8ArrayToString(pubKey, 'base16')\n  }\n\n  return {\n    clear,\n    close,\n    hasKey,\n    addKey,\n    createKey,\n    getKey,\n    getPublic\n  }\n}\n\nexport {\n  KeyStore as default,\n  verifyMessage,\n  signMessage\n}\n","import * as Block from 'multiformats/block'\nimport * as dagCbor from '@ipld/dag-cbor'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { ComposedStorage, IPFSBlockStorage, LRUStorage } from './storage/index.js'\n\nconst codec = dagCbor\nconst hasher = sha256\nconst hashStringEncoding = base58btc\n\nconst ManifestStore = async ({ ipfs, storage } = {}) => {\n  /**\n   * @namespace module:Manifest~Manifest\n   * @description The instance returned by {@link module:Manifest~Manifest}.\n   * @private\n   */\n\n  storage = storage || await ComposedStorage(\n    await LRUStorage({ size: 100000 }),\n    await IPFSBlockStorage({ ipfs, pin: true })\n  )\n\n  const get = async (address) => {\n    const bytes = await storage.get(address)\n    const { value } = await Block.decode({ bytes, codec, hasher })\n    if (value) {\n      // Write to storage to make sure it gets pinned on IPFS\n      await storage.put(address, bytes)\n    }\n    return value\n  }\n\n  const create = async ({ name, type, accessController, meta }) => {\n    if (!name) throw new Error('name is required')\n    if (!type) throw new Error('type is required')\n    if (!accessController) throw new Error('accessController is required')\n\n    const manifest = Object.assign(\n      {\n        name,\n        type,\n        accessController\n      },\n      // meta field is only added to manifest if meta parameter is defined\n      meta !== undefined ? { meta } : {}\n    )\n\n    const { cid, bytes } = await Block.encode({ value: manifest, codec, hasher })\n    const hash = cid.toString(hashStringEncoding)\n    await storage.put(hash, bytes)\n\n    return {\n      hash,\n      manifest\n    }\n  }\n\n  const close = async () => {\n    await storage.close()\n  }\n\n  return {\n    get,\n    create,\n    close\n  }\n}\n\nexport default ManifestStore\n","/**\n * @namespace module:Log~Clock\n * @memberof module:Log\n * @description\n * The lamport clock.\n * @private\n */\n\n/**\n * Compares two clocks by time and then, time is the same, by id.\n *\n * compareClocks should never return zero (0). If it does, a and b refer to the\n * same clock.\n * @param {module:Clock} a The first clock.\n * @param {module:Clock} b The second clock.\n * @return {number} Returns a negative integer if clock a is less than clock b\n * otherwise a positive integer is returned.\n * @memberof module:Log~Clock\n */\nconst compareClocks = (a, b) => {\n  // Calculate the \"distance\" based on the clock, ie. lower or greater\n  const dist = a.time - b.time\n\n  // If the sequence number is the same (concurrent events),\n  // and the IDs are different, take the one with a \"lower\" id\n  if (dist === 0 && a.id !== b.id) return a.id < b.id ? -1 : 1\n\n  return dist\n}\n\n/**\n * Advances a clock's time by 1, returning a new instance of Clock.\n * @param {module:Clock} clock The clock to advance.\n * @return {module:Clock} A new instance of clock with time advanced by 1.\n * @memberof module:Log~Clock\n */\nconst tickClock = (clock) => {\n  return Clock(clock.id, ++clock.time)\n}\n\n/**\n * Creates an instance of Clock.\n * @function\n * @param {string} id A unique identifier.\n * @param {number} [time=0] A natural number (including 0).\n * @memberof module:Log~Clock\n * @instance\n */\nconst Clock = (id, time) => {\n  time = time || 0\n\n  return {\n    id,\n    time\n  }\n}\n\nexport { Clock as default, compareClocks, tickClock }\n","import { compareClocks } from './clock.js'\n\n/**\n * Sort two entries as Last-Write-Wins (LWW).\n *\n * Last Write Wins is a conflict resolution strategy for sorting elements\n * where the element with a greater clock (latest) is chosen as the winner.\n *\n * @param {Entry} a First entry\n * @param {Entry} b Second entry\n * @return {number} 1 if a is latest, -1 if b is latest\n * @private\n */\nfunction LastWriteWins (a, b) {\n  // Ultimate conflict resolution (take the first/left arg)\n  const First = (a, b) => a\n  // Sort two entries by their clock id, if the same always take the first\n  const sortById = (a, b) => SortByClockId(a, b, First)\n  // Sort two entries by their clock time, if concurrent,\n  // determine sorting using provided conflict resolution function\n  const sortByEntryClocks = (a, b) => SortByClocks(a, b, sortById)\n  // Sort entries by clock time as the primary sort criteria\n  return sortByEntryClocks(a, b)\n}\n\n/**\n * Sort two entries by their clock time.\n * @param {Entry} a First entry to compare\n * @param {Entry} b Second entry to compare\n * @param {function(a, b)} resolveConflict A function to call if entries are\n * concurrent (happened at the same time). The function should take in two\n * entries and return 1 if the first entry should be chosen and -1 if the\n * second entry should be chosen.\n * @return {number} 1 if a is greater, -1 if b is greater\n * @private\n */\nfunction SortByClocks (a, b, resolveConflict) {\n  // Compare the clocks\n  const diff = compareClocks(a.clock, b.clock)\n  // If the clocks are concurrent, use the provided\n  // conflict resolution function to determine which comes first\n  return diff === 0 ? resolveConflict(a, b) : diff\n}\n\n/**\n * Sort two entries by their clock id.\n * @param {Entry} a First entry to compare\n * @param {Entry} b Second entry to compare\n * @param {function(a, b)} resolveConflict A function to call if the clocks ids\n * are the same. The function should take in two entries and return 1 if the\n * first entry should be chosen and -1 if the second entry should be chosen.\n * @return {number} 1 if a is greater, -1 if b is greater\n * @private\n */\nfunction SortByClockId (a, b, resolveConflict) {\n  // Sort by ID if clocks are concurrent,\n  // take the entry with a \"greater\" clock id\n  return a.clock.id === b.clock.id\n    ? resolveConflict(a, b)\n    : a.clock.id < b.clock.id ? -1 : 1\n}\n\n/**\n * A wrapper function to throw an error if the results of a passed function\n * return zero\n * @param {function(a, b)} [tiebreaker] The tiebreaker function to validate.\n * @return {function(a, b)} 1 if a is greater, -1 if b is greater\n * @throws {Error} if func ever returns 0\n * @private\n */\nfunction NoZeroes (func) {\n  const msg = `Your log's tiebreaker function, ${func.name}, has returned zero and therefore cannot be`\n\n  const comparator = (a, b) => {\n    // Validate by calling the function\n    const result = func(a, b)\n    if (result === 0) { throw Error(msg) }\n    return result\n  }\n\n  return comparator\n}\n\nexport default {\n  SortByClocks,\n  SortByClockId,\n  LastWriteWins,\n  NoZeroes\n}\n","import Clock from './clock.js'\nimport * as Block from 'multiformats/block'\nimport * as dagCbor from '@ipld/dag-cbor'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { base58btc } from 'multiformats/bases/base58'\n\nconst codec = dagCbor\nconst hasher = sha256\nconst hashStringEncoding = base58btc\n\n/**\n * @typedef {Object} module:Log~Entry\n * @property {string} id A string linking multiple entries together.\n * @property {*} payload An arbitrary chunk of data.\n * @property {Array<string>} next One or more hashes pointing to the next entries in a chain of\n * entries.\n * @property {Array<string>} refs One or more hashes which reference other entries in the chain.\n * @property {Clock} clock A logical clock. See {@link module:Log~Clock}.\n * @property {integer} v The version of the entry.\n * @property {string} key The public key of the identity.\n * @property {string} identity The identity of the entry's owner.\n * @property {string} sig The signature of the entry signed by the owner.\n */\n\n/**\n * Creates an Entry.\n * @param {module:Identities~Identity} identity The identity instance\n * @param {string} logId The unique identifier for this log\n * @param {*} data Data of the entry to be added. Can be any JSON.stringifyable\n * data.\n * @param {module:Log~Clock} [clock] The clock\n * @param {Array<string|Entry>} [next=[]] An array of CIDs as base58btc encoded\n * strings which point to the next entries in a chain of entries.\n * @param {Array<string|module:Log~Entry>} [refs=[]] An array of CIDs as\n * base58btc encoded strings pointing to various entries which come before\n * this entry.\n * @return {Promise<module:Log~Entry>} A promise which contains an instance of\n * Entry.\n * Entry consists of the following properties:\n *\n * - id: A string linking multiple entries together,\n * - payload: An arbitrary chunk of data,\n * - next: One or more hashes pointing to the next entries in a chain of\n * entries,\n * - refs: One or more hashes which reference other entries in the chain,\n * - clock: A logical clock. See {@link module:Log~Clock},\n * - v: The version of the entry,\n * - key: The public key of the identity,\n * - identity: The identity of the entry's owner,\n * - sig: The signature of the entry signed by the owner.\n * @memberof module:Log~Entry\n * @example\n * const entry = await Entry.create(identity, 'log1', 'hello')\n * console.log(entry)\n * // { payload: \"hello\", next: [], ... }\n * @private\n */\nconst create = async (identity, id, payload, clock = null, next = [], refs = []) => {\n  if (identity == null) throw new Error('Identity is required, cannot create entry')\n  if (id == null) throw new Error('Entry requires an id')\n  if (payload == null) throw new Error('Entry requires a payload')\n  if (next == null || !Array.isArray(next)) throw new Error(\"'next' argument is not an array\")\n\n  clock = clock || Clock(identity.publicKey)\n\n  const entry = {\n    id, // For determining a unique chain\n    payload, // Can be any dag-cbor encodeable data\n    next, // Array of strings of CIDs\n    refs, // Array of strings of CIDs\n    clock, // Clock\n    v: 2 // To tag the version of this data structure\n  }\n\n  const { bytes } = await Block.encode({ value: entry, codec, hasher })\n  const signature = await identity.sign(identity, bytes)\n\n  entry.key = identity.publicKey\n  entry.identity = identity.hash\n  entry.sig = signature\n\n  return encode(entry)\n}\n\n/**\n * Verifies an entry signature.\n * @param {Identities} identities Identities system to use\n * @param {module:Log~Entry} entry The entry being verified\n * @return {Promise<boolean>} A promise that resolves to a boolean value indicating if\n * the signature is valid.\n * @memberof module:Log~Entry\n * @private\n */\nconst verify = async (identities, entry) => {\n  if (!identities) throw new Error('Identities is required, cannot verify entry')\n  if (!isEntry(entry)) throw new Error('Invalid Log entry')\n  if (!entry.key) throw new Error(\"Entry doesn't have a key\")\n  if (!entry.sig) throw new Error(\"Entry doesn't have a signature\")\n\n  const value = {\n    id: entry.id,\n    payload: entry.payload,\n    next: entry.next,\n    refs: entry.refs,\n    clock: entry.clock,\n    v: entry.v\n  }\n\n  const { bytes } = await Block.encode({ value, codec, hasher })\n\n  return identities.verify(entry.sig, entry.key, bytes)\n}\n\n/**\n * Checks if an object is an Entry.\n * @param {module:Log~Entry} obj\n * @return {boolean}\n * @memberof module:Log~Entry\n * @private\n */\nconst isEntry = (obj) => {\n  return obj && obj.id !== undefined &&\n    obj.next !== undefined &&\n    obj.payload !== undefined &&\n    obj.v !== undefined &&\n    obj.clock !== undefined &&\n    obj.refs !== undefined\n}\n\n/**\n * Determines whether two entries are equal.\n * @param {module:Log~Entry} a An entry to compare.\n * @param {module:Log~Entry} b An entry to compare.\n * @return {boolean} True if a and b are equal, false otherwise.\n * @memberof module:Log~Entry\n * @private\n */\nconst isEqual = (a, b) => {\n  return a && b && a.hash === b.hash\n}\n\n/**\n * Decodes a serialized Entry from bytes\n * @param {Uint8Array} bytes\n * @return {module:Log~Entry}\n * @memberof module:Log~Entry\n * @private\n */\nconst decode = async (bytes) => {\n  const { cid, value } = await Block.decode({ bytes, codec, hasher })\n  const hash = cid.toString(hashStringEncoding)\n  return {\n    ...value,\n    hash,\n    bytes\n  }\n}\n\n/**\n * Encodes an Entry and adds bytes field to it\n * @param {Entry} entry\n * @return {module:Log~Entry}\n * @memberof module:Log~Entry\n * @private\n */\nconst encode = async (entry) => {\n  const { cid, bytes } = await Block.encode({ value: entry, codec, hasher })\n  const hash = cid.toString(hashStringEncoding)\n  const clock = Clock(entry.clock.id, entry.clock.time)\n  return {\n    ...entry,\n    clock,\n    hash,\n    bytes\n  }\n}\n\nexport default {\n  create,\n  verify,\n  decode,\n  encode,\n  isEntry,\n  isEqual\n}\n","/**\n * @namespace module:Log~Heads\n * @memberof module:Log\n * @description The log's heads.\n * @private\n */\nimport Entry from './entry.js'\nimport MemoryStorage from '../storage/memory.js'\n\nconst DefaultStorage = MemoryStorage\n\nconst Heads = async ({ storage, heads }) => {\n  storage = storage || await DefaultStorage()\n\n  const put = async (heads) => {\n    heads = findHeads(heads)\n    for (const head of heads) {\n      await storage.put(head.hash, head.bytes)\n    }\n  }\n\n  const set = async (heads) => {\n    await storage.clear()\n    await put(heads)\n  }\n\n  const add = async (head) => {\n    const currentHeads = await all()\n    if (currentHeads.find(e => Entry.isEqual(e, head))) {\n      return\n    }\n    const newHeads = findHeads([...currentHeads, head])\n    await set(newHeads)\n\n    return newHeads\n  }\n\n  const remove = async (hash) => {\n    const currentHeads = await all()\n    const newHeads = currentHeads.filter(e => e.hash !== hash)\n    await set(newHeads)\n  }\n\n  const iterator = async function * () {\n    const it = storage.iterator()\n    for await (const [, bytes] of it) {\n      const head = await Entry.decode(bytes)\n      yield head\n    }\n  }\n\n  const all = async () => {\n    const values = []\n    for await (const head of iterator()) {\n      values.push(head)\n    }\n    return values\n  }\n\n  const clear = async () => {\n    await storage.clear()\n  }\n\n  const close = async () => {\n    await storage.close()\n  }\n\n  // Initialize the heads if given as parameter\n  await put(heads || [])\n\n  return {\n    put,\n    set,\n    add,\n    remove,\n    iterator,\n    all,\n    clear,\n    close\n  }\n}\n\n/**\n * Find heads from a collection of entries.\n *\n * Finds entries that are the heads of this collection,\n * ie. entries that are not referenced by other entries.\n *\n * This function is private and not exposed in the Log API\n *\n * @param {Array<Entry>} entries Entries to search heads from\n * @return {Array<Entry>}\n * @private\n */\nconst findHeads = (entries) => {\n  entries = new Set(entries)\n  const items = {}\n  for (const entry of entries) {\n    for (const next of entry.next) {\n      items[next] = entry.hash\n    }\n  }\n\n  const res = []\n  for (const entry of entries) {\n    if (!items[entry.hash]) {\n      res.push(entry)\n    }\n  }\n\n  return res\n}\n\nexport default Heads\n","export { default as Log, DefaultAccessController } from './log.js'\nexport { default as Entry } from './entry.js'\nexport { default as Clock } from './clock.js'\nexport { default as ConflictResolution } from './conflict-resolution.js'\n","/**\n * @module Log\n * @description\n * Log is a verifiable, append-only log CRDT.\n *\n * Implemented as a Merkle-CRDT as per the paper\n * [\"Merkle-CRDTs: Merkle-DAGs meet CRDTs\"]{@link https://arxiv.org/abs/2004.00107}\n */\nimport LRU from 'lru'\nimport PQueue from 'p-queue'\nimport Entry from './entry.js'\nimport Clock, { tickClock } from './clock.js'\nimport Heads from './heads.js'\nimport ConflictResolution from './conflict-resolution.js'\nimport MemoryStorage from '../storage/memory.js'\n\nconst { LastWriteWins, NoZeroes } = ConflictResolution\n\nconst randomId = () => new Date().getTime().toString()\nconst maxClockTimeReducer = (res, acc) => Math.max(res, acc.clock.time)\n\n// Default storage for storing the Log and its entries. Default: Memory. Options: Memory, LRU, IPFS.\nconst DefaultStorage = MemoryStorage\n\n// Default AccessController for the Log.\n// Default policy is that anyone can write to the Log.\n// Signature of an entry will always be verified regardless of AccessController policy.\n// Any object that implements the function `canAppend()` that returns true|false can be\n// used as an AccessController.\nconst DefaultAccessController = async () => {\n  // An AccessController may do any async initialization stuff here...\n  return {\n    canAppend: async (entry) => true\n  }\n}\n\n/**\n * Create a new Log instance\n\n * @function\n * @param {IPFS} ipfs An IPFS instance\n * @param {Object} identity Identity.\n * @param {Object} options\n * @param {string} options.logId ID of the log\n * @param {Array<Entry>} options.logHeads Set the heads of the log\n * @param {Object} options.access AccessController (./default-access-controller)\n * @param {Array<Entry>} options.entries An Array of Entries from which to create the log\n * @param {module:Storage} [options.entryStorage] A compatible storage instance\n * for storing log entries. Defaults to MemoryStorage.\n * @param {module:Storage} [options.headsStorage] A compatible storage\n * instance for storing log heads. Defaults to MemoryStorage.\n * @param {module:Storage} [options.indexStorage] A compatible storage\n * instance for storing an index of log entries. Defaults to MemoryStorage.\n * @param {Function} options.sortFn The sort function - by default LastWriteWins\n * @return {module:Log~Log} sync An instance of Log\n * @memberof module:Log\n * @instance\n */\nconst Log = async (identity, { logId, logHeads, access, entryStorage, headsStorage, indexStorage, sortFn } = {}) => {\n  /**\n   * @namespace Log\n   * @description The instance returned by {@link module:Log}\n   */\n\n  if (identity == null) {\n    throw new Error('Identity is required')\n  }\n  if (logHeads != null && !Array.isArray(logHeads)) {\n    throw new Error('\\'logHeads\\' argument must be an array')\n  }\n  // Set Log's id\n  const id = logId || randomId()\n  // Access Controller\n  access = access || await DefaultAccessController()\n  // Oplog entry storage\n  const _entries = entryStorage || await DefaultStorage()\n  // Entry index for keeping track which entries are already in the log\n  const _index = indexStorage || await DefaultStorage()\n  // Heads storage\n  headsStorage = headsStorage || await DefaultStorage()\n  // Add heads to the state storage, ie. init the log state\n  const _heads = await Heads({ storage: headsStorage, heads: logHeads })\n  // Conflict-resolution sorting function\n  sortFn = NoZeroes(sortFn || LastWriteWins)\n  // Internal queues for processing appends and joins in their call-order\n  const appendQueue = new PQueue({ concurrency: 1 })\n  const joinQueue = new PQueue({ concurrency: 1 })\n\n  /**\n   * Returns the clock of the log.\n   * @return {module:Clock}\n   * @memberof module:Log~Log\n   * @instance\n   */\n  const clock = async () => {\n    // Find the latest clock from the heads\n    const maxTime = Math.max(0, (await heads()).reduce(maxClockTimeReducer, 0))\n    return Clock(identity.publicKey, maxTime)\n  }\n\n  /**\n   * Returns the current heads of the log\n   *\n   * @return {Array<module:Log~Entry>}\n   * @memberof module:Log~Log\n   * @instance\n   */\n  const heads = async () => {\n    const res = await _heads.all()\n    return res.sort(sortFn).reverse()\n  }\n\n  /**\n   * Returns all entries in the log\n   *\n   * @return {Array<module:Log~Entry>}\n   * @memberof module:Log~Log\n   * @instance\n   */\n  const values = async () => {\n    const values = []\n    for await (const entry of traverse()) {\n      values.unshift(entry)\n    }\n    return values\n  }\n\n  /**\n   * Retrieve an entry\n   *\n   * @param {string} hash The hash of the entry to retrieve\n   * @return {module:Log~Entry}\n   * @memberof module:Log~Log\n   * @instance\n   */\n  const get = async (hash) => {\n    const bytes = await _entries.get(hash)\n    if (bytes) {\n      const entry = await Entry.decode(bytes)\n      return entry\n    }\n  }\n\n  const has = async (hash) => {\n    const entry = await _index.get(hash)\n    return entry != null\n  }\n\n  /**\n   * Append an new entry to the log\n   *\n   * @param {data} data Payload to add to the entry\n   * @param {Object} options\n   * @param {number} options.referencesCount TODO\n   * @return {module:Log~Entry} Entry that was appended\n   * @memberof module:Log~Log\n   * @instance\n   */\n  const append = async (data, options = { referencesCount: 0 }) => {\n    const task = async () => {\n      // 1. Prepare entry\n      // 2. Authorize entry\n      // 3. Store entry\n      // 4. return Entry\n      // Get current heads of the log\n      const heads_ = await heads()\n      // Create the next pointers from heads\n      const nexts = heads_.map(entry => entry.hash)\n      // Get references (pointers) to multiple entries in the past\n      // (skips the heads which are covered by the next field)\n      const refs = await getReferences(heads_, options.referencesCount + heads_.length)\n      // Create the entry\n      const entry = await Entry.create(\n        identity,\n        id,\n        data,\n        tickClock(await clock()),\n        nexts,\n        refs\n      )\n      // Authorize the entry\n      const canAppend = await access.canAppend(entry)\n      if (!canAppend) {\n        throw new Error(`Could not append entry:\\nKey \"${identity.hash}\" is not allowed to write to the log`)\n      }\n\n      // The appended entry is now the latest head\n      await _heads.set([entry])\n      // Add entry to the entry storage\n      await _entries.put(entry.hash, entry.bytes)\n      // Add entry to the entry index\n      await _index.put(entry.hash, true)\n      // Return the appended entry\n      return entry\n    }\n\n    return appendQueue.add(task)\n  }\n\n  /**\n   * Join two logs.\n   *\n   * Joins another log into this one.\n   *\n   * @param {module:Log~Log} log Log to join with this Log\n   *\n   * @example\n   *\n   * await log1.join(log2)\n   *\n   * @memberof module:Log~Log\n   * @instance\n   */\n  const join = async (log) => {\n    if (!log) {\n      throw new Error('Log instance not defined')\n    }\n    if (!isLog(log)) {\n      throw new Error('Given argument is not an instance of Log')\n    }\n    if (_entries.merge) {\n      await _entries.merge(log.storage)\n    }\n    const heads = await log.heads()\n    for (const entry of heads) {\n      await joinEntry(entry)\n    }\n  }\n\n  /**\n   * Join an entry into a log.\n   *\n   * @param {module:Log~Entry} entry Entry to join with this Log\n   *\n   * @example\n   *\n   * await log.joinEntry(entry)\n   *\n   * @memberof module:Log~Log\n   * @instance\n   */\n  const joinEntry = async (entry) => {\n    const task = async () => {\n      /* 1. Check if the entry is already in the log and return early if it is */\n      const isAlreadyInTheLog = await has(entry.hash)\n      if (isAlreadyInTheLog) {\n        return false\n      }\n\n      const verifyEntry = async (entry) => {\n        // Check that the Entry belongs to this Log\n        if (entry.id !== id) {\n          throw new Error(`Entry's id (${entry.id}) doesn't match the log's id (${id}).`)\n        }\n        // Verify if entry is allowed to be added to the log\n        const canAppend = await access.canAppend(entry)\n        if (!canAppend) {\n          throw new Error(`Could not append entry:\\nKey \"${entry.identity}\" is not allowed to write to the log`)\n        }\n        // Verify signature for the entry\n        const isValid = await Entry.verify(identity, entry)\n        if (!isValid) {\n          throw new Error(`Could not validate signature for entry \"${entry.hash}\"`)\n        }\n      }\n\n      /* 2. Verify the entry */\n      await verifyEntry(entry)\n\n      /* 3. Find missing entries and connections (=path in the DAG) to the current heads */\n      const headsHashes = (await heads()).map(e => e.hash)\n      const hashesToAdd = new Set([entry.hash])\n      const hashesToGet = new Set([...entry.next, ...entry.refs])\n      const connectedHeads = new Set()\n\n      const traverseAndVerify = async () => {\n        const getEntries = Array.from(hashesToGet.values()).filter(has).map(get)\n        const entries = await Promise.all(getEntries)\n\n        for (const e of entries) {\n          hashesToGet.delete(e.hash)\n\n          await verifyEntry(e)\n\n          hashesToAdd.add(e.hash)\n\n          for (const hash of [...e.next, ...e.refs]) {\n            const isInTheLog = await has(hash)\n\n            if (!isInTheLog && !hashesToAdd.has(hash)) {\n              hashesToGet.add(hash)\n            } else if (headsHashes.includes(hash)) {\n              connectedHeads.add(hash)\n            }\n          }\n        }\n\n        if (hashesToGet.size > 0) {\n          await traverseAndVerify()\n        }\n      }\n\n      await traverseAndVerify()\n\n      /* 4. Add missing entries to the index (=to the log) */\n      for (const hash of hashesToAdd.values()) {\n        await _index.put(hash, true)\n      }\n\n      /* 5. Remove heads which new entries are connect to */\n      for (const hash of connectedHeads.values()) {\n        await _heads.remove(hash)\n      }\n\n      /* 6. Add new entry to entries (for pinning) */\n      await _entries.put(entry.hash, entry.bytes)\n\n      /* 6. Add the new entry to heads (=union with current heads) */\n      await _heads.add(entry)\n\n      return true\n    }\n\n    return joinQueue.add(task)\n  }\n\n  /**\n   * TODO\n   * @memberof module:Log~Log\n   * @instance\n   */\n  const traverse = async function * (rootEntries, shouldStopFn) {\n    // By default, we don't stop traversal and traverse\n    // until the end of the log\n    const defaultStopFn = () => false\n    shouldStopFn = shouldStopFn || defaultStopFn\n    // Start traversal from given entries or from current heads\n    rootEntries = rootEntries || (await heads())\n    // Sort the given given root entries and use as the starting stack\n    let stack = rootEntries.sort(sortFn)\n    // Keep a record of all the hashes of entries we've traversed and yielded\n    const traversed = {}\n    // Keep a record of all the hashes we are fetching or have already fetched\n    let toFetch = []\n    const fetched = {}\n    // A function to check if we've seen a hash\n    const notIndexed = (hash) => !(traversed[hash] || fetched[hash])\n    // Current entry during traversal\n    let entry\n    // Start traversal and process stack until it's empty (traversed the full log)\n    while (stack.length > 0) {\n      stack = stack.sort(sortFn)\n      // Get the next entry from the stack\n      entry = stack.pop()\n      if (entry) {\n        const { hash, next } = entry\n        // If we have an entry that we haven't traversed yet, process it\n        if (!traversed[hash]) {\n          // Yield the current entry\n          yield entry\n          // If we should stop traversing, stop here\n          const done = await shouldStopFn(entry)\n          if (done === true) {\n            break\n          }\n          // Add to the hash indices\n          traversed[hash] = true\n          fetched[hash] = true\n          // Add the next and refs hashes to the list of hashes to fetch next,\n          // filter out traversed and fetched hashes\n          toFetch = [...toFetch, ...next].filter(notIndexed)\n          // Function to fetch an entry and making sure it's not a duplicate (check the hash indices)\n          const fetchEntries = (hash) => {\n            if (!traversed[hash] && !fetched[hash]) {\n              fetched[hash] = true\n              return get(hash)\n            }\n          }\n          // Fetch the next/reference entries\n          const nexts = await Promise.all(toFetch.map(fetchEntries))\n\n          // Add the next and refs fields from the fetched entries to the next round\n          toFetch = nexts\n            .filter(e => e !== null && e !== undefined)\n            .reduce((res, acc) => Array.from(new Set([...res, ...acc.next])), [])\n            .filter(notIndexed)\n          // Add the fetched entries to the stack to be processed\n          stack = [...nexts, ...stack]\n        }\n      }\n    }\n  }\n\n  /**\n   * Async iterator over the log entries\n   *\n   * @param {Object} options\n   * @param {amount} options.amount Number of entried to return. Default: return all entries.\n   * @param {string} options.gt Beginning hash of the iterator, non-inclusive\n   * @param {string} options.gte Beginning hash of the iterator, inclusive\n   * @param {string} options.lt Ending hash of the iterator, non-inclusive\n   * @param {string} options.lte Ending hash of the iterator, inclusive\n   * @return {Symbol.asyncIterator} Iterator object of log entries\n   *\n   * @examples\n   *\n   * (async () => {\n   *   log = await Log(testIdentity, { logId: 'X' })\n   *\n   *   for (let i = 0; i <= 100; i++) {\n   *     await log.append('entry' + i)\n   *   }\n   *\n   *   let it = log.iterator({\n   *     lte: 'zdpuApFd5XAPkCTmSx7qWQmQzvtdJPtx2K5p9to6ytCS79bfk',\n   *     amount: 10\n   *   })\n   *\n   *   for await (let entry of it) {\n   *     console.log(entry.payload) // 'entry100', 'entry99', ..., 'entry91'\n   *   }\n   * })()\n   *\n   * @memberof module:Log~Log\n   * @instance\n   */\n  const iterator = async function * ({ amount = -1, gt, gte, lt, lte } = {}) {\n    // TODO: write comments on how the iterator algorithm works\n\n    if (amount === 0) {\n      return\n    }\n\n    if (typeof lte === 'string') {\n      lte = [await get(lte)]\n    }\n\n    if (typeof lt === 'string') {\n      const entry = await get(lt)\n      const nexts = await Promise.all(entry.next.map(n => get(n)))\n      lt = nexts\n    }\n\n    if (lt != null && !Array.isArray(lt)) throw new Error('lt must be a string or an array of Entries')\n    if (lte != null && !Array.isArray(lte)) throw new Error('lte must be a string or an array of Entries')\n\n    const start = (lt || (lte || await heads())).filter(i => i != null)\n    const end = (gt || gte) ? await get(gt || gte) : null\n\n    const amountToIterate = (end || amount === -1) ? -1 : amount\n\n    let count = 0\n    const shouldStopTraversal = async (entry) => {\n      count++\n      if (!entry) {\n        return false\n      }\n      if (count >= amountToIterate && amountToIterate !== -1) {\n        return true\n      }\n      if (end && Entry.isEqual(entry, end)) {\n        return true\n      }\n      return false\n    }\n\n    const useBuffer = end && amount !== -1 && !lt && !lte\n    const buffer = useBuffer ? new LRU(amount + 2) : null\n    let index = 0\n\n    const it = traverse(start, shouldStopTraversal)\n\n    for await (const entry of it) {\n      const skipFirst = (lt && Entry.isEqual(entry, start))\n      const skipLast = (gt && Entry.isEqual(entry, end))\n      const skip = skipFirst || skipLast\n      if (!skip) {\n        if (useBuffer) {\n          buffer.set(index++, entry.hash)\n        } else {\n          yield entry\n        }\n      }\n    }\n\n    if (useBuffer) {\n      const endIndex = buffer.keys.length\n      const startIndex = endIndex > amount ? endIndex - amount : 0\n      const keys = buffer.keys.slice(startIndex, endIndex)\n      for (const key of keys) {\n        const hash = buffer.get(key)\n        const entry = await get(hash)\n        yield entry\n      }\n    }\n  }\n\n  /**\n   * Clear all entries from the log and the underlying storages\n   * @memberof module:Log~Log\n   * @instance\n   */\n  const clear = async () => {\n    await _index.clear()\n    await _heads.clear()\n    await _entries.clear()\n  }\n\n  /**\n   * Close the log and underlying storages\n   * @memberof module:Log~Log\n   * @instance\n   */\n  const close = async () => {\n    await _index.close()\n    await _heads.close()\n    await _entries.close()\n  }\n\n  /**\n   * Check if an object is a Log.\n   * @param {Log} obj\n   * @return {boolean}\n   * @memberof module:Log~Log\n   * @instance\n   */\n  const isLog = (obj) => {\n    return obj && obj.id !== undefined &&\n      obj.clock !== undefined &&\n      obj.heads !== undefined &&\n      obj.values !== undefined &&\n      obj.access !== undefined &&\n      obj.identity !== undefined &&\n      obj.storage !== undefined\n  }\n\n  /**\n   * Get an array of references to multiple entries in the past.\n   * @param {Array<Entry>} heads An array of Log heads starting rom which the references are collected from.\n   * @param {number} amount The number of references to return.\n   * @return {Array<string>}\n   * @private\n   */\n  const getReferences = async (heads, amount = 0) => {\n    let refs = []\n    const shouldStopTraversal = async (entry) => {\n      return refs.length >= amount && amount !== -1\n    }\n    for await (const { hash } of traverse(heads, shouldStopTraversal)) {\n      refs.push(hash)\n    }\n    refs = refs.slice(heads.length + 1, amount)\n    return refs\n  }\n\n  return {\n    id,\n    clock,\n    heads,\n    values,\n    all: values, // Alias for values()\n    get,\n    has,\n    append,\n    join,\n    joinEntry,\n    traverse,\n    iterator,\n    clear,\n    close,\n    access,\n    identity,\n    storage: _entries\n  }\n}\n\nexport { Log as default, DefaultAccessController, Clock }\n","/**\n* @module OrbitDB\n* @description Provides an interface for users to interact with OrbitDB.\n*/\nimport { getDatabaseType } from './databases/index.js'\nimport KeyStore from './key-store.js'\nimport { Identities } from './identities/index.js'\nimport OrbitDBAddress, { isValidAddress } from './address.js'\nimport ManifestStore from './manifest-store.js'\nimport { createId } from './utils/index.js'\nimport pathJoin from './utils/path-join.js'\nimport { getAccessController } from './access-controllers/index.js'\nimport IPFSAccessController from './access-controllers/ipfs.js'\n\nconst DefaultDatabaseType = 'events'\n\nconst DefaultAccessController = IPFSAccessController\n\n/**\n * Creates an instance of OrbitDB.\n * @function createOrbitDB\n * @param {Object} params One or more parameters for configuring OrbitDB.\n * @param {IPFS} params.ipfs An IPFS instance.\n * @param {string} [params.id] The id of the identity to use for this OrbitDB instance.\n * @param {module:Identity|Object} [params.identity] An identity instance or an object containing an Identity Provider instance and any additional params required to create the identity using the specified provider.\n * @param {Function} [params.identity.provider] An initialized identity provider.\n * @param {module:Identities} [params.identities] An Identities system instance.\n * @param {string} [params.directory] A location for storing OrbitDB data.\n * @return {module:OrbitDB~OrbitDB} An instance of OrbitDB.\n * @throws \"IPFS instance is required argument\" if no IPFS instance is provided.\n * @instance\n */\nconst OrbitDB = async ({ ipfs, id, identity, identities, directory } = {}) => {\n  /**\n   * @namespace module:OrbitDB~OrbitDB\n   * @description The instance returned by {@link module:OrbitDB}.\n   */\n\n  if (ipfs == null) {\n    throw new Error('IPFS instance is a required argument.')\n  }\n\n  id = id || await createId()\n  const peerId = ipfs.libp2p.peerId\n  directory = directory || './orbitdb'\n\n  let keystore\n\n  if (identities) {\n    keystore = identities.keystore\n  } else {\n    keystore = await KeyStore({ path: pathJoin(directory, './keystore') })\n    identities = await Identities({ ipfs, keystore })\n  }\n\n  if (identity) {\n    if (identity.provider) {\n      identity = await identities.createIdentity({ ...identity })\n    }\n  } else {\n    identity = await identities.createIdentity({ id })\n  }\n\n  const manifestStore = await ManifestStore({ ipfs })\n\n  let databases = {}\n\n  /**\n   * Open a database or create one if it does not already exist.\n   *\n   * By default, OrbitDB will create a database of type [DefaultDatabaseType]{@link module:OrbitDB~DefaultDatabaseType}:\n   * ```\n   * const mydb = await orbitdb.open('mydb')\n   * ```\n   * To create a database of a different type, specify the type param:\n   * ```\n   * const mydb = await orbitdb.open('mydb', {type: 'documents'})\n   * ```\n   * The type must be listed in [databaseTypes]{@link module:OrbitDB.databaseTypes} or an error is thrown.\n   * To open an existing database, pass its address to the `open` function:\n   * ```\n   * const existingDB = await orbitdb.open(dbAddress)\n   * ```\n   * The address of a newly created database can be retrieved using\n   * `db.address`.\n   * @function\n   * @param {string} address The address of an existing database to open, or\n   * the name of a new database.\n   * @param {Object} params One or more database configuration parameters.\n   * @param {string} [params.type=events] The database's type.\n   * @param {*} [params.meta={}] The database's metadata. Only applies when\n   * creating a database and is not used when opening an existing database.\n   * @param {boolean} [params.sync=true] If true, sync databases automatically.\n   * Otherwise, false.\n   * @param {module:Database} [params.Database=[Events]{@link module:Database.Database-Events}] A Database-compatible\n   * module.\n   * @param {module:AccessControllers}\n   * [params.AccessController=[IPFSAccessController]{@link module:AccessControllers.AccessControllers-IPFS}]\n   * An AccessController-compatible module.\n   * @param {module:Storage} [params.headsStorage=[ComposedStorage]{@link module:Storage.Storage-Composed}] A compatible storage instance for storing\n   * log heads. Defaults to ComposedStorage(LRUStorage, LevelStorage).\n   * @param {module:Storage} [params.entryStorage=[ComposedStorage]{@link module:Storage.Storage-Composed}] A compatible storage instance for storing\n   * log entries. Defaults to ComposedStorage(LRUStorage, IPFSBlockStorage).\n   * @param {module:Storage} [params.indexStorage=[ComposedStorage]{@link module:Storage.Storage-Composed}] A compatible storage instance for storing an \" index of log entries. Defaults to ComposedStorage(LRUStorage, LevelStorage).\n   * @param {number} [params.referencesCount] The number of references to\n   * use for [Log]{@link module:Log} entries.\n   * @memberof module:OrbitDB\n   * @return {module:Database} A database instance.\n   * @throws \"Unsupported database type\" if the type specified is not in the list\n   * of known databaseTypes.\n   * @memberof module:OrbitDB~OrbitDB\n   * @instance\n   * @async\n   */\n  const open = async (address, { type, meta, sync, Database, AccessController, headsStorage, entryStorage, indexStorage, referencesCount } = {}) => {\n    let name, manifest, accessController\n\n    if (databases[address]) {\n      return databases[address]\n    }\n\n    if (isValidAddress(address)) {\n      // If the address given was a valid OrbitDB address, eg. '/orbitdb/zdpuAuK3BHpS7NvMBivynypqciYCuy2UW77XYBPUYRnLjnw13'\n      const addr = OrbitDBAddress(address)\n      manifest = await manifestStore.get(addr.hash)\n      const acType = manifest.accessController.split('/', 2).pop()\n      AccessController = getAccessController(acType)()\n      accessController = await AccessController({ orbitdb: { open, identity, ipfs }, identities, address: manifest.accessController })\n      name = manifest.name\n      type = type || manifest.type\n      meta = manifest.meta\n    } else {\n      // If the address given was not valid, eg. just the name of the database\n      type = type || DefaultDatabaseType\n      AccessController = AccessController || DefaultAccessController()\n      accessController = await AccessController({ orbitdb: { open, identity, ipfs }, identities, name: address })\n      const m = await manifestStore.create({ name: address, type, accessController: accessController.address, meta })\n      manifest = m.manifest\n      address = OrbitDBAddress(m.hash)\n      name = manifest.name\n      meta = manifest.meta\n      // Check if we already have the database open and return if it is\n      if (databases[address]) {\n        return databases[address]\n      }\n    }\n\n    Database = Database || getDatabaseType(type)()\n\n    if (!Database) {\n      throw new Error(`Unsupported database type: '${type}'`)\n    }\n\n    address = address.toString()\n\n    const db = await Database({ ipfs, identity, address, name, access: accessController, directory, meta, syncAutomatically: sync, headsStorage, entryStorage, indexStorage, referencesCount })\n\n    db.events.on('close', onDatabaseClosed(address))\n\n    databases[address] = db\n\n    return db\n  }\n\n  const onDatabaseClosed = (address) => () => {\n    delete databases[address]\n  }\n\n  /**\n   * Stops OrbitDB, closing the underlying keystore and manifest store.\n   * @function stop\n   * @memberof module:OrbitDB~OrbitDB\n   * @instance\n   * @async\n   */\n  const stop = async () => {\n    for (const db of Object.values(databases)) {\n      await db.close()\n    }\n    if (keystore) {\n      await keystore.close()\n    }\n    if (manifestStore) {\n      await manifestStore.close()\n    }\n    databases = {}\n  }\n\n  return {\n    id,\n    open,\n    stop,\n    ipfs,\n    directory,\n    keystore,\n    identities,\n    identity,\n    peerId\n  }\n}\n\nexport { OrbitDB as default, OrbitDBAddress }\n","/**\n * @namespace Storage-Composed\n * @memberof module:Storage\n * @description\n * ComposedStorage stores data to multiple storage backends.\n * @example <caption>Store to LRU and Level</caption>\n * await ComposedStorage(await LRUStorage(), await LevelStorage())\n * @example <caption>Store to memory and IPFS</caption>\n * await ComposedStorage(await MemoryStorage(), await IPFSBlockStorage())\n * @example <caption>Store to LRU and a nested ComposedStorage</caption>\n * const storage1 = await ComposedStorage(await LRUStorage(), await LevelStorage())\n * await ComposedStorage(storage1, await IPFSBlockStorage())\n */\n\n/**\n  * Creates an instance of ComposedStorage.\n  * @function\n  * @param {module:Storage} storage1 A storage instance.\n  * @param {module:Storage} storage2 A storage instance.\n  * @return {module:Storage.Storage-Composed} An instance of ComposedStorage.\n  * @memberof module:Storage\n  * @instance\n  */\nconst ComposedStorage = async (storage1, storage2) => {\n  /**\n   * Puts data to all configured storages.\n   * @function\n   * @param {string} hash The hash of the data to put.\n   * @param {*} data The data to store.\n   * @memberof module:Storage.Storage-Composed\n   * @instance\n   */\n  const put = async (hash, data) => {\n    await storage1.put(hash, data)\n    await storage2.put(hash, data)\n  }\n\n  /**\n   * Gets data from the composed storage.\n   *\n   * Get will fetch the data from storage1 first. If no value is found, an\n   * attempt is made to fetch the data from storage2. If data exists in\n   * storage2 but not in storage1, the data is added to storage1.\n   * @function\n   * @param {string} hash The hash of the data to get.\n   * @memberof module:Storage.Storage-Composed\n   * @instance\n   */\n  const get = async (hash) => {\n    let value = await storage1.get(hash)\n    if (!value) {\n      value = await storage2.get(hash)\n      if (value) {\n        await storage1.put(hash, value)\n      }\n    }\n    return value\n  }\n\n  /**\n   * Deletes a value from storage.\n   * @function\n   * @param {string} hash The hash of the value to delete.\n   * @memberof module:Storage.Storage-Composed\n   * @instance\n   */\n  const del = async (hash) => {\n    await storage1.del(hash)\n    await storage2.del(hash)\n  }\n\n  /**\n   * Iterates over records stored in both storages.\n   * @function\n   * @yields [string, string] The next key/value pair from all storages.\n   * @memberof module:Storage.Storage-Composed\n   * @instance\n   */\n  const iterator = async function * ({ amount, reverse } = {}) {\n    const keys = []\n    const iteratorOptions = { amount: amount || -1, reverse: reverse || false }\n    for (const storage of [storage1, storage2]) {\n      for await (const [key, value] of storage.iterator(iteratorOptions)) {\n        if (!keys[key]) {\n          keys[key] = true\n          yield [key, value]\n        }\n      }\n    }\n  }\n\n  /**\n   * Merges data from another source into each of the composed storages.\n   * @function\n   * @param {module:Storage} other Another storage instance.\n   * @memberof module:Storage.Storage-Composed\n   * @instance\n   */\n  const merge = async (other) => {\n    await storage1.merge(other)\n    await storage2.merge(other)\n    await other.merge(storage1)\n    await other.merge(storage2)\n  }\n\n  /**\n   * Calls clear on each of the composed storages.\n   * @function\n   * @memberof module:Storage.Storage-Composed\n   * @instance\n   */\n  const clear = async () => {\n    await storage1.clear()\n    await storage2.clear()\n  }\n\n  /**\n   * Calls close on each of the composed storages.\n   * @function\n   * @memberof module:Storage.Storage-Composed\n   * @instance\n   */\n  const close = async () => {\n    await storage1.close()\n    await storage2.close()\n  }\n\n  return {\n    put,\n    get,\n    del,\n    iterator,\n    merge,\n    clear,\n    close\n  }\n}\n\nexport default ComposedStorage\n","/**\n * @module Storage\n * @description\n * Storage backends for OrbitDB.\n */\nexport { default as ComposedStorage } from './composed.js'\nexport { default as IPFSBlockStorage } from './ipfs-block.js'\nexport { default as LevelStorage } from './level.js'\nexport { default as LRUStorage } from './lru.js'\nexport { default as MemoryStorage } from './memory.js'\n","/**\n * @namespace Storage-IPFS\n * @memberof module:Storage\n * @description\n * IPFSBlockStorage uses IPFS to store data as raw blocks.\n */\nimport { CID } from 'multiformats/cid'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport drain from 'it-drain'\n\nconst DefaultTimeout = 30000 // 30 seconds\n\n/**\n * Creates an instance of IPFSBlockStorage.\n * @function\n * @param {Object} params One or more parameters for configuring\n * IPFSBlockStorage.\n * @param {IPFS} params.ipfs An IPFS instance.\n * @param {boolean} [params.pin=false] True, if the block should be pinned,\n * false otherwise.\n * @param {number} [params.timeout=defaultTimeout] A timeout in ms.\n * @return {module:Storage.Storage-IPFS} An instance of IPFSBlockStorage.\n * @memberof module:Storage\n * @throw An instance of ipfs is required if params.ipfs is not specified.\n * @instance\n */\nconst IPFSBlockStorage = async ({ ipfs, pin, timeout } = {}) => {\n  if (!ipfs) throw new Error('An instance of ipfs is required.')\n\n  /**\n   * Puts data to an IPFS block.\n   * @function\n   * @param {string} hash The hash of the block to put.\n   * @param {*} data The data to store in the IPFS block.\n   * @memberof module:Storage.Storage-IPFS\n   * @instance\n   */\n  const put = async (hash, data) => {\n    const cid = CID.parse(hash, base58btc)\n    const { signal } = new TimeoutController(timeout || DefaultTimeout)\n    await ipfs.blockstore.put(cid, data, { signal })\n\n    if (pin && !(await ipfs.pins.isPinned(cid))) {\n      await drain(ipfs.pins.add(cid))\n    }\n  }\n\n  const del = async (hash) => {}\n\n  /**\n   * Gets data from an IPFS block.\n   * @function\n   * @param {string} hash The hash of the block to get.\n   * @return {Uint8Array} The block.\n   * @memberof module:Storage.Storage-IPFS\n   * @instance\n   */\n  const get = async (hash) => {\n    const cid = CID.parse(hash, base58btc)\n    const { signal } = new TimeoutController(timeout || DefaultTimeout)\n    const block = await ipfs.blockstore.get(cid, { signal })\n    if (block) {\n      return block\n    }\n  }\n\n  const iterator = async function * () {}\n\n  const merge = async (other) => {}\n\n  const clear = async () => {}\n\n  const close = async () => {}\n\n  return {\n    put,\n    del,\n    get,\n    iterator,\n    merge,\n    clear,\n    close\n  }\n}\n\nexport default IPFSBlockStorage\n","/**\n * @namespace Storage-Level\n * @memberof module:Storage\n * @description\n * LevelStorage stores data to a Level-compatible database.\n *\n * To learn more about Level, see {@link https://github.com/Level/level}.\n */\nimport { Level } from 'level'\n\nconst defaultPath = './level'\nconst defaultValueEncoding = 'view'\n\n/**\n * Creates an instance of LevelStorage.\n * @function\n * @param {Object} [params={}] One or more parameters for configuring\n * LevelStorage.\n * @param {string} [params.path=defaultPath] The Level path.\n * @param {string} [params.valueEncoding=defaultValueEncoding] Value encoding.\n * @return {module:Storage.Storage-Level} An instance of LevelStorage.\n * @memberof module:Storage\n * @instance\n */\nconst LevelStorage = async ({ path, valueEncoding } = {}) => {\n  path = path || defaultPath\n  valueEncoding = valueEncoding || defaultValueEncoding\n\n  const db = new Level(path, { valueEncoding, passive: true })\n  await db.open()\n\n  /**\n   * Puts data to Level.\n   * @function\n   * @param {string} hash The hash of the data to put.\n   * @param {*} data The data to store.\n   * @memberof module:Storage.Storage-Level\n   * @instance\n   */\n  const put = async (hash, value) => {\n    await db.put(hash, value)\n  }\n\n  /**\n   * Deletes data from Level.\n   * @function\n   * @param {string} hash The hash of the data to delete.\n   * @param {*} data The data to store.\n   * @memberof module:Storage.Storage-Level\n   * @instance\n   */\n  const del = async (hash) => {\n    await db.del(hash)\n  }\n\n  /**\n   * Gets data from Level.\n   * @function\n   * @param {string} hash The hash of the data to get.\n   * @memberof module:Storage.Storage-Level\n   * @instance\n   */\n  const get = async (hash) => {\n    try {\n      const value = await db.get(hash)\n      if (value) {\n        return value\n      }\n    } catch (e) {\n      // LEVEL_NOT_FOUND (ie. key not found)\n    }\n  }\n\n  /**\n   * Iterates over records stored in Level.\n   * @function\n   * @yields [string, string] The next key/value pair from Level.\n   * @memberof module:Storage.Storage-Level\n   * @instance\n   */\n  const iterator = async function * ({ amount, reverse } = {}) {\n    const iteratorOptions = { limit: amount || -1, reverse: reverse || false }\n    for await (const [key, value] of db.iterator(iteratorOptions)) {\n      yield [key, value]\n    }\n  }\n  const merge = async (other) => {}\n\n  /**\n  * Clears the contents of the Level db.\n  * @function\n  * @memberof module:Storage.Storage-Level\n  * @instance\n  */\n  const clear = async () => {\n    await db.clear()\n  }\n\n  /**\n  * Closes the Level db.\n  * @function\n  * @memberof module:Storage.Storage-Level\n  * @instance\n  */\n  const close = async () => {\n    await db.close()\n  }\n\n  return {\n    put,\n    del,\n    get,\n    iterator,\n    merge,\n    clear,\n    close\n  }\n}\n\nexport default LevelStorage\n","/**\n * @namespace Storage-LRU\n * @memberof module:Storage\n * @description\n * LRUStorage stores data in a Least Recently Used (LRU) cache.\n */\nimport LRU from 'lru'\n\nconst defaultSize = 1000000\n\n/**\n * Creates an instance of LRUStorage.\n * @function\n * @param {Object} [params={}] One or more parameters for configuring\n * LRUStorage.\n * @param {string} [params.size=defaultSize] The number of elements to store.\n * @return {module:Storage.Storage-LRU} An instance of LRUStorage.\n * @memberof module:Storage\n * @instance\n */\nconst LRUStorage = async ({ size } = {}) => {\n  let lru = new LRU(size || defaultSize)\n\n  /**\n   * Puts data to the LRU cache.\n   * @function\n   * @param {string} hash The hash of the data to put.\n   * @param {*} data The data to store.\n   * @memberof module:Storage.Storage-LRU\n   * @instance\n   */\n  const put = async (hash, data) => {\n    lru.set(hash, data)\n  }\n\n  /**\n   * Deletes data from the LRU cache.\n   * @function\n   * @param {string} hash The hash of the data to delete.\n   * @memberof module:Storage.Storage-LRU\n   * @instance\n   */\n  const del = async (hash) => {\n    lru.remove(hash)\n  }\n\n  /**\n   * Gets data from the LRU cache.\n   * @function\n   * @param {string} hash The hash of the data to get.\n   * @memberof module:Storage.Storage-LRU\n   * @instance\n   */\n  const get = async (hash) => {\n    return lru.get(hash)\n  }\n\n  /**\n   * Iterates over records stored in the LRU cache.\n   * @function\n   * @yields [string, string] The next key/value pair from the LRU cache.\n   * @memberof module:Storage.Storage-LRU\n   * @instance\n   */\n  const iterator = async function * () {\n    for await (const key of lru.keys) {\n      const value = lru.get(key)\n      yield [key, value]\n    }\n  }\n\n  /**\n   * Merges data from another source into the LRU cache.\n   * @function\n   * @param {module:Storage} other Another storage instance.\n   * @memberof module:Storage.Storage-LRU\n   * @instance\n   */\n  const merge = async (other) => {\n    if (other) {\n      for await (const [key, value] of other.iterator()) {\n        lru.set(key, value)\n      }\n    }\n  }\n\n  /**\n  * Clears the contents of the LRU cache.\n  * @function\n  * @memberof module:Storage.Storage-LRU\n  * @instance\n  */\n  const clear = async () => {\n    lru = new LRU(size || defaultSize)\n  }\n\n  const close = async () => {}\n\n  return {\n    put,\n    del,\n    get,\n    iterator,\n    merge,\n    clear,\n    close\n  }\n}\n\nexport default LRUStorage\n","/**\n * @namespace Storage-Memory\n * @memberof module:Storage\n * @description\n * MemoryStorage stores data in memory.\n */\n\n/**\n  * Creates an instance of MemoryStorage.\n  * @function\n  * @return {module:Storage.Storage-Memory} An instance of MemoryStorage.\n  * @memberof module:Storage\n  * @instance\n  */\nconst MemoryStorage = async () => {\n  let memory = {}\n\n  /**\n   * Puts data to memory.\n   * @function\n   * @param {string} hash The hash of the data to put.\n   * @param {*} data The data to store.\n   * @memberof module:Storage.Storage-Memory\n   * @instance\n   */\n  const put = async (hash, data) => {\n    memory[hash] = data\n  }\n\n  /**\n   * Deletes data from memory.\n   * @function\n   * @param {string} hash The hash of the data to delete.\n   * @memberof module:Storage.Storage-Memory\n   * @instance\n   */\n  const del = async (hash) => {\n    delete memory[hash]\n  }\n\n  /**\n   * Gets data from memory.\n   * @function\n   * @param {string} hash The hash of the data to get.\n   * @memberof module:Storage.Storage-Memory\n   * @instance\n   */\n  const get = async (hash) => {\n    return memory[hash]\n  }\n\n  /**\n   * Iterates over records stored in memory.\n   * @function\n   * @yields [string, string] The next key/value pair from memory.\n   * @memberof module:Storage.Storage-Memory\n   * @instance\n   */\n  const iterator = async function * () {\n    for await (const [key, value] of Object.entries(memory)) {\n      yield [key, value]\n    }\n  }\n\n  /**\n   * Merges data from another source into memory.\n   * @function\n   * @param {module:Storage} other Another storage instance.\n   * @memberof module:Storage.Storage-Memory\n   * @instance\n   */\n  const merge = async (other) => {\n    if (other) {\n      for await (const [key, value] of other.iterator()) {\n        put(key, value)\n      }\n    }\n  }\n\n  /**\n  * Clears the contents of memory.\n  * @function\n  * @memberof module:Storage.Storage-Memory\n  * @instance\n  */\n  const clear = async () => {\n    memory = {}\n  }\n\n  const close = async () => {}\n\n  return {\n    put,\n    del,\n    get,\n    iterator,\n    merge,\n    clear,\n    close\n  }\n}\n\nexport default MemoryStorage\n","import { pipe } from 'it-pipe'\nimport PQueue from 'p-queue'\nimport { EventEmitter } from 'events'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport pathJoin from './utils/path-join.js'\n\nconst DefaultTimeout = 30000 // 30 seconds\n\n/**\n * @module Sync\n * @description\n * The Sync Protocol for OrbitDB synchronizes the database operations {@link module:Log} between multiple peers.\n *\n * The Sync Protocol sends and receives heads between multiple peers,\n * both when opening a database and when a database is updated, ie.\n * new entries are appended to the log.\n *\n * When Sync is started, a peer subscribes to a pubsub topic of the log's id.\n * Upon subscribing to the topic, peers already connected to the topic receive\n * the subscription message and \"dial\" the subscribing peer using a libp2p\n * custom protocol. Once connected to the subscribing peer on a direct\n * peer-to-peer connection, the dialing peer and the subscribing peer exchange\n * the heads of the Log each peer currently has. Once completed, the peers have\n * the same \"local state\".\n *\n * Once the initial sync has completed, peers notify one another of updates to\n * the log, ie. updates to the database, using the initially opened pubsub\n * topic subscription. A peer with new heads broadcasts changes to other peers\n * by publishing the updated heads to the pubsub topic. Peers subscribed to the\n * same topic will then receive the update and will update their log's state,\n * the heads, accordingly.\n *\n * The Sync Protocol is eventually consistent. It guarantees that once all\n * messages have been sent and received, peers will observe the same log state\n * and values. The Sync Protocol does not guarantee the order in which messages\n * are received or even that a message is recieved at all, nor any timing on\n * when messages are received.\n *\n * @example\n * // Using defaults\n * const sync = await Sync({ ipfs, log, onSynced: (peerId, heads) => ... })\n *\n * @example\n * // Using all parameters\n * const sync = await Sync({ ipfs, log, events, onSynced: (peerId, heads) => ..., start: false })\n * sync.events.on('join', (peerId, heads) => ...)\n * sync.events.on('leave', (peerId) => ...)\n * sync.events.on('error', (err) => ...)\n * await sync.start()\n */\n\n/**\n * Creates a Sync instance for sychronizing logs between multiple peers.\n *\n * @function\n * @param {Object} params One or more parameters for configuring Sync.\n * @param {IPFS} params.ipfs An IPFS instance.\n * @param {Log} params.log The log instance to sync.\n * @param {EventEmitter} [params.events] An event emitter to use. Events\n * emitted are 'join', 'leave' and 'error'. If the parameter is not provided,\n * an EventEmitter will be created.\n * @param {onSynced} [params.onSynced] A callback function that is called after\n * the peer has received heads from another peer.\n * @param {Boolean} [params.start] True if sync should start automatically,\n * false otherwise. Defaults to true.\n * @return {module:Sync~Sync} sync An instance of the Sync Protocol.\n * @memberof module:Sync\n * @instance\n */\nconst Sync = async ({ ipfs, log, events, onSynced, start, timeout }) => {\n  /**\n   * @namespace module:Sync~Sync\n   * @description The instance returned by {@link module:Sync}.\n   */\n\n  /**\n   * Callback function when new heads have been received from other peers.\n   * @callback module:Sync~Sync#onSynced\n   * @param {PeerID} peerId PeerID of the peer who we received heads from\n   * @param {Entry[]} heads An array of Log entries\n   */\n\n  /**\n   * Event fired when when a peer has connected and the exchange of\n   * heads has been completed.\n   * @event module:Sync~Sync#join\n   * @param {PeerID} peerId PeerID of the peer who we received heads from\n   * @param {Entry[]} heads An array of Log entries\n   * @example\n   * sync.events.on('join', (peerID, heads) => ...)\n   */\n\n  /**\n   * Event fired when a peer leaves the sync protocol.\n   * @event module:Sync~Sync#leave\n   * @param {PeerID} peerId PeerID of the peer who left\n   * @example\n   * sync.events.on('leave', (peerID) => ...)\n   */\n\n  /**\n   * Event fired when an error occurs.\n   * @event module:Sync~Sync#error\n   * @param {Error} error The error that occured\n   * @example\n   * sync.events.on('error', (error) => ...)\n   */\n\n  if (!ipfs) throw new Error('An instance of ipfs is required.')\n  if (!log) throw new Error('An instance of log is required.')\n\n  const libp2p = ipfs.libp2p\n  const pubsub = ipfs.libp2p.services.pubsub\n\n  const address = log.id\n  const headsSyncAddress = pathJoin('/orbitdb/heads/', address)\n\n  const queue = new PQueue({ concurrency: 1 })\n\n  /**\n   * Set of currently connected peers for the log for this Sync instance.\n   * @name peers\n   * @ype Set\n   * @memberof module:Sync~Sync\n   * @instance\n   */\n  const peers = new Set()\n\n  /**\n   * Event emitter that emits Sync changes. See Events section for details.\n   * @ype EventEmitter\n   * @memberof module:Sync~Sync\n   * @instance\n   */\n  events = events || new EventEmitter()\n\n  timeout = timeout || DefaultTimeout\n\n  let started = false\n\n  const onPeerJoined = async (peerId) => {\n    const heads = await log.heads()\n    events.emit('join', peerId, heads)\n  }\n\n  const sendHeads = (source) => {\n    return (async function * () {\n      const heads = await log.heads()\n      for await (const { bytes } of heads) {\n        yield bytes\n      }\n    })()\n  }\n\n  const receiveHeads = (peerId) => async (source) => {\n    for await (const value of source) {\n      const headBytes = value.subarray()\n      if (headBytes && onSynced) {\n        await onSynced(headBytes)\n      }\n    }\n    if (started) {\n      await onPeerJoined(peerId)\n    }\n  }\n\n  const handleReceiveHeads = async ({ connection, stream }) => {\n    const peerId = String(connection.remotePeer)\n    try {\n      peers.add(peerId)\n      await pipe(stream, receiveHeads(peerId), sendHeads, stream)\n    } catch (e) {\n      peers.delete(peerId)\n      events.emit('error', e)\n    }\n  }\n\n  const handlePeerSubscribed = async (event) => {\n    const task = async () => {\n      const { peerId: remotePeer, subscriptions } = event.detail\n      const peerId = String(remotePeer)\n      const subscription = subscriptions.find(e => e.topic === address)\n      if (!subscription) {\n        return\n      }\n      if (subscription.subscribe) {\n        if (peers.has(peerId)) {\n          return\n        }\n        const timeoutController = new TimeoutController(timeout)\n        const { signal } = timeoutController\n        try {\n          peers.add(peerId)\n          const stream = await libp2p.dialProtocol(remotePeer, headsSyncAddress, { signal })\n          await pipe(sendHeads, stream, receiveHeads(peerId))\n        } catch (e) {\n          console.error(e)\n          peers.delete(peerId)\n          if (e.code === 'ERR_UNSUPPORTED_PROTOCOL') {\n            // Skip peer, they don't have this database currently\n          } else {\n            events.emit('error', e)\n          }\n        } finally {\n          if (timeoutController) {\n            timeoutController.clear()\n          }\n        }\n      } else {\n        peers.delete(peerId)\n        events.emit('leave', peerId)\n      }\n    }\n    queue.add(task)\n  }\n\n  const handleUpdateMessage = async message => {\n    const { topic, data } = message.detail\n\n    const task = async () => {\n      try {\n        if (data && onSynced) {\n          await onSynced(data)\n        }\n      } catch (e) {\n        events.emit('error', e)\n      }\n    }\n\n    if (topic === address) {\n      queue.add(task)\n    }\n  }\n\n  /**\n   * Add a log entry to the Sync Protocol to be sent to peers.\n   * @function add\n   * @param {Entry} entry Log entry\n   * @memberof module:Sync~Sync\n   * @instance\n   */\n  const add = async (entry) => {\n    if (started) {\n      await pubsub.publish(address, entry.bytes)\n    }\n  }\n\n  /**\n   * Stop the Sync Protocol.\n   * @function stop\n   * @memberof module:Sync~Sync\n   * @instance\n   */\n  const stopSync = async () => {\n    if (started) {\n      started = false\n      await queue.onIdle()\n      pubsub.removeEventListener('subscription-change', handlePeerSubscribed)\n      pubsub.removeEventListener('message', handleUpdateMessage)\n      await libp2p.unhandle(headsSyncAddress)\n      await pubsub.unsubscribe(address)\n      peers.clear()\n    }\n  }\n\n  /**\n   * Start the Sync Protocol.\n   * @function start\n   * @memberof module:Sync~Sync\n   * @instance\n   */\n  const startSync = async () => {\n    if (!started) {\n      // Exchange head entries with peers when connected\n      await libp2p.handle(headsSyncAddress, handleReceiveHeads)\n      pubsub.addEventListener('subscription-change', handlePeerSubscribed)\n      pubsub.addEventListener('message', handleUpdateMessage)\n      // Subscribe to the pubsub channel for this database through which updates are sent\n      await pubsub.subscribe(address)\n      started = true\n    }\n  }\n\n  // Start Sync automatically\n  if (start !== false) {\n    await startSync()\n  }\n\n  return {\n    add,\n    stop: stopSync,\n    start: startSync,\n    events,\n    peers\n  }\n}\n\nexport { Sync as default }\n","const createId = async (length = 32) => {\n  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'\n  let result = ''\n  let counter = 0\n  while (counter < length) {\n    result += characters.charAt(Math.floor(Math.random() * characters.length))\n    counter += 1\n  }\n  return result\n}\n\nexport default createId\n","import createId from './create-id.js'\n\nexport {\n  createId\n}\n","export const posixJoin = (...paths) => paths\n  .join('/')\n  .replace(/((?<=\\/)\\/+)|(^\\.\\/)|((?<=\\/)\\.\\/)/g, '') || '.'\n\nexport const win32Join = (...paths) => paths\n  .join('\\\\')\n  .replace(/\\//g, '\\\\')\n  .replace(/((?<=\\\\)\\\\+)|(^\\.\\\\)|((?<=\\\\)\\.\\\\)/g, '') || '.'\n\nexport const join = posixJoin\n\nexport default posixJoin\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export {\n  default as createOrbitDB\n} from './orbitdb.js'\n\nexport {\n  Documents,\n  Events,\n  KeyValue,\n  KeyValueIndexed,\n  useDatabaseType\n} from './databases/index.js'\n\nexport {\n  isValidAddress,\n  parseAddress\n} from './address.js'\n\nexport { Log, Entry, DefaultAccessController } from './oplog/index.js'\n\nexport { default as Database } from './database.js'\n\nexport { default as KeyStore } from './key-store.js'\n\nexport {\n  useAccessController,\n  IPFSAccessController,\n  OrbitDBAccessController\n} from './access-controllers/index.js'\n\nexport {\n  Identities,\n  isIdentity,\n  useIdentityProvider,\n  PublicKeyIdentityProvider\n} from './identities/index.js'\n\nexport {\n  IPFSBlockStorage,\n  LevelStorage,\n  LRUStorage,\n  MemoryStorage,\n  ComposedStorage\n} from './storage/index.js'\n"],"names":[],"sourceRoot":""}
./node_modules/@libp2p/webtransport/dist/index.min.js:2:"use strict";var Libp2PWebtransport=(()=>{var Lf=Object.create;var xn=Object.defineProperty;var Uf=Object.getOwnPropertyDescriptor;var _f=Object.getOwnPropertyNames;var Rf=Object.getPrototypeOf,Hf=Object.prototype.hasOwnProperty;var Pf=(r,t)=>()=>(t||r((t={exports:{}}).exports,t),t.exports),kt=(r,t)=>{for(var e in t)xn(r,e,{get:t[e],enumerable:!0})},tc=(r,t,e,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of _f(t))!Hf.call(r,s)&&s!==e&&xn(r,s,{get:()=>t[s],enumerable:!(n=Uf(t,s))||n.enumerable});return r};var Df=(r,t,e)=>(e=r!=null?Lf(Rf(r)):{},tc(t||!r||!r.__esModule?xn(e,"default",{value:r,enumerable:!0}):e,r)),Vf=r=>tc(xn({},"__esModule",{value:!0}),r);var rl=Pf(mr=>{"use strict";var cp="[object ArrayBuffer]",pe=class r{static isArrayBuffer(t){return Object.prototype.toString.call(t)===cp}static toArrayBuffer(t){return this.isArrayBuffer(t)?t:t.byteLength===t.buffer.byteLength||t.byteOffset===0&&t.byteLength===t.buffer.byteLength?t.buffer:this.toUint8Array(t.buffer).slice(t.byteOffset,t.byteOffset+t.byteLength).buffer}static toUint8Array(t){return this.toView(t,Uint8Array)}static toView(t,e){if(t.constructor===e)return t;if(this.isArrayBuffer(t))return new e(t);if(this.isArrayBufferView(t))return new e(t.buffer,t.byteOffset,t.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(t){return this.isArrayBufferView(t)||this.isArrayBuffer(t)}static isArrayBufferView(t){return ArrayBuffer.isView(t)||t&&this.isArrayBuffer(t.buffer)}static isEqual(t,e){let n=r.toUint8Array(t),s=r.toUint8Array(e);if(n.length!==s.byteLength)return!1;for(let o=0;o<n.length;o++)if(n[o]!==s[o])return!1;return!0}static concat(...t){let e;Array.isArray(t[0])&&!(t[1]instanceof Function)||Array.isArray(t[0])&&t[1]instanceof Function?e=t[0]:t[t.length-1]instanceof Function?e=t.slice(0,t.length-1):e=t;let n=0;for(let i of e)n+=i.byteLength;let s=new Uint8Array(n),o=0;for(let i of e){let a=this.toUint8Array(i);s.set(a,o),o+=a.length}return t[t.length-1]instanceof Function?this.toView(s,t[t.length-1]):s.buffer}},_i="string",lp=/^[0-9a-f\s]+$/i,up=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,fp=/^[a-zA-Z0-9-_]+$/,Wn=class{static fromString(t){let e=unescape(encodeURIComponent(t)),n=new Uint8Array(e.length);for(let s=0;s<e.length;s++)n[s]=e.charCodeAt(s);return n.buffer}static toString(t){let e=pe.toUint8Array(t),n="";for(let o=0;o<e.length;o++)n+=String.fromCharCode(e[o]);return decodeURIComponent(escape(n))}},$t=class{static toString(t,e=!1){let n=pe.toArrayBuffer(t),s=new DataView(n),o="";for(let i=0;i<n.byteLength;i+=2){let a=s.getUint16(i,e);o+=String.fromCharCode(a)}return o}static fromString(t,e=!1){let n=new ArrayBuffer(t.length*2),s=new DataView(n);for(let o=0;o<t.length;o++)s.setUint16(o*2,t.charCodeAt(o),e);return n}},jn=class r{static isHex(t){return typeof t===_i&&lp.test(t)}static isBase64(t){return typeof t===_i&&up.test(t)}static isBase64Url(t){return typeof t===_i&&fp.test(t)}static ToString(t,e="utf8"){let n=pe.toUint8Array(t);switch(e.toLowerCase()){case"utf8":return this.ToUtf8String(n);case"binary":return this.ToBinary(n);case"hex":return this.ToHex(n);case"base64":return this.ToBase64(n);case"base64url":return this.ToBase64Url(n);case"utf16le":return $t.toString(n,!0);case"utf16":case"utf16be":return $t.toString(n);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromString(t,e="utf8"){if(!t)return new ArrayBuffer(0);switch(e.toLowerCase()){case"utf8":return this.FromUtf8String(t);case"binary":return this.FromBinary(t);case"hex":return this.FromHex(t);case"base64":return this.FromBase64(t);case"base64url":return this.FromBase64Url(t);case"utf16le":return $t.fromString(t,!0);case"utf16":case"utf16be":return $t.fromString(t);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToBase64(t){let e=pe.toUint8Array(t);if(typeof btoa<"u"){let n=this.ToString(e,"binary");return btoa(n)}else return Buffer.from(e).toString("base64")}static FromBase64(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isBase64(e))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return typeof atob<"u"?this.FromBinary(atob(e)):new Uint8Array(Buffer.from(e,"base64")).buffer}static FromBase64Url(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isBase64Url(e))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(e.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(t){return this.ToBase64(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(t,e=r.DEFAULT_UTF8_ENCODING){switch(e){case"ascii":return this.FromBinary(t);case"utf8":return Wn.fromString(t);case"utf16":case"utf16be":return $t.fromString(t);case"utf16le":case"usc2":return $t.fromString(t,!0);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToUtf8String(t,e=r.DEFAULT_UTF8_ENCODING){switch(e){case"ascii":return this.ToBinary(t);case"utf8":return Wn.toString(t);case"utf16":case"utf16be":return $t.toString(t);case"utf16le":case"usc2":return $t.toString(t,!0);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromBinary(t){let e=t.length,n=new Uint8Array(e);for(let s=0;s<e;s++)n[s]=t.charCodeAt(s);return n.buffer}static ToBinary(t){let e=pe.toUint8Array(t),n="";for(let s=0;s<e.length;s++)n+=String.fromCharCode(e[s]);return n}static ToHex(t){let e=pe.toUint8Array(t),n="",s=e.length;for(let o=0;o<s;o++){let i=e[o];i<16&&(n+="0"),n+=i.toString(16)}return n}static FromHex(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isHex(e))throw new TypeError("Argument 'hexString' is not HEX encoded");e.length%2&&(e=`0${e}`);let n=new Uint8Array(e.length/2);for(let s=0;s<e.length;s=s+2){let o=e.slice(s,s+2);n[s/2]=parseInt(o,16)}return n.buffer}static ToUtf16String(t,e=!1){return $t.toString(t,e)}static FromUtf16String(t,e=!1){return $t.fromString(t,e)}static Base64Padding(t){let e=4-t.length%4;if(e<4)for(let n=0;n<e;n++)t+="=";return t}static formatString(t){return t?.replace(/[\n\r\t ]/g,"")||""}};jn.DEFAULT_UTF8_ENCODING="utf8";function hp(r,...t){let e=arguments[0];for(let n=1;n<arguments.length;n++){let s=arguments[n];for(let o in s)e[o]=s[o]}return e}function dp(...r){let t=r.map(s=>s.byteLength).reduce((s,o)=>s+o),e=new Uint8Array(t),n=0;return r.map(s=>new Uint8Array(s)).forEach(s=>{for(let o of s)e[n++]=o}),e.buffer}function pp(r,t){if(!(r&&t)||r.byteLength!==t.byteLength)return!1;let e=new Uint8Array(r),n=new Uint8Array(t);for(let s=0;s<r.byteLength;s++)if(e[s]!==n[s])return!1;return!0}mr.BufferSourceConverter=pe;mr.Convert=jn;mr.assign=hp;mr.combine=dp;mr.isEqual=pp});var V0={};kt(V0,{webTransport:()=>D0});var Eo=Symbol.for("@libp2p/peer-id");var rc=Symbol.for("@libp2p/transport");var ec;(function(r){r[r.FATAL_ALL=0]="FATAL_ALL",r[r.NO_FATAL=1]="NO_FATAL"})(ec||(ec={}));var vn=class extends Error{static name="UnexpectedPeerError";constructor(t="Unexpected Peer"){super(t),this.name="UnexpectedPeerError"}},En=class extends Error{static name="InvalidCryptoExchangeError";constructor(t="Invalid crypto exchange"){super(t),this.name="InvalidCryptoExchangeError"}},yt=class extends Error{static name="InvalidParametersError";constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}},sr=class extends Error{static name="InvalidPublicKeyError";constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}};var Bn=class extends Error{static name="StreamResetError";constructor(t="The stream has been reset"){super(t),this.name="StreamResetError"}},An=class extends Error{static name="StreamStateError";constructor(t="The stream is in an invalid state"){super(t),this.name="StreamStateError"}};var Sn=class extends Error{static name="InvalidMultiaddrError";constructor(t="Invalid multiaddr"){super(t),this.name="InvalidMultiaddrError"}};var kn=class extends Error{static name="InvalidMultihashError";constructor(t="Invalid Multihash"){super(t),this.name="InvalidMultihashError"}};var Me=class extends Error{static name="UnsupportedKeyTypeError";constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}};var In=Symbol.for("@libp2p/service-capabilities"),$0=Symbol.for("@libp2p/service-dependencies");var Io={};kt(Io,{base58btc:()=>rt,base58flickr:()=>qf});var dg=new Uint8Array(0);function nc(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function ie(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function sc(r){return new TextEncoder().encode(r)}function oc(r){return new TextDecoder().decode(r)}function Mf(r,t){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),n=0;n<e.length;n++)e[n]=255;for(var s=0;s<r.length;s++){var o=r.charAt(s),i=o.charCodeAt(0);if(e[i]!==255)throw new TypeError(o+" is ambiguous");e[i]=s}var a=r.length,c=r.charAt(0),l=Math.log(a)/Math.log(256),f=Math.log(256)/Math.log(a);function u(w){if(w instanceof Uint8Array||(ArrayBuffer.isView(w)?w=new Uint8Array(w.buffer,w.byteOffset,w.byteLength):Array.isArray(w)&&(w=Uint8Array.from(w))),!(w instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(w.length===0)return"";for(var m=0,d=0,b=0,v=w.length;b!==v&&w[b]===0;)b++,m++;for(var p=(v-b)*f+1>>>0,k=new Uint8Array(p);b!==v;){for(var L=w[b],T=0,C=p-1;(L!==0||T<d)&&C!==-1;C--,T++)L+=256*k[C]>>>0,k[C]=L%a>>>0,L=L/a>>>0;if(L!==0)throw new Error("Non-zero carry");d=T,b++}for(var N=p-d;N!==p&&k[N]===0;)N++;for(var S=c.repeat(m);N<p;++N)S+=r.charAt(k[N]);return S}function h(w){if(typeof w!="string")throw new TypeError("Expected String");if(w.length===0)return new Uint8Array;var m=0;if(w[m]!==" "){for(var d=0,b=0;w[m]===c;)d++,m++;for(var v=(w.length-m)*l+1>>>0,p=new Uint8Array(v);w[m];){var k=e[w.charCodeAt(m)];if(k===255)return;for(var L=0,T=v-1;(k!==0||L<b)&&T!==-1;T--,L++)k+=a*p[T]>>>0,p[T]=k%256>>>0,k=k/256>>>0;if(k!==0)throw new Error("Non-zero carry");b=L,m++}if(w[m]!==" "){for(var C=v-b;C!==v&&p[C]===0;)C++;for(var N=new Uint8Array(d+(v-C)),S=d;C!==v;)N[S++]=p[C++];return N}}}function g(w){var m=h(w);if(m)return m;throw new Error(`Non-${t} character`)}return{encode:u,decodeUnsafe:h,decode:g}}var Of=Mf,Kf=Of,ac=Kf;var Bo=class{name;prefix;baseEncode;constructor(t,e,n){this.name=t,this.prefix=e,this.baseEncode=n}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}},Ao=class{name;prefix;baseDecode;prefixCodePoint;constructor(t,e,n){this.name=t,this.prefix=e;let s=e.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=n}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return cc(this,t)}},So=class{decoders;constructor(t){this.decoders=t}or(t){return cc(this,t)}decode(t){let e=t[0],n=this.decoders[e];if(n!=null)return n.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};function cc(r,t){return new So({...r.decoders??{[r.prefix]:r},...t.decoders??{[t.prefix]:t}})}var ko=class{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(t,e,n,s){this.name=t,this.prefix=e,this.baseEncode=n,this.baseDecode=s,this.encoder=new Bo(t,e,n),this.decoder=new Ao(t,e,s)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}};function or({name:r,prefix:t,encode:e,decode:n}){return new ko(r,t,e,n)}function Se({name:r,prefix:t,alphabet:e}){let{encode:n,decode:s}=ac(e,r);return or({prefix:t,name:r,encode:n,decode:o=>ie(s(o))})}function Ff(r,t,e,n){let s={};for(let f=0;f<t.length;++f)s[t[f]]=f;let o=r.length;for(;r[o-1]==="=";)--o;let i=new Uint8Array(o*e/8|0),a=0,c=0,l=0;for(let f=0;f<o;++f){let u=s[r[f]];if(u===void 0)throw new SyntaxError(`Non-${n} character`);c=c<<e|u,a+=e,a>=8&&(a-=8,i[l++]=255&c>>a)}if(a>=e||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return i}function $f(r,t,e){let n=t[t.length-1]==="=",s=(1<<e)-1,o="",i=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],i+=8;i>e;)i-=e,o+=t[s&a>>i];if(i!==0&&(o+=t[s&a<<e-i]),n)for(;o.length*e&7;)o+="=";return o}function ft({name:r,prefix:t,bitsPerChar:e,alphabet:n}){return or({prefix:t,name:r,encode(s){return $f(s,n,e)},decode(s){return Ff(s,n,e,r)}})}var rt=Se({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),qf=Se({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var Co={};kt(Co,{base32:()=>ae,base32hex:()=>jf,base32hexpad:()=>Yf,base32hexpadupper:()=>Xf,base32hexupper:()=>Zf,base32pad:()=>Gf,base32padupper:()=>Wf,base32upper:()=>zf,base32z:()=>Jf});var ae=ft({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),zf=ft({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Gf=ft({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Wf=ft({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),jf=ft({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Zf=ft({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Yf=ft({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Xf=ft({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Jf=ft({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var No={};kt(No,{base36:()=>_r,base36upper:()=>Qf});var _r=Se({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Qf=Se({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var Jt={};kt(Jt,{Digest:()=>Oe,create:()=>Kt,decode:()=>ke,equals:()=>Lo,hasCode:()=>wh});var th=fc,lc=128,eh=127,rh=~eh,nh=Math.pow(2,31);function fc(r,t,e){t=t||[],e=e||0;for(var n=e;r>=nh;)t[e++]=r&255|lc,r/=128;for(;r&rh;)t[e++]=r&255|lc,r>>>=7;return t[e]=r|0,fc.bytes=e-n+1,t}var sh=To,oh=128,uc=127;function To(r,n){var e=0,n=n||0,s=0,o=n,i,a=r.length;do{if(o>=a)throw To.bytes=0,new RangeError("Could not decode varint");i=r[o++],e+=s<28?(i&uc)<<s:(i&uc)*Math.pow(2,s),s+=7}while(i>=oh);return To.bytes=o-n,e}var ih=Math.pow(2,7),ah=Math.pow(2,14),ch=Math.pow(2,21),lh=Math.pow(2,28),uh=Math.pow(2,35),fh=Math.pow(2,42),hh=Math.pow(2,49),dh=Math.pow(2,56),ph=Math.pow(2,63),gh=function(r){return r<ih?1:r<ah?2:r<ch?3:r<lh?4:r<uh?5:r<fh?6:r<hh?7:r<dh?8:r<ph?9:10},mh={encode:th,decode:sh,encodingLength:gh},yh=mh,Rr=yh;function Hr(r,t=0){return[Rr.decode(r,t),Rr.decode.bytes]}function ir(r,t,e=0){return Rr.encode(r,t,e),t}function ar(r){return Rr.encodingLength(r)}function Kt(r,t){let e=t.byteLength,n=ar(r),s=n+ar(e),o=new Uint8Array(s+e);return ir(r,o,0),ir(e,o,n),o.set(t,s),new Oe(r,e,t,o)}function ke(r){let t=ie(r),[e,n]=Hr(t),[s,o]=Hr(t.subarray(n)),i=t.subarray(n+o);if(i.byteLength!==s)throw new Error("Incorrect length");return new Oe(e,s,i,t)}function Lo(r,t){if(r===t)return!0;{let e=t;return r.code===e.code&&r.size===e.size&&e.bytes instanceof Uint8Array&&nc(r.bytes,e.bytes)}}var Oe=class{code;size;digest;bytes;constructor(t,e,n,s){this.code=t,this.size=e,this.digest=n,this.bytes=s}};function wh(r,t){return r.code===t}function hc(r,t){let{bytes:e,version:n}=r;switch(n){case 0:return xh(e,Uo(r),t??rt.encoder);default:return vh(e,Uo(r),t??ae.encoder)}}var dc=new WeakMap;function Uo(r){let t=dc.get(r);if(t==null){let e=new Map;return dc.set(r,e),e}return t}var bt=class r{code;version;multihash;bytes;"/";constructor(t,e,n,s){this.code=e,this.version=t,this.multihash=n,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{let{code:t,multihash:e}=this;if(t!==Pr)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==Eh)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return r.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{let{code:t,digest:e}=this.multihash,n=Kt(t,e);return r.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return r.equals(this,t)}static equals(t,e){let n=e;return n!=null&&t.code===n.code&&t.version===n.version&&Lo(t.multihash,n.multihash)}toString(t){return hc(this,t)}toJSON(){return{"/":hc(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;let e=t;if(e instanceof r)return e;if(e["/"]!=null&&e["/"]===e.bytes||e.asCID===e){let{version:n,code:s,multihash:o,bytes:i}=e;return new r(n,s,o,i??pc(n,s,o.bytes))}else if(e[Bh]===!0){let{version:n,multihash:s,code:o}=e,i=ke(s);return r.create(n,o,i)}else return null}static create(t,e,n){if(typeof e!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(e!==Pr)throw new Error(`Version 0 CID must use dag-pb (code: ${Pr}) block encoding`);return new r(t,e,n,n.bytes)}case 1:{let s=pc(t,e,n.bytes);return new r(t,e,n,s)}default:throw new Error("Invalid version")}}static createV0(t){return r.create(0,Pr,t)}static createV1(t,e){return r.create(1,t,e)}static decode(t){let[e,n]=r.decodeFirst(t);if(n.length!==0)throw new Error("Incorrect length");return e}static decodeFirst(t){let e=r.inspectBytes(t),n=e.size-e.multihashSize,s=ie(t.subarray(n,n+e.multihashSize));if(s.byteLength!==e.multihashSize)throw new Error("Incorrect length");let o=s.subarray(e.multihashSize-e.digestSize),i=new Oe(e.multihashCode,e.digestSize,o,s);return[e.version===0?r.createV0(i):r.createV1(e.codec,i),t.subarray(e.size)]}static inspectBytes(t){let e=0,n=()=>{let[u,h]=Hr(t.subarray(e));return e+=h,u},s=n(),o=Pr;if(s===18?(s=0,e=0):o=n(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);let i=e,a=n(),c=n(),l=e+c,f=l-i;return{version:s,codec:o,multihashCode:a,digestSize:c,multihashSize:f,size:l}}static parse(t,e){let[n,s]=bh(t,e),o=r.decode(s);if(o.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Uo(o).set(n,t),o}};function bh(r,t){switch(r[0]){case"Q":{let e=t??rt;return[rt.prefix,e.decode(`${rt.prefix}${r}`)]}case rt.prefix:{let e=t??rt;return[rt.prefix,e.decode(r)]}case ae.prefix:{let e=t??ae;return[ae.prefix,e.decode(r)]}case _r.prefix:{let e=t??_r;return[_r.prefix,e.decode(r)]}default:{if(t==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],t.decode(r)]}}}function xh(r,t,e){let{prefix:n}=e;if(n!==rt.prefix)throw Error(`Cannot string encode V0 in ${e.name} encoding`);let s=t.get(n);if(s==null){let o=e.encode(r).slice(1);return t.set(n,o),o}else return s}function vh(r,t,e){let{prefix:n}=e,s=t.get(n);if(s==null){let o=e.encode(r);return t.set(n,o),o}else return s}var Pr=112,Eh=18;function pc(r,t,e){let n=ar(r),s=n+ar(t),o=new Uint8Array(s+e.byteLength);return ir(r,o,0),ir(t,o,n),o.set(e,s),o}var Bh=Symbol.for("@ipld/js-cid/CID");var _o={};kt(_o,{identity:()=>ce});var gc=0,Ah="identity",mc=ie;function Sh(r){return Kt(gc,mc(r))}var ce={code:gc,name:Ah,encode:mc,digest:Sh};function xt(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function Nn(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function kh(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function cr(r,...t){if(!kh(r))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(r.length))throw new Error("Uint8Array expected of length "+t+", got length="+r.length)}function Dr(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Nn(r.outputLen),Nn(r.blockLen)}function lr(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function yc(r,t){cr(r);let e=t.outputLen;if(r.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}var Ke=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var Tn=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),qt=(r,t)=>r<<32-t|r>>>t;function wc(r){if(typeof r!="string")throw new Error("utf8ToBytes expected string, got "+typeof r);return new Uint8Array(new TextEncoder().encode(r))}function Ie(r){return typeof r=="string"&&(r=wc(r)),cr(r),r}function Ro(...r){let t=0;for(let n=0;n<r.length;n++){let s=r[n];cr(s),t+=s.length}let e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){let o=r[n];e.set(o,s),s+=o.length}return e}var ur=class{clone(){return this._cloneInto()}};function Ln(r){let t=n=>r().update(Ie(n)).digest(),e=r();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>r(),t}function Vr(r=32){if(Ke&&typeof Ke.getRandomValues=="function")return Ke.getRandomValues(new Uint8Array(r));if(Ke&&typeof Ke.randomBytes=="function")return Ke.randomBytes(r);throw new Error("crypto.getRandomValues must be defined")}function Ih(r,t,e,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(t,e,n);let s=BigInt(32),o=BigInt(4294967295),i=Number(e>>s&o),a=Number(e&o),c=n?4:0,l=n?0:4;r.setUint32(t+c,i,n),r.setUint32(t+l,a,n)}var bc=(r,t,e)=>r&t^~r&e,xc=(r,t,e)=>r&t^r&e^t&e,fr=class extends ur{constructor(t,e,n,s){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=Tn(this.buffer)}update(t){lr(this);let{view:e,buffer:n,blockLen:s}=this;t=Ie(t);let o=t.length;for(let i=0;i<o;){let a=Math.min(s-this.pos,o-i);if(a===s){let c=Tn(t);for(;s<=o-i;i+=s)this.process(c,i);continue}n.set(t.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){lr(this),yc(t,this),this.finished=!0;let{buffer:e,view:n,blockLen:s,isLE:o}=this,{pos:i}=this;e[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>s-i&&(this.process(n,0),i=0);for(let u=i;u<s;u++)e[u]=0;Ih(n,s-8,BigInt(this.length*8),o),this.process(n,0);let a=Tn(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let l=c/4,f=this.get();if(l>f.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<l;u++)a.setUint32(4*u,f[u],o)}digest(){let{buffer:t,outputLen:e}=this;this.digestInto(t);let n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:e,buffer:n,length:s,finished:o,destroyed:i,pos:a}=this;return t.length=s,t.pos=a,t.finished=o,t.destroyed=i,s%e&&t.buffer.set(n),t}};var Un=BigInt(4294967295),Ho=BigInt(32);function vc(r,t=!1){return t?{h:Number(r&Un),l:Number(r>>Ho&Un)}:{h:Number(r>>Ho&Un)|0,l:Number(r&Un)|0}}function Ch(r,t=!1){let e=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let s=0;s<r.length;s++){let{h:o,l:i}=vc(r[s],t);[e[s],n[s]]=[o,i]}return[e,n]}var Nh=(r,t)=>BigInt(r>>>0)<<Ho|BigInt(t>>>0),Th=(r,t,e)=>r>>>e,Lh=(r,t,e)=>r<<32-e|t>>>e,Uh=(r,t,e)=>r>>>e|t<<32-e,_h=(r,t,e)=>r<<32-e|t>>>e,Rh=(r,t,e)=>r<<64-e|t>>>e-32,Hh=(r,t,e)=>r>>>e-32|t<<64-e,Ph=(r,t)=>t,Dh=(r,t)=>r,Vh=(r,t,e)=>r<<e|t>>>32-e,Mh=(r,t,e)=>t<<e|r>>>32-e,Oh=(r,t,e)=>t<<e-32|r>>>64-e,Kh=(r,t,e)=>r<<e-32|t>>>64-e;function Fh(r,t,e,n){let s=(t>>>0)+(n>>>0);return{h:r+e+(s/2**32|0)|0,l:s|0}}var $h=(r,t,e)=>(r>>>0)+(t>>>0)+(e>>>0),qh=(r,t,e,n)=>t+e+n+(r/2**32|0)|0,zh=(r,t,e,n)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0),Gh=(r,t,e,n,s)=>t+e+n+s+(r/2**32|0)|0,Wh=(r,t,e,n,s)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(s>>>0),jh=(r,t,e,n,s,o)=>t+e+n+s+o+(r/2**32|0)|0;var Zh={fromBig:vc,split:Ch,toBig:Nh,shrSH:Th,shrSL:Lh,rotrSH:Uh,rotrSL:_h,rotrBH:Rh,rotrBL:Hh,rotr32H:Ph,rotr32L:Dh,rotlSH:Vh,rotlSL:Mh,rotlBH:Oh,rotlBL:Kh,add:Fh,add3L:$h,add3H:qh,add4L:zh,add4H:Gh,add5H:jh,add5L:Wh},$=Zh;var[Yh,Xh]=$.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),Ce=new Uint32Array(80),Ne=new Uint32Array(80),Po=class extends fr{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){let{Ah:t,Al:e,Bh:n,Bl:s,Ch:o,Cl:i,Dh:a,Dl:c,Eh:l,El:f,Fh:u,Fl:h,Gh:g,Gl:w,Hh:m,Hl:d}=this;return[t,e,n,s,o,i,a,c,l,f,u,h,g,w,m,d]}set(t,e,n,s,o,i,a,c,l,f,u,h,g,w,m,d){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=a|0,this.Dl=c|0,this.Eh=l|0,this.El=f|0,this.Fh=u|0,this.Fl=h|0,this.Gh=g|0,this.Gl=w|0,this.Hh=m|0,this.Hl=d|0}process(t,e){for(let p=0;p<16;p++,e+=4)Ce[p]=t.getUint32(e),Ne[p]=t.getUint32(e+=4);for(let p=16;p<80;p++){let k=Ce[p-15]|0,L=Ne[p-15]|0,T=$.rotrSH(k,L,1)^$.rotrSH(k,L,8)^$.shrSH(k,L,7),C=$.rotrSL(k,L,1)^$.rotrSL(k,L,8)^$.shrSL(k,L,7),N=Ce[p-2]|0,S=Ne[p-2]|0,M=$.rotrSH(N,S,19)^$.rotrBH(N,S,61)^$.shrSH(N,S,6),R=$.rotrSL(N,S,19)^$.rotrBL(N,S,61)^$.shrSL(N,S,6),V=$.add4L(C,R,Ne[p-7],Ne[p-16]),K=$.add4H(V,T,M,Ce[p-7],Ce[p-16]);Ce[p]=K|0,Ne[p]=V|0}let{Ah:n,Al:s,Bh:o,Bl:i,Ch:a,Cl:c,Dh:l,Dl:f,Eh:u,El:h,Fh:g,Fl:w,Gh:m,Gl:d,Hh:b,Hl:v}=this;for(let p=0;p<80;p++){let k=$.rotrSH(u,h,14)^$.rotrSH(u,h,18)^$.rotrBH(u,h,41),L=$.rotrSL(u,h,14)^$.rotrSL(u,h,18)^$.rotrBL(u,h,41),T=u&g^~u&m,C=h&w^~h&d,N=$.add5L(v,L,C,Xh[p],Ne[p]),S=$.add5H(N,b,k,T,Yh[p],Ce[p]),M=N|0,R=$.rotrSH(n,s,28)^$.rotrBH(n,s,34)^$.rotrBH(n,s,39),V=$.rotrSL(n,s,28)^$.rotrBL(n,s,34)^$.rotrBL(n,s,39),K=n&o^n&a^o&a,A=s&i^s&c^i&c;b=m|0,v=d|0,m=g|0,d=w|0,g=u|0,w=h|0,{h:u,l:h}=$.add(l|0,f|0,S|0,M|0),l=a|0,f=c|0,a=o|0,c=i|0,o=n|0,i=s|0;let I=$.add3L(M,V,A);n=$.add3H(I,S,R,K),s=I|0}({h:n,l:s}=$.add(this.Ah|0,this.Al|0,n|0,s|0)),{h:o,l:i}=$.add(this.Bh|0,this.Bl|0,o|0,i|0),{h:a,l:c}=$.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:l,l:f}=$.add(this.Dh|0,this.Dl|0,l|0,f|0),{h:u,l:h}=$.add(this.Eh|0,this.El|0,u|0,h|0),{h:g,l:w}=$.add(this.Fh|0,this.Fl|0,g|0,w|0),{h:m,l:d}=$.add(this.Gh|0,this.Gl|0,m|0,d|0),{h:b,l:v}=$.add(this.Hh|0,this.Hl|0,b|0,v|0),this.set(n,s,o,i,a,c,l,f,u,h,g,w,m,d,b,v)}roundClean(){Ce.fill(0),Ne.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}};var Ec=Ln(()=>new Po);var Hn={};kt(Hn,{aInRange:()=>vt,abool:()=>zt,abytes:()=>hr,bitGet:()=>nd,bitLen:()=>Oo,bitMask:()=>Or,bitSet:()=>sd,bytesToHex:()=>ue,bytesToNumberBE:()=>fe,bytesToNumberLE:()=>Gt,concatBytes:()=>de,createHmacDrbg:()=>Ko,ensureBytes:()=>nt,equalBytes:()=>ed,hexToBytes:()=>$e,hexToNumber:()=>Mo,inRange:()=>Mr,isBytes:()=>Te,memoized:()=>qe,notImplemented:()=>id,numberToBytesBE:()=>Le,numberToBytesLE:()=>he,numberToHexUnpadded:()=>Fe,numberToVarBytesBE:()=>td,utf8ToBytes:()=>rd,validateObject:()=>Ft});var _n=BigInt(0),Rn=BigInt(1),Jh=BigInt(2);function Te(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function hr(r){if(!Te(r))throw new Error("Uint8Array expected")}function zt(r,t){if(typeof t!="boolean")throw new Error(r+" boolean expected, got "+t)}var Qh=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function ue(r){hr(r);let t="";for(let e=0;e<r.length;e++)t+=Qh[r[e]];return t}function Fe(r){let t=r.toString(16);return t.length&1?"0"+t:t}function Mo(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?_n:BigInt("0x"+r)}var le={_0:48,_9:57,A:65,F:70,a:97,f:102};function Bc(r){if(r>=le._0&&r<=le._9)return r-le._0;if(r>=le.A&&r<=le.F)return r-(le.A-10);if(r>=le.a&&r<=le.f)return r-(le.a-10)}function $e(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);let t=r.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);let n=new Uint8Array(e);for(let s=0,o=0;s<e;s++,o+=2){let i=Bc(r.charCodeAt(o)),a=Bc(r.charCodeAt(o+1));if(i===void 0||a===void 0){let c=r[o]+r[o+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+o)}n[s]=i*16+a}return n}function fe(r){return Mo(ue(r))}function Gt(r){return hr(r),Mo(ue(Uint8Array.from(r).reverse()))}function Le(r,t){return $e(r.toString(16).padStart(t*2,"0"))}function he(r,t){return Le(r,t).reverse()}function td(r){return $e(Fe(r))}function nt(r,t,e){let n;if(typeof t=="string")try{n=$e(t)}catch(o){throw new Error(r+" must be hex string or Uint8Array, cause: "+o)}else if(Te(t))n=Uint8Array.from(t);else throw new Error(r+" must be hex string or Uint8Array");let s=n.length;if(typeof e=="number"&&s!==e)throw new Error(r+" of length "+e+" expected, got "+s);return n}function de(...r){let t=0;for(let n=0;n<r.length;n++){let s=r[n];hr(s),t+=s.length}let e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){let o=r[n];e.set(o,s),s+=o.length}return e}function ed(r,t){if(r.length!==t.length)return!1;let e=0;for(let n=0;n<r.length;n++)e|=r[n]^t[n];return e===0}function rd(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}var Do=r=>typeof r=="bigint"&&_n<=r;function Mr(r,t,e){return Do(r)&&Do(t)&&Do(e)&&t<=r&&r<e}function vt(r,t,e,n){if(!Mr(t,e,n))throw new Error("expected valid "+r+": "+e+" <= n < "+n+", got "+t)}function Oo(r){let t;for(t=0;r>_n;r>>=Rn,t+=1);return t}function nd(r,t){return r>>BigInt(t)&Rn}function sd(r,t,e){return r|(e?Rn:_n)<<BigInt(t)}var Or=r=>(Jh<<BigInt(r-1))-Rn,Vo=r=>new Uint8Array(r),Ac=r=>Uint8Array.from(r);function Ko(r,t,e){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let n=Vo(r),s=Vo(r),o=0,i=()=>{n.fill(1),s.fill(0),o=0},a=(...u)=>e(s,n,...u),c=(u=Vo())=>{s=a(Ac([0]),u),n=a(),u.length!==0&&(s=a(Ac([1]),u),n=a())},l=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let u=0,h=[];for(;u<t;){n=a();let g=n.slice();h.push(g),u+=n.length}return de(...h)};return(u,h)=>{i(),c(u);let g;for(;!(g=h(l()));)c();return i(),g}}var od={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||Te(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,t)=>t.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function Ft(r,t,e={}){let n=(s,o,i)=>{let a=od[o];if(typeof a!="function")throw new Error("invalid validator function");let c=r[s];if(!(i&&c===void 0)&&!a(c,r))throw new Error("param "+String(s)+" is invalid. Expected "+o+", got "+c)};for(let[s,o]of Object.entries(t))n(s,o,!1);for(let[s,o]of Object.entries(e))n(s,o,!0);return r}var id=()=>{throw new Error("not implemented")};function qe(r){let t=new WeakMap;return(e,...n)=>{let s=t.get(e);if(s!==void 0)return s;let o=r(e,...n);return t.set(e,o),o}}var dt=BigInt(0),ct=BigInt(1),ze=BigInt(2),ad=BigInt(3),Fo=BigInt(4),Sc=BigInt(5),kc=BigInt(8),cd=BigInt(9),ld=BigInt(16);function Z(r,t){let e=r%t;return e>=dt?e:t+e}function $o(r,t,e){if(t<dt)throw new Error("invalid exponent, negatives unsupported");if(e<=dt)throw new Error("invalid modulus");if(e===ct)return dt;let n=ct;for(;t>dt;)t&ct&&(n=n*r%e),r=r*r%e,t>>=ct;return n}function it(r,t,e){let n=r;for(;t-- >dt;)n*=n,n%=e;return n}function Pn(r,t){if(r===dt)throw new Error("invert: expected non-zero number");if(t<=dt)throw new Error("invert: expected positive modulus, got "+t);let e=Z(r,t),n=t,s=dt,o=ct,i=ct,a=dt;for(;e!==dt;){let l=n/e,f=n%e,u=s-i*l,h=o-a*l;n=e,e=f,s=i,o=a,i=u,a=h}if(n!==ct)throw new Error("invert: does not exist");return Z(s,t)}function ud(r){let t=(r-ct)/ze,e,n,s;for(e=r-ct,n=0;e%ze===dt;e/=ze,n++);for(s=ze;s<r&&$o(s,t,r)!==r-ct;s++)if(s>1e3)throw new Error("Cannot find square root: likely non-prime P");if(n===1){let i=(r+ct)/Fo;return function(c,l){let f=c.pow(l,i);if(!c.eql(c.sqr(f),l))throw new Error("Cannot find square root");return f}}let o=(e+ct)/ze;return function(a,c){if(a.pow(c,t)===a.neg(a.ONE))throw new Error("Cannot find square root");let l=n,f=a.pow(a.mul(a.ONE,s),e),u=a.pow(c,o),h=a.pow(c,e);for(;!a.eql(h,a.ONE);){if(a.eql(h,a.ZERO))return a.ZERO;let g=1;for(let m=a.sqr(h);g<l&&!a.eql(m,a.ONE);g++)m=a.sqr(m);let w=a.pow(f,ct<<BigInt(l-g-1));f=a.sqr(w),u=a.mul(u,w),h=a.mul(h,f),l=g}return u}}function fd(r){if(r%Fo===ad){let t=(r+ct)/Fo;return function(n,s){let o=n.pow(s,t);if(!n.eql(n.sqr(o),s))throw new Error("Cannot find square root");return o}}if(r%kc===Sc){let t=(r-Sc)/kc;return function(n,s){let o=n.mul(s,ze),i=n.pow(o,t),a=n.mul(s,i),c=n.mul(n.mul(a,ze),i),l=n.mul(a,n.sub(c,n.ONE));if(!n.eql(n.sqr(l),s))throw new Error("Cannot find square root");return l}}return r%ld,ud(r)}var Ic=(r,t)=>(Z(r,t)&ct)===ct,hd=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function qo(r){let t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=hd.reduce((n,s)=>(n[s]="function",n),t);return Ft(r,e)}function dd(r,t,e){if(e<dt)throw new Error("invalid exponent, negatives unsupported");if(e===dt)return r.ONE;if(e===ct)return t;let n=r.ONE,s=t;for(;e>dt;)e&ct&&(n=r.mul(n,s)),s=r.sqr(s),e>>=ct;return n}function pd(r,t){let e=new Array(t.length),n=t.reduce((o,i,a)=>r.is0(i)?o:(e[a]=o,r.mul(o,i)),r.ONE),s=r.inv(n);return t.reduceRight((o,i,a)=>r.is0(i)?o:(e[a]=r.mul(o,e[a]),r.mul(o,i)),s),e}function zo(r,t){let e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}function Ue(r,t,e=!1,n={}){if(r<=dt)throw new Error("invalid field: expected ORDER > 0, got "+r);let{nBitLength:s,nByteLength:o}=zo(r,t);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let i,a=Object.freeze({ORDER:r,isLE:e,BITS:s,BYTES:o,MASK:Or(s),ZERO:dt,ONE:ct,create:c=>Z(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return dt<=c&&c<r},is0:c=>c===dt,isOdd:c=>(c&ct)===ct,neg:c=>Z(-c,r),eql:(c,l)=>c===l,sqr:c=>Z(c*c,r),add:(c,l)=>Z(c+l,r),sub:(c,l)=>Z(c-l,r),mul:(c,l)=>Z(c*l,r),pow:(c,l)=>dd(a,c,l),div:(c,l)=>Z(c*Pn(l,r),r),sqrN:c=>c*c,addN:(c,l)=>c+l,subN:(c,l)=>c-l,mulN:(c,l)=>c*l,inv:c=>Pn(c,r),sqrt:n.sqrt||(c=>(i||(i=fd(r)),i(a,c))),invertBatch:c=>pd(a,c),cmov:(c,l,f)=>f?l:c,toBytes:c=>e?he(c,o):Le(c,o),fromBytes:c=>{if(c.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+c.length);return e?Gt(c):fe(c)}});return Object.freeze(a)}function Cc(r){if(typeof r!="bigint")throw new Error("field order must be bigint");let t=r.toString(2).length;return Math.ceil(t/8)}function Go(r){let t=Cc(r);return t+Math.ceil(t/2)}function Nc(r,t,e=!1){let n=r.length,s=Cc(t),o=Go(t);if(n<16||n<o||n>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+n);let i=e?Gt(r):fe(r),a=Z(i,t-ct)+ct;return e?he(a,s):Le(a,s)}var Tc=BigInt(0),Dn=BigInt(1);function Wo(r,t){let e=t.negate();return r?e:t}function Lc(r,t){if(!Number.isSafeInteger(r)||r<=0||r>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+r)}function jo(r,t){Lc(r,t);let e=Math.ceil(t/r)+1,n=2**(r-1);return{windows:e,windowSize:n}}function md(r,t){if(!Array.isArray(r))throw new Error("array expected");r.forEach((e,n)=>{if(!(e instanceof t))throw new Error("invalid point at index "+n)})}function yd(r,t){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((e,n)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+n)})}var Zo=new WeakMap,Uc=new WeakMap;function Yo(r){return Uc.get(r)||1}function Vn(r,t){return{constTimeNegate:Wo,hasPrecomputes(e){return Yo(e)!==1},unsafeLadder(e,n,s=r.ZERO){let o=e;for(;n>Tc;)n&Dn&&(s=s.add(o)),o=o.double(),n>>=Dn;return s},precomputeWindow(e,n){let{windows:s,windowSize:o}=jo(n,t),i=[],a=e,c=a;for(let l=0;l<s;l++){c=a,i.push(c);for(let f=1;f<o;f++)c=c.add(a),i.push(c);a=c.double()}return i},wNAF(e,n,s){let{windows:o,windowSize:i}=jo(e,t),a=r.ZERO,c=r.BASE,l=BigInt(2**e-1),f=2**e,u=BigInt(e);for(let h=0;h<o;h++){let g=h*i,w=Number(s&l);s>>=u,w>i&&(w-=f,s+=Dn);let m=g,d=g+Math.abs(w)-1,b=h%2!==0,v=w<0;w===0?c=c.add(Wo(b,n[m])):a=a.add(Wo(v,n[d]))}return{p:a,f:c}},wNAFUnsafe(e,n,s,o=r.ZERO){let{windows:i,windowSize:a}=jo(e,t),c=BigInt(2**e-1),l=2**e,f=BigInt(e);for(let u=0;u<i;u++){let h=u*a;if(s===Tc)break;let g=Number(s&c);if(s>>=f,g>a&&(g-=l,s+=Dn),g===0)continue;let w=n[h+Math.abs(g)-1];g<0&&(w=w.negate()),o=o.add(w)}return o},getPrecomputes(e,n,s){let o=Zo.get(n);return o||(o=this.precomputeWindow(n,e),e!==1&&Zo.set(n,s(o))),o},wNAFCached(e,n,s){let o=Yo(e);return this.wNAF(o,this.getPrecomputes(o,e,s),n)},wNAFCachedUnsafe(e,n,s,o){let i=Yo(e);return i===1?this.unsafeLadder(e,n,o):this.wNAFUnsafe(i,this.getPrecomputes(i,e,s),n,o)},setWindowSize(e,n){Lc(n,t),Uc.set(e,n),Zo.delete(e)}}}function Mn(r,t,e,n){if(md(e,r),yd(n,t),e.length!==n.length)throw new Error("arrays of points and scalars must have equal length");let s=r.ZERO,o=Oo(BigInt(e.length)),i=o>12?o-3:o>4?o-2:o?2:1,a=(1<<i)-1,c=new Array(a+1).fill(s),l=Math.floor((t.BITS-1)/i)*i,f=s;for(let u=l;u>=0;u-=i){c.fill(s);for(let g=0;g<n.length;g++){let w=n[g],m=Number(w>>BigInt(u)&BigInt(a));c[m]=c[m].add(e[g])}let h=s;for(let g=c.length-1,w=s;g>0;g--)w=w.add(c[g]),h=h.add(w);if(f=f.add(h),u!==0)for(let g=0;g<i;g++)f=f.double()}return f}function Kr(r){return qo(r.Fp),Ft(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...zo(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}var Wt=BigInt(0),Dt=BigInt(1),On=BigInt(2),wd=BigInt(8),bd={zip215:!0};function xd(r){let t=Kr(r);return Ft(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}function _c(r){let t=xd(r),{Fp:e,n,prehash:s,hash:o,randomBytes:i,nByteLength:a,h:c}=t,l=On<<BigInt(a*8)-Dt,f=e.create,u=Ue(t.n,t.nBitLength),h=t.uvRatio||((x,y)=>{try{return{isValid:!0,value:e.sqrt(x*e.inv(y))}}catch{return{isValid:!1,value:Wt}}}),g=t.adjustScalarBytes||(x=>x),w=t.domain||((x,y,B)=>{if(zt("phflag",B),y.length||B)throw new Error("Contexts/pre-hash are not supported");return x});function m(x,y){vt("coordinate "+x,y,Wt,l)}function d(x){if(!(x instanceof p))throw new Error("ExtendedPoint expected")}let b=qe((x,y)=>{let{ex:B,ey:E,ez:U}=x,_=x.is0();y==null&&(y=_?wd:e.inv(U));let D=f(B*y),F=f(E*y),O=f(U*y);if(_)return{x:Wt,y:Dt};if(O!==Dt)throw new Error("invZ was invalid");return{x:D,y:F}}),v=qe(x=>{let{a:y,d:B}=t;if(x.is0())throw new Error("bad point: ZERO");let{ex:E,ey:U,ez:_,et:D}=x,F=f(E*E),O=f(U*U),q=f(_*_),j=f(q*q),st=f(F*y),ot=f(q*f(st+O)),at=f(j+f(B*f(F*O)));if(ot!==at)throw new Error("bad point: equation left != right (1)");let St=f(E*U),Pt=f(_*D);if(St!==Pt)throw new Error("bad point: equation left != right (2)");return!0});class p{constructor(y,B,E,U){this.ex=y,this.ey=B,this.ez=E,this.et=U,m("x",y),m("y",B),m("z",E),m("t",U),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(y){if(y instanceof p)throw new Error("extended point not allowed");let{x:B,y:E}=y||{};return m("x",B),m("y",E),new p(B,E,Dt,f(B*E))}static normalizeZ(y){let B=e.invertBatch(y.map(E=>E.ez));return y.map((E,U)=>E.toAffine(B[U])).map(p.fromAffine)}static msm(y,B){return Mn(p,u,y,B)}_setWindowSize(y){T.setWindowSize(this,y)}assertValidity(){v(this)}equals(y){d(y);let{ex:B,ey:E,ez:U}=this,{ex:_,ey:D,ez:F}=y,O=f(B*F),q=f(_*U),j=f(E*F),st=f(D*U);return O===q&&j===st}is0(){return this.equals(p.ZERO)}negate(){return new p(f(-this.ex),this.ey,this.ez,f(-this.et))}double(){let{a:y}=t,{ex:B,ey:E,ez:U}=this,_=f(B*B),D=f(E*E),F=f(On*f(U*U)),O=f(y*_),q=B+E,j=f(f(q*q)-_-D),st=O+D,ot=st-F,at=O-D,St=f(j*ot),Pt=f(st*at),_t=f(j*at),Xt=f(ot*st);return new p(St,Pt,Xt,_t)}add(y){d(y);let{a:B,d:E}=t,{ex:U,ey:_,ez:D,et:F}=this,{ex:O,ey:q,ez:j,et:st}=y;if(B===BigInt(-1)){let Wa=f((_-U)*(q+O)),ja=f((_+U)*(q-O)),vo=f(ja-Wa);if(vo===Wt)return this.double();let Za=f(D*On*st),Ya=f(F*On*j),Xa=Ya+Za,Ja=ja+Wa,Qa=Ya-Za,If=f(Xa*vo),Cf=f(Ja*Qa),Nf=f(Xa*Qa),Tf=f(vo*Ja);return new p(If,Cf,Tf,Nf)}let ot=f(U*O),at=f(_*q),St=f(F*E*st),Pt=f(D*j),_t=f((U+_)*(O+q)-ot-at),Xt=Pt-St,oe=Pt+St,Ur=f(at-B*ot),Bf=f(_t*Xt),Af=f(oe*Ur),Sf=f(_t*Ur),kf=f(Xt*oe);return new p(Bf,Af,kf,Sf)}subtract(y){return this.add(y.negate())}wNAF(y){return T.wNAFCached(this,y,p.normalizeZ)}multiply(y){let B=y;vt("scalar",B,Dt,n);let{p:E,f:U}=this.wNAF(B);return p.normalizeZ([E,U])[0]}multiplyUnsafe(y,B=p.ZERO){let E=y;return vt("scalar",E,Wt,n),E===Wt?L:this.is0()||E===Dt?this:T.wNAFCachedUnsafe(this,E,p.normalizeZ,B)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return T.unsafeLadder(this,n).is0()}toAffine(y){return b(this,y)}clearCofactor(){let{h:y}=t;return y===Dt?this:this.multiplyUnsafe(y)}static fromHex(y,B=!1){let{d:E,a:U}=t,_=e.BYTES;y=nt("pointHex",y,_),zt("zip215",B);let D=y.slice(),F=y[_-1];D[_-1]=F&-129;let O=Gt(D),q=B?l:e.ORDER;vt("pointHex.y",O,Wt,q);let j=f(O*O),st=f(j-Dt),ot=f(E*j-U),{isValid:at,value:St}=h(st,ot);if(!at)throw new Error("Point.fromHex: invalid y coordinate");let Pt=(St&Dt)===Dt,_t=(F&128)!==0;if(!B&&St===Wt&&_t)throw new Error("Point.fromHex: x=0 and x_0=1");return _t!==Pt&&(St=f(-St)),p.fromAffine({x:St,y:O})}static fromPrivateKey(y){return S(y).point}toRawBytes(){let{x:y,y:B}=this.toAffine(),E=he(B,e.BYTES);return E[E.length-1]|=y&Dt?128:0,E}toHex(){return ue(this.toRawBytes())}}p.BASE=new p(t.Gx,t.Gy,Dt,f(t.Gx*t.Gy)),p.ZERO=new p(Wt,Dt,Dt,Wt);let{BASE:k,ZERO:L}=p,T=Vn(p,a*8);function C(x){return Z(x,n)}function N(x){return C(Gt(x))}function S(x){let y=e.BYTES;x=nt("private key",x,y);let B=nt("hashed private key",o(x),2*y),E=g(B.slice(0,y)),U=B.slice(y,2*y),_=N(E),D=k.multiply(_),F=D.toRawBytes();return{head:E,prefix:U,scalar:_,point:D,pointBytes:F}}function M(x){return S(x).pointBytes}function R(x=new Uint8Array,...y){let B=de(...y);return N(o(w(B,nt("context",x),!!s)))}function V(x,y,B={}){x=nt("message",x),s&&(x=s(x));let{prefix:E,scalar:U,pointBytes:_}=S(y),D=R(B.context,E,x),F=k.multiply(D).toRawBytes(),O=R(B.context,F,_,x),q=C(D+O*U);vt("signature.s",q,Wt,n);let j=de(F,he(q,e.BYTES));return nt("result",j,e.BYTES*2)}let K=bd;function A(x,y,B,E=K){let{context:U,zip215:_}=E,D=e.BYTES;x=nt("signature",x,2*D),y=nt("message",y),B=nt("publicKey",B,D),_!==void 0&&zt("zip215",_),s&&(y=s(y));let F=Gt(x.slice(D,2*D)),O,q,j;try{O=p.fromHex(B,_),q=p.fromHex(x.slice(0,D),_),j=k.multiplyUnsafe(F)}catch{return!1}if(!_&&O.isSmallOrder())return!1;let st=R(U,q.toRawBytes(),O.toRawBytes(),y);return q.add(O.multiplyUnsafe(st)).subtract(j).clearCofactor().equals(p.ZERO)}return k._setWindowSize(8),{CURVE:t,getPublicKey:M,sign:V,verify:A,ExtendedPoint:p,utils:{getExtendedPublicKey:S,randomPrivateKey:()=>i(e.BYTES),precompute(x=8,y=p.BASE){return y._setWindowSize(x),y.multiply(BigInt(3)),y}}}}var dr=BigInt(0),Xo=BigInt(1);function vd(r){return Ft(r,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...r})}function Rc(r){let t=vd(r),{P:e}=t,n=v=>Z(v,e),s=t.montgomeryBits,o=Math.ceil(s/8),i=t.nByteLength,a=t.adjustScalarBytes||(v=>v),c=t.powPminus2||(v=>$o(v,e-BigInt(2),e));function l(v,p,k){let L=n(v*(p-k));return p=n(p-L),k=n(k+L),[p,k]}let f=(t.a-BigInt(2))/BigInt(4);function u(v,p){vt("u",v,dr,e),vt("scalar",p,dr,e);let k=p,L=v,T=Xo,C=dr,N=v,S=Xo,M=dr,R;for(let K=BigInt(s-1);K>=dr;K--){let A=k>>K&Xo;M^=A,R=l(M,T,N),T=R[0],N=R[1],R=l(M,C,S),C=R[0],S=R[1],M=A;let I=T+C,x=n(I*I),y=T-C,B=n(y*y),E=x-B,U=N+S,_=N-S,D=n(_*I),F=n(U*y),O=D+F,q=D-F;N=n(O*O),S=n(L*n(q*q)),T=n(x*B),C=n(E*(x+n(f*E)))}R=l(M,T,N),T=R[0],N=R[1],R=l(M,C,S),C=R[0],S=R[1];let V=c(C);return n(T*V)}function h(v){return he(n(v),o)}function g(v){let p=nt("u coordinate",v,o);return i===32&&(p[31]&=127),Gt(p)}function w(v){let p=nt("scalar",v),k=p.length;if(k!==o&&k!==i){let L=""+o+" or "+i;throw new Error("invalid scalar, expected "+L+" bytes, got "+k)}return Gt(a(p))}function m(v,p){let k=g(p),L=w(v),T=u(k,L);if(T===dr)throw new Error("invalid private or public key received");return h(T)}let d=h(t.Gu);function b(v){return m(v,d)}return{scalarMult:m,scalarMultBase:b,getSharedSecret:(v,p)=>m(v,p),getPublicKey:v=>b(v),utils:{randomPrivateKey:()=>t.randomBytes(t.nByteLength)},GuBytes:d}}var Fr=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Hc=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),cm=BigInt(0),Ed=BigInt(1),Pc=BigInt(2),Bd=BigInt(3),Ad=BigInt(5),Sd=BigInt(8);function Dc(r){let t=BigInt(10),e=BigInt(20),n=BigInt(40),s=BigInt(80),o=Fr,a=r*r%o*r%o,c=it(a,Pc,o)*a%o,l=it(c,Ed,o)*r%o,f=it(l,Ad,o)*l%o,u=it(f,t,o)*f%o,h=it(u,e,o)*u%o,g=it(h,n,o)*h%o,w=it(g,s,o)*g%o,m=it(w,s,o)*g%o,d=it(m,t,o)*f%o;return{pow_p_5_8:it(d,Pc,o)*r%o,b2:a}}function Vc(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function kd(r,t){let e=Fr,n=Z(t*t*t,e),s=Z(n*n*t,e),o=Dc(r*s).pow_p_5_8,i=Z(r*n*o,e),a=Z(t*i*i,e),c=i,l=Z(i*Hc,e),f=a===r,u=a===Z(-r,e),h=a===Z(-r*Hc,e);return f&&(i=c),(u||h)&&(i=l),Ic(i,e)&&(i=Z(-i,e)),{isValid:f||u,value:i}}var Id=Ue(Fr,void 0,!0),Cd={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:Id,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:Sd,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Ec,randomBytes:Vr,adjustScalarBytes:Vc,uvRatio:kd},Mc=_c(Cd);var $r=Rc({P:Fr,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:r=>{let t=Fr,{pow_p_5_8:e,b2:n}=Dc(r);return Z(it(e,Bd,t)*n,t)},adjustScalarBytes:Vc,randomBytes:Vr});var Kn=32;function Oc(r,t,e){return Mc.verify(t,e instanceof Uint8Array?e:e.subarray(),r)}var Fn=class{type="Ed25519";raw;constructor(t){this.raw=Jo(t,Kn)}toMultihash(){return ce.digest(pr(this))}toCID(){return bt.createV1(114,this.toMultihash())}toString(){return rt.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:xt(this.raw,t.raw)}verify(t,e){return Oc(this.raw,e,t)}};function Qo(r){return r=Jo(r,Kn),new Fn(r)}function Jo(r,t){if(r=Uint8Array.from(r??[]),r.length!==t)throw new yt(`Key must be a Uint8Array of length ${t}, got ${r.length}`);return r}function pt(r=0){return new Uint8Array(r)}function gt(r=0){return new Uint8Array(r)}var Td=Math.pow(2,7),Ld=Math.pow(2,14),Ud=Math.pow(2,21),ti=Math.pow(2,28),ei=Math.pow(2,35),ri=Math.pow(2,42),ni=Math.pow(2,49),J=128,It=127;function ht(r){if(r<Td)return 1;if(r<Ld)return 2;if(r<Ud)return 3;if(r<ti)return 4;if(r<ei)return 5;if(r<ri)return 6;if(r<ni)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function si(r,t,e=0){switch(ht(r)){case 8:t[e++]=r&255|J,r/=128;case 7:t[e++]=r&255|J,r/=128;case 6:t[e++]=r&255|J,r/=128;case 5:t[e++]=r&255|J,r/=128;case 4:t[e++]=r&255|J,r>>>=7;case 3:t[e++]=r&255|J,r>>>=7;case 2:t[e++]=r&255|J,r>>>=7;case 1:{t[e++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return t}function _d(r,t,e=0){switch(ht(r)){case 8:t.set(e++,r&255|J),r/=128;case 7:t.set(e++,r&255|J),r/=128;case 6:t.set(e++,r&255|J),r/=128;case 5:t.set(e++,r&255|J),r/=128;case 4:t.set(e++,r&255|J),r>>>=7;case 3:t.set(e++,r&255|J),r>>>=7;case 2:t.set(e++,r&255|J),r>>>=7;case 1:{t.set(e++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return t}function oi(r,t){let e=r[t],n=0;if(n+=e&It,e<J||(e=r[t+1],n+=(e&It)<<7,e<J)||(e=r[t+2],n+=(e&It)<<14,e<J)||(e=r[t+3],n+=(e&It)<<21,e<J)||(e=r[t+4],n+=(e&It)*ti,e<J)||(e=r[t+5],n+=(e&It)*ei,e<J)||(e=r[t+6],n+=(e&It)*ri,e<J)||(e=r[t+7],n+=(e&It)*ni,e<J))return n;throw new RangeError("Could not decode varint")}function Rd(r,t){let e=r.get(t),n=0;if(n+=e&It,e<J||(e=r.get(t+1),n+=(e&It)<<7,e<J)||(e=r.get(t+2),n+=(e&It)<<14,e<J)||(e=r.get(t+3),n+=(e&It)<<21,e<J)||(e=r.get(t+4),n+=(e&It)*ti,e<J)||(e=r.get(t+5),n+=(e&It)*ei,e<J)||(e=r.get(t+6),n+=(e&It)*ri,e<J)||(e=r.get(t+7),n+=(e&It)*ni,e<J))return n;throw new RangeError("Could not decode varint")}function Qt(r,t,e=0){return t==null&&(t=gt(ht(r))),t instanceof Uint8Array?si(r,t,e):_d(r,t,e)}function jt(r,t=0){return r instanceof Uint8Array?oi(r,t):Rd(r,t)}var ii=new Float32Array([-0]),_e=new Uint8Array(ii.buffer);function Fc(r,t,e){ii[0]=r,t[e]=_e[0],t[e+1]=_e[1],t[e+2]=_e[2],t[e+3]=_e[3]}function $c(r,t){return _e[0]=r[t],_e[1]=r[t+1],_e[2]=r[t+2],_e[3]=r[t+3],ii[0]}var ai=new Float64Array([-0]),Ct=new Uint8Array(ai.buffer);function qc(r,t,e){ai[0]=r,t[e]=Ct[0],t[e+1]=Ct[1],t[e+2]=Ct[2],t[e+3]=Ct[3],t[e+4]=Ct[4],t[e+5]=Ct[5],t[e+6]=Ct[6],t[e+7]=Ct[7]}function zc(r,t){return Ct[0]=r[t],Ct[1]=r[t+1],Ct[2]=r[t+2],Ct[3]=r[t+3],Ct[4]=r[t+4],Ct[5]=r[t+5],Ct[6]=r[t+6],Ct[7]=r[t+7],ai[0]}var Hd=BigInt(Number.MAX_SAFE_INTEGER),Pd=BigInt(Number.MIN_SAFE_INTEGER),Ot=class r{lo;hi;constructor(t,e){this.lo=t|0,this.hi=e|0}toNumber(t=!1){if(!t&&this.hi>>>31>0){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(e+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(t=!1){if(t)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(BigInt(e)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(t=!1){return this.toBigInt(t).toString()}zzEncode(){let t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this}zzDecode(){let t=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this}length(){let t=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?e===0?t<16384?t<128?1:2:t<2097152?3:4:e<16384?e<128?5:6:e<2097152?7:8:n<128?9:10}static fromBigInt(t){if(t===0n)return Ge;if(t<Hd&&t>Pd)return this.fromNumber(Number(t));let e=t<0n;e&&(t=-t);let n=t>>32n,s=t-(n<<32n);return e&&(n=~n|0n,s=~s|0n,++s>Gc&&(s=0n,++n>Gc&&(n=0n))),new r(Number(s),Number(n))}static fromNumber(t){if(t===0)return Ge;let e=t<0;e&&(t=-t);let n=t>>>0,s=(t-n)/4294967296>>>0;return e&&(s=~s>>>0,n=~n>>>0,++n>4294967295&&(n=0,++s>4294967295&&(s=0))),new r(n,s)}static from(t){return typeof t=="number"?r.fromNumber(t):typeof t=="bigint"?r.fromBigInt(t):typeof t=="string"?r.fromBigInt(BigInt(t)):t.low!=null||t.high!=null?new r(t.low>>>0,t.high>>>0):Ge}},Ge=new Ot(0,0);Ge.toBigInt=function(){return 0n};Ge.zzEncode=Ge.zzDecode=function(){return this};Ge.length=function(){return 1};var Gc=4294967296n;function Wc(r){let t=0,e=0;for(let n=0;n<r.length;++n)e=r.charCodeAt(n),e<128?t+=1:e<2048?t+=2:(e&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,t+=4):t+=3;return t}function jc(r,t,e){if(e-t<1)return"";let s,o=[],i=0,a;for(;t<e;)a=r[t++],a<128?o[i++]=a:a>191&&a<224?o[i++]=(a&31)<<6|r[t++]&63:a>239&&a<365?(a=((a&7)<<18|(r[t++]&63)<<12|(r[t++]&63)<<6|r[t++]&63)-65536,o[i++]=55296+(a>>10),o[i++]=56320+(a&1023)):o[i++]=(a&15)<<12|(r[t++]&63)<<6|r[t++]&63,i>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,o)),i=0);return s!=null?(i>0&&s.push(String.fromCharCode.apply(String,o.slice(0,i))),s.join("")):String.fromCharCode.apply(String,o.slice(0,i))}function ci(r,t,e){let n=e,s,o;for(let i=0;i<r.length;++i)s=r.charCodeAt(i),s<128?t[e++]=s:s<2048?(t[e++]=s>>6|192,t[e++]=s&63|128):(s&64512)===55296&&((o=r.charCodeAt(i+1))&64512)===56320?(s=65536+((s&1023)<<10)+(o&1023),++i,t[e++]=s>>18|240,t[e++]=s>>12&63|128,t[e++]=s>>6&63|128,t[e++]=s&63|128):(t[e++]=s>>12|224,t[e++]=s>>6&63|128,t[e++]=s&63|128);return e-n}function Zt(r,t){return RangeError(`index out of range: ${r.pos} + ${t??1} > ${r.len}`)}function $n(r,t){return(r[t-4]|r[t-3]<<8|r[t-2]<<16|r[t-1]<<24)>>>0}var li=class{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(t){this.buf=t,this.pos=0,this.len=t.length}uint32(){let t=4294967295;if(t=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(t=(t|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return t;if((this.pos+=5)>this.len)throw this.pos=this.len,Zt(this,10);return t}int32(){return this.uint32()|0}sint32(){let t=this.uint32();return t>>>1^-(t&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw Zt(this,4);return $n(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw Zt(this,4);return $n(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw Zt(this,4);let t=$c(this.buf,this.pos);return this.pos+=4,t}double(){if(this.pos+8>this.len)throw Zt(this,4);let t=zc(this.buf,this.pos);return this.pos+=8,t}bytes(){let t=this.uint32(),e=this.pos,n=this.pos+t;if(n>this.len)throw Zt(this,t);return this.pos+=t,e===n?new Uint8Array(0):this.buf.subarray(e,n)}string(){let t=this.bytes();return jc(t,0,t.length)}skip(t){if(typeof t=="number"){if(this.pos+t>this.len)throw Zt(this,t);this.pos+=t}else do if(this.pos>=this.len)throw Zt(this);while(this.buf[this.pos++]&128);return this}skipType(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${t} at offset ${this.pos}`)}return this}readLongVarint(){let t=new Ot(0,0),e=0;if(this.len-this.pos>4){for(;e<4;++e)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw Zt(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,t}if(this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw Zt(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw Zt(this,8);let t=$n(this.buf,this.pos+=4),e=$n(this.buf,this.pos+=4);return new Ot(t,e)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){let t=oi(this.buf,this.pos);return this.pos+=ht(t),t}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}};function ui(r){return new li(r instanceof Uint8Array?r:r.subarray())}function We(r,t,e){let n=ui(r);return t.decode(n,void 0,e)}var fi={};kt(fi,{base10:()=>Dd});var Dd=Se({prefix:"9",name:"base10",alphabet:"0123456789"});var hi={};kt(hi,{base16:()=>Vd,base16upper:()=>Md});var Vd=ft({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Md=ft({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var di={};kt(di,{base2:()=>Od});var Od=ft({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var pi={};kt(pi,{base256emoji:()=>zd});var Yc=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),Kd=Yc.reduce((r,t,e)=>(r[e]=t,r),[]),Fd=Yc.reduce((r,t,e)=>{let n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);return r[n]=e,r},[]);function $d(r){return r.reduce((t,e)=>(t+=Kd[e],t),"")}function qd(r){let t=[];for(let e of r){let n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);let s=Fd[n];if(s==null)throw new Error(`Non-base256emoji character: ${e}`);t.push(s)}return new Uint8Array(t)}var zd=or({prefix:"\u{1F680}",name:"base256emoji",encode:$d,decode:qd});var mi={};kt(mi,{base64:()=>Gd,base64pad:()=>Wd,base64url:()=>gi,base64urlpad:()=>jd});var Gd=ft({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Wd=ft({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),gi=ft({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),jd=ft({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var yi={};kt(yi,{base8:()=>Zd});var Zd=ft({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var wi={};kt(wi,{identity:()=>Yd});var Yd=or({prefix:"\0",name:"identity",encode:r=>oc(r),decode:r=>sc(r)});var qm=new TextEncoder,zm=new TextDecoder;var vi={};kt(vi,{sha256:()=>zr,sha512:()=>Qd});function xi({name:r,code:t,encode:e}){return new bi(r,t,e)}var bi=class{name;code;encode;constructor(t,e,n){this.name=t,this.code=e,this.encode=n}digest(t){if(t instanceof Uint8Array){let e=this.encode(t);return e instanceof Uint8Array?Kt(this.code,e):e.then(n=>Kt(this.code,n))}else throw Error("Unknown type, must be binary type")}};function Jc(r){return async t=>new Uint8Array(await crypto.subtle.digest(r,t))}var zr=xi({name:"sha2-256",code:18,encode:Jc("SHA-256")}),Qd=xi({name:"sha2-512",code:19,encode:Jc("SHA-512")});var je={...wi,...di,...yi,...fi,...hi,...Co,...No,...Io,...mi,...pi},ny={...vi,..._o};function tl(r,t,e,n){return{name:r,prefix:t,encoder:{name:r,prefix:t,encode:e},decoder:{decode:n}}}var Qc=tl("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),Ei=tl("ascii","a",r=>{let t="a";for(let e=0;e<r.length;e++)t+=String.fromCharCode(r[e]);return t},r=>{r=r.substring(1);let t=gt(r.length);for(let e=0;e<r.length;e++)t[e]=r.charCodeAt(e);return t}),tp={utf8:Qc,"utf-8":Qc,hex:je.base16,latin1:Ei,ascii:Ei,binary:Ei,...je},qn=tp;function et(r,t="utf8"){let e=qn[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.decoder.decode(`${e.prefix}${r}`)}function Bi(r){let t=r??8192,e=t>>>1,n,s=t;return function(i){if(i<1||i>e)return gt(i);s+i>t&&(n=gt(t),s=0);let a=n.subarray(s,s+=i);return s&7&&(s=(s|7)+1),a}}var Ze=class{fn;len;next;val;constructor(t,e,n){this.fn=t,this.len=e,this.next=void 0,this.val=n}};function Ai(){}var ki=class{head;tail;len;next;constructor(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}},ep=Bi();function rp(r){return globalThis.Buffer!=null?gt(r):ep(r)}var Wr=class{len;head;tail;states;constructor(){this.len=0,this.head=new Ze(Ai,0,0),this.tail=this.head,this.states=null}_push(t,e,n){return this.tail=this.tail.next=new Ze(t,e,n),this.len+=e,this}uint32(t){return this.len+=(this.tail=this.tail.next=new Ii((t=t>>>0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this}int32(t){return t<0?this._push(zn,10,Ot.fromNumber(t)):this.uint32(t)}sint32(t){return this.uint32((t<<1^t>>31)>>>0)}uint64(t){let e=Ot.fromBigInt(t);return this._push(zn,e.length(),e)}uint64Number(t){return this._push(si,ht(t),t)}uint64String(t){return this.uint64(BigInt(t))}int64(t){return this.uint64(t)}int64Number(t){return this.uint64Number(t)}int64String(t){return this.uint64String(t)}sint64(t){let e=Ot.fromBigInt(t).zzEncode();return this._push(zn,e.length(),e)}sint64Number(t){let e=Ot.fromNumber(t).zzEncode();return this._push(zn,e.length(),e)}sint64String(t){return this.sint64(BigInt(t))}bool(t){return this._push(Si,1,t?1:0)}fixed32(t){return this._push(Gr,4,t>>>0)}sfixed32(t){return this.fixed32(t)}fixed64(t){let e=Ot.fromBigInt(t);return this._push(Gr,4,e.lo)._push(Gr,4,e.hi)}fixed64Number(t){let e=Ot.fromNumber(t);return this._push(Gr,4,e.lo)._push(Gr,4,e.hi)}fixed64String(t){return this.fixed64(BigInt(t))}sfixed64(t){return this.fixed64(t)}sfixed64Number(t){return this.fixed64Number(t)}sfixed64String(t){return this.fixed64String(t)}float(t){return this._push(Fc,4,t)}double(t){return this._push(qc,8,t)}bytes(t){let e=t.length>>>0;return e===0?this._push(Si,1,0):this.uint32(e)._push(sp,e,t)}string(t){let e=Wc(t);return e!==0?this.uint32(e)._push(ci,e,t):this._push(Si,1,0)}fork(){return this.states=new ki(this),this.head=this.tail=new Ze(Ai,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Ze(Ai,0,0),this.len=0),this}ldelim(){let t=this.head,e=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=t.next,this.tail=e,this.len+=n),this}finish(){let t=this.head.next,e=rp(this.len),n=0;for(;t!=null;)t.fn(t.val,e,n),n+=t.len,t=t.next;return e}};function Si(r,t,e){t[e]=r&255}function np(r,t,e){for(;r>127;)t[e++]=r&127|128,r>>>=7;t[e]=r}var Ii=class extends Ze{next;constructor(t,e){super(np,t,e),this.next=void 0}};function zn(r,t,e){for(;r.hi!==0;)t[e++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)t[e++]=r.lo&127|128,r.lo=r.lo>>>7;t[e++]=r.lo}function Gr(r,t,e){t[e]=r&255,t[e+1]=r>>>8&255,t[e+2]=r>>>16&255,t[e+3]=r>>>24}function sp(r,t,e){t.set(r,e)}globalThis.Buffer!=null&&(Wr.prototype.bytes=function(r){let t=r.length>>>0;return this.uint32(t),t>0&&this._push(op,t,r),this},Wr.prototype.string=function(r){let t=globalThis.Buffer.byteLength(r);return this.uint32(t),t>0&&this._push(ip,t,r),this});function op(r,t,e){t.set(r,e)}function ip(r,t,e){r.length<40?ci(r,t,e):t.utf8Write!=null?t.utf8Write(r,e):t.set(et(r),e)}function Ci(){return new Wr}function Ye(r,t){let e=Ci();return t.encode(r,e,{lengthDelimited:!1}),e.finish()}var gr;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(gr||(gr={}));function Gn(r,t,e,n){return{name:r,type:t,encode:e,decode:n}}function Ni(r){function t(s){if(r[s.toString()]==null)throw new Error("Invalid enum value");return r[s]}let e=function(o,i){let a=t(o);i.int32(a)},n=function(o){let i=o.int32();return t(i)};return Gn("enum",gr.VARINT,e,n)}function Xe(r,t){return Gn("message",gr.LENGTH_DELIMITED,r,t)}var mt;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1"})(mt||(mt={}));var Ti;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1"})(Ti||(Ti={}));(function(r){r.codec=()=>Ni(Ti)})(mt||(mt={}));var te;(function(r){let t;r.codec=()=>(t==null&&(t=Xe((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),mt.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{let o={},i=n==null?e.len:e.pos+n;for(;e.pos<i;){let a=e.uint32();switch(a>>>3){case 1:{o.Type=mt.codec().decode(e);break}case 2:{o.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return o})),t),r.encode=e=>Ye(e,r.codec()),r.decode=(e,n)=>We(e,r.codec(),n)})(te||(te={}));var Li;(function(r){let t;r.codec=()=>(t==null&&(t=Xe((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),mt.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{let o={},i=n==null?e.len:e.pos+n;for(;e.pos<i;){let a=e.uint32();switch(a>>>3){case 1:{o.Type=mt.codec().decode(e);break}case 2:{o.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return o})),t),r.encode=e=>Ye(e,r.codec()),r.decode=(e,n)=>We(e,r.codec(),n)})(Li||(Li={}));var nn={};kt(nn,{MAX_RSA_KEY_SIZE:()=>Ds,generateRSAKeyPair:()=>Xl,jwkToJWKKeyPair:()=>Jl,jwkToPkcs1:()=>Ep,jwkToPkix:()=>Oi,jwkToRSAPrivateKey:()=>Yl,pkcs1ToJwk:()=>Wl,pkcs1ToRSAPrivateKey:()=>Zl,pkixToJwk:()=>jl,pkixToRSAPublicKey:()=>Ki});var ap=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Re=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),He=new Uint32Array(64),Ui=class extends fr{constructor(){super(64,32,8,!1),this.A=Re[0]|0,this.B=Re[1]|0,this.C=Re[2]|0,this.D=Re[3]|0,this.E=Re[4]|0,this.F=Re[5]|0,this.G=Re[6]|0,this.H=Re[7]|0}get(){let{A:t,B:e,C:n,D:s,E:o,F:i,G:a,H:c}=this;return[t,e,n,s,o,i,a,c]}set(t,e,n,s,o,i,a,c){this.A=t|0,this.B=e|0,this.C=n|0,this.D=s|0,this.E=o|0,this.F=i|0,this.G=a|0,this.H=c|0}process(t,e){for(let u=0;u<16;u++,e+=4)He[u]=t.getUint32(e,!1);for(let u=16;u<64;u++){let h=He[u-15],g=He[u-2],w=qt(h,7)^qt(h,18)^h>>>3,m=qt(g,17)^qt(g,19)^g>>>10;He[u]=m+He[u-7]+w+He[u-16]|0}let{A:n,B:s,C:o,D:i,E:a,F:c,G:l,H:f}=this;for(let u=0;u<64;u++){let h=qt(a,6)^qt(a,11)^qt(a,25),g=f+h+bc(a,c,l)+ap[u]+He[u]|0,m=(qt(n,2)^qt(n,13)^qt(n,22))+xc(n,s,o)|0;f=l,l=c,c=a,a=i+g|0,i=o,o=s,s=n,n=g+m|0}n=n+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,a=a+this.E|0,c=c+this.F|0,l=l+this.G|0,f=f+this.H|0,this.set(n,s,o,i,a,c,l,f)}roundClean(){He.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var ee=Ln(()=>new Ui);var z=Df(rl());function Je(r,t){let e=0;if(r.length===1)return r[0];for(let n=r.length-1;n>=0;n--)e+=r[r.length-1-n]*Math.pow(2,t*n);return e}function Pe(r,t,e=-1){let n=e,s=r,o=0,i=Math.pow(2,t);for(let a=1;a<8;a++){if(r<i){let c;if(n<0)c=new ArrayBuffer(a),o=a;else{if(n<a)return new ArrayBuffer(0);c=new ArrayBuffer(n),o=n}let l=new Uint8Array(c);for(let f=a-1;f>=0;f--){let u=Math.pow(2,f*t);l[o-f-1]=Math.floor(s/u),s-=l[o-f-1]*u}return c}i*=Math.pow(2,t)}return new ArrayBuffer(0)}function Zn(...r){let t=0,e=0;for(let o of r)t+=o.length;let n=new ArrayBuffer(t),s=new Uint8Array(n);for(let o of r)s.set(o,e),e+=o.length;return s}function Ri(){let r=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){let a=r[0]===255&&r[1]&128,c=r[0]===0&&(r[1]&128)===0;(a||c)&&this.warnings.push("Needlessly long format")}let t=new ArrayBuffer(this.valueHex.byteLength),e=new Uint8Array(t);for(let a=0;a<this.valueHex.byteLength;a++)e[a]=0;e[0]=r[0]&128;let n=Je(e,8),s=new ArrayBuffer(this.valueHex.byteLength),o=new Uint8Array(s);for(let a=0;a<this.valueHex.byteLength;a++)o[a]=r[a];return o[0]&=127,Je(o,8)-n}function nl(r){let t=r<0?r*-1:r,e=128;for(let n=1;n<8;n++){if(t<=e){if(r<0){let i=e-t,a=Pe(i,8,n),c=new Uint8Array(a);return c[0]|=128,a}let s=Pe(t,8,n),o=new Uint8Array(s);if(o[0]&128){let i=s.slice(0),a=new Uint8Array(i);s=new ArrayBuffer(s.byteLength+1),o=new Uint8Array(s);for(let c=0;c<i.byteLength;c++)o[c+1]=a[c];o[0]=0}return s}e*=Math.pow(2,8)}return new ArrayBuffer(0)}function sl(r,t){if(r.byteLength!==t.byteLength)return!1;let e=new Uint8Array(r),n=new Uint8Array(t);for(let s=0;s<e.length;s++)if(e[s]!==n[s])return!1;return!0}function Vt(r,t){let e=r.toString(10);if(t<e.length)return"";let n=t-e.length,s=new Array(n);for(let i=0;i<n;i++)s[i]="0";return s.join("").concat(e)}var Vy=Math.log(2);function Yn(){if(typeof BigInt>"u")throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function Hi(r){let t=0,e=0;for(let s=0;s<r.length;s++){let o=r[s];t+=o.byteLength}let n=new Uint8Array(t);for(let s=0;s<r.length;s++){let o=r[s];n.set(new Uint8Array(o),e),e+=o.byteLength}return n.buffer}function we(r,t,e,n){return t instanceof Uint8Array?t.byteLength?e<0?(r.error="Wrong parameter: inputOffset less than zero",!1):n<0?(r.error="Wrong parameter: inputLength less than zero",!1):t.byteLength-e-n<0?(r.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):!0:(r.error="Wrong parameter: inputBuffer has zero length",!1):(r.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}var Zr=class{constructor(){this.items=[]}write(t){this.items.push(t)}final(){return Hi(this.items)}},jr=[new Uint8Array([1])],ol="0123456789";var xr="",Yt=new ArrayBuffer(0),Pi=new Uint8Array(0),Yr="EndOfContent",al="OCTET STRING",cl="BIT STRING";function be(r){var t;return t=class extends r{constructor(...n){var s;super(...n);let o=n[0]||{};this.isHexOnly=(s=o.isHexOnly)!==null&&s!==void 0?s:!1,this.valueHexView=o.valueHex?z.BufferSourceConverter.toUint8Array(o.valueHex):Pi}get valueHex(){return this.valueHexView.slice().buffer}set valueHex(n){this.valueHexView=new Uint8Array(n)}fromBER(n,s,o){let i=n instanceof ArrayBuffer?new Uint8Array(n):n;if(!we(this,i,s,o))return-1;let a=s+o;return this.valueHexView=i.subarray(s,a),this.valueHexView.length?(this.blockLength=o,a):(this.warnings.push("Zero buffer length"),s)}toBER(n=!1){return this.isHexOnly?n?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",Yt)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:z.Convert.ToHex(this.valueHexView)}}},t.NAME="hexBlock",t}var ge=class{constructor({blockLength:t=0,error:e=xr,warnings:n=[],valueBeforeDecode:s=Pi}={}){this.blockLength=t,this.error=e,this.warnings=n,this.valueBeforeDecodeView=z.BufferSourceConverter.toUint8Array(s)}static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(t){this.valueBeforeDecodeView=new Uint8Array(t)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:z.Convert.ToHex(this.valueBeforeDecodeView)}}};ge.NAME="baseBlock";var Nt=class extends ge{fromBER(t,e,n){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(t,e){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}};Nt.NAME="valueBlock";var Xn=class extends be(ge){constructor({idBlock:t={}}={}){var e,n,s,o;super(),t?(this.isHexOnly=(e=t.isHexOnly)!==null&&e!==void 0?e:!1,this.valueHexView=t.valueHex?z.BufferSourceConverter.toUint8Array(t.valueHex):Pi,this.tagClass=(n=t.tagClass)!==null&&n!==void 0?n:-1,this.tagNumber=(s=t.tagNumber)!==null&&s!==void 0?s:-1,this.isConstructed=(o=t.isConstructed)!==null&&o!==void 0?o:!1):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(t=!1){let e=0;switch(this.tagClass){case 1:e|=0;break;case 2:e|=64;break;case 3:e|=128;break;case 4:e|=192;break;default:return this.error="Unknown tag class",Yt}if(this.isConstructed&&(e|=32),this.tagNumber<31&&!this.isHexOnly){let s=new Uint8Array(1);if(!t){let o=this.tagNumber;o&=31,e|=o,s[0]=e}return s.buffer}if(!this.isHexOnly){let s=Pe(this.tagNumber,7),o=new Uint8Array(s),i=s.byteLength,a=new Uint8Array(i+1);if(a[0]=e|31,!t){for(let c=0;c<i-1;c++)a[c+1]=o[c]|128;a[i]=o[i-1]}return a.buffer}let n=new Uint8Array(this.valueHexView.byteLength+1);if(n[0]=e|31,!t){let s=this.valueHexView;for(let o=0;o<s.length-1;o++)n[o+1]=s[o]|128;n[this.valueHexView.byteLength]=s[s.length-1]}return n.buffer}fromBER(t,e,n){let s=z.BufferSourceConverter.toUint8Array(t);if(!we(this,s,e,n))return-1;let o=s.subarray(e,e+n);if(o.length===0)return this.error="Zero buffer length",-1;switch(o[0]&192){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=(o[0]&32)===32,this.isHexOnly=!1;let a=o[0]&31;if(a!==31)this.tagNumber=a,this.blockLength=1;else{let c=1,l=this.valueHexView=new Uint8Array(255),f=255;for(;o[c]&128;){if(l[c-1]=o[c]&127,c++,c>=o.length)return this.error="End of input reached before message was fully decoded",-1;if(c===f){f+=255;let h=new Uint8Array(f);for(let g=0;g<l.length;g++)h[g]=l[g];l=this.valueHexView=new Uint8Array(f)}}this.blockLength=c+1,l[c-1]=o[c]&127;let u=new Uint8Array(c);for(let h=0;h<c;h++)u[h]=l[h];l=this.valueHexView=new Uint8Array(c),l.set(u),this.blockLength<=9?this.tagNumber=Je(l,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(this.tagClass===1&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return e+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}};Xn.NAME="identificationBlock";var Jn=class extends ge{constructor({lenBlock:t={}}={}){var e,n,s;super(),this.isIndefiniteForm=(e=t.isIndefiniteForm)!==null&&e!==void 0?e:!1,this.longFormUsed=(n=t.longFormUsed)!==null&&n!==void 0?n:!1,this.length=(s=t.length)!==null&&s!==void 0?s:0}fromBER(t,e,n){let s=z.BufferSourceConverter.toUint8Array(t);if(!we(this,s,e,n))return-1;let o=s.subarray(e,e+n);if(o.length===0)return this.error="Zero buffer length",-1;if(o[0]===255)return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=o[0]===128,this.isIndefiniteForm)return this.blockLength=1,e+this.blockLength;if(this.longFormUsed=!!(o[0]&128),this.longFormUsed===!1)return this.length=o[0],this.blockLength=1,e+this.blockLength;let i=o[0]&127;if(i>8)return this.error="Too big integer",-1;if(i+1>o.length)return this.error="End of input reached before message was fully decoded",-1;let a=e+1,c=s.subarray(a,a+i);return c[i-1]===0&&this.warnings.push("Needlessly long encoded length"),this.length=Je(c,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=i+1,e+this.blockLength}toBER(t=!1){let e,n;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return e=new ArrayBuffer(1),t===!1&&(n=new Uint8Array(e),n[0]=128),e;if(this.longFormUsed){let s=Pe(this.length,8);if(s.byteLength>127)return this.error="Too big length",Yt;if(e=new ArrayBuffer(s.byteLength+1),t)return e;let o=new Uint8Array(s);n=new Uint8Array(e),n[0]=s.byteLength|128;for(let i=0;i<s.byteLength;i++)n[i+1]=o[i];return e}return e=new ArrayBuffer(1),t===!1&&(n=new Uint8Array(e),n[0]=this.length),e}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}};Jn.NAME="lengthBlock";var H={},Et=class extends ge{constructor({name:t=xr,optional:e=!1,primitiveSchema:n,...s}={},o){super(s),this.name=t,this.optional=e,n&&(this.primitiveSchema=n),this.idBlock=new Xn(s),this.lenBlock=new Jn(s),this.valueBlock=o?new o(s):new Nt(s)}fromBER(t,e,n){let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}toBER(t,e){let n=e||new Zr;e||ll(this);let s=this.idBlock.toBER(t);if(n.write(s),this.lenBlock.isIndefiniteForm)n.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(t,n),n.write(new ArrayBuffer(2));else{let o=this.valueBlock.toBER(t);this.lenBlock.length=o.byteLength;let i=this.lenBlock.toBER(t);n.write(i),n.write(o)}return e?Yt:n.final()}toJSON(){let t={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(t.primitiveSchema=this.primitiveSchema.toJSON()),t}toString(t="ascii"){return t==="ascii"?this.onAsciiEncoding():z.Convert.ToHex(this.toBER())}onAsciiEncoding(){return`${this.constructor.NAME} : ${z.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`}isEqual(t){if(this===t)return!0;if(!(t instanceof this.constructor))return!1;let e=this.toBER(),n=t.toBER();return sl(e,n)}};Et.NAME="BaseBlock";function ll(r){if(r instanceof H.Constructed)for(let t of r.valueBlock.value)ll(t)&&(r.lenBlock.isIndefiniteForm=!0);return!!r.lenBlock.isIndefiniteForm}var Qn=class extends Et{constructor({value:t=xr,...e}={},n){super(e,n),t&&this.fromString(t)}getValue(){return this.valueBlock.value}setValue(t){this.valueBlock.value=t}fromBER(t,e,n){let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}};Qn.NAME="BaseStringBlock";var ts=class extends be(Nt){constructor({isHexOnly:t=!0,...e}={}){super(e),this.isHexOnly=t}};ts.NAME="PrimitiveValueBlock";var ul,es=class extends Et{constructor(t={}){super(t,ts),this.idBlock.isConstructed=!1}};ul=es;H.Primitive=ul;es.NAME="PRIMITIVE";function mp(r,t){if(r instanceof t)return r;let e=new t;return e.idBlock=r.idBlock,e.lenBlock=r.lenBlock,e.warnings=r.warnings,e.valueBeforeDecodeView=r.valueBeforeDecodeView,e}function Hs(r,t=0,e=r.length){let n=t,s=new Et({},Nt),o=new ge;if(!we(o,r,t,e))return s.error=o.error,{offset:-1,result:s};if(!r.subarray(t,t+e).length)return s.error="Zero buffer length",{offset:-1,result:s};let a=s.idBlock.fromBER(r,t,e);if(s.idBlock.warnings.length&&s.warnings.concat(s.idBlock.warnings),a===-1)return s.error=s.idBlock.error,{offset:-1,result:s};if(t=a,e-=s.idBlock.blockLength,a=s.lenBlock.fromBER(r,t,e),s.lenBlock.warnings.length&&s.warnings.concat(s.lenBlock.warnings),a===-1)return s.error=s.lenBlock.error,{offset:-1,result:s};if(t=a,e-=s.lenBlock.blockLength,!s.idBlock.isConstructed&&s.lenBlock.isIndefiniteForm)return s.error="Indefinite length form used for primitive encoding form",{offset:-1,result:s};let c=Et;switch(s.idBlock.tagClass){case 1:if(s.idBlock.tagNumber>=37&&s.idBlock.isHexOnly===!1)return s.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:s};switch(s.idBlock.tagNumber){case 0:if(s.idBlock.isConstructed&&s.lenBlock.length>0)return s.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:s};c=H.EndOfContent;break;case 1:c=H.Boolean;break;case 2:c=H.Integer;break;case 3:c=H.BitString;break;case 4:c=H.OctetString;break;case 5:c=H.Null;break;case 6:c=H.ObjectIdentifier;break;case 10:c=H.Enumerated;break;case 12:c=H.Utf8String;break;case 13:c=H.RelativeObjectIdentifier;break;case 14:c=H.TIME;break;case 15:return s.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:s};case 16:c=H.Sequence;break;case 17:c=H.Set;break;case 18:c=H.NumericString;break;case 19:c=H.PrintableString;break;case 20:c=H.TeletexString;break;case 21:c=H.VideotexString;break;case 22:c=H.IA5String;break;case 23:c=H.UTCTime;break;case 24:c=H.GeneralizedTime;break;case 25:c=H.GraphicString;break;case 26:c=H.VisibleString;break;case 27:c=H.GeneralString;break;case 28:c=H.UniversalString;break;case 29:c=H.CharacterString;break;case 30:c=H.BmpString;break;case 31:c=H.DATE;break;case 32:c=H.TimeOfDay;break;case 33:c=H.DateTime;break;case 34:c=H.Duration;break;default:{let l=s.idBlock.isConstructed?new H.Constructed:new H.Primitive;l.idBlock=s.idBlock,l.lenBlock=s.lenBlock,l.warnings=s.warnings,s=l}}break;case 2:case 3:case 4:default:c=s.idBlock.isConstructed?H.Constructed:H.Primitive}return s=mp(s,c),a=s.fromBER(r,t,s.lenBlock.isIndefiniteForm?e:s.lenBlock.length),s.valueBeforeDecodeView=r.subarray(n,n+s.blockLength),{offset:a,result:s}}function Di(r){if(!r.byteLength){let t=new Et({},Nt);return t.error="Input buffer has zero length",{offset:-1,result:t}}return Hs(z.BufferSourceConverter.toUint8Array(r).slice(),0,r.byteLength)}function yp(r,t){return r?1:t}var re=class extends Nt{constructor({value:t=[],isIndefiniteForm:e=!1,...n}={}){super(n),this.value=t,this.isIndefiniteForm=e}fromBER(t,e,n){let s=z.BufferSourceConverter.toUint8Array(t);if(!we(this,s,e,n))return-1;if(this.valueBeforeDecodeView=s.subarray(e,e+n),this.valueBeforeDecodeView.length===0)return this.warnings.push("Zero buffer length"),e;let o=e;for(;yp(this.isIndefiniteForm,n)>0;){let i=Hs(s,o,n);if(i.offset===-1)return this.error=i.result.error,this.warnings.concat(i.result.warnings),-1;if(o=i.offset,this.blockLength+=i.result.blockLength,n-=i.result.blockLength,this.value.push(i.result),this.isIndefiniteForm&&i.result.constructor.NAME===Yr)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===Yr?this.value.pop():this.warnings.push("No EndOfContent block encoded")),o}toBER(t,e){let n=e||new Zr;for(let s=0;s<this.value.length;s++)this.value[s].toBER(t,n);return e?Yt:n.final()}toJSON(){let t={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(let e of this.value)t.value.push(e.toJSON());return t}};re.NAME="ConstructedValueBlock";var fl,De=class extends Et{constructor(t={}){super(t,re),this.idBlock.isConstructed=!0}fromBER(t,e,n){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){let t=[];for(let n of this.valueBlock.value)t.push(n.toString("ascii").split(`
./node_modules/@libp2p/identify/dist/index.min.js:2:"use strict";var Libp2PIdentify=(()=>{var Tu=Object.create;var dn=Object.defineProperty;var Uu=Object.getOwnPropertyDescriptor;var Lu=Object.getOwnPropertyNames;var Ru=Object.getPrototypeOf,_u=Object.prototype.hasOwnProperty;var eo=(r,t)=>()=>(t||r((t={exports:{}}).exports,t),t.exports),St=(r,t)=>{for(var e in t)dn(r,e,{get:t[e],enumerable:!0})},ca=(r,t,e,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of Lu(t))!_u.call(r,s)&&s!==e&&dn(r,s,{get:()=>t[s],enumerable:!(n=Uu(t,s))||n.enumerable});return r};var ro=(r,t,e)=>(e=r!=null?Tu(Ru(r)):{},ca(t||!r||!r.__esModule?dn(e,"default",{value:r,enumerable:!0}):e,r)),Ou=r=>ca(dn({},"__esModule",{value:!0}),r);var cc=eo(pr=>{"use strict";var id="[object ArrayBuffer]",pe=class r{static isArrayBuffer(t){return Object.prototype.toString.call(t)===id}static toArrayBuffer(t){return this.isArrayBuffer(t)?t:t.byteLength===t.buffer.byteLength||t.byteOffset===0&&t.byteLength===t.buffer.byteLength?t.buffer:this.toUint8Array(t.buffer).slice(t.byteOffset,t.byteOffset+t.byteLength).buffer}static toUint8Array(t){return this.toView(t,Uint8Array)}static toView(t,e){if(t.constructor===e)return t;if(this.isArrayBuffer(t))return new e(t);if(this.isArrayBufferView(t))return new e(t.buffer,t.byteOffset,t.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(t){return this.isArrayBufferView(t)||this.isArrayBuffer(t)}static isArrayBufferView(t){return ArrayBuffer.isView(t)||t&&this.isArrayBuffer(t.buffer)}static isEqual(t,e){let n=r.toUint8Array(t),s=r.toUint8Array(e);if(n.length!==s.byteLength)return!1;for(let o=0;o<n.length;o++)if(n[o]!==s[o])return!1;return!0}static concat(...t){let e;Array.isArray(t[0])&&!(t[1]instanceof Function)||Array.isArray(t[0])&&t[1]instanceof Function?e=t[0]:t[t.length-1]instanceof Function?e=t.slice(0,t.length-1):e=t;let n=0;for(let i of e)n+=i.byteLength;let s=new Uint8Array(n),o=0;for(let i of e){let c=this.toUint8Array(i);s.set(c,o),o+=c.length}return t[t.length-1]instanceof Function?this.toView(s,t[t.length-1]):s.buffer}},di="string",ad=/^[0-9a-f\s]+$/i,cd=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,ld=/^[a-zA-Z0-9-_]+$/,Dn=class{static fromString(t){let e=unescape(encodeURIComponent(t)),n=new Uint8Array(e.length);for(let s=0;s<e.length;s++)n[s]=e.charCodeAt(s);return n.buffer}static toString(t){let e=pe.toUint8Array(t),n="";for(let o=0;o<e.length;o++)n+=String.fromCharCode(e[o]);return decodeURIComponent(escape(n))}},Vt=class{static toString(t,e=!1){let n=pe.toArrayBuffer(t),s=new DataView(n),o="";for(let i=0;i<n.byteLength;i+=2){let c=s.getUint16(i,e);o+=String.fromCharCode(c)}return o}static fromString(t,e=!1){let n=new ArrayBuffer(t.length*2),s=new DataView(n);for(let o=0;o<t.length;o++)s.setUint16(o*2,t.charCodeAt(o),e);return n}},Mn=class r{static isHex(t){return typeof t===di&&ad.test(t)}static isBase64(t){return typeof t===di&&cd.test(t)}static isBase64Url(t){return typeof t===di&&ld.test(t)}static ToString(t,e="utf8"){let n=pe.toUint8Array(t);switch(e.toLowerCase()){case"utf8":return this.ToUtf8String(n);case"binary":return this.ToBinary(n);case"hex":return this.ToHex(n);case"base64":return this.ToBase64(n);case"base64url":return this.ToBase64Url(n);case"utf16le":return Vt.toString(n,!0);case"utf16":case"utf16be":return Vt.toString(n);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromString(t,e="utf8"){if(!t)return new ArrayBuffer(0);switch(e.toLowerCase()){case"utf8":return this.FromUtf8String(t);case"binary":return this.FromBinary(t);case"hex":return this.FromHex(t);case"base64":return this.FromBase64(t);case"base64url":return this.FromBase64Url(t);case"utf16le":return Vt.fromString(t,!0);case"utf16":case"utf16be":return Vt.fromString(t);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToBase64(t){let e=pe.toUint8Array(t);if(typeof btoa<"u"){let n=this.ToString(e,"binary");return btoa(n)}else return Buffer.from(e).toString("base64")}static FromBase64(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isBase64(e))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return typeof atob<"u"?this.FromBinary(atob(e)):new Uint8Array(Buffer.from(e,"base64")).buffer}static FromBase64Url(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isBase64Url(e))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(e.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(t){return this.ToBase64(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(t,e=r.DEFAULT_UTF8_ENCODING){switch(e){case"ascii":return this.FromBinary(t);case"utf8":return Dn.fromString(t);case"utf16":case"utf16be":return Vt.fromString(t);case"utf16le":case"usc2":return Vt.fromString(t,!0);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToUtf8String(t,e=r.DEFAULT_UTF8_ENCODING){switch(e){case"ascii":return this.ToBinary(t);case"utf8":return Dn.toString(t);case"utf16":case"utf16be":return Vt.toString(t);case"utf16le":case"usc2":return Vt.toString(t,!0);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromBinary(t){let e=t.length,n=new Uint8Array(e);for(let s=0;s<e;s++)n[s]=t.charCodeAt(s);return n.buffer}static ToBinary(t){let e=pe.toUint8Array(t),n="";for(let s=0;s<e.length;s++)n+=String.fromCharCode(e[s]);return n}static ToHex(t){let e=pe.toUint8Array(t),n="",s=e.length;for(let o=0;o<s;o++){let i=e[o];i<16&&(n+="0"),n+=i.toString(16)}return n}static FromHex(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isHex(e))throw new TypeError("Argument 'hexString' is not HEX encoded");e.length%2&&(e=`0${e}`);let n=new Uint8Array(e.length/2);for(let s=0;s<e.length;s=s+2){let o=e.slice(s,s+2);n[s/2]=parseInt(o,16)}return n.buffer}static ToUtf16String(t,e=!1){return Vt.toString(t,e)}static FromUtf16String(t,e=!1){return Vt.fromString(t,e)}static Base64Padding(t){let e=4-t.length%4;if(e<4)for(let n=0;n<e;n++)t+="=";return t}static formatString(t){return t?.replace(/[\n\r\t ]/g,"")||""}};Mn.DEFAULT_UTF8_ENCODING="utf8";function ud(r,...t){let e=arguments[0];for(let n=1;n<arguments.length;n++){let s=arguments[n];for(let o in s)e[o]=s[o]}return e}function fd(...r){let t=r.map(s=>s.byteLength).reduce((s,o)=>s+o),e=new Uint8Array(t),n=0;return r.map(s=>new Uint8Array(s)).forEach(s=>{for(let o of s)e[n++]=o}),e.buffer}function hd(r,t){if(!(r&&t)||r.byteLength!==t.byteLength)return!1;let e=new Uint8Array(r),n=new Uint8Array(t);for(let s=0;s<r.byteLength;s++)if(e[s]!==n[s])return!1;return!0}pr.BufferSourceConverter=pe;pr.Convert=Mn;pr.assign=ud;pr.combine=fd;pr.isEqual=hd});var tu=eo((Nx,Ql)=>{function Qd(){return!!(typeof window<"u"&&typeof window.process=="object"&&window.process.type==="renderer"||typeof process<"u"&&typeof process.versions=="object"&&process.versions.electron||typeof navigator=="object"&&typeof navigator.userAgent=="string"&&navigator.userAgent.indexOf("Electron")>=0)}Ql.exports=Qd});var uu=eo(ln=>{(function(){var r,t,e,n,s,o,i,c;c=function(a){var l,u,f,h;return l=(a&255<<24)>>>24,u=(a&255<<16)>>>16,f=(a&65280)>>>8,h=a&255,[l,u,f,h].join(".")},i=function(a){var l,u,f,h,m,p;for(l=[],f=h=0;h<=3&&a.length!==0;f=++h){if(f>0){if(a[0]!==".")throw new Error("Invalid IP");a=a.substring(1)}p=t(a),m=p[0],u=p[1],a=a.substring(u),l.push(m)}if(a.length!==0)throw new Error("Invalid IP");switch(l.length){case 1:if(l[0]>4294967295)throw new Error("Invalid IP");return l[0]>>>0;case 2:if(l[0]>255||l[1]>16777215)throw new Error("Invalid IP");return(l[0]<<24|l[1])>>>0;case 3:if(l[0]>255||l[1]>255||l[2]>65535)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2])>>>0;case 4:if(l[0]>255||l[1]>255||l[2]>255||l[3]>255)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2]<<8|l[3])>>>0;default:throw new Error("Invalid IP")}},e=function(a){return a.charCodeAt(0)},n=e("0"),o=e("a"),s=e("A"),t=function(a){var l,u,f,h,m;for(h=0,l=10,u="9",f=0,a.length>1&&a[f]==="0"&&(a[f+1]==="x"||a[f+1]==="X"?(f+=2,l=16):"0"<=a[f+1]&&a[f+1]<="9"&&(f++,l=8,u="7")),m=f;f<a.length;){if("0"<=a[f]&&a[f]<=u)h=h*l+(e(a[f])-n)>>>0;else if(l===16)if("a"<=a[f]&&a[f]<="f")h=h*l+(10+e(a[f])-o)>>>0;else if("A"<=a[f]&&a[f]<="F")h=h*l+(10+e(a[f])-s)>>>0;else break;else break;if(h>4294967295)throw new Error("too large");f++}if(f===m)throw new Error("empty octet");return[h,f]},r=function(){function a(l,u){var f,h,m,p;if(typeof l!="string")throw new Error("Missing `net' parameter");if(u||(p=l.split("/",2),l=p[0],u=p[1]),u||(u=32),typeof u=="string"&&u.indexOf(".")>-1){try{this.maskLong=i(u)}catch(b){throw f=b,new Error("Invalid mask: "+u)}for(h=m=32;m>=0;h=--m)if(this.maskLong===4294967295<<32-h>>>0){this.bitmask=h;break}}else if(u||u===0)this.bitmask=parseInt(u,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(i(l)&this.maskLong)>>>0}catch(b){throw f=b,new Error("Invalid net address: "+l)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+u);this.size=Math.pow(2,32-this.bitmask),this.base=c(this.netLong),this.mask=c(this.maskLong),this.hostmask=c(~this.maskLong),this.first=this.bitmask<=30?c(this.netLong+1):this.base,this.last=this.bitmask<=30?c(this.netLong+this.size-2):c(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?c(this.netLong+this.size-1):void 0}return a.prototype.contains=function(l){return typeof l=="string"&&(l.indexOf("/")>0||l.split(".").length!==4)&&(l=new a(l)),l instanceof a?this.contains(l.base)&&this.contains(l.broadcast||l.last):(i(l)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},a.prototype.next=function(l){return l==null&&(l=1),new a(c(this.netLong+this.size*l),this.mask)},a.prototype.forEach=function(l){var u,f,h;for(h=i(this.first),f=i(this.last),u=0;h<=f;)l(c(h),h,u),u++,h++},a.prototype.toString=function(){return this.base+"/"+this.bitmask},a}(),ln.ip2long=i,ln.long2ip=c,ln.Netmask=r}).call(ln)});var k0={};St(k0,{identify:()=>S0,identifyPush:()=>I0});var no=Symbol.for("@libp2p/peer-id");var It=class extends Error{static name="InvalidParametersError";constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}},rr=class extends Error{static name="InvalidPublicKeyError";constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}};var pn=class extends Error{static name="InvalidCIDError";constructor(t="Invalid CID"){super(t),this.name="InvalidCIDError"}},mn=class extends Error{static name="InvalidMultihashError";constructor(t="Invalid Multihash"){super(t),this.name="InvalidMultihashError"}},gn=class extends Error{static name="UnsupportedProtocolError";constructor(t="Unsupported protocol error"){super(t),this.name="UnsupportedProtocolError"}},Dt=class extends Error{static name="InvalidMessageError";constructor(t="Invalid message"){super(t),this.name="InvalidMessageError"}};var Me=class extends Error{static name="UnsupportedKeyTypeError";constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}};var Tr=(r,...t)=>{try{[...t]}catch{}};var yn=Symbol.for("@libp2p/service-capabilities"),L0=Symbol.for("@libp2p/service-dependencies");var co={};St(co,{base58btc:()=>X,base58flickr:()=>Hu});var rp=new Uint8Array(0);function la(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function ie(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function ua(r){return new TextEncoder().encode(r)}function fa(r){return new TextDecoder().decode(r)}function Pu(r,t){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),n=0;n<e.length;n++)e[n]=255;for(var s=0;s<r.length;s++){var o=r.charAt(s),i=o.charCodeAt(0);if(e[i]!==255)throw new TypeError(o+" is ambiguous");e[i]=s}var c=r.length,a=r.charAt(0),l=Math.log(c)/Math.log(256),u=Math.log(256)/Math.log(c);function f(p){if(p instanceof Uint8Array||(ArrayBuffer.isView(p)?p=new Uint8Array(p.buffer,p.byteOffset,p.byteLength):Array.isArray(p)&&(p=Uint8Array.from(p))),!(p instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(p.length===0)return"";for(var b=0,d=0,v=0,A=p.length;v!==A&&p[v]===0;)v++,b++;for(var y=(A-v)*u+1>>>0,I=new Uint8Array(y);v!==A;){for(var L=p[v],U=0,k=y-1;(L!==0||U<d)&&k!==-1;k--,U++)L+=256*I[k]>>>0,I[k]=L%c>>>0,L=L/c>>>0;if(L!==0)throw new Error("Non-zero carry");d=U,v++}for(var T=y-d;T!==y&&I[T]===0;)T++;for(var N=a.repeat(b);T<y;++T)N+=r.charAt(I[T]);return N}function h(p){if(typeof p!="string")throw new TypeError("Expected String");if(p.length===0)return new Uint8Array;var b=0;if(p[b]!==" "){for(var d=0,v=0;p[b]===a;)d++,b++;for(var A=(p.length-b)*l+1>>>0,y=new Uint8Array(A);p[b];){var I=e[p.charCodeAt(b)];if(I===255)return;for(var L=0,U=A-1;(I!==0||L<v)&&U!==-1;U--,L++)I+=c*y[U]>>>0,y[U]=I%256>>>0,I=I/256>>>0;if(I!==0)throw new Error("Non-zero carry");v=L,b++}if(p[b]!==" "){for(var k=A-v;k!==A&&y[k]===0;)k++;for(var T=new Uint8Array(d+(A-k)),N=d;k!==A;)T[N++]=y[k++];return T}}}function m(p){var b=h(p);if(b)return b;throw new Error(`Non-${t} character`)}return{encode:f,decodeUnsafe:h,decode:m}}var Vu=Pu,Du=Vu,da=Du;var so=class{name;prefix;baseEncode;constructor(t,e,n){this.name=t,this.prefix=e,this.baseEncode=n}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}},oo=class{name;prefix;baseDecode;prefixCodePoint;constructor(t,e,n){this.name=t,this.prefix=e;let s=e.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=n}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return pa(this,t)}},io=class{decoders;constructor(t){this.decoders=t}or(t){return pa(this,t)}decode(t){let e=t[0],n=this.decoders[e];if(n!=null)return n.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};function pa(r,t){return new io({...r.decoders??{[r.prefix]:r},...t.decoders??{[t.prefix]:t}})}var ao=class{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(t,e,n,s){this.name=t,this.prefix=e,this.baseEncode=n,this.baseDecode=s,this.encoder=new so(t,e,n),this.decoder=new oo(t,e,s)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}};function nr({name:r,prefix:t,encode:e,decode:n}){return new ao(r,t,e,n)}function Be({name:r,prefix:t,alphabet:e}){let{encode:n,decode:s}=da(e,r);return nr({prefix:t,name:r,encode:n,decode:o=>ie(s(o))})}function Mu(r,t,e,n){let s={};for(let u=0;u<t.length;++u)s[t[u]]=u;let o=r.length;for(;r[o-1]==="=";)--o;let i=new Uint8Array(o*e/8|0),c=0,a=0,l=0;for(let u=0;u<o;++u){let f=s[r[u]];if(f===void 0)throw new SyntaxError(`Non-${n} character`);a=a<<e|f,c+=e,c>=8&&(c-=8,i[l++]=255&a>>c)}if(c>=e||255&a<<8-c)throw new SyntaxError("Unexpected end of data");return i}function Fu(r,t,e){let n=t[t.length-1]==="=",s=(1<<e)-1,o="",i=0,c=0;for(let a=0;a<r.length;++a)for(c=c<<8|r[a],i+=8;i>e;)i-=e,o+=t[s&c>>i];if(i!==0&&(o+=t[s&c<<e-i]),n)for(;o.length*e&7;)o+="=";return o}function ot({name:r,prefix:t,bitsPerChar:e,alphabet:n}){return nr({prefix:t,name:r,encode(s){return Fu(s,n,e)},decode(s){return Mu(s,n,e,r)}})}var X=Be({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Hu=Be({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var lo={};St(lo,{base32:()=>ae,base32hex:()=>zu,base32hexpad:()=>Wu,base32hexpadupper:()=>ju,base32hexupper:()=>Gu,base32pad:()=>qu,base32padupper:()=>$u,base32upper:()=>Ku,base32z:()=>Zu});var ae=ot({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Ku=ot({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),qu=ot({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),$u=ot({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),zu=ot({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Gu=ot({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Wu=ot({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),ju=ot({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Zu=ot({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var uo={};St(uo,{base36:()=>Ur,base36upper:()=>Yu});var Ur=Be({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Yu=Be({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var Ju=ya,ma=128,Xu=127,Qu=~Xu,tf=Math.pow(2,31);function ya(r,t,e){t=t||[],e=e||0;for(var n=e;r>=tf;)t[e++]=r&255|ma,r/=128;for(;r&Qu;)t[e++]=r&255|ma,r>>>=7;return t[e]=r|0,ya.bytes=e-n+1,t}var ef=fo,rf=128,ga=127;function fo(r,n){var e=0,n=n||0,s=0,o=n,i,c=r.length;do{if(o>=c)throw fo.bytes=0,new RangeError("Could not decode varint");i=r[o++],e+=s<28?(i&ga)<<s:(i&ga)*Math.pow(2,s),s+=7}while(i>=rf);return fo.bytes=o-n,e}var nf=Math.pow(2,7),sf=Math.pow(2,14),of=Math.pow(2,21),af=Math.pow(2,28),cf=Math.pow(2,35),lf=Math.pow(2,42),uf=Math.pow(2,49),ff=Math.pow(2,56),hf=Math.pow(2,63),df=function(r){return r<nf?1:r<sf?2:r<of?3:r<af?4:r<cf?5:r<lf?6:r<uf?7:r<ff?8:r<hf?9:10},pf={encode:Ju,decode:ef,encodingLength:df},mf=pf,Lr=mf;function Rr(r,t=0){return[Lr.decode(r,t),Lr.decode.bytes]}function sr(r,t,e=0){return Lr.encode(r,t,e),t}function or(r){return Lr.encodingLength(r)}function Mt(r,t){let e=t.byteLength,n=or(r),s=n+or(e),o=new Uint8Array(s+e);return sr(r,o,0),sr(e,o,n),o.set(t,s),new ir(r,e,t,o)}function Fe(r){let t=ie(r),[e,n]=Rr(t),[s,o]=Rr(t.subarray(n)),i=t.subarray(n+o);if(i.byteLength!==s)throw new Error("Incorrect length");return new ir(e,s,i,t)}function ba(r,t){if(r===t)return!0;{let e=t;return r.code===e.code&&r.size===e.size&&e.bytes instanceof Uint8Array&&la(r.bytes,e.bytes)}}var ir=class{code;size;digest;bytes;constructor(t,e,n,s){this.code=t,this.size=e,this.digest=n,this.bytes=s}};function wa(r,t){let{bytes:e,version:n}=r;switch(n){case 0:return yf(e,ho(r),t??X.encoder);default:return bf(e,ho(r),t??ae.encoder)}}var xa=new WeakMap;function ho(r){let t=xa.get(r);if(t==null){let e=new Map;return xa.set(r,e),e}return t}var dt=class r{code;version;multihash;bytes;"/";constructor(t,e,n,s){this.code=e,this.version=t,this.multihash=n,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{let{code:t,multihash:e}=this;if(t!==_r)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==wf)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return r.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{let{code:t,digest:e}=this.multihash,n=Mt(t,e);return r.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return r.equals(this,t)}static equals(t,e){let n=e;return n!=null&&t.code===n.code&&t.version===n.version&&ba(t.multihash,n.multihash)}toString(t){return wa(this,t)}toJSON(){return{"/":wa(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;let e=t;if(e instanceof r)return e;if(e["/"]!=null&&e["/"]===e.bytes||e.asCID===e){let{version:n,code:s,multihash:o,bytes:i}=e;return new r(n,s,o,i??va(n,s,o.bytes))}else if(e[xf]===!0){let{version:n,multihash:s,code:o}=e,i=Fe(s);return r.create(n,o,i)}else return null}static create(t,e,n){if(typeof e!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(e!==_r)throw new Error(`Version 0 CID must use dag-pb (code: ${_r}) block encoding`);return new r(t,e,n,n.bytes)}case 1:{let s=va(t,e,n.bytes);return new r(t,e,n,s)}default:throw new Error("Invalid version")}}static createV0(t){return r.create(0,_r,t)}static createV1(t,e){return r.create(1,t,e)}static decode(t){let[e,n]=r.decodeFirst(t);if(n.length!==0)throw new Error("Incorrect length");return e}static decodeFirst(t){let e=r.inspectBytes(t),n=e.size-e.multihashSize,s=ie(t.subarray(n,n+e.multihashSize));if(s.byteLength!==e.multihashSize)throw new Error("Incorrect length");let o=s.subarray(e.multihashSize-e.digestSize),i=new ir(e.multihashCode,e.digestSize,o,s);return[e.version===0?r.createV0(i):r.createV1(e.codec,i),t.subarray(e.size)]}static inspectBytes(t){let e=0,n=()=>{let[f,h]=Rr(t.subarray(e));return e+=h,f},s=n(),o=_r;if(s===18?(s=0,e=0):o=n(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);let i=e,c=n(),a=n(),l=e+a,u=l-i;return{version:s,codec:o,multihashCode:c,digestSize:a,multihashSize:u,size:l}}static parse(t,e){let[n,s]=gf(t,e),o=r.decode(s);if(o.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return ho(o).set(n,t),o}};function gf(r,t){switch(r[0]){case"Q":{let e=t??X;return[X.prefix,e.decode(`${X.prefix}${r}`)]}case X.prefix:{let e=t??X;return[X.prefix,e.decode(r)]}case ae.prefix:{let e=t??ae;return[ae.prefix,e.decode(r)]}case Ur.prefix:{let e=t??Ur;return[Ur.prefix,e.decode(r)]}default:{if(t==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],t.decode(r)]}}}function yf(r,t,e){let{prefix:n}=e;if(n!==X.prefix)throw Error(`Cannot string encode V0 in ${e.name} encoding`);let s=t.get(n);if(s==null){let o=e.encode(r).slice(1);return t.set(n,o),o}else return s}function bf(r,t,e){let{prefix:n}=e,s=t.get(n);if(s==null){let o=e.encode(r);return t.set(n,o),o}else return s}var _r=112,wf=18;function va(r,t,e){let n=or(r),s=n+or(t),o=new Uint8Array(s+e.byteLength);return sr(r,o,0),sr(t,o,n),o.set(e,s),o}var xf=Symbol.for("@ipld/js-cid/CID");var po={};St(po,{identity:()=>ce});var Ea=0,vf="identity",Ba=ie;function Ef(r){return Mt(Ea,Ba(r))}var ce={code:Ea,name:vf,encode:Ba,digest:Ef};function bt(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function Aa(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function Bf(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function ar(r,...t){if(!Bf(r))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(r.length))throw new Error("Uint8Array expected of length "+t+", got length="+r.length)}function Sa(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Aa(r.outputLen),Aa(r.blockLen)}function cr(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function Ia(r,t){ar(r);let e=t.outputLen;if(r.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}var He=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var wn=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),Ft=(r,t)=>r<<32-t|r>>>t;function ka(r){if(typeof r!="string")throw new Error("utf8ToBytes expected string, got "+typeof r);return new Uint8Array(new TextEncoder().encode(r))}function Or(r){return typeof r=="string"&&(r=ka(r)),ar(r),r}function mo(...r){let t=0;for(let n=0;n<r.length;n++){let s=r[n];ar(s),t+=s.length}let e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){let o=r[n];e.set(o,s),s+=o.length}return e}var lr=class{clone(){return this._cloneInto()}};function xn(r){let t=n=>r().update(Or(n)).digest(),e=r();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>r(),t}function vn(r=32){if(He&&typeof He.getRandomValues=="function")return He.getRandomValues(new Uint8Array(r));if(He&&typeof He.randomBytes=="function")return He.randomBytes(r);throw new Error("crypto.getRandomValues must be defined")}function Af(r,t,e,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(t,e,n);let s=BigInt(32),o=BigInt(4294967295),i=Number(e>>s&o),c=Number(e&o),a=n?4:0,l=n?0:4;r.setUint32(t+a,i,n),r.setUint32(t+l,c,n)}var Na=(r,t,e)=>r&t^~r&e,Ca=(r,t,e)=>r&t^r&e^t&e,ur=class extends lr{constructor(t,e,n,s){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=wn(this.buffer)}update(t){cr(this);let{view:e,buffer:n,blockLen:s}=this;t=Or(t);let o=t.length;for(let i=0;i<o;){let c=Math.min(s-this.pos,o-i);if(c===s){let a=wn(t);for(;s<=o-i;i+=s)this.process(a,i);continue}n.set(t.subarray(i,i+c),this.pos),this.pos+=c,i+=c,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){cr(this),Ia(t,this),this.finished=!0;let{buffer:e,view:n,blockLen:s,isLE:o}=this,{pos:i}=this;e[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>s-i&&(this.process(n,0),i=0);for(let f=i;f<s;f++)e[f]=0;Af(n,s-8,BigInt(this.length*8),o),this.process(n,0);let c=wn(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let l=a/4,u=this.get();if(l>u.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<l;f++)c.setUint32(4*f,u[f],o)}digest(){let{buffer:t,outputLen:e}=this;this.digestInto(t);let n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:e,buffer:n,length:s,finished:o,destroyed:i,pos:c}=this;return t.length=s,t.pos=c,t.finished=o,t.destroyed=i,s%e&&t.buffer.set(n),t}};var En=BigInt(4294967295),go=BigInt(32);function Ta(r,t=!1){return t?{h:Number(r&En),l:Number(r>>go&En)}:{h:Number(r>>go&En)|0,l:Number(r&En)|0}}function Sf(r,t=!1){let e=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let s=0;s<r.length;s++){let{h:o,l:i}=Ta(r[s],t);[e[s],n[s]]=[o,i]}return[e,n]}var If=(r,t)=>BigInt(r>>>0)<<go|BigInt(t>>>0),kf=(r,t,e)=>r>>>e,Nf=(r,t,e)=>r<<32-e|t>>>e,Cf=(r,t,e)=>r>>>e|t<<32-e,Tf=(r,t,e)=>r<<32-e|t>>>e,Uf=(r,t,e)=>r<<64-e|t>>>e-32,Lf=(r,t,e)=>r>>>e-32|t<<64-e,Rf=(r,t)=>t,_f=(r,t)=>r,Of=(r,t,e)=>r<<e|t>>>32-e,Pf=(r,t,e)=>t<<e|r>>>32-e,Vf=(r,t,e)=>t<<e-32|r>>>64-e,Df=(r,t,e)=>r<<e-32|t>>>64-e;function Mf(r,t,e,n){let s=(t>>>0)+(n>>>0);return{h:r+e+(s/2**32|0)|0,l:s|0}}var Ff=(r,t,e)=>(r>>>0)+(t>>>0)+(e>>>0),Hf=(r,t,e,n)=>t+e+n+(r/2**32|0)|0,Kf=(r,t,e,n)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0),qf=(r,t,e,n,s)=>t+e+n+s+(r/2**32|0)|0,$f=(r,t,e,n,s)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(s>>>0),zf=(r,t,e,n,s,o)=>t+e+n+s+o+(r/2**32|0)|0;var Gf={fromBig:Ta,split:Sf,toBig:If,shrSH:kf,shrSL:Nf,rotrSH:Cf,rotrSL:Tf,rotrBH:Uf,rotrBL:Lf,rotr32H:Rf,rotr32L:_f,rotlSH:Of,rotlSL:Pf,rotlBH:Vf,rotlBL:Df,add:Mf,add3L:Ff,add3H:Hf,add4L:Kf,add4H:qf,add5H:zf,add5L:$f},P=Gf;var[Wf,jf]=P.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),Se=new Uint32Array(80),Ie=new Uint32Array(80),yo=class extends ur{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){let{Ah:t,Al:e,Bh:n,Bl:s,Ch:o,Cl:i,Dh:c,Dl:a,Eh:l,El:u,Fh:f,Fl:h,Gh:m,Gl:p,Hh:b,Hl:d}=this;return[t,e,n,s,o,i,c,a,l,u,f,h,m,p,b,d]}set(t,e,n,s,o,i,c,a,l,u,f,h,m,p,b,d){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=c|0,this.Dl=a|0,this.Eh=l|0,this.El=u|0,this.Fh=f|0,this.Fl=h|0,this.Gh=m|0,this.Gl=p|0,this.Hh=b|0,this.Hl=d|0}process(t,e){for(let y=0;y<16;y++,e+=4)Se[y]=t.getUint32(e),Ie[y]=t.getUint32(e+=4);for(let y=16;y<80;y++){let I=Se[y-15]|0,L=Ie[y-15]|0,U=P.rotrSH(I,L,1)^P.rotrSH(I,L,8)^P.shrSH(I,L,7),k=P.rotrSL(I,L,1)^P.rotrSL(I,L,8)^P.shrSL(I,L,7),T=Se[y-2]|0,N=Ie[y-2]|0,tt=P.rotrSH(T,N,19)^P.rotrBH(T,N,61)^P.shrSH(T,N,6),q=P.rotrSL(T,N,19)^P.rotrBL(T,N,61)^P.shrSL(T,N,6),D=P.add4L(k,q,Ie[y-7],Ie[y-16]),it=P.add4H(D,U,tt,Se[y-7],Se[y-16]);Se[y]=it|0,Ie[y]=D|0}let{Ah:n,Al:s,Bh:o,Bl:i,Ch:c,Cl:a,Dh:l,Dl:u,Eh:f,El:h,Fh:m,Fl:p,Gh:b,Gl:d,Hh:v,Hl:A}=this;for(let y=0;y<80;y++){let I=P.rotrSH(f,h,14)^P.rotrSH(f,h,18)^P.rotrBH(f,h,41),L=P.rotrSL(f,h,14)^P.rotrSL(f,h,18)^P.rotrBL(f,h,41),U=f&m^~f&b,k=h&p^~h&d,T=P.add5L(A,L,k,jf[y],Ie[y]),N=P.add5H(T,v,I,U,Wf[y],Se[y]),tt=T|0,q=P.rotrSH(n,s,28)^P.rotrBH(n,s,34)^P.rotrBH(n,s,39),D=P.rotrSL(n,s,28)^P.rotrBL(n,s,34)^P.rotrBL(n,s,39),it=n&o^n&c^o&c,E=s&i^s&a^i&a;v=b|0,A=d|0,b=m|0,d=p|0,m=f|0,p=h|0,{h:f,l:h}=P.add(l|0,u|0,N|0,tt|0),l=c|0,u=a|0,c=o|0,a=i|0,o=n|0,i=s|0;let C=P.add3L(tt,D,E);n=P.add3H(C,N,q,it),s=C|0}({h:n,l:s}=P.add(this.Ah|0,this.Al|0,n|0,s|0)),{h:o,l:i}=P.add(this.Bh|0,this.Bl|0,o|0,i|0),{h:c,l:a}=P.add(this.Ch|0,this.Cl|0,c|0,a|0),{h:l,l:u}=P.add(this.Dh|0,this.Dl|0,l|0,u|0),{h:f,l:h}=P.add(this.Eh|0,this.El|0,f|0,h|0),{h:m,l:p}=P.add(this.Fh|0,this.Fl|0,m|0,p|0),{h:b,l:d}=P.add(this.Gh|0,this.Gl|0,b|0,d|0),{h:v,l:A}=P.add(this.Hh|0,this.Hl|0,v|0,A|0),this.set(n,s,o,i,c,a,l,u,f,h,m,p,b,d,v,A)}roundClean(){Se.fill(0),Ie.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}};var Ua=xn(()=>new yo);var Sn={};St(Sn,{aInRange:()=>Ct,abool:()=>Ht,abytes:()=>fr,bitGet:()=>th,bitLen:()=>vo,bitMask:()=>Vr,bitSet:()=>eh,bytesToHex:()=>ue,bytesToNumberBE:()=>fe,bytesToNumberLE:()=>Ne,concatBytes:()=>he,createHmacDrbg:()=>Eo,ensureBytes:()=>nt,equalBytes:()=>Xf,hexToBytes:()=>qe,hexToNumber:()=>xo,inRange:()=>Pr,isBytes:()=>ke,memoized:()=>ze,notImplemented:()=>nh,numberToBytesBE:()=>Ce,numberToBytesLE:()=>$e,numberToHexUnpadded:()=>Ke,numberToVarBytesBE:()=>Jf,utf8ToBytes:()=>Qf,validateObject:()=>Xt});var Bn=BigInt(0),An=BigInt(1),Zf=BigInt(2);function ke(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function fr(r){if(!ke(r))throw new Error("Uint8Array expected")}function Ht(r,t){if(typeof t!="boolean")throw new Error(r+" boolean expected, got "+t)}var Yf=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function ue(r){fr(r);let t="";for(let e=0;e<r.length;e++)t+=Yf[r[e]];return t}function Ke(r){let t=r.toString(16);return t.length&1?"0"+t:t}function xo(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?Bn:BigInt("0x"+r)}var le={_0:48,_9:57,A:65,F:70,a:97,f:102};function La(r){if(r>=le._0&&r<=le._9)return r-le._0;if(r>=le.A&&r<=le.F)return r-(le.A-10);if(r>=le.a&&r<=le.f)return r-(le.a-10)}function qe(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);let t=r.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);let n=new Uint8Array(e);for(let s=0,o=0;s<e;s++,o+=2){let i=La(r.charCodeAt(o)),c=La(r.charCodeAt(o+1));if(i===void 0||c===void 0){let a=r[o]+r[o+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+o)}n[s]=i*16+c}return n}function fe(r){return xo(ue(r))}function Ne(r){return fr(r),xo(ue(Uint8Array.from(r).reverse()))}function Ce(r,t){return qe(r.toString(16).padStart(t*2,"0"))}function $e(r,t){return Ce(r,t).reverse()}function Jf(r){return qe(Ke(r))}function nt(r,t,e){let n;if(typeof t=="string")try{n=qe(t)}catch(o){throw new Error(r+" must be hex string or Uint8Array, cause: "+o)}else if(ke(t))n=Uint8Array.from(t);else throw new Error(r+" must be hex string or Uint8Array");let s=n.length;if(typeof e=="number"&&s!==e)throw new Error(r+" of length "+e+" expected, got "+s);return n}function he(...r){let t=0;for(let n=0;n<r.length;n++){let s=r[n];fr(s),t+=s.length}let e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){let o=r[n];e.set(o,s),s+=o.length}return e}function Xf(r,t){if(r.length!==t.length)return!1;let e=0;for(let n=0;n<r.length;n++)e|=r[n]^t[n];return e===0}function Qf(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}var bo=r=>typeof r=="bigint"&&Bn<=r;function Pr(r,t,e){return bo(r)&&bo(t)&&bo(e)&&t<=r&&r<e}function Ct(r,t,e,n){if(!Pr(t,e,n))throw new Error("expected valid "+r+": "+e+" <= n < "+n+", got "+t)}function vo(r){let t;for(t=0;r>Bn;r>>=An,t+=1);return t}function th(r,t){return r>>BigInt(t)&An}function eh(r,t,e){return r|(e?An:Bn)<<BigInt(t)}var Vr=r=>(Zf<<BigInt(r-1))-An,wo=r=>new Uint8Array(r),Ra=r=>Uint8Array.from(r);function Eo(r,t,e){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let n=wo(r),s=wo(r),o=0,i=()=>{n.fill(1),s.fill(0),o=0},c=(...f)=>e(s,n,...f),a=(f=wo())=>{s=c(Ra([0]),f),n=c(),f.length!==0&&(s=c(Ra([1]),f),n=c())},l=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let f=0,h=[];for(;f<t;){n=c();let m=n.slice();h.push(m),f+=n.length}return he(...h)};return(f,h)=>{i(),a(f);let m;for(;!(m=h(l()));)a();return i(),m}}var rh={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||ke(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,t)=>t.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function Xt(r,t,e={}){let n=(s,o,i)=>{let c=rh[o];if(typeof c!="function")throw new Error("invalid validator function");let a=r[s];if(!(i&&a===void 0)&&!c(a,r))throw new Error("param "+String(s)+" is invalid. Expected "+o+", got "+a)};for(let[s,o]of Object.entries(t))n(s,o,!1);for(let[s,o]of Object.entries(e))n(s,o,!0);return r}var nh=()=>{throw new Error("not implemented")};function ze(r){let t=new WeakMap;return(e,...n)=>{let s=t.get(e);if(s!==void 0)return s;let o=r(e,...n);return t.set(e,o),o}}var at=BigInt(0),et=BigInt(1),Ge=BigInt(2),sh=BigInt(3),Bo=BigInt(4),_a=BigInt(5),Oa=BigInt(8),oh=BigInt(9),ih=BigInt(16);function Z(r,t){let e=r%t;return e>=at?e:t+e}function ah(r,t,e){if(t<at)throw new Error("invalid exponent, negatives unsupported");if(e<=at)throw new Error("invalid modulus");if(e===et)return at;let n=et;for(;t>at;)t&et&&(n=n*r%e),r=r*r%e,t>>=et;return n}function rt(r,t,e){let n=r;for(;t-- >at;)n*=n,n%=e;return n}function In(r,t){if(r===at)throw new Error("invert: expected non-zero number");if(t<=at)throw new Error("invert: expected positive modulus, got "+t);let e=Z(r,t),n=t,s=at,o=et,i=et,c=at;for(;e!==at;){let l=n/e,u=n%e,f=s-i*l,h=o-c*l;n=e,e=u,s=i,o=c,i=f,c=h}if(n!==et)throw new Error("invert: does not exist");return Z(s,t)}function ch(r){let t=(r-et)/Ge,e,n,s;for(e=r-et,n=0;e%Ge===at;e/=Ge,n++);for(s=Ge;s<r&&ah(s,t,r)!==r-et;s++)if(s>1e3)throw new Error("Cannot find square root: likely non-prime P");if(n===1){let i=(r+et)/Bo;return function(a,l){let u=a.pow(l,i);if(!a.eql(a.sqr(u),l))throw new Error("Cannot find square root");return u}}let o=(e+et)/Ge;return function(c,a){if(c.pow(a,t)===c.neg(c.ONE))throw new Error("Cannot find square root");let l=n,u=c.pow(c.mul(c.ONE,s),e),f=c.pow(a,o),h=c.pow(a,e);for(;!c.eql(h,c.ONE);){if(c.eql(h,c.ZERO))return c.ZERO;let m=1;for(let b=c.sqr(h);m<l&&!c.eql(b,c.ONE);m++)b=c.sqr(b);let p=c.pow(u,et<<BigInt(l-m-1));u=c.sqr(p),f=c.mul(f,p),h=c.mul(h,u),l=m}return f}}function lh(r){if(r%Bo===sh){let t=(r+et)/Bo;return function(n,s){let o=n.pow(s,t);if(!n.eql(n.sqr(o),s))throw new Error("Cannot find square root");return o}}if(r%Oa===_a){let t=(r-_a)/Oa;return function(n,s){let o=n.mul(s,Ge),i=n.pow(o,t),c=n.mul(s,i),a=n.mul(n.mul(c,Ge),i),l=n.mul(c,n.sub(a,n.ONE));if(!n.eql(n.sqr(l),s))throw new Error("Cannot find square root");return l}}return r%ih,ch(r)}var Pa=(r,t)=>(Z(r,t)&et)===et,uh=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ao(r){let t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=uh.reduce((n,s)=>(n[s]="function",n),t);return Xt(r,e)}function fh(r,t,e){if(e<at)throw new Error("invalid exponent, negatives unsupported");if(e===at)return r.ONE;if(e===et)return t;let n=r.ONE,s=t;for(;e>at;)e&et&&(n=r.mul(n,s)),s=r.sqr(s),e>>=et;return n}function hh(r,t){let e=new Array(t.length),n=t.reduce((o,i,c)=>r.is0(i)?o:(e[c]=o,r.mul(o,i)),r.ONE),s=r.inv(n);return t.reduceRight((o,i,c)=>r.is0(i)?o:(e[c]=r.mul(o,e[c]),r.mul(o,i)),s),e}function So(r,t){let e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}function Te(r,t,e=!1,n={}){if(r<=at)throw new Error("invalid field: expected ORDER > 0, got "+r);let{nBitLength:s,nByteLength:o}=So(r,t);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let i,c=Object.freeze({ORDER:r,isLE:e,BITS:s,BYTES:o,MASK:Vr(s),ZERO:at,ONE:et,create:a=>Z(a,r),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return at<=a&&a<r},is0:a=>a===at,isOdd:a=>(a&et)===et,neg:a=>Z(-a,r),eql:(a,l)=>a===l,sqr:a=>Z(a*a,r),add:(a,l)=>Z(a+l,r),sub:(a,l)=>Z(a-l,r),mul:(a,l)=>Z(a*l,r),pow:(a,l)=>fh(c,a,l),div:(a,l)=>Z(a*In(l,r),r),sqrN:a=>a*a,addN:(a,l)=>a+l,subN:(a,l)=>a-l,mulN:(a,l)=>a*l,inv:a=>In(a,r),sqrt:n.sqrt||(a=>(i||(i=lh(r)),i(c,a))),invertBatch:a=>hh(c,a),cmov:(a,l,u)=>u?l:a,toBytes:a=>e?$e(a,o):Ce(a,o),fromBytes:a=>{if(a.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+a.length);return e?Ne(a):fe(a)}});return Object.freeze(c)}function Va(r){if(typeof r!="bigint")throw new Error("field order must be bigint");let t=r.toString(2).length;return Math.ceil(t/8)}function Io(r){let t=Va(r);return t+Math.ceil(t/2)}function Da(r,t,e=!1){let n=r.length,s=Va(t),o=Io(t);if(n<16||n<o||n>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+n);let i=e?Ne(r):fe(r),c=Z(i,t-et)+et;return e?$e(c,s):Ce(c,s)}var Ma=BigInt(0),kn=BigInt(1);function ko(r,t){let e=t.negate();return r?e:t}function Fa(r,t){if(!Number.isSafeInteger(r)||r<=0||r>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+r)}function No(r,t){Fa(r,t);let e=Math.ceil(t/r)+1,n=2**(r-1);return{windows:e,windowSize:n}}function ph(r,t){if(!Array.isArray(r))throw new Error("array expected");r.forEach((e,n)=>{if(!(e instanceof t))throw new Error("invalid point at index "+n)})}function mh(r,t){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((e,n)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+n)})}var Co=new WeakMap,Ha=new WeakMap;function To(r){return Ha.get(r)||1}function Nn(r,t){return{constTimeNegate:ko,hasPrecomputes(e){return To(e)!==1},unsafeLadder(e,n,s=r.ZERO){let o=e;for(;n>Ma;)n&kn&&(s=s.add(o)),o=o.double(),n>>=kn;return s},precomputeWindow(e,n){let{windows:s,windowSize:o}=No(n,t),i=[],c=e,a=c;for(let l=0;l<s;l++){a=c,i.push(a);for(let u=1;u<o;u++)a=a.add(c),i.push(a);c=a.double()}return i},wNAF(e,n,s){let{windows:o,windowSize:i}=No(e,t),c=r.ZERO,a=r.BASE,l=BigInt(2**e-1),u=2**e,f=BigInt(e);for(let h=0;h<o;h++){let m=h*i,p=Number(s&l);s>>=f,p>i&&(p-=u,s+=kn);let b=m,d=m+Math.abs(p)-1,v=h%2!==0,A=p<0;p===0?a=a.add(ko(v,n[b])):c=c.add(ko(A,n[d]))}return{p:c,f:a}},wNAFUnsafe(e,n,s,o=r.ZERO){let{windows:i,windowSize:c}=No(e,t),a=BigInt(2**e-1),l=2**e,u=BigInt(e);for(let f=0;f<i;f++){let h=f*c;if(s===Ma)break;let m=Number(s&a);if(s>>=u,m>c&&(m-=l,s+=kn),m===0)continue;let p=n[h+Math.abs(m)-1];m<0&&(p=p.negate()),o=o.add(p)}return o},getPrecomputes(e,n,s){let o=Co.get(n);return o||(o=this.precomputeWindow(n,e),e!==1&&Co.set(n,s(o))),o},wNAFCached(e,n,s){let o=To(e);return this.wNAF(o,this.getPrecomputes(o,e,s),n)},wNAFCachedUnsafe(e,n,s,o){let i=To(e);return i===1?this.unsafeLadder(e,n,o):this.wNAFUnsafe(i,this.getPrecomputes(i,e,s),n,o)},setWindowSize(e,n){Fa(n,t),Ha.set(e,n),Co.delete(e)}}}function Cn(r,t,e,n){if(ph(e,r),mh(n,t),e.length!==n.length)throw new Error("arrays of points and scalars must have equal length");let s=r.ZERO,o=vo(BigInt(e.length)),i=o>12?o-3:o>4?o-2:o?2:1,c=(1<<i)-1,a=new Array(c+1).fill(s),l=Math.floor((t.BITS-1)/i)*i,u=s;for(let f=l;f>=0;f-=i){a.fill(s);for(let m=0;m<n.length;m++){let p=n[m],b=Number(p>>BigInt(f)&BigInt(c));a[b]=a[b].add(e[m])}let h=s;for(let m=a.length-1,p=s;m>0;m--)p=p.add(a[m]),h=h.add(p);if(u=u.add(h),f!==0)for(let m=0;m<i;m++)u=u.double()}return u}function Dr(r){return Ao(r.Fp),Xt(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...So(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}var Kt=BigInt(0),Tt=BigInt(1),Tn=BigInt(2),gh=BigInt(8),yh={zip215:!0};function bh(r){let t=Dr(r);return Xt(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}function Ka(r){let t=bh(r),{Fp:e,n,prehash:s,hash:o,randomBytes:i,nByteLength:c,h:a}=t,l=Tn<<BigInt(c*8)-Tt,u=e.create,f=Te(t.n,t.nBitLength),h=t.uvRatio||((w,g)=>{try{return{isValid:!0,value:e.sqrt(w*e.inv(g))}}catch{return{isValid:!1,value:Kt}}}),m=t.adjustScalarBytes||(w=>w),p=t.domain||((w,g,x)=>{if(Ht("phflag",x),g.length||x)throw new Error("Contexts/pre-hash are not supported");return w});function b(w,g){Ct("coordinate "+w,g,Kt,l)}function d(w){if(!(w instanceof y))throw new Error("ExtendedPoint expected")}let v=ze((w,g)=>{let{ex:x,ey:S,ez:R}=w,_=w.is0();g==null&&(g=_?gh:e.inv(R));let V=u(x*g),F=u(S*g),O=u(R*g);if(_)return{x:Kt,y:Tt};if(O!==Tt)throw new Error("invZ was invalid");return{x:V,y:F}}),A=ze(w=>{let{a:g,d:x}=t;if(w.is0())throw new Error("bad point: ZERO");let{ex:S,ey:R,ez:_,et:V}=w,F=u(S*S),O=u(R*R),j=u(_*_),J=u(j*j),lt=u(F*g),ut=u(j*u(lt+O)),ht=u(J+u(x*u(F*O)));if(ut!==ht)throw new Error("bad point: equation left != right (1)");let yt=u(S*R),Nt=u(_*V);if(yt!==Nt)throw new Error("bad point: equation left != right (2)");return!0});class y{constructor(g,x,S,R){this.ex=g,this.ey=x,this.ez=S,this.et=R,b("x",g),b("y",x),b("z",S),b("t",R),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(g){if(g instanceof y)throw new Error("extended point not allowed");let{x,y:S}=g||{};return b("x",x),b("y",S),new y(x,S,Tt,u(x*S))}static normalizeZ(g){let x=e.invertBatch(g.map(S=>S.ez));return g.map((S,R)=>S.toAffine(x[R])).map(y.fromAffine)}static msm(g,x){return Cn(y,f,g,x)}_setWindowSize(g){U.setWindowSize(this,g)}assertValidity(){A(this)}equals(g){d(g);let{ex:x,ey:S,ez:R}=this,{ex:_,ey:V,ez:F}=g,O=u(x*F),j=u(_*R),J=u(S*F),lt=u(V*R);return O===j&&J===lt}is0(){return this.equals(y.ZERO)}negate(){return new y(u(-this.ex),this.ey,this.ez,u(-this.et))}double(){let{a:g}=t,{ex:x,ey:S,ez:R}=this,_=u(x*x),V=u(S*S),F=u(Tn*u(R*R)),O=u(g*_),j=x+S,J=u(u(j*j)-_-V),lt=O+V,ut=lt-F,ht=O-V,yt=u(J*ut),Nt=u(lt*ht),At=u(J*ht),Jt=u(ut*lt);return new y(yt,Nt,Jt,At)}add(g){d(g);let{a:x,d:S}=t,{ex:R,ey:_,ez:V,et:F}=this,{ex:O,ey:j,ez:J,et:lt}=g;if(x===BigInt(-1)){let ea=u((_-R)*(j+O)),ra=u((_+R)*(j-O)),to=u(ra-ea);if(to===Kt)return this.double();let na=u(V*Tn*lt),sa=u(F*Tn*J),oa=sa+na,ia=ra+ea,aa=sa-na,Iu=u(oa*to),ku=u(ia*aa),Nu=u(oa*aa),Cu=u(to*ia);return new y(Iu,ku,Cu,Nu)}let ut=u(R*O),ht=u(_*j),yt=u(F*S*lt),Nt=u(V*J),At=u((R+_)*(O+j)-ut-ht),Jt=Nt-yt,oe=Nt+yt,Cr=u(ht-x*ut),Eu=u(At*Jt),Bu=u(oe*Cr),Au=u(At*Cr),Su=u(Jt*oe);return new y(Eu,Bu,Su,Au)}subtract(g){return this.add(g.negate())}wNAF(g){return U.wNAFCached(this,g,y.normalizeZ)}multiply(g){let x=g;Ct("scalar",x,Tt,n);let{p:S,f:R}=this.wNAF(x);return y.normalizeZ([S,R])[0]}multiplyUnsafe(g,x=y.ZERO){let S=g;return Ct("scalar",S,Kt,n),S===Kt?L:this.is0()||S===Tt?this:U.wNAFCachedUnsafe(this,S,y.normalizeZ,x)}isSmallOrder(){return this.multiplyUnsafe(a).is0()}isTorsionFree(){return U.unsafeLadder(this,n).is0()}toAffine(g){return v(this,g)}clearCofactor(){let{h:g}=t;return g===Tt?this:this.multiplyUnsafe(g)}static fromHex(g,x=!1){let{d:S,a:R}=t,_=e.BYTES;g=nt("pointHex",g,_),Ht("zip215",x);let V=g.slice(),F=g[_-1];V[_-1]=F&-129;let O=Ne(V),j=x?l:e.ORDER;Ct("pointHex.y",O,Kt,j);let J=u(O*O),lt=u(J-Tt),ut=u(S*J-R),{isValid:ht,value:yt}=h(lt,ut);if(!ht)throw new Error("Point.fromHex: invalid y coordinate");let Nt=(yt&Tt)===Tt,At=(F&128)!==0;if(!x&&yt===Kt&&At)throw new Error("Point.fromHex: x=0 and x_0=1");return At!==Nt&&(yt=u(-yt)),y.fromAffine({x:yt,y:O})}static fromPrivateKey(g){return N(g).point}toRawBytes(){let{x:g,y:x}=this.toAffine(),S=$e(x,e.BYTES);return S[S.length-1]|=g&Tt?128:0,S}toHex(){return ue(this.toRawBytes())}}y.BASE=new y(t.Gx,t.Gy,Tt,u(t.Gx*t.Gy)),y.ZERO=new y(Kt,Tt,Tt,Kt);let{BASE:I,ZERO:L}=y,U=Nn(y,c*8);function k(w){return Z(w,n)}function T(w){return k(Ne(w))}function N(w){let g=e.BYTES;w=nt("private key",w,g);let x=nt("hashed private key",o(w),2*g),S=m(x.slice(0,g)),R=x.slice(g,2*g),_=T(S),V=I.multiply(_),F=V.toRawBytes();return{head:S,prefix:R,scalar:_,point:V,pointBytes:F}}function tt(w){return N(w).pointBytes}function q(w=new Uint8Array,...g){let x=he(...g);return T(o(p(x,nt("context",w),!!s)))}function D(w,g,x={}){w=nt("message",w),s&&(w=s(w));let{prefix:S,scalar:R,pointBytes:_}=N(g),V=q(x.context,S,w),F=I.multiply(V).toRawBytes(),O=q(x.context,F,_,w),j=k(V+O*R);Ct("signature.s",j,Kt,n);let J=he(F,$e(j,e.BYTES));return nt("result",J,e.BYTES*2)}let it=yh;function E(w,g,x,S=it){let{context:R,zip215:_}=S,V=e.BYTES;w=nt("signature",w,2*V),g=nt("message",g),x=nt("publicKey",x,V),_!==void 0&&Ht("zip215",_),s&&(g=s(g));let F=Ne(w.slice(V,2*V)),O,j,J;try{O=y.fromHex(x,_),j=y.fromHex(w.slice(0,V),_),J=I.multiplyUnsafe(F)}catch{return!1}if(!_&&O.isSmallOrder())return!1;let lt=q(R,j.toRawBytes(),O.toRawBytes(),g);return j.add(O.multiplyUnsafe(lt)).subtract(J).clearCofactor().equals(y.ZERO)}return I._setWindowSize(8),{CURVE:t,getPublicKey:tt,sign:D,verify:E,ExtendedPoint:y,utils:{getExtendedPublicKey:N,randomPrivateKey:()=>i(e.BYTES),precompute(w=8,g=y.BASE){return g._setWindowSize(w),g.multiply(BigInt(3)),g}}}}var Uo=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),qa=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),Wp=BigInt(0),wh=BigInt(1),$a=BigInt(2),jp=BigInt(3),xh=BigInt(5),vh=BigInt(8);function Eh(r){let t=BigInt(10),e=BigInt(20),n=BigInt(40),s=BigInt(80),o=Uo,c=r*r%o*r%o,a=rt(c,$a,o)*c%o,l=rt(a,wh,o)*r%o,u=rt(l,xh,o)*l%o,f=rt(u,t,o)*u%o,h=rt(f,e,o)*f%o,m=rt(h,n,o)*h%o,p=rt(m,s,o)*m%o,b=rt(p,s,o)*m%o,d=rt(b,t,o)*u%o;return{pow_p_5_8:rt(d,$a,o)*r%o,b2:c}}function Bh(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function Ah(r,t){let e=Uo,n=Z(t*t*t,e),s=Z(n*n*t,e),o=Eh(r*s).pow_p_5_8,i=Z(r*n*o,e),c=Z(t*i*i,e),a=i,l=Z(i*qa,e),u=c===r,f=c===Z(-r,e),h=c===Z(-r*qa,e);return u&&(i=a),(f||h)&&(i=l),Pa(i,e)&&(i=Z(-i,e)),{isValid:u||f,value:i}}var Sh=Te(Uo,void 0,!0),Ih={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:Sh,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:vh,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Ua,randomBytes:vn,adjustScalarBytes:Bh,uvRatio:Ah},za=Ka(Ih);var Un=32;function Ga(r,t,e){return za.verify(t,e instanceof Uint8Array?e:e.subarray(),r)}var Ln=class{type="Ed25519";raw;constructor(t){this.raw=Lo(t,Un)}toMultihash(){return ce.digest(Ue(this))}toCID(){return dt.createV1(114,this.toMultihash())}toString(){return X.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:bt(this.raw,t.raw)}verify(t,e){return Ga(this.raw,e,t)}};function Ro(r){return r=Lo(r,Un),new Ln(r)}function Lo(r,t){if(r=Uint8Array.from(r??[]),r.length!==t)throw new It(`Key must be a Uint8Array of length ${t}, got ${r.length}`);return r}function pt(r=0){return new Uint8Array(r)}function Ut(r=0){return new Uint8Array(r)}var Nh=Math.pow(2,7),Ch=Math.pow(2,14),Th=Math.pow(2,21),_o=Math.pow(2,28),Oo=Math.pow(2,35),Po=Math.pow(2,42),Vo=Math.pow(2,49),W=128,wt=127;function xt(r){if(r<Nh)return 1;if(r<Ch)return 2;if(r<Th)return 3;if(r<_o)return 4;if(r<Oo)return 5;if(r<Po)return 6;if(r<Vo)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function Do(r,t,e=0){switch(xt(r)){case 8:t[e++]=r&255|W,r/=128;case 7:t[e++]=r&255|W,r/=128;case 6:t[e++]=r&255|W,r/=128;case 5:t[e++]=r&255|W,r/=128;case 4:t[e++]=r&255|W,r>>>=7;case 3:t[e++]=r&255|W,r>>>=7;case 2:t[e++]=r&255|W,r>>>=7;case 1:{t[e++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return t}function Uh(r,t,e=0){switch(xt(r)){case 8:t.set(e++,r&255|W),r/=128;case 7:t.set(e++,r&255|W),r/=128;case 6:t.set(e++,r&255|W),r/=128;case 5:t.set(e++,r&255|W),r/=128;case 4:t.set(e++,r&255|W),r>>>=7;case 3:t.set(e++,r&255|W),r>>>=7;case 2:t.set(e++,r&255|W),r>>>=7;case 1:{t.set(e++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return t}function Mo(r,t){let e=r[t],n=0;if(n+=e&wt,e<W||(e=r[t+1],n+=(e&wt)<<7,e<W)||(e=r[t+2],n+=(e&wt)<<14,e<W)||(e=r[t+3],n+=(e&wt)<<21,e<W)||(e=r[t+4],n+=(e&wt)*_o,e<W)||(e=r[t+5],n+=(e&wt)*Oo,e<W)||(e=r[t+6],n+=(e&wt)*Po,e<W)||(e=r[t+7],n+=(e&wt)*Vo,e<W))return n;throw new RangeError("Could not decode varint")}function Lh(r,t){let e=r.get(t),n=0;if(n+=e&wt,e<W||(e=r.get(t+1),n+=(e&wt)<<7,e<W)||(e=r.get(t+2),n+=(e&wt)<<14,e<W)||(e=r.get(t+3),n+=(e&wt)<<21,e<W)||(e=r.get(t+4),n+=(e&wt)*_o,e<W)||(e=r.get(t+5),n+=(e&wt)*Oo,e<W)||(e=r.get(t+6),n+=(e&wt)*Po,e<W)||(e=r.get(t+7),n+=(e&wt)*Vo,e<W))return n;throw new RangeError("Could not decode varint")}function Pt(r,t,e=0){return t==null&&(t=Ut(xt(r))),t instanceof Uint8Array?Do(r,t,e):Uh(r,t,e)}function de(r,t=0){return r instanceof Uint8Array?Mo(r,t):Lh(r,t)}var Fo=new Float32Array([-0]),Le=new Uint8Array(Fo.buffer);function ja(r,t,e){Fo[0]=r,t[e]=Le[0],t[e+1]=Le[1],t[e+2]=Le[2],t[e+3]=Le[3]}function Za(r,t){return Le[0]=r[t],Le[1]=r[t+1],Le[2]=r[t+2],Le[3]=r[t+3],Fo[0]}var Ho=new Float64Array([-0]),vt=new Uint8Array(Ho.buffer);function Ya(r,t,e){Ho[0]=r,t[e]=vt[0],t[e+1]=vt[1],t[e+2]=vt[2],t[e+3]=vt[3],t[e+4]=vt[4],t[e+5]=vt[5],t[e+6]=vt[6],t[e+7]=vt[7]}function Ja(r,t){return vt[0]=r[t],vt[1]=r[t+1],vt[2]=r[t+2],vt[3]=r[t+3],vt[4]=r[t+4],vt[5]=r[t+5],vt[6]=r[t+6],vt[7]=r[t+7],Ho[0]}var Rh=BigInt(Number.MAX_SAFE_INTEGER),_h=BigInt(Number.MIN_SAFE_INTEGER),_t=class r{lo;hi;constructor(t,e){this.lo=t|0,this.hi=e|0}toNumber(t=!1){if(!t&&this.hi>>>31>0){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(e+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(t=!1){if(t)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(BigInt(e)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(t=!1){return this.toBigInt(t).toString()}zzEncode(){let t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this}zzDecode(){let t=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this}length(){let t=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?e===0?t<16384?t<128?1:2:t<2097152?3:4:e<16384?e<128?5:6:e<2097152?7:8:n<128?9:10}static fromBigInt(t){if(t===0n)return We;if(t<Rh&&t>_h)return this.fromNumber(Number(t));let e=t<0n;e&&(t=-t);let n=t>>32n,s=t-(n<<32n);return e&&(n=~n|0n,s=~s|0n,++s>Xa&&(s=0n,++n>Xa&&(n=0n))),new r(Number(s),Number(n))}static fromNumber(t){if(t===0)return We;let e=t<0;e&&(t=-t);let n=t>>>0,s=(t-n)/4294967296>>>0;return e&&(s=~s>>>0,n=~n>>>0,++n>4294967295&&(n=0,++s>4294967295&&(s=0))),new r(n,s)}static from(t){return typeof t=="number"?r.fromNumber(t):typeof t=="bigint"?r.fromBigInt(t):typeof t=="string"?r.fromBigInt(BigInt(t)):t.low!=null||t.high!=null?new r(t.low>>>0,t.high>>>0):We}},We=new _t(0,0);We.toBigInt=function(){return 0n};We.zzEncode=We.zzDecode=function(){return this};We.length=function(){return 1};var Xa=4294967296n;function Qa(r){let t=0,e=0;for(let n=0;n<r.length;++n)e=r.charCodeAt(n),e<128?t+=1:e<2048?t+=2:(e&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,t+=4):t+=3;return t}function tc(r,t,e){if(e-t<1)return"";let s,o=[],i=0,c;for(;t<e;)c=r[t++],c<128?o[i++]=c:c>191&&c<224?o[i++]=(c&31)<<6|r[t++]&63:c>239&&c<365?(c=((c&7)<<18|(r[t++]&63)<<12|(r[t++]&63)<<6|r[t++]&63)-65536,o[i++]=55296+(c>>10),o[i++]=56320+(c&1023)):o[i++]=(c&15)<<12|(r[t++]&63)<<6|r[t++]&63,i>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,o)),i=0);return s!=null?(i>0&&s.push(String.fromCharCode.apply(String,o.slice(0,i))),s.join("")):String.fromCharCode.apply(String,o.slice(0,i))}function Ko(r,t,e){let n=e,s,o;for(let i=0;i<r.length;++i)s=r.charCodeAt(i),s<128?t[e++]=s:s<2048?(t[e++]=s>>6|192,t[e++]=s&63|128):(s&64512)===55296&&((o=r.charCodeAt(i+1))&64512)===56320?(s=65536+((s&1023)<<10)+(o&1023),++i,t[e++]=s>>18|240,t[e++]=s>>12&63|128,t[e++]=s>>6&63|128,t[e++]=s&63|128):(t[e++]=s>>12|224,t[e++]=s>>6&63|128,t[e++]=s&63|128);return e-n}function qt(r,t){return RangeError(`index out of range: ${r.pos} + ${t??1} > ${r.len}`)}function _n(r,t){return(r[t-4]|r[t-3]<<8|r[t-2]<<16|r[t-1]<<24)>>>0}var qo=class{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(t){this.buf=t,this.pos=0,this.len=t.length}uint32(){let t=4294967295;if(t=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(t=(t|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return t;if((this.pos+=5)>this.len)throw this.pos=this.len,qt(this,10);return t}int32(){return this.uint32()|0}sint32(){let t=this.uint32();return t>>>1^-(t&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw qt(this,4);return _n(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw qt(this,4);return _n(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw qt(this,4);let t=Za(this.buf,this.pos);return this.pos+=4,t}double(){if(this.pos+8>this.len)throw qt(this,4);let t=Ja(this.buf,this.pos);return this.pos+=8,t}bytes(){let t=this.uint32(),e=this.pos,n=this.pos+t;if(n>this.len)throw qt(this,t);return this.pos+=t,e===n?new Uint8Array(0):this.buf.subarray(e,n)}string(){let t=this.bytes();return tc(t,0,t.length)}skip(t){if(typeof t=="number"){if(this.pos+t>this.len)throw qt(this,t);this.pos+=t}else do if(this.pos>=this.len)throw qt(this);while(this.buf[this.pos++]&128);return this}skipType(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${t} at offset ${this.pos}`)}return this}readLongVarint(){let t=new _t(0,0),e=0;if(this.len-this.pos>4){for(;e<4;++e)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw qt(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,t}if(this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw qt(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw qt(this,8);let t=_n(this.buf,this.pos+=4),e=_n(this.buf,this.pos+=4);return new _t(t,e)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){let t=Mo(this.buf,this.pos);return this.pos+=xt(t),t}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}};function $o(r){return new qo(r instanceof Uint8Array?r:r.subarray())}function $t(r,t,e){let n=$o(r);return t.decode(n,void 0,e)}var zo={};St(zo,{base10:()=>Oh});var Oh=Be({prefix:"9",name:"base10",alphabet:"0123456789"});var Go={};St(Go,{base16:()=>Ph,base16upper:()=>Vh});var Ph=ot({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Vh=ot({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var Wo={};St(Wo,{base2:()=>Dh});var Dh=ot({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var jo={};St(jo,{base256emoji:()=>qh});var rc=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),Mh=rc.reduce((r,t,e)=>(r[e]=t,r),[]),Fh=rc.reduce((r,t,e)=>{let n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);return r[n]=e,r},[]);function Hh(r){return r.reduce((t,e)=>(t+=Mh[e],t),"")}function Kh(r){let t=[];for(let e of r){let n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);let s=Fh[n];if(s==null)throw new Error(`Non-base256emoji character: ${e}`);t.push(s)}return new Uint8Array(t)}var qh=nr({prefix:"\u{1F680}",name:"base256emoji",encode:Hh,decode:Kh});var Yo={};St(Yo,{base64:()=>$h,base64pad:()=>zh,base64url:()=>Zo,base64urlpad:()=>Gh});var $h=ot({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),zh=ot({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Zo=ot({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Gh=ot({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var Jo={};St(Jo,{base8:()=>Wh});var Wh=ot({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var Xo={};St(Xo,{identity:()=>jh});var jh=nr({prefix:"\0",name:"identity",encode:r=>fa(r),decode:r=>ua(r)});var Tm=new TextEncoder,Um=new TextDecoder;var ei={};St(ei,{sha256:()=>Mr,sha512:()=>Jh});function ti({name:r,code:t,encode:e}){return new Qo(r,t,e)}var Qo=class{name;code;encode;constructor(t,e,n){this.name=t,this.code=e,this.encode=n}digest(t){if(t instanceof Uint8Array){let e=this.encode(t);return e instanceof Uint8Array?Mt(this.code,e):e.then(n=>Mt(this.code,n))}else throw Error("Unknown type, must be binary type")}};function sc(r){return async t=>new Uint8Array(await crypto.subtle.digest(r,t))}var Mr=ti({name:"sha2-256",code:18,encode:sc("SHA-256")}),Jh=ti({name:"sha2-512",code:19,encode:sc("SHA-512")});var Fr={...Xo,...Wo,...Jo,...zo,...Go,...lo,...uo,...co,...Yo,...jo},qm={...ei,...po};function ic(r,t,e,n){return{name:r,prefix:t,encoder:{name:r,prefix:t,encode:e},decoder:{decode:n}}}var oc=ic("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),ri=ic("ascii","a",r=>{let t="a";for(let e=0;e<r.length;e++)t+=String.fromCharCode(r[e]);return t},r=>{r=r.substring(1);let t=Ut(r.length);for(let e=0;e<r.length;e++)t[e]=r.charCodeAt(e);return t}),Xh={utf8:oc,"utf-8":oc,hex:Fr.base16,latin1:ri,ascii:ri,binary:ri,...Fr},On=Xh;function $(r,t="utf8"){let e=On[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.decoder.decode(`${e.prefix}${r}`)}function ni(r){let t=r??8192,e=t>>>1,n,s=t;return function(i){if(i<1||i>e)return Ut(i);s+i>t&&(n=Ut(t),s=0);let c=n.subarray(s,s+=i);return s&7&&(s=(s|7)+1),c}}var je=class{fn;len;next;val;constructor(t,e,n){this.fn=t,this.len=e,this.next=void 0,this.val=n}};function si(){}var ii=class{head;tail;len;next;constructor(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}},Qh=ni();function td(r){return globalThis.Buffer!=null?Ut(r):Qh(r)}var Kr=class{len;head;tail;states;constructor(){this.len=0,this.head=new je(si,0,0),this.tail=this.head,this.states=null}_push(t,e,n){return this.tail=this.tail.next=new je(t,e,n),this.len+=e,this}uint32(t){return this.len+=(this.tail=this.tail.next=new ai((t=t>>>0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this}int32(t){return t<0?this._push(Pn,10,_t.fromNumber(t)):this.uint32(t)}sint32(t){return this.uint32((t<<1^t>>31)>>>0)}uint64(t){let e=_t.fromBigInt(t);return this._push(Pn,e.length(),e)}uint64Number(t){return this._push(Do,xt(t),t)}uint64String(t){return this.uint64(BigInt(t))}int64(t){return this.uint64(t)}int64Number(t){return this.uint64Number(t)}int64String(t){return this.uint64String(t)}sint64(t){let e=_t.fromBigInt(t).zzEncode();return this._push(Pn,e.length(),e)}sint64Number(t){let e=_t.fromNumber(t).zzEncode();return this._push(Pn,e.length(),e)}sint64String(t){return this.sint64(BigInt(t))}bool(t){return this._push(oi,1,t?1:0)}fixed32(t){return this._push(Hr,4,t>>>0)}sfixed32(t){return this.fixed32(t)}fixed64(t){let e=_t.fromBigInt(t);return this._push(Hr,4,e.lo)._push(Hr,4,e.hi)}fixed64Number(t){let e=_t.fromNumber(t);return this._push(Hr,4,e.lo)._push(Hr,4,e.hi)}fixed64String(t){return this.fixed64(BigInt(t))}sfixed64(t){return this.fixed64(t)}sfixed64Number(t){return this.fixed64Number(t)}sfixed64String(t){return this.fixed64String(t)}float(t){return this._push(ja,4,t)}double(t){return this._push(Ya,8,t)}bytes(t){let e=t.length>>>0;return e===0?this._push(oi,1,0):this.uint32(e)._push(rd,e,t)}string(t){let e=Qa(t);return e!==0?this.uint32(e)._push(Ko,e,t):this._push(oi,1,0)}fork(){return this.states=new ii(this),this.head=this.tail=new je(si,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new je(si,0,0),this.len=0),this}ldelim(){let t=this.head,e=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=t.next,this.tail=e,this.len+=n),this}finish(){let t=this.head.next,e=td(this.len),n=0;for(;t!=null;)t.fn(t.val,e,n),n+=t.len,t=t.next;return e}};function oi(r,t,e){t[e]=r&255}function ed(r,t,e){for(;r>127;)t[e++]=r&127|128,r>>>=7;t[e]=r}var ai=class extends je{next;constructor(t,e){super(ed,t,e),this.next=void 0}};function Pn(r,t,e){for(;r.hi!==0;)t[e++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)t[e++]=r.lo&127|128,r.lo=r.lo>>>7;t[e++]=r.lo}function Hr(r,t,e){t[e]=r&255,t[e+1]=r>>>8&255,t[e+2]=r>>>16&255,t[e+3]=r>>>24}function rd(r,t,e){t.set(r,e)}globalThis.Buffer!=null&&(Kr.prototype.bytes=function(r){let t=r.length>>>0;return this.uint32(t),t>0&&this._push(nd,t,r),this},Kr.prototype.string=function(r){let t=globalThis.Buffer.byteLength(r);return this.uint32(t),t>0&&this._push(sd,t,r),this});function nd(r,t,e){t.set(r,e)}function sd(r,t,e){r.length<40?Ko(r,t,e):t.utf8Write!=null?t.utf8Write(r,e):t.set($(r),e)}function ci(){return new Kr}function zt(r,t){let e=ci();return t.encode(r,e,{lengthDelimited:!1}),e.finish()}var hr;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(hr||(hr={}));function Vn(r,t,e,n){return{name:r,type:t,encode:e,decode:n}}function li(r){function t(s){if(r[s.toString()]==null)throw new Error("Invalid enum value");return r[s]}let e=function(o,i){let c=t(o);i.int32(c)},n=function(o){let i=o.int32();return t(i)};return Vn("enum",hr.VARINT,e,n)}function Gt(r,t){return Vn("message",hr.LENGTH_DELIMITED,r,t)}var Ze=class extends Error{code="ERR_MAX_LENGTH";name="MaxLengthError"};var ct;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1"})(ct||(ct={}));var ui;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1"})(ui||(ui={}));(function(r){r.codec=()=>li(ui)})(ct||(ct={}));var Qt;(function(r){let t;r.codec=()=>(t==null&&(t=Gt((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),ct.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{let o={},i=n==null?e.len:e.pos+n;for(;e.pos<i;){let c=e.uint32();switch(c>>>3){case 1:{o.Type=ct.codec().decode(e);break}case 2:{o.Data=e.bytes();break}default:{e.skipType(c&7);break}}}return o})),t),r.encode=e=>zt(e,r.codec()),r.decode=(e,n)=>$t(e,r.codec(),n)})(Qt||(Qt={}));var fi;(function(r){let t;r.codec=()=>(t==null&&(t=Gt((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),ct.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{let o={},i=n==null?e.len:e.pos+n;for(;e.pos<i;){let c=e.uint32();switch(c>>>3){case 1:{o.Type=ct.codec().decode(e);break}case 2:{o.Data=e.bytes();break}default:{e.skipType(c&7);break}}}return o})),t),r.encode=e=>zt(e,r.codec()),r.decode=(e,n)=>$t(e,r.codec(),n)})(fi||(fi={}));var Xr={};St(Xr,{MAX_RSA_KEY_SIZE:()=>Ns,generateRSAKeyPair:()=>nl,jwkToJWKKeyPair:()=>sl,jwkToPkcs1:()=>xd,jwkToPkix:()=>xi,jwkToRSAPrivateKey:()=>rl,pkcs1ToJwk:()=>Qc,pkcs1ToRSAPrivateKey:()=>el,pkixToJwk:()=>tl,pkixToRSAPublicKey:()=>vi});var od=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Re=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),_e=new Uint32Array(64),hi=class extends ur{constructor(){super(64,32,8,!1),this.A=Re[0]|0,this.B=Re[1]|0,this.C=Re[2]|0,this.D=Re[3]|0,this.E=Re[4]|0,this.F=Re[5]|0,this.G=Re[6]|0,this.H=Re[7]|0}get(){let{A:t,B:e,C:n,D:s,E:o,F:i,G:c,H:a}=this;return[t,e,n,s,o,i,c,a]}set(t,e,n,s,o,i,c,a){this.A=t|0,this.B=e|0,this.C=n|0,this.D=s|0,this.E=o|0,this.F=i|0,this.G=c|0,this.H=a|0}process(t,e){for(let f=0;f<16;f++,e+=4)_e[f]=t.getUint32(e,!1);for(let f=16;f<64;f++){let h=_e[f-15],m=_e[f-2],p=Ft(h,7)^Ft(h,18)^h>>>3,b=Ft(m,17)^Ft(m,19)^m>>>10;_e[f]=b+_e[f-7]+p+_e[f-16]|0}let{A:n,B:s,C:o,D:i,E:c,F:a,G:l,H:u}=this;for(let f=0;f<64;f++){let h=Ft(c,6)^Ft(c,11)^Ft(c,25),m=u+h+Na(c,a,l)+od[f]+_e[f]|0,b=(Ft(n,2)^Ft(n,13)^Ft(n,22))+Ca(n,s,o)|0;u=l,l=a,a=c,c=i+m|0,i=o,o=s,s=n,n=m+b|0}n=n+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,c=c+this.E|0,a=a+this.F|0,l=l+this.G|0,u=u+this.H|0,this.set(n,s,o,i,c,a,l,u)}roundClean(){_e.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var dr=xn(()=>new hi);var M=ro(cc());function Ye(r,t){let e=0;if(r.length===1)return r[0];for(let n=r.length-1;n>=0;n--)e+=r[r.length-1-n]*Math.pow(2,t*n);return e}function Oe(r,t,e=-1){let n=e,s=r,o=0,i=Math.pow(2,t);for(let c=1;c<8;c++){if(r<i){let a;if(n<0)a=new ArrayBuffer(c),o=c;else{if(n<c)return new ArrayBuffer(0);a=new ArrayBuffer(n),o=n}let l=new Uint8Array(a);for(let u=c-1;u>=0;u--){let f=Math.pow(2,u*t);l[o-u-1]=Math.floor(s/f),s-=l[o-u-1]*f}return a}i*=Math.pow(2,t)}return new ArrayBuffer(0)}function Fn(...r){let t=0,e=0;for(let o of r)t+=o.length;let n=new ArrayBuffer(t),s=new Uint8Array(n);for(let o of r)s.set(o,e),e+=o.length;return s}function pi(){let r=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){let c=r[0]===255&&r[1]&128,a=r[0]===0&&(r[1]&128)===0;(c||a)&&this.warnings.push("Needlessly long format")}let t=new ArrayBuffer(this.valueHex.byteLength),e=new Uint8Array(t);for(let c=0;c<this.valueHex.byteLength;c++)e[c]=0;e[0]=r[0]&128;let n=Ye(e,8),s=new ArrayBuffer(this.valueHex.byteLength),o=new Uint8Array(s);for(let c=0;c<this.valueHex.byteLength;c++)o[c]=r[c];return o[0]&=127,Ye(o,8)-n}function lc(r){let t=r<0?r*-1:r,e=128;for(let n=1;n<8;n++){if(t<=e){if(r<0){let i=e-t,c=Oe(i,8,n),a=new Uint8Array(c);return a[0]|=128,c}let s=Oe(t,8,n),o=new Uint8Array(s);if(o[0]&128){let i=s.slice(0),c=new Uint8Array(i);s=new ArrayBuffer(s.byteLength+1),o=new Uint8Array(s);for(let a=0;a<i.byteLength;a++)o[a+1]=c[a];o[0]=0}return s}e*=Math.pow(2,8)}return new ArrayBuffer(0)}function uc(r,t){if(r.byteLength!==t.byteLength)return!1;let e=new Uint8Array(r),n=new Uint8Array(t);for(let s=0;s<e.length;s++)if(e[s]!==n[s])return!1;return!0}function Lt(r,t){let e=r.toString(10);if(t<e.length)return"";let n=t-e.length,s=new Array(n);for(let i=0;i<n;i++)s[i]="0";return s.join("").concat(e)}var Ag=Math.log(2);function Hn(){if(typeof BigInt>"u")throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function mi(r){let t=0,e=0;for(let s=0;s<r.length;s++){let o=r[s];t+=o.byteLength}let n=new Uint8Array(t);for(let s=0;s<r.length;s++){let o=r[s];n.set(new Uint8Array(o),e),e+=o.byteLength}return n.buffer}function be(r,t,e,n){return t instanceof Uint8Array?t.byteLength?e<0?(r.error="Wrong parameter: inputOffset less than zero",!1):n<0?(r.error="Wrong parameter: inputLength less than zero",!1):t.byteLength-e-n<0?(r.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):!0:(r.error="Wrong parameter: inputBuffer has zero length",!1):(r.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}var $r=class{constructor(){this.items=[]}write(t){this.items.push(t)}final(){return mi(this.items)}},qr=[new Uint8Array([1])],fc="0123456789";var br="",Wt=new ArrayBuffer(0),gi=new Uint8Array(0),zr="EndOfContent",dc="OCTET STRING",pc="BIT STRING";function we(r){var t;return t=class extends r{constructor(...n){var s;super(...n);let o=n[0]||{};this.isHexOnly=(s=o.isHexOnly)!==null&&s!==void 0?s:!1,this.valueHexView=o.valueHex?M.BufferSourceConverter.toUint8Array(o.valueHex):gi}get valueHex(){return this.valueHexView.slice().buffer}set valueHex(n){this.valueHexView=new Uint8Array(n)}fromBER(n,s,o){let i=n instanceof ArrayBuffer?new Uint8Array(n):n;if(!be(this,i,s,o))return-1;let c=s+o;return this.valueHexView=i.subarray(s,c),this.valueHexView.length?(this.blockLength=o,c):(this.warnings.push("Zero buffer length"),s)}toBER(n=!1){return this.isHexOnly?n?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",Wt)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:M.Convert.ToHex(this.valueHexView)}}},t.NAME="hexBlock",t}var me=class{constructor({blockLength:t=0,error:e=br,warnings:n=[],valueBeforeDecode:s=gi}={}){this.blockLength=t,this.error=e,this.warnings=n,this.valueBeforeDecodeView=M.BufferSourceConverter.toUint8Array(s)}static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(t){this.valueBeforeDecodeView=new Uint8Array(t)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:M.Convert.ToHex(this.valueBeforeDecodeView)}}};me.NAME="baseBlock";var Et=class extends me{fromBER(t,e,n){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(t,e){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}};Et.NAME="valueBlock";var Kn=class extends we(me){constructor({idBlock:t={}}={}){var e,n,s,o;super(),t?(this.isHexOnly=(e=t.isHexOnly)!==null&&e!==void 0?e:!1,this.valueHexView=t.valueHex?M.BufferSourceConverter.toUint8Array(t.valueHex):gi,this.tagClass=(n=t.tagClass)!==null&&n!==void 0?n:-1,this.tagNumber=(s=t.tagNumber)!==null&&s!==void 0?s:-1,this.isConstructed=(o=t.isConstructed)!==null&&o!==void 0?o:!1):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(t=!1){let e=0;switch(this.tagClass){case 1:e|=0;break;case 2:e|=64;break;case 3:e|=128;break;case 4:e|=192;break;default:return this.error="Unknown tag class",Wt}if(this.isConstructed&&(e|=32),this.tagNumber<31&&!this.isHexOnly){let s=new Uint8Array(1);if(!t){let o=this.tagNumber;o&=31,e|=o,s[0]=e}return s.buffer}if(!this.isHexOnly){let s=Oe(this.tagNumber,7),o=new Uint8Array(s),i=s.byteLength,c=new Uint8Array(i+1);if(c[0]=e|31,!t){for(let a=0;a<i-1;a++)c[a+1]=o[a]|128;c[i]=o[i-1]}return c.buffer}let n=new Uint8Array(this.valueHexView.byteLength+1);if(n[0]=e|31,!t){let s=this.valueHexView;for(let o=0;o<s.length-1;o++)n[o+1]=s[o]|128;n[this.valueHexView.byteLength]=s[s.length-1]}return n.buffer}fromBER(t,e,n){let s=M.BufferSourceConverter.toUint8Array(t);if(!be(this,s,e,n))return-1;let o=s.subarray(e,e+n);if(o.length===0)return this.error="Zero buffer length",-1;switch(o[0]&192){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=(o[0]&32)===32,this.isHexOnly=!1;let c=o[0]&31;if(c!==31)this.tagNumber=c,this.blockLength=1;else{let a=1,l=this.valueHexView=new Uint8Array(255),u=255;for(;o[a]&128;){if(l[a-1]=o[a]&127,a++,a>=o.length)return this.error="End of input reached before message was fully decoded",-1;if(a===u){u+=255;let h=new Uint8Array(u);for(let m=0;m<l.length;m++)h[m]=l[m];l=this.valueHexView=new Uint8Array(u)}}this.blockLength=a+1,l[a-1]=o[a]&127;let f=new Uint8Array(a);for(let h=0;h<a;h++)f[h]=l[h];l=this.valueHexView=new Uint8Array(a),l.set(f),this.blockLength<=9?this.tagNumber=Ye(l,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(this.tagClass===1&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return e+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}};Kn.NAME="identificationBlock";var qn=class extends me{constructor({lenBlock:t={}}={}){var e,n,s;super(),this.isIndefiniteForm=(e=t.isIndefiniteForm)!==null&&e!==void 0?e:!1,this.longFormUsed=(n=t.longFormUsed)!==null&&n!==void 0?n:!1,this.length=(s=t.length)!==null&&s!==void 0?s:0}fromBER(t,e,n){let s=M.BufferSourceConverter.toUint8Array(t);if(!be(this,s,e,n))return-1;let o=s.subarray(e,e+n);if(o.length===0)return this.error="Zero buffer length",-1;if(o[0]===255)return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=o[0]===128,this.isIndefiniteForm)return this.blockLength=1,e+this.blockLength;if(this.longFormUsed=!!(o[0]&128),this.longFormUsed===!1)return this.length=o[0],this.blockLength=1,e+this.blockLength;let i=o[0]&127;if(i>8)return this.error="Too big integer",-1;if(i+1>o.length)return this.error="End of input reached before message was fully decoded",-1;let c=e+1,a=s.subarray(c,c+i);return a[i-1]===0&&this.warnings.push("Needlessly long encoded length"),this.length=Ye(a,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=i+1,e+this.blockLength}toBER(t=!1){let e,n;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return e=new ArrayBuffer(1),t===!1&&(n=new Uint8Array(e),n[0]=128),e;if(this.longFormUsed){let s=Oe(this.length,8);if(s.byteLength>127)return this.error="Too big length",Wt;if(e=new ArrayBuffer(s.byteLength+1),t)return e;let o=new Uint8Array(s);n=new Uint8Array(e),n[0]=s.byteLength|128;for(let i=0;i<s.byteLength;i++)n[i+1]=o[i];return e}return e=new ArrayBuffer(1),t===!1&&(n=new Uint8Array(e),n[0]=this.length),e}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}};qn.NAME="lengthBlock";var B={},mt=class extends me{constructor({name:t=br,optional:e=!1,primitiveSchema:n,...s}={},o){super(s),this.name=t,this.optional=e,n&&(this.primitiveSchema=n),this.idBlock=new Kn(s),this.lenBlock=new qn(s),this.valueBlock=o?new o(s):new Et(s)}fromBER(t,e,n){let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}toBER(t,e){let n=e||new $r;e||mc(this);let s=this.idBlock.toBER(t);if(n.write(s),this.lenBlock.isIndefiniteForm)n.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(t,n),n.write(new ArrayBuffer(2));else{let o=this.valueBlock.toBER(t);this.lenBlock.length=o.byteLength;let i=this.lenBlock.toBER(t);n.write(i),n.write(o)}return e?Wt:n.final()}toJSON(){let t={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(t.primitiveSchema=this.primitiveSchema.toJSON()),t}toString(t="ascii"){return t==="ascii"?this.onAsciiEncoding():M.Convert.ToHex(this.toBER())}onAsciiEncoding(){return`${this.constructor.NAME} : ${M.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`}isEqual(t){if(this===t)return!0;if(!(t instanceof this.constructor))return!1;let e=this.toBER(),n=t.toBER();return uc(e,n)}};mt.NAME="BaseBlock";function mc(r){if(r instanceof B.Constructed)for(let t of r.valueBlock.value)mc(t)&&(r.lenBlock.isIndefiniteForm=!0);return!!r.lenBlock.isIndefiniteForm}var $n=class extends mt{constructor({value:t=br,...e}={},n){super(e,n),t&&this.fromString(t)}getValue(){return this.valueBlock.value}setValue(t){this.valueBlock.value=t}fromBER(t,e,n){let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}};$n.NAME="BaseStringBlock";var zn=class extends we(Et){constructor({isHexOnly:t=!0,...e}={}){super(e),this.isHexOnly=t}};zn.NAME="PrimitiveValueBlock";var gc,Gn=class extends mt{constructor(t={}){super(t,zn),this.idBlock.isConstructed=!1}};gc=Gn;B.Primitive=gc;Gn.NAME="PRIMITIVE";function pd(r,t){if(r instanceof t)return r;let e=new t;return e.idBlock=r.idBlock,e.lenBlock=r.lenBlock,e.warnings=r.warnings,e.valueBeforeDecodeView=r.valueBeforeDecodeView,e}function Is(r,t=0,e=r.length){let n=t,s=new mt({},Et),o=new me;if(!be(o,r,t,e))return s.error=o.error,{offset:-1,result:s};if(!r.subarray(t,t+e).length)return s.error="Zero buffer length",{offset:-1,result:s};let c=s.idBlock.fromBER(r,t,e);if(s.idBlock.warnings.length&&s.warnings.concat(s.idBlock.warnings),c===-1)return s.error=s.idBlock.error,{offset:-1,result:s};if(t=c,e-=s.idBlock.blockLength,c=s.lenBlock.fromBER(r,t,e),s.lenBlock.warnings.length&&s.warnings.concat(s.lenBlock.warnings),c===-1)return s.error=s.lenBlock.error,{offset:-1,result:s};if(t=c,e-=s.lenBlock.blockLength,!s.idBlock.isConstructed&&s.lenBlock.isIndefiniteForm)return s.error="Indefinite length form used for primitive encoding form",{offset:-1,result:s};let a=mt;switch(s.idBlock.tagClass){case 1:if(s.idBlock.tagNumber>=37&&s.idBlock.isHexOnly===!1)return s.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:s};switch(s.idBlock.tagNumber){case 0:if(s.idBlock.isConstructed&&s.lenBlock.length>0)return s.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:s};a=B.EndOfContent;break;case 1:a=B.Boolean;break;case 2:a=B.Integer;break;case 3:a=B.BitString;break;case 4:a=B.OctetString;break;case 5:a=B.Null;break;case 6:a=B.ObjectIdentifier;break;case 10:a=B.Enumerated;break;case 12:a=B.Utf8String;break;case 13:a=B.RelativeObjectIdentifier;break;case 14:a=B.TIME;break;case 15:return s.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:s};case 16:a=B.Sequence;break;case 17:a=B.Set;break;case 18:a=B.NumericString;break;case 19:a=B.PrintableString;break;case 20:a=B.TeletexString;break;case 21:a=B.VideotexString;break;case 22:a=B.IA5String;break;case 23:a=B.UTCTime;break;case 24:a=B.GeneralizedTime;break;case 25:a=B.GraphicString;break;case 26:a=B.VisibleString;break;case 27:a=B.GeneralString;break;case 28:a=B.UniversalString;break;case 29:a=B.CharacterString;break;case 30:a=B.BmpString;break;case 31:a=B.DATE;break;case 32:a=B.TimeOfDay;break;case 33:a=B.DateTime;break;case 34:a=B.Duration;break;default:{let l=s.idBlock.isConstructed?new B.Constructed:new B.Primitive;l.idBlock=s.idBlock,l.lenBlock=s.lenBlock,l.warnings=s.warnings,s=l}}break;case 2:case 3:case 4:default:a=s.idBlock.isConstructed?B.Constructed:B.Primitive}return s=pd(s,a),c=s.fromBER(r,t,s.lenBlock.isIndefiniteForm?e:s.lenBlock.length),s.valueBeforeDecodeView=r.subarray(n,n+s.blockLength),{offset:c,result:s}}function yi(r){if(!r.byteLength){let t=new mt({},Et);return t.error="Input buffer has zero length",{offset:-1,result:t}}return Is(M.BufferSourceConverter.toUint8Array(r).slice(),0,r.byteLength)}function md(r,t){return r?1:t}var te=class extends Et{constructor({value:t=[],isIndefiniteForm:e=!1,...n}={}){super(n),this.value=t,this.isIndefiniteForm=e}fromBER(t,e,n){let s=M.BufferSourceConverter.toUint8Array(t);if(!be(this,s,e,n))return-1;if(this.valueBeforeDecodeView=s.subarray(e,e+n),this.valueBeforeDecodeView.length===0)return this.warnings.push("Zero buffer length"),e;let o=e;for(;md(this.isIndefiniteForm,n)>0;){let i=Is(s,o,n);if(i.offset===-1)return this.error=i.result.error,this.warnings.concat(i.result.warnings),-1;if(o=i.offset,this.blockLength+=i.result.blockLength,n-=i.result.blockLength,this.value.push(i.result),this.isIndefiniteForm&&i.result.constructor.NAME===zr)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===zr?this.value.pop():this.warnings.push("No EndOfContent block encoded")),o}toBER(t,e){let n=e||new $r;for(let s=0;s<this.value.length;s++)this.value[s].toBER(t,n);return e?Wt:n.final()}toJSON(){let t={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(let e of this.value)t.value.push(e.toJSON());return t}};te.NAME="ConstructedValueBlock";var yc,Pe=class extends mt{constructor(t={}){super(t,te),this.idBlock.isConstructed=!0}fromBER(t,e,n){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){let t=[];for(let n of this.valueBlock.value)t.push(n.toString("ascii").split(`
./node_modules/@libp2p/crypto/dist/index.min.js:2:"use strict";var Libp2PCrypto=(()=>{var fc=Object.create;var Rr=Object.defineProperty;var hc=Object.getOwnPropertyDescriptor;var dc=Object.getOwnPropertyNames;var gc=Object.getPrototypeOf,pc=Object.prototype.hasOwnProperty;var mc=(r,t)=>()=>(t||r((t={exports:{}}).exports,t),t.exports),ot=(r,t)=>{for(var e in t)Rr(r,e,{get:t[e],enumerable:!0})},Lo=(r,t,e,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of dc(t))!pc.call(r,s)&&s!==e&&Rr(r,s,{get:()=>t[s],enumerable:!(n=hc(t,s))||n.enumerable});return r};var yc=(r,t,e)=>(e=r!=null?fc(gc(r)):{},Lo(t||!r||!r.__esModule?Rr(e,"default",{value:r,enumerable:!0}):e,r)),bc=r=>Lo(Rr({},"__esModule",{value:!0}),r);var qi=mc(je=>{"use strict";var Pu="[object ArrayBuffer]",$t=class r{static isArrayBuffer(t){return Object.prototype.toString.call(t)===Pu}static toArrayBuffer(t){return this.isArrayBuffer(t)?t:t.byteLength===t.buffer.byteLength||t.byteOffset===0&&t.byteLength===t.buffer.byteLength?t.buffer:this.toUint8Array(t.buffer).slice(t.byteOffset,t.byteOffset+t.byteLength).buffer}static toUint8Array(t){return this.toView(t,Uint8Array)}static toView(t,e){if(t.constructor===e)return t;if(this.isArrayBuffer(t))return new e(t);if(this.isArrayBufferView(t))return new e(t.buffer,t.byteOffset,t.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(t){return this.isArrayBufferView(t)||this.isArrayBuffer(t)}static isArrayBufferView(t){return ArrayBuffer.isView(t)||t&&this.isArrayBuffer(t.buffer)}static isEqual(t,e){let n=r.toUint8Array(t),s=r.toUint8Array(e);if(n.length!==s.byteLength)return!1;for(let o=0;o<n.length;o++)if(n[o]!==s[o])return!1;return!0}static concat(...t){let e;Array.isArray(t[0])&&!(t[1]instanceof Function)||Array.isArray(t[0])&&t[1]instanceof Function?e=t[0]:t[t.length-1]instanceof Function?e=t.slice(0,t.length-1):e=t;let n=0;for(let i of e)n+=i.byteLength;let s=new Uint8Array(n),o=0;for(let i of e){let a=this.toUint8Array(i);s.set(a,o),o+=a.length}return t[t.length-1]instanceof Function?this.toView(s,t[t.length-1]):s.buffer}},oo="string",Fu=/^[0-9a-f\s]+$/i,qu=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,zu=/^[a-zA-Z0-9-_]+$/,an=class{static fromString(t){let e=unescape(encodeURIComponent(t)),n=new Uint8Array(e.length);for(let s=0;s<e.length;s++)n[s]=e.charCodeAt(s);return n.buffer}static toString(t){let e=$t.toUint8Array(t),n="";for(let o=0;o<e.length;o++)n+=String.fromCharCode(e[o]);return decodeURIComponent(escape(n))}},vt=class{static toString(t,e=!1){let n=$t.toArrayBuffer(t),s=new DataView(n),o="";for(let i=0;i<n.byteLength;i+=2){let a=s.getUint16(i,e);o+=String.fromCharCode(a)}return o}static fromString(t,e=!1){let n=new ArrayBuffer(t.length*2),s=new DataView(n);for(let o=0;o<t.length;o++)s.setUint16(o*2,t.charCodeAt(o),e);return n}},cn=class r{static isHex(t){return typeof t===oo&&Fu.test(t)}static isBase64(t){return typeof t===oo&&qu.test(t)}static isBase64Url(t){return typeof t===oo&&zu.test(t)}static ToString(t,e="utf8"){let n=$t.toUint8Array(t);switch(e.toLowerCase()){case"utf8":return this.ToUtf8String(n);case"binary":return this.ToBinary(n);case"hex":return this.ToHex(n);case"base64":return this.ToBase64(n);case"base64url":return this.ToBase64Url(n);case"utf16le":return vt.toString(n,!0);case"utf16":case"utf16be":return vt.toString(n);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromString(t,e="utf8"){if(!t)return new ArrayBuffer(0);switch(e.toLowerCase()){case"utf8":return this.FromUtf8String(t);case"binary":return this.FromBinary(t);case"hex":return this.FromHex(t);case"base64":return this.FromBase64(t);case"base64url":return this.FromBase64Url(t);case"utf16le":return vt.fromString(t,!0);case"utf16":case"utf16be":return vt.fromString(t);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToBase64(t){let e=$t.toUint8Array(t);if(typeof btoa<"u"){let n=this.ToString(e,"binary");return btoa(n)}else return Buffer.from(e).toString("base64")}static FromBase64(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isBase64(e))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return typeof atob<"u"?this.FromBinary(atob(e)):new Uint8Array(Buffer.from(e,"base64")).buffer}static FromBase64Url(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isBase64Url(e))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(e.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(t){return this.ToBase64(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(t,e=r.DEFAULT_UTF8_ENCODING){switch(e){case"ascii":return this.FromBinary(t);case"utf8":return an.fromString(t);case"utf16":case"utf16be":return vt.fromString(t);case"utf16le":case"usc2":return vt.fromString(t,!0);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToUtf8String(t,e=r.DEFAULT_UTF8_ENCODING){switch(e){case"ascii":return this.ToBinary(t);case"utf8":return an.toString(t);case"utf16":case"utf16be":return vt.toString(t);case"utf16le":case"usc2":return vt.toString(t,!0);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromBinary(t){let e=t.length,n=new Uint8Array(e);for(let s=0;s<e;s++)n[s]=t.charCodeAt(s);return n.buffer}static ToBinary(t){let e=$t.toUint8Array(t),n="";for(let s=0;s<e.length;s++)n+=String.fromCharCode(e[s]);return n}static ToHex(t){let e=$t.toUint8Array(t),n="",s=e.length;for(let o=0;o<s;o++){let i=e[o];i<16&&(n+="0"),n+=i.toString(16)}return n}static FromHex(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isHex(e))throw new TypeError("Argument 'hexString' is not HEX encoded");e.length%2&&(e=`0${e}`);let n=new Uint8Array(e.length/2);for(let s=0;s<e.length;s=s+2){let o=e.slice(s,s+2);n[s/2]=parseInt(o,16)}return n.buffer}static ToUtf16String(t,e=!1){return vt.toString(t,e)}static FromUtf16String(t,e=!1){return vt.fromString(t,e)}static Base64Padding(t){let e=4-t.length%4;if(e<4)for(let n=0;n<e;n++)t+="=";return t}static formatString(t){return t?.replace(/[\n\r\t ]/g,"")||""}};cn.DEFAULT_UTF8_ENCODING="utf8";function $u(r,...t){let e=arguments[0];for(let n=1;n<arguments.length;n++){let s=arguments[n];for(let o in s)e[o]=s[o]}return e}function ju(...r){let t=r.map(s=>s.byteLength).reduce((s,o)=>s+o),e=new Uint8Array(t),n=0;return r.map(s=>new Uint8Array(s)).forEach(s=>{for(let o of s)e[n++]=o}),e.buffer}function Gu(r,t){if(!(r&&t)||r.byteLength!==t.byteLength)return!1;let e=new Uint8Array(r),n=new Uint8Array(t);for(let s=0;s<r.byteLength;s++)if(e[s]!==n[s])return!1;return!0}je.BufferSourceConverter=$t;je.Convert=cn;je.assign=$u;je.combine=ju;je.isEqual=Gu});var kf={};ot(kf,{hmac:()=>Hr,keys:()=>Eo,pbkdf2:()=>So,randomBytes:()=>uo});var Hr={};ot(Hr,{create:()=>ns});var tr=class extends Error{constructor(t="An error occurred while signing a message"){super(t),this.name="SigningError"}},er=class extends Error{constructor(t="An error occurred while verifying a message"){super(t),this.name="VerificationError"}},Lr=class extends Error{constructor(t="Missing Web Crypto API"){super(t),this.name="WebCryptoMissingError"}};var Ho={get(r=globalThis){let t=r.crypto;if(t?.subtle==null)throw new Lr("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return t}};var it=Ho;var Vo={SHA1:20,SHA256:32,SHA512:64};var xc={SHA1:"SHA-1",SHA256:"SHA-256",SHA512:"SHA-512"},wc=async(r,t)=>{let e=await it.get().subtle.sign({name:"HMAC"},r,t);return new Uint8Array(e,0,e.byteLength)};async function ns(r,t){let e=xc[r],n=await it.get().subtle.importKey("raw",t,{name:"HMAC",hash:{name:e}},!1,["sign"]);return{async digest(s){return wc(n,s)},length:Vo[r]}}var Eo={};ot(Eo,{generateEphemeralKeyPair:()=>Ya,generateKeyPair:()=>mf,generateKeyPairFromSeed:()=>yf,keyStretcher:()=>Qa,privateKeyFromProtobuf:()=>vf,privateKeyFromRaw:()=>Bf,privateKeyToProtobuf:()=>Ef,publicKeyFromMultihash:()=>wf,publicKeyFromProtobuf:()=>bf,publicKeyFromRaw:()=>xf,publicKeyToProtobuf:()=>dr});var q=class extends Error{static name="InvalidParametersError";constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}},Ie=class extends Error{static name="InvalidPublicKeyError";constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}},rr=class extends Error{static name="InvalidPrivateKeyError";constructor(t="Invalid private key"){super(t),this.name="InvalidPrivateKeyError"}};var Qt=class extends Error{static name="UnsupportedKeyTypeError";constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}};var cs={};ot(cs,{base58btc:()=>ut,base58flickr:()=>kc});var Of=new Uint8Array(0);function _o(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function Kt(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function Oo(r){return new TextEncoder().encode(r)}function Mo(r){return new TextDecoder().decode(r)}function vc(r,t){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),n=0;n<e.length;n++)e[n]=255;for(var s=0;s<r.length;s++){var o=r.charAt(s),i=o.charCodeAt(0);if(e[i]!==255)throw new TypeError(o+" is ambiguous");e[i]=s}var a=r.length,c=r.charAt(0),u=Math.log(a)/Math.log(256),l=Math.log(256)/Math.log(a);function f(b){if(b instanceof Uint8Array||(ArrayBuffer.isView(b)?b=new Uint8Array(b.buffer,b.byteOffset,b.byteLength):Array.isArray(b)&&(b=Uint8Array.from(b))),!(b instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(b.length===0)return"";for(var y=0,d=0,x=0,B=b.length;x!==B&&b[x]===0;)x++,y++;for(var p=(B-x)*l+1>>>0,k=new Uint8Array(p);x!==B;){for(var R=b[x],T=0,N=p-1;(R!==0||T<d)&&N!==-1;N--,T++)R+=256*k[N]>>>0,k[N]=R%a>>>0,R=R/a>>>0;if(R!==0)throw new Error("Non-zero carry");d=T,x++}for(var U=p-d;U!==p&&k[U]===0;)U++;for(var I=c.repeat(y);U<p;++U)I+=r.charAt(k[U]);return I}function h(b){if(typeof b!="string")throw new TypeError("Expected String");if(b.length===0)return new Uint8Array;var y=0;if(b[y]!==" "){for(var d=0,x=0;b[y]===c;)d++,y++;for(var B=(b.length-y)*u+1>>>0,p=new Uint8Array(B);b[y];){var k=e[b.charCodeAt(y)];if(k===255)return;for(var R=0,T=B-1;(k!==0||R<x)&&T!==-1;T--,R++)k+=a*p[T]>>>0,p[T]=k%256>>>0,k=k/256>>>0;if(k!==0)throw new Error("Non-zero carry");x=R,y++}if(b[y]!==" "){for(var N=B-x;N!==B&&p[N]===0;)N++;for(var U=new Uint8Array(d+(B-N)),I=d;N!==B;)U[I++]=p[N++];return U}}}function w(b){var y=h(b);if(y)return y;throw new Error(`Non-${t} character`)}return{encode:f,decodeUnsafe:h,decode:w}}var Bc=vc,Ec=Bc,Ko=Ec;var ss=class{name;prefix;baseEncode;constructor(t,e,n){this.name=t,this.prefix=e,this.baseEncode=n}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}},os=class{name;prefix;baseDecode;prefixCodePoint;constructor(t,e,n){this.name=t,this.prefix=e;let s=e.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=n}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return Po(this,t)}},is=class{decoders;constructor(t){this.decoders=t}or(t){return Po(this,t)}decode(t){let e=t[0],n=this.decoders[e];if(n!=null)return n.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};function Po(r,t){return new is({...r.decoders??{[r.prefix]:r},...t.decoders??{[t.prefix]:t}})}var as=class{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(t,e,n,s){this.name=t,this.prefix=e,this.baseEncode=n,this.baseDecode=s,this.encoder=new ss(t,e,n),this.decoder=new os(t,e,s)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}};function Ce({name:r,prefix:t,encode:e,decode:n}){return new as(r,t,e,n)}function te({name:r,prefix:t,alphabet:e}){let{encode:n,decode:s}=Ko(e,r);return Ce({prefix:t,name:r,encode:n,decode:o=>Kt(s(o))})}function Ac(r,t,e,n){let s={};for(let l=0;l<t.length;++l)s[t[l]]=l;let o=r.length;for(;r[o-1]==="=";)--o;let i=new Uint8Array(o*e/8|0),a=0,c=0,u=0;for(let l=0;l<o;++l){let f=s[r[l]];if(f===void 0)throw new SyntaxError(`Non-${n} character`);c=c<<e|f,a+=e,a>=8&&(a-=8,i[u++]=255&c>>a)}if(a>=e||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return i}function Sc(r,t,e){let n=t[t.length-1]==="=",s=(1<<e)-1,o="",i=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],i+=8;i>e;)i-=e,o+=t[s&a>>i];if(i!==0&&(o+=t[s&a<<e-i]),n)for(;o.length*e&7;)o+="=";return o}function Y({name:r,prefix:t,bitsPerChar:e,alphabet:n}){return Ce({prefix:t,name:r,encode(s){return Sc(s,n,e)},decode(s){return Ac(s,n,e,r)}})}var ut=te({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),kc=te({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var ls={};ot(ls,{base32:()=>Ue,base32hex:()=>Uc,base32hexpad:()=>Rc,base32hexpadupper:()=>Lc,base32hexupper:()=>Tc,base32pad:()=>Ic,base32padupper:()=>Cc,base32upper:()=>Nc,base32z:()=>Hc});var Ue=Y({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Nc=Y({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Ic=Y({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Cc=Y({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Uc=Y({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Tc=Y({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Rc=Y({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Lc=Y({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Hc=Y({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var us={};ot(us,{base36:()=>nr,base36upper:()=>Vc});var nr=te({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Vc=te({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var _c=zo,Fo=128,Oc=127,Mc=~Oc,Dc=Math.pow(2,31);function zo(r,t,e){t=t||[],e=e||0;for(var n=e;r>=Dc;)t[e++]=r&255|Fo,r/=128;for(;r&Mc;)t[e++]=r&255|Fo,r>>>=7;return t[e]=r|0,zo.bytes=e-n+1,t}var Kc=fs,Pc=128,qo=127;function fs(r,n){var e=0,n=n||0,s=0,o=n,i,a=r.length;do{if(o>=a)throw fs.bytes=0,new RangeError("Could not decode varint");i=r[o++],e+=s<28?(i&qo)<<s:(i&qo)*Math.pow(2,s),s+=7}while(i>=Pc);return fs.bytes=o-n,e}var Fc=Math.pow(2,7),qc=Math.pow(2,14),zc=Math.pow(2,21),$c=Math.pow(2,28),jc=Math.pow(2,35),Gc=Math.pow(2,42),Zc=Math.pow(2,49),Wc=Math.pow(2,56),Jc=Math.pow(2,63),Yc=function(r){return r<Fc?1:r<qc?2:r<zc?3:r<$c?4:r<jc?5:r<Gc?6:r<Zc?7:r<Wc?8:r<Jc?9:10},Xc={encode:_c,decode:Kc,encodingLength:Yc},Qc=Xc,sr=Qc;function or(r,t=0){return[sr.decode(r,t),sr.decode.bytes]}function Te(r,t,e=0){return sr.encode(r,t,e),t}function Re(r){return sr.encodingLength(r)}function Et(r,t){let e=t.byteLength,n=Re(r),s=n+Re(e),o=new Uint8Array(s+e);return Te(r,o,0),Te(e,o,n),o.set(t,s),new Le(r,e,t,o)}function $o(r){let t=Kt(r),[e,n]=or(t),[s,o]=or(t.subarray(n)),i=t.subarray(n+o);if(i.byteLength!==s)throw new Error("Incorrect length");return new Le(e,s,i,t)}function jo(r,t){if(r===t)return!0;{let e=t;return r.code===e.code&&r.size===e.size&&e.bytes instanceof Uint8Array&&_o(r.bytes,e.bytes)}}var Le=class{code;size;digest;bytes;constructor(t,e,n,s){this.code=t,this.size=e,this.digest=n,this.bytes=s}};function Go(r,t){let{bytes:e,version:n}=r;switch(n){case 0:return el(e,hs(r),t??ut.encoder);default:return rl(e,hs(r),t??Ue.encoder)}}var Zo=new WeakMap;function hs(r){let t=Zo.get(r);if(t==null){let e=new Map;return Zo.set(r,e),e}return t}var Tt=class r{code;version;multihash;bytes;"/";constructor(t,e,n,s){this.code=e,this.version=t,this.multihash=n,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{let{code:t,multihash:e}=this;if(t!==ar)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==nl)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return r.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{let{code:t,digest:e}=this.multihash,n=Et(t,e);return r.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return r.equals(this,t)}static equals(t,e){let n=e;return n!=null&&t.code===n.code&&t.version===n.version&&jo(t.multihash,n.multihash)}toString(t){return Go(this,t)}toJSON(){return{"/":Go(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;let e=t;if(e instanceof r)return e;if(e["/"]!=null&&e["/"]===e.bytes||e.asCID===e){let{version:n,code:s,multihash:o,bytes:i}=e;return new r(n,s,o,i??Wo(n,s,o.bytes))}else if(e[sl]===!0){let{version:n,multihash:s,code:o}=e,i=$o(s);return r.create(n,o,i)}else return null}static create(t,e,n){if(typeof e!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(e!==ar)throw new Error(`Version 0 CID must use dag-pb (code: ${ar}) block encoding`);return new r(t,e,n,n.bytes)}case 1:{let s=Wo(t,e,n.bytes);return new r(t,e,n,s)}default:throw new Error("Invalid version")}}static createV0(t){return r.create(0,ar,t)}static createV1(t,e){return r.create(1,t,e)}static decode(t){let[e,n]=r.decodeFirst(t);if(n.length!==0)throw new Error("Incorrect length");return e}static decodeFirst(t){let e=r.inspectBytes(t),n=e.size-e.multihashSize,s=Kt(t.subarray(n,n+e.multihashSize));if(s.byteLength!==e.multihashSize)throw new Error("Incorrect length");let o=s.subarray(e.multihashSize-e.digestSize),i=new Le(e.multihashCode,e.digestSize,o,s);return[e.version===0?r.createV0(i):r.createV1(e.codec,i),t.subarray(e.size)]}static inspectBytes(t){let e=0,n=()=>{let[f,h]=or(t.subarray(e));return e+=h,f},s=n(),o=ar;if(s===18?(s=0,e=0):o=n(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);let i=e,a=n(),c=n(),u=e+c,l=u-i;return{version:s,codec:o,multihashCode:a,digestSize:c,multihashSize:l,size:u}}static parse(t,e){let[n,s]=tl(t,e),o=r.decode(s);if(o.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return hs(o).set(n,t),o}};function tl(r,t){switch(r[0]){case"Q":{let e=t??ut;return[ut.prefix,e.decode(`${ut.prefix}${r}`)]}case ut.prefix:{let e=t??ut;return[ut.prefix,e.decode(r)]}case Ue.prefix:{let e=t??Ue;return[Ue.prefix,e.decode(r)]}case nr.prefix:{let e=t??nr;return[nr.prefix,e.decode(r)]}default:{if(t==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],t.decode(r)]}}}function el(r,t,e){let{prefix:n}=e;if(n!==ut.prefix)throw Error(`Cannot string encode V0 in ${e.name} encoding`);let s=t.get(n);if(s==null){let o=e.encode(r).slice(1);return t.set(n,o),o}else return s}function rl(r,t,e){let{prefix:n}=e,s=t.get(n);if(s==null){let o=e.encode(r);return t.set(n,o),o}else return s}var ar=112,nl=18;function Wo(r,t,e){let n=Re(r),s=n+Re(t),o=new Uint8Array(s+e.byteLength);return Te(r,o,0),Te(t,o,n),o.set(e,s),o}var sl=Symbol.for("@ipld/js-cid/CID");var ds={};ot(ds,{identity:()=>cr});var Jo=0,ol="identity",Yo=Kt;function il(r){return Et(Jo,Yo(r))}var cr={code:Jo,name:ol,encode:Yo,digest:il};function At(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function He(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function al(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Ve(r,...t){if(!al(r))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(r.length))throw new Error("Uint8Array expected of length "+t+", got length="+r.length)}function _r(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");He(r.outputLen),He(r.blockLen)}function _e(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function Xo(r,t){Ve(r);let e=t.outputLen;if(r.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}var ye=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var Me=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),St=(r,t)=>r<<32-t|r>>>t,Or=(r,t)=>r<<t|r>>>32-t>>>0;function Qo(r){if(typeof r!="string")throw new Error("utf8ToBytes expected string, got "+typeof r);return new Uint8Array(new TextEncoder().encode(r))}function ee(r){return typeof r=="string"&&(r=Qo(r)),Ve(r),r}function gs(...r){let t=0;for(let n=0;n<r.length;n++){let s=r[n];Ve(s),t+=s.length}let e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){let o=r[n];e.set(o,s),s+=o.length}return e}var Oe=class{clone(){return this._cloneInto()}};function ti(r,t){if(t!==void 0&&{}.toString.call(t)!=="[object Object]")throw new Error("Options should be object or undefined");return Object.assign(r,t)}function De(r){let t=n=>r().update(ee(n)).digest(),e=r();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>r(),t}function Ke(r=32){if(ye&&typeof ye.getRandomValues=="function")return ye.getRandomValues(new Uint8Array(r));if(ye&&typeof ye.randomBytes=="function")return ye.randomBytes(r);throw new Error("crypto.getRandomValues must be defined")}function cl(r,t,e,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(t,e,n);let s=BigInt(32),o=BigInt(4294967295),i=Number(e>>s&o),a=Number(e&o),c=n?4:0,u=n?0:4;r.setUint32(t+c,i,n),r.setUint32(t+u,a,n)}var Mr=(r,t,e)=>r&t^~r&e,Dr=(r,t,e)=>r&t^r&e^t&e,re=class extends Oe{constructor(t,e,n,s){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=Me(this.buffer)}update(t){_e(this);let{view:e,buffer:n,blockLen:s}=this;t=ee(t);let o=t.length;for(let i=0;i<o;){let a=Math.min(s-this.pos,o-i);if(a===s){let c=Me(t);for(;s<=o-i;i+=s)this.process(c,i);continue}n.set(t.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){_e(this),Xo(t,this),this.finished=!0;let{buffer:e,view:n,blockLen:s,isLE:o}=this,{pos:i}=this;e[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>s-i&&(this.process(n,0),i=0);for(let f=i;f<s;f++)e[f]=0;cl(n,s-8,BigInt(this.length*8),o),this.process(n,0);let a=Me(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let u=c/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<u;f++)a.setUint32(4*f,l[f],o)}digest(){let{buffer:t,outputLen:e}=this;this.digestInto(t);let n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:e,buffer:n,length:s,finished:o,destroyed:i,pos:a}=this;return t.length=s,t.pos=a,t.finished=o,t.destroyed=i,s%e&&t.buffer.set(n),t}};var Kr=BigInt(4294967295),ps=BigInt(32);function ei(r,t=!1){return t?{h:Number(r&Kr),l:Number(r>>ps&Kr)}:{h:Number(r>>ps&Kr)|0,l:Number(r&Kr)|0}}function ll(r,t=!1){let e=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let s=0;s<r.length;s++){let{h:o,l:i}=ei(r[s],t);[e[s],n[s]]=[o,i]}return[e,n]}var ul=(r,t)=>BigInt(r>>>0)<<ps|BigInt(t>>>0),fl=(r,t,e)=>r>>>e,hl=(r,t,e)=>r<<32-e|t>>>e,dl=(r,t,e)=>r>>>e|t<<32-e,gl=(r,t,e)=>r<<32-e|t>>>e,pl=(r,t,e)=>r<<64-e|t>>>e-32,ml=(r,t,e)=>r>>>e-32|t<<64-e,yl=(r,t)=>t,bl=(r,t)=>r,xl=(r,t,e)=>r<<e|t>>>32-e,wl=(r,t,e)=>t<<e|r>>>32-e,vl=(r,t,e)=>t<<e-32|r>>>64-e,Bl=(r,t,e)=>r<<e-32|t>>>64-e;function El(r,t,e,n){let s=(t>>>0)+(n>>>0);return{h:r+e+(s/2**32|0)|0,l:s|0}}var Al=(r,t,e)=>(r>>>0)+(t>>>0)+(e>>>0),Sl=(r,t,e,n)=>t+e+n+(r/2**32|0)|0,kl=(r,t,e,n)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0),Nl=(r,t,e,n,s)=>t+e+n+s+(r/2**32|0)|0,Il=(r,t,e,n,s)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(s>>>0),Cl=(r,t,e,n,s,o)=>t+e+n+s+o+(r/2**32|0)|0;var Ul={fromBig:ei,split:ll,toBig:ul,shrSH:fl,shrSL:hl,rotrSH:dl,rotrSL:gl,rotrBH:pl,rotrBL:ml,rotr32H:yl,rotr32L:bl,rotlSH:xl,rotlSL:wl,rotlBH:vl,rotlBL:Bl,add:El,add3L:Al,add3H:Sl,add4L:kl,add4H:Nl,add5H:Cl,add5L:Il},_=Ul;var[Tl,Rl]=_.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),ne=new Uint32Array(80),se=new Uint32Array(80),ms=class extends re{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){let{Ah:t,Al:e,Bh:n,Bl:s,Ch:o,Cl:i,Dh:a,Dl:c,Eh:u,El:l,Fh:f,Fl:h,Gh:w,Gl:b,Hh:y,Hl:d}=this;return[t,e,n,s,o,i,a,c,u,l,f,h,w,b,y,d]}set(t,e,n,s,o,i,a,c,u,l,f,h,w,b,y,d){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=a|0,this.Dl=c|0,this.Eh=u|0,this.El=l|0,this.Fh=f|0,this.Fl=h|0,this.Gh=w|0,this.Gl=b|0,this.Hh=y|0,this.Hl=d|0}process(t,e){for(let p=0;p<16;p++,e+=4)ne[p]=t.getUint32(e),se[p]=t.getUint32(e+=4);for(let p=16;p<80;p++){let k=ne[p-15]|0,R=se[p-15]|0,T=_.rotrSH(k,R,1)^_.rotrSH(k,R,8)^_.shrSH(k,R,7),N=_.rotrSL(k,R,1)^_.rotrSL(k,R,8)^_.shrSL(k,R,7),U=ne[p-2]|0,I=se[p-2]|0,j=_.rotrSH(U,I,19)^_.rotrBH(U,I,61)^_.shrSH(U,I,6),P=_.rotrSL(U,I,19)^_.rotrBL(U,I,61)^_.shrSL(U,I,6),M=_.add4L(N,P,se[p-7],se[p-16]),X=_.add4H(M,T,j,ne[p-7],ne[p-16]);ne[p]=X|0,se[p]=M|0}let{Ah:n,Al:s,Bh:o,Bl:i,Ch:a,Cl:c,Dh:u,Dl:l,Eh:f,El:h,Fh:w,Fl:b,Gh:y,Gl:d,Hh:x,Hl:B}=this;for(let p=0;p<80;p++){let k=_.rotrSH(f,h,14)^_.rotrSH(f,h,18)^_.rotrBH(f,h,41),R=_.rotrSL(f,h,14)^_.rotrSL(f,h,18)^_.rotrBL(f,h,41),T=f&w^~f&y,N=h&b^~h&d,U=_.add5L(B,R,N,Rl[p],se[p]),I=_.add5H(U,x,k,T,Tl[p],ne[p]),j=U|0,P=_.rotrSH(n,s,28)^_.rotrBH(n,s,34)^_.rotrBH(n,s,39),M=_.rotrSL(n,s,28)^_.rotrBL(n,s,34)^_.rotrBL(n,s,39),X=n&o^n&a^o&a,E=s&i^s&c^i&c;x=y|0,B=d|0,y=w|0,d=b|0,w=f|0,b=h|0,{h:f,l:h}=_.add(u|0,l|0,I|0,j|0),u=a|0,l=c|0,a=o|0,c=i|0,o=n|0,i=s|0;let C=_.add3L(j,M,E);n=_.add3H(C,I,P,X),s=C|0}({h:n,l:s}=_.add(this.Ah|0,this.Al|0,n|0,s|0)),{h:o,l:i}=_.add(this.Bh|0,this.Bl|0,o|0,i|0),{h:a,l:c}=_.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:u,l}=_.add(this.Dh|0,this.Dl|0,u|0,l|0),{h:f,l:h}=_.add(this.Eh|0,this.El|0,f|0,h|0),{h:w,l:b}=_.add(this.Fh|0,this.Fl|0,w|0,b|0),{h:y,l:d}=_.add(this.Gh|0,this.Gl|0,y|0,d|0),{h:x,l:B}=_.add(this.Hh|0,this.Hl|0,x|0,B|0),this.set(n,s,o,i,a,c,u,l,f,h,w,b,y,d,x,B)}roundClean(){ne.fill(0),se.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}};var Pr=De(()=>new ms);var zr={};ot(zr,{aInRange:()=>yt,abool:()=>kt,abytes:()=>Pe,bitGet:()=>Ml,bitLen:()=>ws,bitMask:()=>ur,bitSet:()=>Dl,bytesToHex:()=>Ft,bytesToNumberBE:()=>qt,bytesToNumberLE:()=>ie,concatBytes:()=>zt,createHmacDrbg:()=>vs,ensureBytes:()=>W,equalBytes:()=>_l,hexToBytes:()=>xe,hexToNumber:()=>xs,inRange:()=>lr,isBytes:()=>oe,memoized:()=>ve,notImplemented:()=>Pl,numberToBytesBE:()=>ae,numberToBytesLE:()=>we,numberToHexUnpadded:()=>be,numberToVarBytesBE:()=>Vl,utf8ToBytes:()=>Ol,validateObject:()=>Rt});var Fr=BigInt(0),qr=BigInt(1),Ll=BigInt(2);function oe(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Pe(r){if(!oe(r))throw new Error("Uint8Array expected")}function kt(r,t){if(typeof t!="boolean")throw new Error(r+" boolean expected, got "+t)}var Hl=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function Ft(r){Pe(r);let t="";for(let e=0;e<r.length;e++)t+=Hl[r[e]];return t}function be(r){let t=r.toString(16);return t.length&1?"0"+t:t}function xs(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?Fr:BigInt("0x"+r)}var Pt={_0:48,_9:57,A:65,F:70,a:97,f:102};function ri(r){if(r>=Pt._0&&r<=Pt._9)return r-Pt._0;if(r>=Pt.A&&r<=Pt.F)return r-(Pt.A-10);if(r>=Pt.a&&r<=Pt.f)return r-(Pt.a-10)}function xe(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);let t=r.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);let n=new Uint8Array(e);for(let s=0,o=0;s<e;s++,o+=2){let i=ri(r.charCodeAt(o)),a=ri(r.charCodeAt(o+1));if(i===void 0||a===void 0){let c=r[o]+r[o+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+o)}n[s]=i*16+a}return n}function qt(r){return xs(Ft(r))}function ie(r){return Pe(r),xs(Ft(Uint8Array.from(r).reverse()))}function ae(r,t){return xe(r.toString(16).padStart(t*2,"0"))}function we(r,t){return ae(r,t).reverse()}function Vl(r){return xe(be(r))}function W(r,t,e){let n;if(typeof t=="string")try{n=xe(t)}catch(o){throw new Error(r+" must be hex string or Uint8Array, cause: "+o)}else if(oe(t))n=Uint8Array.from(t);else throw new Error(r+" must be hex string or Uint8Array");let s=n.length;if(typeof e=="number"&&s!==e)throw new Error(r+" of length "+e+" expected, got "+s);return n}function zt(...r){let t=0;for(let n=0;n<r.length;n++){let s=r[n];Pe(s),t+=s.length}let e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){let o=r[n];e.set(o,s),s+=o.length}return e}function _l(r,t){if(r.length!==t.length)return!1;let e=0;for(let n=0;n<r.length;n++)e|=r[n]^t[n];return e===0}function Ol(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}var ys=r=>typeof r=="bigint"&&Fr<=r;function lr(r,t,e){return ys(r)&&ys(t)&&ys(e)&&t<=r&&r<e}function yt(r,t,e,n){if(!lr(t,e,n))throw new Error("expected valid "+r+": "+e+" <= n < "+n+", got "+t)}function ws(r){let t;for(t=0;r>Fr;r>>=qr,t+=1);return t}function Ml(r,t){return r>>BigInt(t)&qr}function Dl(r,t,e){return r|(e?qr:Fr)<<BigInt(t)}var ur=r=>(Ll<<BigInt(r-1))-qr,bs=r=>new Uint8Array(r),ni=r=>Uint8Array.from(r);function vs(r,t,e){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let n=bs(r),s=bs(r),o=0,i=()=>{n.fill(1),s.fill(0),o=0},a=(...f)=>e(s,n,...f),c=(f=bs())=>{s=a(ni([0]),f),n=a(),f.length!==0&&(s=a(ni([1]),f),n=a())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let f=0,h=[];for(;f<t;){n=a();let w=n.slice();h.push(w),f+=n.length}return zt(...h)};return(f,h)=>{i(),c(f);let w;for(;!(w=h(u()));)c();return i(),w}}var Kl={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||oe(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,t)=>t.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function Rt(r,t,e={}){let n=(s,o,i)=>{let a=Kl[o];if(typeof a!="function")throw new Error("invalid validator function");let c=r[s];if(!(i&&c===void 0)&&!a(c,r))throw new Error("param "+String(s)+" is invalid. Expected "+o+", got "+c)};for(let[s,o]of Object.entries(t))n(s,o,!1);for(let[s,o]of Object.entries(e))n(s,o,!0);return r}var Pl=()=>{throw new Error("not implemented")};function ve(r){let t=new WeakMap;return(e,...n)=>{let s=t.get(e);if(s!==void 0)return s;let o=r(e,...n);return t.set(e,o),o}}var Q=BigInt(0),G=BigInt(1),Be=BigInt(2),Fl=BigInt(3),Bs=BigInt(4),si=BigInt(5),oi=BigInt(8),ql=BigInt(9),zl=BigInt(16);function z(r,t){let e=r%t;return e>=Q?e:t+e}function $l(r,t,e){if(t<Q)throw new Error("invalid exponent, negatives unsupported");if(e<=Q)throw new Error("invalid modulus");if(e===G)return Q;let n=G;for(;t>Q;)t&G&&(n=n*r%e),r=r*r%e,t>>=G;return n}function Z(r,t,e){let n=r;for(;t-- >Q;)n*=n,n%=e;return n}function $r(r,t){if(r===Q)throw new Error("invert: expected non-zero number");if(t<=Q)throw new Error("invert: expected positive modulus, got "+t);let e=z(r,t),n=t,s=Q,o=G,i=G,a=Q;for(;e!==Q;){let u=n/e,l=n%e,f=s-i*u,h=o-a*u;n=e,e=l,s=i,o=a,i=f,a=h}if(n!==G)throw new Error("invert: does not exist");return z(s,t)}function jl(r){let t=(r-G)/Be,e,n,s;for(e=r-G,n=0;e%Be===Q;e/=Be,n++);for(s=Be;s<r&&$l(s,t,r)!==r-G;s++)if(s>1e3)throw new Error("Cannot find square root: likely non-prime P");if(n===1){let i=(r+G)/Bs;return function(c,u){let l=c.pow(u,i);if(!c.eql(c.sqr(l),u))throw new Error("Cannot find square root");return l}}let o=(e+G)/Be;return function(a,c){if(a.pow(c,t)===a.neg(a.ONE))throw new Error("Cannot find square root");let u=n,l=a.pow(a.mul(a.ONE,s),e),f=a.pow(c,o),h=a.pow(c,e);for(;!a.eql(h,a.ONE);){if(a.eql(h,a.ZERO))return a.ZERO;let w=1;for(let y=a.sqr(h);w<u&&!a.eql(y,a.ONE);w++)y=a.sqr(y);let b=a.pow(l,G<<BigInt(u-w-1));l=a.sqr(b),f=a.mul(f,b),h=a.mul(h,l),u=w}return f}}function Gl(r){if(r%Bs===Fl){let t=(r+G)/Bs;return function(n,s){let o=n.pow(s,t);if(!n.eql(n.sqr(o),s))throw new Error("Cannot find square root");return o}}if(r%oi===si){let t=(r-si)/oi;return function(n,s){let o=n.mul(s,Be),i=n.pow(o,t),a=n.mul(s,i),c=n.mul(n.mul(a,Be),i),u=n.mul(a,n.sub(c,n.ONE));if(!n.eql(n.sqr(u),s))throw new Error("Cannot find square root");return u}}return r%zl,jl(r)}var ii=(r,t)=>(z(r,t)&G)===G,Zl=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Es(r){let t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Zl.reduce((n,s)=>(n[s]="function",n),t);return Rt(r,e)}function Wl(r,t,e){if(e<Q)throw new Error("invalid exponent, negatives unsupported");if(e===Q)return r.ONE;if(e===G)return t;let n=r.ONE,s=t;for(;e>Q;)e&G&&(n=r.mul(n,s)),s=r.sqr(s),e>>=G;return n}function Jl(r,t){let e=new Array(t.length),n=t.reduce((o,i,a)=>r.is0(i)?o:(e[a]=o,r.mul(o,i)),r.ONE),s=r.inv(n);return t.reduceRight((o,i,a)=>r.is0(i)?o:(e[a]=r.mul(o,e[a]),r.mul(o,i)),s),e}function As(r,t){let e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}function ce(r,t,e=!1,n={}){if(r<=Q)throw new Error("invalid field: expected ORDER > 0, got "+r);let{nBitLength:s,nByteLength:o}=As(r,t);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let i,a=Object.freeze({ORDER:r,isLE:e,BITS:s,BYTES:o,MASK:ur(s),ZERO:Q,ONE:G,create:c=>z(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return Q<=c&&c<r},is0:c=>c===Q,isOdd:c=>(c&G)===G,neg:c=>z(-c,r),eql:(c,u)=>c===u,sqr:c=>z(c*c,r),add:(c,u)=>z(c+u,r),sub:(c,u)=>z(c-u,r),mul:(c,u)=>z(c*u,r),pow:(c,u)=>Wl(a,c,u),div:(c,u)=>z(c*$r(u,r),r),sqrN:c=>c*c,addN:(c,u)=>c+u,subN:(c,u)=>c-u,mulN:(c,u)=>c*u,inv:c=>$r(c,r),sqrt:n.sqrt||(c=>(i||(i=Gl(r)),i(a,c))),invertBatch:c=>Jl(a,c),cmov:(c,u,l)=>l?u:c,toBytes:c=>e?we(c,o):ae(c,o),fromBytes:c=>{if(c.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+c.length);return e?ie(c):qt(c)}});return Object.freeze(a)}function ai(r){if(typeof r!="bigint")throw new Error("field order must be bigint");let t=r.toString(2).length;return Math.ceil(t/8)}function Ss(r){let t=ai(r);return t+Math.ceil(t/2)}function ci(r,t,e=!1){let n=r.length,s=ai(t),o=Ss(t);if(n<16||n<o||n>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+n);let i=e?ie(r):qt(r),a=z(i,t-G)+G;return e?we(a,s):ae(a,s)}var li=BigInt(0),jr=BigInt(1);function ks(r,t){let e=t.negate();return r?e:t}function ui(r,t){if(!Number.isSafeInteger(r)||r<=0||r>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+r)}function Ns(r,t){ui(r,t);let e=Math.ceil(t/r)+1,n=2**(r-1);return{windows:e,windowSize:n}}function Xl(r,t){if(!Array.isArray(r))throw new Error("array expected");r.forEach((e,n)=>{if(!(e instanceof t))throw new Error("invalid point at index "+n)})}function Ql(r,t){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((e,n)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+n)})}var Is=new WeakMap,fi=new WeakMap;function Cs(r){return fi.get(r)||1}function Gr(r,t){return{constTimeNegate:ks,hasPrecomputes(e){return Cs(e)!==1},unsafeLadder(e,n,s=r.ZERO){let o=e;for(;n>li;)n&jr&&(s=s.add(o)),o=o.double(),n>>=jr;return s},precomputeWindow(e,n){let{windows:s,windowSize:o}=Ns(n,t),i=[],a=e,c=a;for(let u=0;u<s;u++){c=a,i.push(c);for(let l=1;l<o;l++)c=c.add(a),i.push(c);a=c.double()}return i},wNAF(e,n,s){let{windows:o,windowSize:i}=Ns(e,t),a=r.ZERO,c=r.BASE,u=BigInt(2**e-1),l=2**e,f=BigInt(e);for(let h=0;h<o;h++){let w=h*i,b=Number(s&u);s>>=f,b>i&&(b-=l,s+=jr);let y=w,d=w+Math.abs(b)-1,x=h%2!==0,B=b<0;b===0?c=c.add(ks(x,n[y])):a=a.add(ks(B,n[d]))}return{p:a,f:c}},wNAFUnsafe(e,n,s,o=r.ZERO){let{windows:i,windowSize:a}=Ns(e,t),c=BigInt(2**e-1),u=2**e,l=BigInt(e);for(let f=0;f<i;f++){let h=f*a;if(s===li)break;let w=Number(s&c);if(s>>=l,w>a&&(w-=u,s+=jr),w===0)continue;let b=n[h+Math.abs(w)-1];w<0&&(b=b.negate()),o=o.add(b)}return o},getPrecomputes(e,n,s){let o=Is.get(n);return o||(o=this.precomputeWindow(n,e),e!==1&&Is.set(n,s(o))),o},wNAFCached(e,n,s){let o=Cs(e);return this.wNAF(o,this.getPrecomputes(o,e,s),n)},wNAFCachedUnsafe(e,n,s,o){let i=Cs(e);return i===1?this.unsafeLadder(e,n,o):this.wNAFUnsafe(i,this.getPrecomputes(i,e,s),n,o)},setWindowSize(e,n){ui(n,t),fi.set(e,n),Is.delete(e)}}}function Zr(r,t,e,n){if(Xl(e,r),Ql(n,t),e.length!==n.length)throw new Error("arrays of points and scalars must have equal length");let s=r.ZERO,o=ws(BigInt(e.length)),i=o>12?o-3:o>4?o-2:o?2:1,a=(1<<i)-1,c=new Array(a+1).fill(s),u=Math.floor((t.BITS-1)/i)*i,l=s;for(let f=u;f>=0;f-=i){c.fill(s);for(let w=0;w<n.length;w++){let b=n[w],y=Number(b>>BigInt(f)&BigInt(a));c[y]=c[y].add(e[w])}let h=s;for(let w=c.length-1,b=s;w>0;w--)b=b.add(c[w]),h=h.add(b);if(l=l.add(h),f!==0)for(let w=0;w<i;w++)l=l.double()}return l}function fr(r){return Es(r.Fp),Rt(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...As(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}var Nt=BigInt(0),bt=BigInt(1),Wr=BigInt(2),tu=BigInt(8),eu={zip215:!0};function ru(r){let t=fr(r);return Rt(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}function hi(r){let t=ru(r),{Fp:e,n,prehash:s,hash:o,randomBytes:i,nByteLength:a,h:c}=t,u=Wr<<BigInt(a*8)-bt,l=e.create,f=ce(t.n,t.nBitLength),h=t.uvRatio||((m,g)=>{try{return{isValid:!0,value:e.sqrt(m*e.inv(g))}}catch{return{isValid:!1,value:Nt}}}),w=t.adjustScalarBytes||(m=>m),b=t.domain||((m,g,v)=>{if(kt("phflag",v),g.length||v)throw new Error("Contexts/pre-hash are not supported");return m});function y(m,g){yt("coordinate "+m,g,Nt,u)}function d(m){if(!(m instanceof p))throw new Error("ExtendedPoint expected")}let x=ve((m,g)=>{let{ex:v,ey:S,ez:L}=m,H=m.is0();g==null&&(g=H?tu:e.inv(L));let O=l(v*g),K=l(S*g),V=l(L*g);if(H)return{x:Nt,y:bt};if(V!==bt)throw new Error("invZ was invalid");return{x:O,y:K}}),B=ve(m=>{let{a:g,d:v}=t;if(m.is0())throw new Error("bad point: ZERO");let{ex:S,ey:L,ez:H,et:O}=m,K=l(S*S),V=l(L*L),F=l(H*H),$=l(F*F),et=l(K*g),rt=l(F*l(et+V)),st=l($+l(v*l(K*V)));if(rt!==st)throw new Error("bad point: equation left != right (1)");let lt=l(S*L),mt=l(H*O);if(lt!==mt)throw new Error("bad point: equation left != right (2)");return!0});class p{constructor(g,v,S,L){this.ex=g,this.ey=v,this.ez=S,this.et=L,y("x",g),y("y",v),y("z",S),y("t",L),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(g){if(g instanceof p)throw new Error("extended point not allowed");let{x:v,y:S}=g||{};return y("x",v),y("y",S),new p(v,S,bt,l(v*S))}static normalizeZ(g){let v=e.invertBatch(g.map(S=>S.ez));return g.map((S,L)=>S.toAffine(v[L])).map(p.fromAffine)}static msm(g,v){return Zr(p,f,g,v)}_setWindowSize(g){T.setWindowSize(this,g)}assertValidity(){B(this)}equals(g){d(g);let{ex:v,ey:S,ez:L}=this,{ex:H,ey:O,ez:K}=g,V=l(v*K),F=l(H*L),$=l(S*K),et=l(O*L);return V===F&&$===et}is0(){return this.equals(p.ZERO)}negate(){return new p(l(-this.ex),this.ey,this.ez,l(-this.et))}double(){let{a:g}=t,{ex:v,ey:S,ez:L}=this,H=l(v*v),O=l(S*S),K=l(Wr*l(L*L)),V=l(g*H),F=v+S,$=l(l(F*F)-H-O),et=V+O,rt=et-K,st=V-O,lt=l($*rt),mt=l(et*st),dt=l($*st),Ut=l(rt*et);return new p(lt,mt,Ut,dt)}add(g){d(g);let{a:v,d:S}=t,{ex:L,ey:H,ez:O,et:K}=this,{ex:V,ey:F,ez:$,et}=g;if(v===BigInt(-1)){let ko=l((H-L)*(F+V)),No=l((H+L)*(F-V)),rs=l(No-ko);if(rs===Nt)return this.double();let Io=l(O*Wr*et),Co=l(K*Wr*$),Uo=Co+Io,To=No+ko,Ro=Co-Io,ac=l(Uo*rs),cc=l(To*Ro),lc=l(Uo*Ro),uc=l(rs*To);return new p(ac,cc,uc,lc)}let rt=l(L*V),st=l(H*F),lt=l(K*S*et),mt=l(O*$),dt=l((L+H)*(V+F)-rt-st),Ut=mt-lt,Dt=mt+lt,Qe=l(st-v*rt),nc=l(dt*Ut),sc=l(Dt*Qe),oc=l(dt*Qe),ic=l(Ut*Dt);return new p(nc,sc,ic,oc)}subtract(g){return this.add(g.negate())}wNAF(g){return T.wNAFCached(this,g,p.normalizeZ)}multiply(g){let v=g;yt("scalar",v,bt,n);let{p:S,f:L}=this.wNAF(v);return p.normalizeZ([S,L])[0]}multiplyUnsafe(g,v=p.ZERO){let S=g;return yt("scalar",S,Nt,n),S===Nt?R:this.is0()||S===bt?this:T.wNAFCachedUnsafe(this,S,p.normalizeZ,v)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return T.unsafeLadder(this,n).is0()}toAffine(g){return x(this,g)}clearCofactor(){let{h:g}=t;return g===bt?this:this.multiplyUnsafe(g)}static fromHex(g,v=!1){let{d:S,a:L}=t,H=e.BYTES;g=W("pointHex",g,H),kt("zip215",v);let O=g.slice(),K=g[H-1];O[H-1]=K&-129;let V=ie(O),F=v?u:e.ORDER;yt("pointHex.y",V,Nt,F);let $=l(V*V),et=l($-bt),rt=l(S*$-L),{isValid:st,value:lt}=h(et,rt);if(!st)throw new Error("Point.fromHex: invalid y coordinate");let mt=(lt&bt)===bt,dt=(K&128)!==0;if(!v&&lt===Nt&&dt)throw new Error("Point.fromHex: x=0 and x_0=1");return dt!==mt&&(lt=l(-lt)),p.fromAffine({x:lt,y:V})}static fromPrivateKey(g){return I(g).point}toRawBytes(){let{x:g,y:v}=this.toAffine(),S=we(v,e.BYTES);return S[S.length-1]|=g&bt?128:0,S}toHex(){return Ft(this.toRawBytes())}}p.BASE=new p(t.Gx,t.Gy,bt,l(t.Gx*t.Gy)),p.ZERO=new p(Nt,bt,bt,Nt);let{BASE:k,ZERO:R}=p,T=Gr(p,a*8);function N(m){return z(m,n)}function U(m){return N(ie(m))}function I(m){let g=e.BYTES;m=W("private key",m,g);let v=W("hashed private key",o(m),2*g),S=w(v.slice(0,g)),L=v.slice(g,2*g),H=U(S),O=k.multiply(H),K=O.toRawBytes();return{head:S,prefix:L,scalar:H,point:O,pointBytes:K}}function j(m){return I(m).pointBytes}function P(m=new Uint8Array,...g){let v=zt(...g);return U(o(b(v,W("context",m),!!s)))}function M(m,g,v={}){m=W("message",m),s&&(m=s(m));let{prefix:S,scalar:L,pointBytes:H}=I(g),O=P(v.context,S,m),K=k.multiply(O).toRawBytes(),V=P(v.context,K,H,m),F=N(O+V*L);yt("signature.s",F,Nt,n);let $=zt(K,we(F,e.BYTES));return W("result",$,e.BYTES*2)}let X=eu;function E(m,g,v,S=X){let{context:L,zip215:H}=S,O=e.BYTES;m=W("signature",m,2*O),g=W("message",g),v=W("publicKey",v,O),H!==void 0&&kt("zip215",H),s&&(g=s(g));let K=ie(m.slice(O,2*O)),V,F,$;try{V=p.fromHex(v,H),F=p.fromHex(m.slice(0,O),H),$=k.multiplyUnsafe(K)}catch{return!1}if(!H&&V.isSmallOrder())return!1;let et=P(L,F.toRawBytes(),V.toRawBytes(),g);return F.add(V.multiplyUnsafe(et)).subtract($).clearCofactor().equals(p.ZERO)}return k._setWindowSize(8),{CURVE:t,getPublicKey:j,sign:M,verify:E,ExtendedPoint:p,utils:{getExtendedPublicKey:I,randomPrivateKey:()=>i(e.BYTES),precompute(m=8,g=p.BASE){return g._setWindowSize(m),g.multiply(BigInt(3)),g}}}}var Us=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),di=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),Ih=BigInt(0),nu=BigInt(1),gi=BigInt(2),Ch=BigInt(3),su=BigInt(5),ou=BigInt(8);function iu(r){let t=BigInt(10),e=BigInt(20),n=BigInt(40),s=BigInt(80),o=Us,a=r*r%o*r%o,c=Z(a,gi,o)*a%o,u=Z(c,nu,o)*r%o,l=Z(u,su,o)*u%o,f=Z(l,t,o)*l%o,h=Z(f,e,o)*f%o,w=Z(h,n,o)*h%o,b=Z(w,s,o)*w%o,y=Z(b,s,o)*w%o,d=Z(y,t,o)*l%o;return{pow_p_5_8:Z(d,gi,o)*r%o,b2:a}}function au(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function cu(r,t){let e=Us,n=z(t*t*t,e),s=z(n*n*t,e),o=iu(r*s).pow_p_5_8,i=z(r*n*o,e),a=z(t*i*i,e),c=i,u=z(i*di,e),l=a===r,f=a===z(-r,e),h=a===z(-r*di,e);return l&&(i=c),(f||h)&&(i=u),ii(i,e)&&(i=z(-i,e)),{isValid:l||f,value:i}}var lu=ce(Us,void 0,!0),uu={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:lu,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:ou,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Pr,randomBytes:Ke,adjustScalarBytes:au,uvRatio:cu},Fe=hi(uu);var qe=32,Lt=64,Jr=32;function pi(){let r=Fe.utils.randomPrivateKey(),t=Fe.getPublicKey(r);return{privateKey:xi(r,t),publicKey:t}}function mi(r){if(r.length!==Jr)throw new TypeError('"seed" must be 32 bytes in length.');if(!(r instanceof Uint8Array))throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');let t=r,e=Fe.getPublicKey(t);return{privateKey:xi(t,e),publicKey:e}}function yi(r,t){let e=r.subarray(0,Jr);return Fe.sign(t instanceof Uint8Array?t:t.subarray(),e)}function bi(r,t,e){return Fe.verify(t,e instanceof Uint8Array?e:e.subarray(),r)}function xi(r,t){let e=new Uint8Array(Lt);for(let n=0;n<Jr;n++)e[n]=r[n],e[Jr+n]=t[n];return e}var hr=class{type="Ed25519";raw;constructor(t){this.raw=ze(t,qe)}toMultihash(){return cr.digest(dr(this))}toCID(){return Tt.createV1(114,this.toMultihash())}toString(){return ut.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:At(this.raw,t.raw)}verify(t,e){return bi(this.raw,e,t)}},Ee=class{type="Ed25519";raw;publicKey;constructor(t,e){this.raw=ze(t,Lt),this.publicKey=new hr(e)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:At(this.raw,t.raw)}sign(t){return yi(this.raw,t)}};function Ts(r){if(r.length>Lt){r=ze(r,Lt+qe);let n=r.subarray(0,Lt),s=r.subarray(Lt,r.length);return new Ee(n,s)}r=ze(r,Lt);let t=r.subarray(0,Lt),e=r.subarray(qe);return new Ee(t,e)}function Yr(r){return r=ze(r,qe),new hr(r)}async function vi(){let{privateKey:r,publicKey:t}=pi();return new Ee(r,t)}async function Bi(r){let{privateKey:t,publicKey:e}=mi(r);return new Ee(t,e)}function ze(r,t){if(r=Uint8Array.from(r??[]),r.length!==t)throw new q(`Key must be a Uint8Array of length ${t}, got ${r.length}`);return r}function Ht(r=0){return new Uint8Array(r)}var fu=Math.pow(2,7),hu=Math.pow(2,14),du=Math.pow(2,21),Ei=Math.pow(2,28),Ai=Math.pow(2,35),Si=Math.pow(2,42),ki=Math.pow(2,49),gt=128,le=127;function gr(r){if(r<fu)return 1;if(r<hu)return 2;if(r<du)return 3;if(r<Ei)return 4;if(r<Ai)return 5;if(r<Si)return 6;if(r<ki)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function Ni(r,t,e=0){switch(gr(r)){case 8:t[e++]=r&255|gt,r/=128;case 7:t[e++]=r&255|gt,r/=128;case 6:t[e++]=r&255|gt,r/=128;case 5:t[e++]=r&255|gt,r/=128;case 4:t[e++]=r&255|gt,r>>>=7;case 3:t[e++]=r&255|gt,r>>>=7;case 2:t[e++]=r&255|gt,r>>>=7;case 1:{t[e++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return t}function Ii(r,t){let e=r[t],n=0;if(n+=e&le,e<gt||(e=r[t+1],n+=(e&le)<<7,e<gt)||(e=r[t+2],n+=(e&le)<<14,e<gt)||(e=r[t+3],n+=(e&le)<<21,e<gt)||(e=r[t+4],n+=(e&le)*Ei,e<gt)||(e=r[t+5],n+=(e&le)*Ai,e<gt)||(e=r[t+6],n+=(e&le)*Si,e<gt)||(e=r[t+7],n+=(e&le)*ki,e<gt))return n;throw new RangeError("Could not decode varint")}var Rs=new Float32Array([-0]),ue=new Uint8Array(Rs.buffer);function Ci(r,t,e){Rs[0]=r,t[e]=ue[0],t[e+1]=ue[1],t[e+2]=ue[2],t[e+3]=ue[3]}function Ui(r,t){return ue[0]=r[t],ue[1]=r[t+1],ue[2]=r[t+2],ue[3]=r[t+3],Rs[0]}var Ls=new Float64Array([-0]),ft=new Uint8Array(Ls.buffer);function Ti(r,t,e){Ls[0]=r,t[e]=ft[0],t[e+1]=ft[1],t[e+2]=ft[2],t[e+3]=ft[3],t[e+4]=ft[4],t[e+5]=ft[5],t[e+6]=ft[6],t[e+7]=ft[7]}function Ri(r,t){return ft[0]=r[t],ft[1]=r[t+1],ft[2]=r[t+2],ft[3]=r[t+3],ft[4]=r[t+4],ft[5]=r[t+5],ft[6]=r[t+6],ft[7]=r[t+7],Ls[0]}var gu=BigInt(Number.MAX_SAFE_INTEGER),pu=BigInt(Number.MIN_SAFE_INTEGER),wt=class r{lo;hi;constructor(t,e){this.lo=t|0,this.hi=e|0}toNumber(t=!1){if(!t&&this.hi>>>31>0){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(e+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(t=!1){if(t)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(BigInt(e)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(t=!1){return this.toBigInt(t).toString()}zzEncode(){let t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this}zzDecode(){let t=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this}length(){let t=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?e===0?t<16384?t<128?1:2:t<2097152?3:4:e<16384?e<128?5:6:e<2097152?7:8:n<128?9:10}static fromBigInt(t){if(t===0n)return Ae;if(t<gu&&t>pu)return this.fromNumber(Number(t));let e=t<0n;e&&(t=-t);let n=t>>32n,s=t-(n<<32n);return e&&(n=~n|0n,s=~s|0n,++s>Li&&(s=0n,++n>Li&&(n=0n))),new r(Number(s),Number(n))}static fromNumber(t){if(t===0)return Ae;let e=t<0;e&&(t=-t);let n=t>>>0,s=(t-n)/4294967296>>>0;return e&&(s=~s>>>0,n=~n>>>0,++n>4294967295&&(n=0,++s>4294967295&&(s=0))),new r(n,s)}static from(t){return typeof t=="number"?r.fromNumber(t):typeof t=="bigint"?r.fromBigInt(t):typeof t=="string"?r.fromBigInt(BigInt(t)):t.low!=null||t.high!=null?new r(t.low>>>0,t.high>>>0):Ae}},Ae=new wt(0,0);Ae.toBigInt=function(){return 0n};Ae.zzEncode=Ae.zzDecode=function(){return this};Ae.length=function(){return 1};var Li=4294967296n;function Hi(r){let t=0,e=0;for(let n=0;n<r.length;++n)e=r.charCodeAt(n),e<128?t+=1:e<2048?t+=2:(e&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,t+=4):t+=3;return t}function Vi(r,t,e){if(e-t<1)return"";let s,o=[],i=0,a;for(;t<e;)a=r[t++],a<128?o[i++]=a:a>191&&a<224?o[i++]=(a&31)<<6|r[t++]&63:a>239&&a<365?(a=((a&7)<<18|(r[t++]&63)<<12|(r[t++]&63)<<6|r[t++]&63)-65536,o[i++]=55296+(a>>10),o[i++]=56320+(a&1023)):o[i++]=(a&15)<<12|(r[t++]&63)<<6|r[t++]&63,i>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,o)),i=0);return s!=null?(i>0&&s.push(String.fromCharCode.apply(String,o.slice(0,i))),s.join("")):String.fromCharCode.apply(String,o.slice(0,i))}function Hs(r,t,e){let n=e,s,o;for(let i=0;i<r.length;++i)s=r.charCodeAt(i),s<128?t[e++]=s:s<2048?(t[e++]=s>>6|192,t[e++]=s&63|128):(s&64512)===55296&&((o=r.charCodeAt(i+1))&64512)===56320?(s=65536+((s&1023)<<10)+(o&1023),++i,t[e++]=s>>18|240,t[e++]=s>>12&63|128,t[e++]=s>>6&63|128,t[e++]=s&63|128):(t[e++]=s>>12|224,t[e++]=s>>6&63|128,t[e++]=s&63|128);return e-n}function It(r,t){return RangeError(`index out of range: ${r.pos} + ${t??1} > ${r.len}`)}function Xr(r,t){return(r[t-4]|r[t-3]<<8|r[t-2]<<16|r[t-1]<<24)>>>0}var Vs=class{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(t){this.buf=t,this.pos=0,this.len=t.length}uint32(){let t=4294967295;if(t=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(t=(t|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return t;if((this.pos+=5)>this.len)throw this.pos=this.len,It(this,10);return t}int32(){return this.uint32()|0}sint32(){let t=this.uint32();return t>>>1^-(t&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw It(this,4);return Xr(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw It(this,4);return Xr(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw It(this,4);let t=Ui(this.buf,this.pos);return this.pos+=4,t}double(){if(this.pos+8>this.len)throw It(this,4);let t=Ri(this.buf,this.pos);return this.pos+=8,t}bytes(){let t=this.uint32(),e=this.pos,n=this.pos+t;if(n>this.len)throw It(this,t);return this.pos+=t,e===n?new Uint8Array(0):this.buf.subarray(e,n)}string(){let t=this.bytes();return Vi(t,0,t.length)}skip(t){if(typeof t=="number"){if(this.pos+t>this.len)throw It(this,t);this.pos+=t}else do if(this.pos>=this.len)throw It(this);while(this.buf[this.pos++]&128);return this}skipType(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${t} at offset ${this.pos}`)}return this}readLongVarint(){let t=new wt(0,0),e=0;if(this.len-this.pos>4){for(;e<4;++e)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw It(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,t}if(this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw It(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw It(this,8);let t=Xr(this.buf,this.pos+=4),e=Xr(this.buf,this.pos+=4);return new wt(t,e)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){let t=Ii(this.buf,this.pos);return this.pos+=gr(t),t}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}};function _s(r){return new Vs(r instanceof Uint8Array?r:r.subarray())}function Qr(r,t,e){let n=_s(r);return t.decode(n,void 0,e)}var Os={};ot(Os,{base10:()=>mu});var mu=te({prefix:"9",name:"base10",alphabet:"0123456789"});var Ms={};ot(Ms,{base16:()=>yu,base16upper:()=>bu});var yu=Y({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),bu=Y({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var Ds={};ot(Ds,{base2:()=>xu});var xu=Y({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var Ks={};ot(Ks,{base256emoji:()=>Au});var Oi=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),wu=Oi.reduce((r,t,e)=>(r[e]=t,r),[]),vu=Oi.reduce((r,t,e)=>{let n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);return r[n]=e,r},[]);function Bu(r){return r.reduce((t,e)=>(t+=wu[e],t),"")}function Eu(r){let t=[];for(let e of r){let n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);let s=vu[n];if(s==null)throw new Error(`Non-base256emoji character: ${e}`);t.push(s)}return new Uint8Array(t)}var Au=Ce({prefix:"\u{1F680}",name:"base256emoji",encode:Bu,decode:Eu});var Fs={};ot(Fs,{base64:()=>Ps,base64pad:()=>Su,base64url:()=>ku,base64urlpad:()=>Nu});var Ps=Y({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Su=Y({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),ku=Y({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Nu=Y({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var qs={};ot(qs,{base8:()=>Iu});var Iu=Y({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var zs={};ot(zs,{identity:()=>Cu});var Cu=Ce({prefix:"\0",name:"identity",encode:r=>Mo(r),decode:r=>Oo(r)});var cd=new TextEncoder,ld=new TextDecoder;var Gs={};ot(Gs,{sha256:()=>tn,sha512:()=>Ru});function js({name:r,code:t,encode:e}){return new $s(r,t,e)}var $s=class{name;code;encode;constructor(t,e,n){this.name=t,this.code=e,this.encode=n}digest(t){if(t instanceof Uint8Array){let e=this.encode(t);return e instanceof Uint8Array?Et(this.code,e):e.then(n=>Et(this.code,n))}else throw Error("Unknown type, must be binary type")}};function Di(r){return async t=>new Uint8Array(await crypto.subtle.digest(r,t))}var tn=js({name:"sha2-256",code:18,encode:Di("SHA-256")}),Ru=js({name:"sha2-512",code:19,encode:Di("SHA-512")});var Zs={...zs,...Ds,...qs,...Os,...Ms,...ls,...us,...cs,...Fs,...Ks},vd={...Gs,...ds};function Pi(r,t,e,n){return{name:r,prefix:t,encoder:{name:r,prefix:t,encode:e},decoder:{decode:n}}}var Ki=Pi("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),Ws=Pi("ascii","a",r=>{let t="a";for(let e=0;e<r.length;e++)t+=String.fromCharCode(r[e]);return t},r=>{r=r.substring(1);let t=Ht(r.length);for(let e=0;e<r.length;e++)t[e]=r.charCodeAt(e);return t}),Lu={utf8:Ki,"utf-8":Ki,hex:Zs.base16,latin1:Ws,ascii:Ws,binary:Ws,...Zs},en=Lu;function tt(r,t="utf8"){let e=en[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.decoder.decode(`${e.prefix}${r}`)}function Js(r){let t=r??8192,e=t>>>1,n,s=t;return function(i){if(i<1||i>e)return Ht(i);s+i>t&&(n=Ht(t),s=0);let a=n.subarray(s,s+=i);return s&7&&(s=(s|7)+1),a}}var Se=class{fn;len;next;val;constructor(t,e,n){this.fn=t,this.len=e,this.next=void 0,this.val=n}};function Ys(){}var Qs=class{head;tail;len;next;constructor(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}},Hu=Js();function Vu(r){return globalThis.Buffer!=null?Ht(r):Hu(r)}var mr=class{len;head;tail;states;constructor(){this.len=0,this.head=new Se(Ys,0,0),this.tail=this.head,this.states=null}_push(t,e,n){return this.tail=this.tail.next=new Se(t,e,n),this.len+=e,this}uint32(t){return this.len+=(this.tail=this.tail.next=new to((t=t>>>0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this}int32(t){return t<0?this._push(rn,10,wt.fromNumber(t)):this.uint32(t)}sint32(t){return this.uint32((t<<1^t>>31)>>>0)}uint64(t){let e=wt.fromBigInt(t);return this._push(rn,e.length(),e)}uint64Number(t){return this._push(Ni,gr(t),t)}uint64String(t){return this.uint64(BigInt(t))}int64(t){return this.uint64(t)}int64Number(t){return this.uint64Number(t)}int64String(t){return this.uint64String(t)}sint64(t){let e=wt.fromBigInt(t).zzEncode();return this._push(rn,e.length(),e)}sint64Number(t){let e=wt.fromNumber(t).zzEncode();return this._push(rn,e.length(),e)}sint64String(t){return this.sint64(BigInt(t))}bool(t){return this._push(Xs,1,t?1:0)}fixed32(t){return this._push(pr,4,t>>>0)}sfixed32(t){return this.fixed32(t)}fixed64(t){let e=wt.fromBigInt(t);return this._push(pr,4,e.lo)._push(pr,4,e.hi)}fixed64Number(t){let e=wt.fromNumber(t);return this._push(pr,4,e.lo)._push(pr,4,e.hi)}fixed64String(t){return this.fixed64(BigInt(t))}sfixed64(t){return this.fixed64(t)}sfixed64Number(t){return this.fixed64Number(t)}sfixed64String(t){return this.fixed64String(t)}float(t){return this._push(Ci,4,t)}double(t){return this._push(Ti,8,t)}bytes(t){let e=t.length>>>0;return e===0?this._push(Xs,1,0):this.uint32(e)._push(Ou,e,t)}string(t){let e=Hi(t);return e!==0?this.uint32(e)._push(Hs,e,t):this._push(Xs,1,0)}fork(){return this.states=new Qs(this),this.head=this.tail=new Se(Ys,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Se(Ys,0,0),this.len=0),this}ldelim(){let t=this.head,e=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=t.next,this.tail=e,this.len+=n),this}finish(){let t=this.head.next,e=Vu(this.len),n=0;for(;t!=null;)t.fn(t.val,e,n),n+=t.len,t=t.next;return e}};function Xs(r,t,e){t[e]=r&255}function _u(r,t,e){for(;r>127;)t[e++]=r&127|128,r>>>=7;t[e]=r}var to=class extends Se{next;constructor(t,e){super(_u,t,e),this.next=void 0}};function rn(r,t,e){for(;r.hi!==0;)t[e++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)t[e++]=r.lo&127|128,r.lo=r.lo>>>7;t[e++]=r.lo}function pr(r,t,e){t[e]=r&255,t[e+1]=r>>>8&255,t[e+2]=r>>>16&255,t[e+3]=r>>>24}function Ou(r,t,e){t.set(r,e)}globalThis.Buffer!=null&&(mr.prototype.bytes=function(r){let t=r.length>>>0;return this.uint32(t),t>0&&this._push(Mu,t,r),this},mr.prototype.string=function(r){let t=globalThis.Buffer.byteLength(r);return this.uint32(t),t>0&&this._push(Du,t,r),this});function Mu(r,t,e){t.set(r,e)}function Du(r,t,e){r.length<40?Hs(r,t,e):t.utf8Write!=null?t.utf8Write(r,e):t.set(tt(r),e)}function eo(){return new mr}function nn(r,t){let e=eo();return t.encode(r,e,{lengthDelimited:!1}),e.finish()}var $e;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})($e||($e={}));function sn(r,t,e,n){return{name:r,type:t,encode:e,decode:n}}function ro(r){function t(s){if(r[s.toString()]==null)throw new Error("Invalid enum value");return r[s]}let e=function(o,i){let a=t(o);i.int32(a)},n=function(o){let i=o.int32();return t(i)};return sn("enum",$e.VARINT,e,n)}function on(r,t){return sn("message",$e.LENGTH_DELIMITED,r,t)}var J;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1"})(J||(J={}));var no;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1"})(no||(no={}));(function(r){r.codec=()=>ro(no)})(J||(J={}));var Vt;(function(r){let t;r.codec=()=>(t==null&&(t=on((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),J.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{let o={},i=n==null?e.len:e.pos+n;for(;e.pos<i;){let a=e.uint32();switch(a>>>3){case 1:{o.Type=J.codec().decode(e);break}case 2:{o.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return o})),t),r.encode=e=>nn(e,r.codec()),r.decode=(e,n)=>Qr(e,r.codec(),n)})(Vt||(Vt={}));var yr;(function(r){let t;r.codec=()=>(t==null&&(t=on((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),J.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{let o={},i=n==null?e.len:e.pos+n;for(;e.pos<i;){let a=e.uint32();switch(a>>>3){case 1:{o.Type=J.codec().decode(e);break}case 2:{o.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return o})),t),r.encode=e=>nn(e,r.codec()),r.decode=(e,n)=>Qr(e,r.codec(),n)})(yr||(yr={}));var kr={};ot(kr,{MAX_RSA_KEY_SIZE:()=>Jn,generateRSAKeyPair:()=>po,jwkToJWKKeyPair:()=>_a,jwkToPkcs1:()=>ef,jwkToPkix:()=>go,jwkToRSAPrivateKey:()=>Va,pkcs1ToJwk:()=>La,pkcs1ToRSAPrivateKey:()=>Yn,pkixToJwk:()=>Ha,pkixToRSAPublicKey:()=>Xn});var Ku=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),fe=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),he=new Uint32Array(64),so=class extends re{constructor(){super(64,32,8,!1),this.A=fe[0]|0,this.B=fe[1]|0,this.C=fe[2]|0,this.D=fe[3]|0,this.E=fe[4]|0,this.F=fe[5]|0,this.G=fe[6]|0,this.H=fe[7]|0}get(){let{A:t,B:e,C:n,D:s,E:o,F:i,G:a,H:c}=this;return[t,e,n,s,o,i,a,c]}set(t,e,n,s,o,i,a,c){this.A=t|0,this.B=e|0,this.C=n|0,this.D=s|0,this.E=o|0,this.F=i|0,this.G=a|0,this.H=c|0}process(t,e){for(let f=0;f<16;f++,e+=4)he[f]=t.getUint32(e,!1);for(let f=16;f<64;f++){let h=he[f-15],w=he[f-2],b=St(h,7)^St(h,18)^h>>>3,y=St(w,17)^St(w,19)^w>>>10;he[f]=y+he[f-7]+b+he[f-16]|0}let{A:n,B:s,C:o,D:i,E:a,F:c,G:u,H:l}=this;for(let f=0;f<64;f++){let h=St(a,6)^St(a,11)^St(a,25),w=l+h+Mr(a,c,u)+Ku[f]+he[f]|0,y=(St(n,2)^St(n,13)^St(n,22))+Dr(n,s,o)|0;l=u,u=c,c=a,a=i+w|0,i=o,o=s,s=n,n=w+y|0}n=n+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(n,s,o,i,a,c,u,l)}roundClean(){he.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var de=De(()=>new so);var D=yc(qi());function ke(r,t){let e=0;if(r.length===1)return r[0];for(let n=r.length-1;n>=0;n--)e+=r[r.length-1-n]*Math.pow(2,t*n);return e}function ge(r,t,e=-1){let n=e,s=r,o=0,i=Math.pow(2,t);for(let a=1;a<8;a++){if(r<i){let c;if(n<0)c=new ArrayBuffer(a),o=a;else{if(n<a)return new ArrayBuffer(0);c=new ArrayBuffer(n),o=n}let u=new Uint8Array(c);for(let l=a-1;l>=0;l--){let f=Math.pow(2,l*t);u[o-l-1]=Math.floor(s/f),s-=u[o-l-1]*f}return c}i*=Math.pow(2,t)}return new ArrayBuffer(0)}function ln(...r){let t=0,e=0;for(let o of r)t+=o.length;let n=new ArrayBuffer(t),s=new Uint8Array(n);for(let o of r)s.set(o,e),e+=o.length;return s}function io(){let r=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){let a=r[0]===255&&r[1]&128,c=r[0]===0&&(r[1]&128)===0;(a||c)&&this.warnings.push("Needlessly long format")}let t=new ArrayBuffer(this.valueHex.byteLength),e=new Uint8Array(t);for(let a=0;a<this.valueHex.byteLength;a++)e[a]=0;e[0]=r[0]&128;let n=ke(e,8),s=new ArrayBuffer(this.valueHex.byteLength),o=new Uint8Array(s);for(let a=0;a<this.valueHex.byteLength;a++)o[a]=r[a];return o[0]&=127,ke(o,8)-n}function zi(r){let t=r<0?r*-1:r,e=128;for(let n=1;n<8;n++){if(t<=e){if(r<0){let i=e-t,a=ge(i,8,n),c=new Uint8Array(a);return c[0]|=128,a}let s=ge(t,8,n),o=new Uint8Array(s);if(o[0]&128){let i=s.slice(0),a=new Uint8Array(i);s=new ArrayBuffer(s.byteLength+1),o=new Uint8Array(s);for(let c=0;c<i.byteLength;c++)o[c+1]=a[c];o[0]=0}return s}e*=Math.pow(2,8)}return new ArrayBuffer(0)}function $i(r,t){if(r.byteLength!==t.byteLength)return!1;let e=new Uint8Array(r),n=new Uint8Array(t);for(let s=0;s<e.length;s++)if(e[s]!==n[s])return!1;return!0}function xt(r,t){let e=r.toString(10);if(t<e.length)return"";let n=t-e.length,s=new Array(n);for(let i=0;i<n;i++)s[i]="0";return s.join("").concat(e)}var r0=Math.log(2);function un(){if(typeof BigInt>"u")throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function ao(r){let t=0,e=0;for(let s=0;s<r.length;s++){let o=r[s];t+=o.byteLength}let n=new Uint8Array(t);for(let s=0;s<r.length;s++){let o=r[s];n.set(new Uint8Array(o),e),e+=o.byteLength}return n.buffer}function Wt(r,t,e,n){return t instanceof Uint8Array?t.byteLength?e<0?(r.error="Wrong parameter: inputOffset less than zero",!1):n<0?(r.error="Wrong parameter: inputLength less than zero",!1):t.byteLength-e-n<0?(r.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):!0:(r.error="Wrong parameter: inputBuffer has zero length",!1):(r.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}var xr=class{constructor(){this.items=[]}write(t){this.items.push(t)}final(){return ao(this.items)}},br=[new Uint8Array([1])],ji="0123456789";var Je="",Ct=new ArrayBuffer(0),co=new Uint8Array(0),wr="EndOfContent",Zi="OCTET STRING",Wi="BIT STRING";function Jt(r){var t;return t=class extends r{constructor(...n){var s;super(...n);let o=n[0]||{};this.isHexOnly=(s=o.isHexOnly)!==null&&s!==void 0?s:!1,this.valueHexView=o.valueHex?D.BufferSourceConverter.toUint8Array(o.valueHex):co}get valueHex(){return this.valueHexView.slice().buffer}set valueHex(n){this.valueHexView=new Uint8Array(n)}fromBER(n,s,o){let i=n instanceof ArrayBuffer?new Uint8Array(n):n;if(!Wt(this,i,s,o))return-1;let a=s+o;return this.valueHexView=i.subarray(s,a),this.valueHexView.length?(this.blockLength=o,a):(this.warnings.push("Zero buffer length"),s)}toBER(n=!1){return this.isHexOnly?n?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",Ct)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:D.Convert.ToHex(this.valueHexView)}}},t.NAME="hexBlock",t}var jt=class{constructor({blockLength:t=0,error:e=Je,warnings:n=[],valueBeforeDecode:s=co}={}){this.blockLength=t,this.error=e,this.warnings=n,this.valueBeforeDecodeView=D.BufferSourceConverter.toUint8Array(s)}static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(t){this.valueBeforeDecodeView=new Uint8Array(t)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:D.Convert.ToHex(this.valueBeforeDecodeView)}}};jt.NAME="baseBlock";var ht=class extends jt{fromBER(t,e,n){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(t,e){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}};ht.NAME="valueBlock";var fn=class extends Jt(jt){constructor({idBlock:t={}}={}){var e,n,s,o;super(),t?(this.isHexOnly=(e=t.isHexOnly)!==null&&e!==void 0?e:!1,this.valueHexView=t.valueHex?D.BufferSourceConverter.toUint8Array(t.valueHex):co,this.tagClass=(n=t.tagClass)!==null&&n!==void 0?n:-1,this.tagNumber=(s=t.tagNumber)!==null&&s!==void 0?s:-1,this.isConstructed=(o=t.isConstructed)!==null&&o!==void 0?o:!1):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(t=!1){let e=0;switch(this.tagClass){case 1:e|=0;break;case 2:e|=64;break;case 3:e|=128;break;case 4:e|=192;break;default:return this.error="Unknown tag class",Ct}if(this.isConstructed&&(e|=32),this.tagNumber<31&&!this.isHexOnly){let s=new Uint8Array(1);if(!t){let o=this.tagNumber;o&=31,e|=o,s[0]=e}return s.buffer}if(!this.isHexOnly){let s=ge(this.tagNumber,7),o=new Uint8Array(s),i=s.byteLength,a=new Uint8Array(i+1);if(a[0]=e|31,!t){for(let c=0;c<i-1;c++)a[c+1]=o[c]|128;a[i]=o[i-1]}return a.buffer}let n=new Uint8Array(this.valueHexView.byteLength+1);if(n[0]=e|31,!t){let s=this.valueHexView;for(let o=0;o<s.length-1;o++)n[o+1]=s[o]|128;n[this.valueHexView.byteLength]=s[s.length-1]}return n.buffer}fromBER(t,e,n){let s=D.BufferSourceConverter.toUint8Array(t);if(!Wt(this,s,e,n))return-1;let o=s.subarray(e,e+n);if(o.length===0)return this.error="Zero buffer length",-1;switch(o[0]&192){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=(o[0]&32)===32,this.isHexOnly=!1;let a=o[0]&31;if(a!==31)this.tagNumber=a,this.blockLength=1;else{let c=1,u=this.valueHexView=new Uint8Array(255),l=255;for(;o[c]&128;){if(u[c-1]=o[c]&127,c++,c>=o.length)return this.error="End of input reached before message was fully decoded",-1;if(c===l){l+=255;let h=new Uint8Array(l);for(let w=0;w<u.length;w++)h[w]=u[w];u=this.valueHexView=new Uint8Array(l)}}this.blockLength=c+1,u[c-1]=o[c]&127;let f=new Uint8Array(c);for(let h=0;h<c;h++)f[h]=u[h];u=this.valueHexView=new Uint8Array(c),u.set(f),this.blockLength<=9?this.tagNumber=ke(u,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(this.tagClass===1&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return e+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}};fn.NAME="identificationBlock";var hn=class extends jt{constructor({lenBlock:t={}}={}){var e,n,s;super(),this.isIndefiniteForm=(e=t.isIndefiniteForm)!==null&&e!==void 0?e:!1,this.longFormUsed=(n=t.longFormUsed)!==null&&n!==void 0?n:!1,this.length=(s=t.length)!==null&&s!==void 0?s:0}fromBER(t,e,n){let s=D.BufferSourceConverter.toUint8Array(t);if(!Wt(this,s,e,n))return-1;let o=s.subarray(e,e+n);if(o.length===0)return this.error="Zero buffer length",-1;if(o[0]===255)return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=o[0]===128,this.isIndefiniteForm)return this.blockLength=1,e+this.blockLength;if(this.longFormUsed=!!(o[0]&128),this.longFormUsed===!1)return this.length=o[0],this.blockLength=1,e+this.blockLength;let i=o[0]&127;if(i>8)return this.error="Too big integer",-1;if(i+1>o.length)return this.error="End of input reached before message was fully decoded",-1;let a=e+1,c=s.subarray(a,a+i);return c[i-1]===0&&this.warnings.push("Needlessly long encoded length"),this.length=ke(c,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=i+1,e+this.blockLength}toBER(t=!1){let e,n;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return e=new ArrayBuffer(1),t===!1&&(n=new Uint8Array(e),n[0]=128),e;if(this.longFormUsed){let s=ge(this.length,8);if(s.byteLength>127)return this.error="Too big length",Ct;if(e=new ArrayBuffer(s.byteLength+1),t)return e;let o=new Uint8Array(s);n=new Uint8Array(e),n[0]=s.byteLength|128;for(let i=0;i<s.byteLength;i++)n[i+1]=o[i];return e}return e=new ArrayBuffer(1),t===!1&&(n=new Uint8Array(e),n[0]=this.length),e}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}};hn.NAME="lengthBlock";var A={},at=class extends jt{constructor({name:t=Je,optional:e=!1,primitiveSchema:n,...s}={},o){super(s),this.name=t,this.optional=e,n&&(this.primitiveSchema=n),this.idBlock=new fn(s),this.lenBlock=new hn(s),this.valueBlock=o?new o(s):new ht(s)}fromBER(t,e,n){let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}toBER(t,e){let n=e||new xr;e||Ji(this);let s=this.idBlock.toBER(t);if(n.write(s),this.lenBlock.isIndefiniteForm)n.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(t,n),n.write(new ArrayBuffer(2));else{let o=this.valueBlock.toBER(t);this.lenBlock.length=o.byteLength;let i=this.lenBlock.toBER(t);n.write(i),n.write(o)}return e?Ct:n.final()}toJSON(){let t={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(t.primitiveSchema=this.primitiveSchema.toJSON()),t}toString(t="ascii"){return t==="ascii"?this.onAsciiEncoding():D.Convert.ToHex(this.toBER())}onAsciiEncoding(){return`${this.constructor.NAME} : ${D.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`}isEqual(t){if(this===t)return!0;if(!(t instanceof this.constructor))return!1;let e=this.toBER(),n=t.toBER();return $i(e,n)}};at.NAME="BaseBlock";function Ji(r){if(r instanceof A.Constructed)for(let t of r.valueBlock.value)Ji(t)&&(r.lenBlock.isIndefiniteForm=!0);return!!r.lenBlock.isIndefiniteForm}var dn=class extends at{constructor({value:t=Je,...e}={},n){super(e,n),t&&this.fromString(t)}getValue(){return this.valueBlock.value}setValue(t){this.valueBlock.value=t}fromBER(t,e,n){let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}};dn.NAME="BaseStringBlock";var gn=class extends Jt(ht){constructor({isHexOnly:t=!0,...e}={}){super(e),this.isHexOnly=t}};gn.NAME="PrimitiveValueBlock";var Yi,pn=class extends at{constructor(t={}){super(t,gn),this.idBlock.isConstructed=!1}};Yi=pn;A.Primitive=Yi;pn.NAME="PRIMITIVE";function Wu(r,t){if(r instanceof t)return r;let e=new t;return e.idBlock=r.idBlock,e.lenBlock=r.lenBlock,e.warnings=r.warnings,e.valueBeforeDecodeView=r.valueBeforeDecodeView,e}function Wn(r,t=0,e=r.length){let n=t,s=new at({},ht),o=new jt;if(!Wt(o,r,t,e))return s.error=o.error,{offset:-1,result:s};if(!r.subarray(t,t+e).length)return s.error="Zero buffer length",{offset:-1,result:s};let a=s.idBlock.fromBER(r,t,e);if(s.idBlock.warnings.length&&s.warnings.concat(s.idBlock.warnings),a===-1)return s.error=s.idBlock.error,{offset:-1,result:s};if(t=a,e-=s.idBlock.blockLength,a=s.lenBlock.fromBER(r,t,e),s.lenBlock.warnings.length&&s.warnings.concat(s.lenBlock.warnings),a===-1)return s.error=s.lenBlock.error,{offset:-1,result:s};if(t=a,e-=s.lenBlock.blockLength,!s.idBlock.isConstructed&&s.lenBlock.isIndefiniteForm)return s.error="Indefinite length form used for primitive encoding form",{offset:-1,result:s};let c=at;switch(s.idBlock.tagClass){case 1:if(s.idBlock.tagNumber>=37&&s.idBlock.isHexOnly===!1)return s.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:s};switch(s.idBlock.tagNumber){case 0:if(s.idBlock.isConstructed&&s.lenBlock.length>0)return s.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:s};c=A.EndOfContent;break;case 1:c=A.Boolean;break;case 2:c=A.Integer;break;case 3:c=A.BitString;break;case 4:c=A.OctetString;break;case 5:c=A.Null;break;case 6:c=A.ObjectIdentifier;break;case 10:c=A.Enumerated;break;case 12:c=A.Utf8String;break;case 13:c=A.RelativeObjectIdentifier;break;case 14:c=A.TIME;break;case 15:return s.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:s};case 16:c=A.Sequence;break;case 17:c=A.Set;break;case 18:c=A.NumericString;break;case 19:c=A.PrintableString;break;case 20:c=A.TeletexString;break;case 21:c=A.VideotexString;break;case 22:c=A.IA5String;break;case 23:c=A.UTCTime;break;case 24:c=A.GeneralizedTime;break;case 25:c=A.GraphicString;break;case 26:c=A.VisibleString;break;case 27:c=A.GeneralString;break;case 28:c=A.UniversalString;break;case 29:c=A.CharacterString;break;case 30:c=A.BmpString;break;case 31:c=A.DATE;break;case 32:c=A.TimeOfDay;break;case 33:c=A.DateTime;break;case 34:c=A.Duration;break;default:{let u=s.idBlock.isConstructed?new A.Constructed:new A.Primitive;u.idBlock=s.idBlock,u.lenBlock=s.lenBlock,u.warnings=s.warnings,s=u}}break;case 2:case 3:case 4:default:c=s.idBlock.isConstructed?A.Constructed:A.Primitive}return s=Wu(s,c),a=s.fromBER(r,t,s.lenBlock.isIndefiniteForm?e:s.lenBlock.length),s.valueBeforeDecodeView=r.subarray(n,n+s.blockLength),{offset:a,result:s}}function lo(r){if(!r.byteLength){let t=new at({},ht);return t.error="Input buffer has zero length",{offset:-1,result:t}}return Wn(D.BufferSourceConverter.toUint8Array(r).slice(),0,r.byteLength)}function Ju(r,t){return r?1:t}var _t=class extends ht{constructor({value:t=[],isIndefiniteForm:e=!1,...n}={}){super(n),this.value=t,this.isIndefiniteForm=e}fromBER(t,e,n){let s=D.BufferSourceConverter.toUint8Array(t);if(!Wt(this,s,e,n))return-1;if(this.valueBeforeDecodeView=s.subarray(e,e+n),this.valueBeforeDecodeView.length===0)return this.warnings.push("Zero buffer length"),e;let o=e;for(;Ju(this.isIndefiniteForm,n)>0;){let i=Wn(s,o,n);if(i.offset===-1)return this.error=i.result.error,this.warnings.concat(i.result.warnings),-1;if(o=i.offset,this.blockLength+=i.result.blockLength,n-=i.result.blockLength,this.value.push(i.result),this.isIndefiniteForm&&i.result.constructor.NAME===wr)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===wr?this.value.pop():this.warnings.push("No EndOfContent block encoded")),o}toBER(t,e){let n=e||new xr;for(let s=0;s<this.value.length;s++)this.value[s].toBER(t,n);return e?Ct:n.final()}toJSON(){let t={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(let e of this.value)t.value.push(e.toJSON());return t}};_t.NAME="ConstructedValueBlock";var Xi,pe=class extends at{constructor(t={}){super(t,_t),this.idBlock.isConstructed=!0}fromBER(t,e,n){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){let t=[];for(let n of this.valueBlock.value)t.push(n.toString("ascii").split(`
./node_modules/@libp2p/crypto/dist/src/ciphers/aes-gcm.browser.js:30:        const salt = crypto.getRandomValues(new Uint8Array(saltLength));
./node_modules/@libp2p/crypto/dist/src/ciphers/aes-gcm.browser.js:31:        const nonce = crypto.getRandomValues(new Uint8Array(nonceLength));
./node_modules/@libp2p/crypto/src/ciphers/aes-gcm.browser.ts:36:    const salt = crypto.getRandomValues(new Uint8Array(saltLength))
./node_modules/@libp2p/crypto/src/ciphers/aes-gcm.browser.ts:37:    const nonce = crypto.getRandomValues(new Uint8Array(nonceLength))
./node_modules/@libp2p/peer-id/dist/index.min.js:2:"use strict";var Libp2PPeerId=(()=>{var ar=Object.defineProperty;var es=Object.getOwnPropertyDescriptor;var rs=Object.getOwnPropertyNames;var ns=Object.prototype.hasOwnProperty;var it=(e,t)=>{for(var r in t)ar(e,r,{get:t[r],enumerable:!0})},os=(e,t,r,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of rs(t))!ns.call(e,o)&&o!==r&&ar(e,o,{get:()=>t[o],enumerable:!(n=es(t,o))||n.enumerable});return e};var ss=e=>os(ar({},"__esModule",{value:!0}),e);var Zc={};it(Zc,{peerIdFromCID:()=>Vc,peerIdFromMultihash:()=>xn,peerIdFromPrivateKey:()=>kc,peerIdFromPublicKey:()=>Go,peerIdFromString:()=>qc});var fr=Symbol.for("@libp2p/peer-id");var Xt=class extends Error{static name="InvalidParametersError";constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}},_e=class extends Error{static name="InvalidPublicKeyError";constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}};var De=class extends Error{static name="InvalidCIDError";constructor(t="Invalid CID"){super(t),this.name="InvalidCIDError"}},Oe=class extends Error{static name="InvalidMultihashError";constructor(t="Invalid Multihash"){super(t),this.name="InvalidMultihashError"}};var $t=class extends Error{static name="UnsupportedKeyTypeError";constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}};var pr={};it(pr,{base58btc:()=>Q,base58flickr:()=>hs});var Wc=new Uint8Array(0);function vn(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let r=0;r<e.byteLength;r++)if(e[r]!==t[r])return!1;return!0}function bt(e){if(e instanceof Uint8Array&&e.constructor.name==="Uint8Array")return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")}function An(e){return new TextEncoder().encode(e)}function In(e){return new TextDecoder().decode(e)}function is(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var o=0;o<e.length;o++){var s=e.charAt(o),i=s.charCodeAt(0);if(r[i]!==255)throw new TypeError(s+" is ambiguous");r[i]=o}var c=e.length,a=e.charAt(0),l=Math.log(c)/Math.log(256),f=Math.log(256)/Math.log(c);function x(w){if(w instanceof Uint8Array||(ArrayBuffer.isView(w)?w=new Uint8Array(w.buffer,w.byteOffset,w.byteLength):Array.isArray(w)&&(w=Uint8Array.from(w))),!(w instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(w.length===0)return"";for(var y=0,u=0,b=0,S=w.length;b!==S&&w[b]===0;)b++,y++;for(var d=(S-b)*f+1>>>0,A=new Uint8Array(d);b!==S;){for(var C=w[b],U=0,I=d-1;(C!==0||U<u)&&I!==-1;I--,U++)C+=256*A[I]>>>0,A[I]=C%c>>>0,C=C/c>>>0;if(C!==0)throw new Error("Non-zero carry");u=U,b++}for(var L=d-u;L!==d&&A[L]===0;)L++;for(var T=a.repeat(y);L<d;++L)T+=e.charAt(A[L]);return T}function p(w){if(typeof w!="string")throw new TypeError("Expected String");if(w.length===0)return new Uint8Array;var y=0;if(w[y]!==" "){for(var u=0,b=0;w[y]===a;)u++,y++;for(var S=(w.length-y)*l+1>>>0,d=new Uint8Array(S);w[y];){var A=r[w.charCodeAt(y)];if(A===255)return;for(var C=0,U=S-1;(A!==0||C<b)&&U!==-1;U--,C++)A+=c*d[U]>>>0,d[U]=A%256>>>0,A=A/256>>>0;if(A!==0)throw new Error("Non-zero carry");b=C,y++}if(w[y]!==" "){for(var I=S-b;I!==S&&d[I]===0;)I++;for(var L=new Uint8Array(u+(S-I)),T=u;I!==S;)L[T++]=d[I++];return L}}}function B(w){var y=p(w);if(y)return y;throw new Error(`Non-${t} character`)}return{encode:x,decodeUnsafe:p,decode:B}}var cs=is,as=cs,Rn=as;var ur=class{name;prefix;baseEncode;constructor(t,r,n){this.name=t,this.prefix=r,this.baseEncode=n}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}},hr=class{name;prefix;baseDecode;prefixCodePoint;constructor(t,r,n){this.name=t,this.prefix=r;let o=r.codePointAt(0);if(o===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=o,this.baseDecode=n}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return Ln(this,t)}},dr=class{decoders;constructor(t){this.decoders=t}or(t){return Ln(this,t)}decode(t){let r=t[0],n=this.decoders[r];if(n!=null)return n.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};function Ln(e,t){return new dr({...e.decoders??{[e.prefix]:e},...t.decoders??{[t.prefix]:t}})}var lr=class{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(t,r,n,o){this.name=t,this.prefix=r,this.baseEncode=n,this.baseDecode=o,this.encoder=new ur(t,r,n),this.decoder=new hr(t,r,o)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}};function Qt({name:e,prefix:t,encode:r,decode:n}){return new lr(e,t,r,n)}function Rt({name:e,prefix:t,alphabet:r}){let{encode:n,decode:o}=Rn(r,e);return Qt({prefix:t,name:e,encode:n,decode:s=>bt(o(s))})}function fs(e,t,r,n){let o={};for(let f=0;f<t.length;++f)o[t[f]]=f;let s=e.length;for(;e[s-1]==="=";)--s;let i=new Uint8Array(s*r/8|0),c=0,a=0,l=0;for(let f=0;f<s;++f){let x=o[e[f]];if(x===void 0)throw new SyntaxError(`Non-${n} character`);a=a<<r|x,c+=r,c>=8&&(c-=8,i[l++]=255&a>>c)}if(c>=r||255&a<<8-c)throw new SyntaxError("Unexpected end of data");return i}function us(e,t,r){let n=t[t.length-1]==="=",o=(1<<r)-1,s="",i=0,c=0;for(let a=0;a<e.length;++a)for(c=c<<8|e[a],i+=8;i>r;)i-=r,s+=t[o&c>>i];if(i!==0&&(s+=t[o&c<<r-i]),n)for(;s.length*r&7;)s+="=";return s}function j({name:e,prefix:t,bitsPerChar:r,alphabet:n}){return Qt({prefix:t,name:e,encode(o){return us(o,n,r)},decode(o){return fs(o,n,r,e)}})}var Q=Rt({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),hs=Rt({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var mr={};it(mr,{base32:()=>Jt,base32hex:()=>ms,base32hexpad:()=>ys,base32hexpadupper:()=>gs,base32hexupper:()=>xs,base32pad:()=>ls,base32padupper:()=>ps,base32upper:()=>ds,base32z:()=>bs});var Jt=j({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),ds=j({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),ls=j({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),ps=j({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),ms=j({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),xs=j({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),ys=j({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),gs=j({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),bs=j({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var xr={};it(xr,{base36:()=>he,base36upper:()=>ws});var he=Rt({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),ws=Rt({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var Es=Nn,Un=128,Bs=127,Ss=~Bs,vs=Math.pow(2,31);function Nn(e,t,r){t=t||[],r=r||0;for(var n=r;e>=vs;)t[r++]=e&255|Un,e/=128;for(;e&Ss;)t[r++]=e&255|Un,e>>>=7;return t[r]=e|0,Nn.bytes=r-n+1,t}var As=yr,Is=128,Cn=127;function yr(e,n){var r=0,n=n||0,o=0,s=n,i,c=e.length;do{if(s>=c)throw yr.bytes=0,new RangeError("Could not decode varint");i=e[s++],r+=o<28?(i&Cn)<<o:(i&Cn)*Math.pow(2,o),o+=7}while(i>=Is);return yr.bytes=s-n,r}var Ts=Math.pow(2,7),Rs=Math.pow(2,14),Ls=Math.pow(2,21),Us=Math.pow(2,28),Cs=Math.pow(2,35),Ns=Math.pow(2,42),_s=Math.pow(2,49),Ds=Math.pow(2,56),Os=Math.pow(2,63),Ps=function(e){return e<Ts?1:e<Rs?2:e<Ls?3:e<Us?4:e<Cs?5:e<Ns?6:e<_s?7:e<Ds?8:e<Os?9:10},Ks={encode:Es,decode:As,encodingLength:Ps},Hs=Ks,de=Hs;function le(e,t=0){return[de.decode(e,t),de.decode.bytes]}function te(e,t,r=0){return de.encode(e,t,r),t}function ee(e){return de.encodingLength(e)}function Mt(e,t){let r=t.byteLength,n=ee(e),o=n+ee(r),s=new Uint8Array(o+r);return te(e,s,0),te(r,s,n),s.set(t,o),new re(e,r,t,s)}function pe(e){let t=bt(e),[r,n]=le(t),[o,s]=le(t.subarray(n)),i=t.subarray(n+s);if(i.byteLength!==o)throw new Error("Incorrect length");return new re(r,o,i,t)}function _n(e,t){if(e===t)return!0;{let r=t;return e.code===r.code&&e.size===r.size&&r.bytes instanceof Uint8Array&&vn(e.bytes,r.bytes)}}var re=class{code;size;digest;bytes;constructor(t,r,n,o){this.code=t,this.size=r,this.digest=n,this.bytes=o}};function Dn(e,t){let{bytes:r,version:n}=e;switch(n){case 0:return qs(r,gr(e),t??Q.encoder);default:return ks(r,gr(e),t??Jt.encoder)}}var On=new WeakMap;function gr(e){let t=On.get(e);if(t==null){let r=new Map;return On.set(e,r),r}return t}var ht=class e{code;version;multihash;bytes;"/";constructor(t,r,n,o){this.code=r,this.version=t,this.multihash=n,this.bytes=o,this["/"]=o}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{let{code:t,multihash:r}=this;if(t!==me)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(r.code!==Vs)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return e.createV0(r)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{let{code:t,digest:r}=this.multihash,n=Mt(t,r);return e.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return e.equals(this,t)}static equals(t,r){let n=r;return n!=null&&t.code===n.code&&t.version===n.version&&_n(t.multihash,n.multihash)}toString(t){return Dn(this,t)}toJSON(){return{"/":Dn(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;let r=t;if(r instanceof e)return r;if(r["/"]!=null&&r["/"]===r.bytes||r.asCID===r){let{version:n,code:o,multihash:s,bytes:i}=r;return new e(n,o,s,i??Pn(n,o,s.bytes))}else if(r[zs]===!0){let{version:n,multihash:o,code:s}=r,i=pe(o);return e.create(n,s,i)}else return null}static create(t,r,n){if(typeof r!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(r!==me)throw new Error(`Version 0 CID must use dag-pb (code: ${me}) block encoding`);return new e(t,r,n,n.bytes)}case 1:{let o=Pn(t,r,n.bytes);return new e(t,r,n,o)}default:throw new Error("Invalid version")}}static createV0(t){return e.create(0,me,t)}static createV1(t,r){return e.create(1,t,r)}static decode(t){let[r,n]=e.decodeFirst(t);if(n.length!==0)throw new Error("Incorrect length");return r}static decodeFirst(t){let r=e.inspectBytes(t),n=r.size-r.multihashSize,o=bt(t.subarray(n,n+r.multihashSize));if(o.byteLength!==r.multihashSize)throw new Error("Incorrect length");let s=o.subarray(r.multihashSize-r.digestSize),i=new re(r.multihashCode,r.digestSize,s,o);return[r.version===0?e.createV0(i):e.createV1(r.codec,i),t.subarray(r.size)]}static inspectBytes(t){let r=0,n=()=>{let[x,p]=le(t.subarray(r));return r+=p,x},o=n(),s=me;if(o===18?(o=0,r=0):s=n(),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);let i=r,c=n(),a=n(),l=r+a,f=l-i;return{version:o,codec:s,multihashCode:c,digestSize:a,multihashSize:f,size:l}}static parse(t,r){let[n,o]=Ms(t,r),s=e.decode(o);if(s.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return gr(s).set(n,t),s}};function Ms(e,t){switch(e[0]){case"Q":{let r=t??Q;return[Q.prefix,r.decode(`${Q.prefix}${e}`)]}case Q.prefix:{let r=t??Q;return[Q.prefix,r.decode(e)]}case Jt.prefix:{let r=t??Jt;return[Jt.prefix,r.decode(e)]}case he.prefix:{let r=t??he;return[he.prefix,r.decode(e)]}default:{if(t==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}}}function qs(e,t,r){let{prefix:n}=r;if(n!==Q.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);let o=t.get(n);if(o==null){let s=r.encode(e).slice(1);return t.set(n,s),s}else return o}function ks(e,t,r){let{prefix:n}=r,o=t.get(n);if(o==null){let s=r.encode(e);return t.set(n,s),s}else return o}var me=112,Vs=18;function Pn(e,t,r){let n=ee(e),o=n+ee(t),s=new Uint8Array(o+r.byteLength);return te(e,s,0),te(t,s,n),s.set(r,o),s}var zs=Symbol.for("@ipld/js-cid/CID");var br={};it(br,{identity:()=>wt});var Kn=0,Fs="identity",Hn=bt;function Zs(e){return Mt(Kn,Hn(e))}var wt={code:Kn,name:Fs,encode:Hn,digest:Zs};function qt(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let r=0;r<e.byteLength;r++)if(e[r]!==t[r])return!1;return!0}function Mn(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function Gs(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function oe(e,...t){if(!Gs(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function qn(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Mn(e.outputLen),Mn(e.blockLen)}function se(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function kn(e,t){oe(e);let r=t.outputLen;if(e.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}var kt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var Ke=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),dt=(e,t)=>e<<32-t|e>>>t;function Vn(e){if(typeof e!="string")throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array(new TextEncoder().encode(e))}function xe(e){return typeof e=="string"&&(e=Vn(e)),oe(e),e}function wr(...e){let t=0;for(let n=0;n<e.length;n++){let o=e[n];oe(o),t+=o.length}let r=new Uint8Array(t);for(let n=0,o=0;n<e.length;n++){let s=e[n];r.set(s,o),o+=s.length}return r}var ie=class{clone(){return this._cloneInto()}};function He(e){let t=n=>e().update(xe(n)).digest(),r=e();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>e(),t}function Me(e=32){if(kt&&typeof kt.getRandomValues=="function")return kt.getRandomValues(new Uint8Array(e));if(kt&&typeof kt.randomBytes=="function")return kt.randomBytes(e);throw new Error("crypto.getRandomValues must be defined")}function js(e,t,r,n){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,r,n);let o=BigInt(32),s=BigInt(4294967295),i=Number(r>>o&s),c=Number(r&s),a=n?4:0,l=n?0:4;e.setUint32(t+a,i,n),e.setUint32(t+l,c,n)}var zn=(e,t,r)=>e&t^~e&r,Fn=(e,t,r)=>e&t^e&r^t&r,ce=class extends ie{constructor(t,r,n,o){super(),this.blockLen=t,this.outputLen=r,this.padOffset=n,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=Ke(this.buffer)}update(t){se(this);let{view:r,buffer:n,blockLen:o}=this;t=xe(t);let s=t.length;for(let i=0;i<s;){let c=Math.min(o-this.pos,s-i);if(c===o){let a=Ke(t);for(;o<=s-i;i+=o)this.process(a,i);continue}n.set(t.subarray(i,i+c),this.pos),this.pos+=c,i+=c,this.pos===o&&(this.process(r,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){se(this),kn(t,this),this.finished=!0;let{buffer:r,view:n,blockLen:o,isLE:s}=this,{pos:i}=this;r[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>o-i&&(this.process(n,0),i=0);for(let x=i;x<o;x++)r[x]=0;js(n,o-8,BigInt(this.length*8),s),this.process(n,0);let c=Ke(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let l=a/4,f=this.get();if(l>f.length)throw new Error("_sha2: outputLen bigger than state");for(let x=0;x<l;x++)c.setUint32(4*x,f[x],s)}digest(){let{buffer:t,outputLen:r}=this;this.digestInto(t);let n=t.slice(0,r);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:r,buffer:n,length:o,finished:s,destroyed:i,pos:c}=this;return t.length=o,t.pos=c,t.finished=s,t.destroyed=i,o%r&&t.buffer.set(n),t}};var qe=BigInt(4294967295),Er=BigInt(32);function Zn(e,t=!1){return t?{h:Number(e&qe),l:Number(e>>Er&qe)}:{h:Number(e>>Er&qe)|0,l:Number(e&qe)|0}}function Ys(e,t=!1){let r=new Uint32Array(e.length),n=new Uint32Array(e.length);for(let o=0;o<e.length;o++){let{h:s,l:i}=Zn(e[o],t);[r[o],n[o]]=[s,i]}return[r,n]}var Ws=(e,t)=>BigInt(e>>>0)<<Er|BigInt(t>>>0),Xs=(e,t,r)=>e>>>r,$s=(e,t,r)=>e<<32-r|t>>>r,Qs=(e,t,r)=>e>>>r|t<<32-r,Js=(e,t,r)=>e<<32-r|t>>>r,ti=(e,t,r)=>e<<64-r|t>>>r-32,ei=(e,t,r)=>e>>>r-32|t<<64-r,ri=(e,t)=>t,ni=(e,t)=>e,oi=(e,t,r)=>e<<r|t>>>32-r,si=(e,t,r)=>t<<r|e>>>32-r,ii=(e,t,r)=>t<<r-32|e>>>64-r,ci=(e,t,r)=>e<<r-32|t>>>64-r;function ai(e,t,r,n){let o=(t>>>0)+(n>>>0);return{h:e+r+(o/2**32|0)|0,l:o|0}}var fi=(e,t,r)=>(e>>>0)+(t>>>0)+(r>>>0),ui=(e,t,r,n)=>t+r+n+(e/2**32|0)|0,hi=(e,t,r,n)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0),di=(e,t,r,n,o)=>t+r+n+o+(e/2**32|0)|0,li=(e,t,r,n,o)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0)+(o>>>0),pi=(e,t,r,n,o,s)=>t+r+n+o+s+(e/2**32|0)|0;var mi={fromBig:Zn,split:Ys,toBig:Ws,shrSH:Xs,shrSL:$s,rotrSH:Qs,rotrSL:Js,rotrBH:ti,rotrBL:ei,rotr32H:ri,rotr32L:ni,rotlSH:oi,rotlSL:si,rotlBH:ii,rotlBL:ci,add:ai,add3L:fi,add3H:ui,add4L:hi,add4H:di,add5H:pi,add5L:li},O=mi;var[xi,yi]=O.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(e=>BigInt(e))),Lt=new Uint32Array(80),Ut=new Uint32Array(80),Br=class extends ce{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){let{Ah:t,Al:r,Bh:n,Bl:o,Ch:s,Cl:i,Dh:c,Dl:a,Eh:l,El:f,Fh:x,Fl:p,Gh:B,Gl:w,Hh:y,Hl:u}=this;return[t,r,n,o,s,i,c,a,l,f,x,p,B,w,y,u]}set(t,r,n,o,s,i,c,a,l,f,x,p,B,w,y,u){this.Ah=t|0,this.Al=r|0,this.Bh=n|0,this.Bl=o|0,this.Ch=s|0,this.Cl=i|0,this.Dh=c|0,this.Dl=a|0,this.Eh=l|0,this.El=f|0,this.Fh=x|0,this.Fl=p|0,this.Gh=B|0,this.Gl=w|0,this.Hh=y|0,this.Hl=u|0}process(t,r){for(let d=0;d<16;d++,r+=4)Lt[d]=t.getUint32(r),Ut[d]=t.getUint32(r+=4);for(let d=16;d<80;d++){let A=Lt[d-15]|0,C=Ut[d-15]|0,U=O.rotrSH(A,C,1)^O.rotrSH(A,C,8)^O.shrSH(A,C,7),I=O.rotrSL(A,C,1)^O.rotrSL(A,C,8)^O.shrSL(A,C,7),L=Lt[d-2]|0,T=Ut[d-2]|0,z=O.rotrSH(L,T,19)^O.rotrBH(L,T,61)^O.shrSH(L,T,6),M=O.rotrSL(L,T,19)^O.rotrBL(L,T,61)^O.shrSL(L,T,6),K=O.add4L(I,M,Ut[d-7],Ut[d-16]),Y=O.add4H(K,U,z,Lt[d-7],Lt[d-16]);Lt[d]=Y|0,Ut[d]=K|0}let{Ah:n,Al:o,Bh:s,Bl:i,Ch:c,Cl:a,Dh:l,Dl:f,Eh:x,El:p,Fh:B,Fl:w,Gh:y,Gl:u,Hh:b,Hl:S}=this;for(let d=0;d<80;d++){let A=O.rotrSH(x,p,14)^O.rotrSH(x,p,18)^O.rotrBH(x,p,41),C=O.rotrSL(x,p,14)^O.rotrSL(x,p,18)^O.rotrBL(x,p,41),U=x&B^~x&y,I=p&w^~p&u,L=O.add5L(S,C,I,yi[d],Ut[d]),T=O.add5H(L,b,A,U,xi[d],Lt[d]),z=L|0,M=O.rotrSH(n,o,28)^O.rotrBH(n,o,34)^O.rotrBH(n,o,39),K=O.rotrSL(n,o,28)^O.rotrBL(n,o,34)^O.rotrBL(n,o,39),Y=n&s^n&c^s&c,E=o&i^o&a^i&a;b=y|0,S=u|0,y=B|0,u=w|0,B=x|0,w=p|0,{h:x,l:p}=O.add(l|0,f|0,T|0,z|0),l=c|0,f=a|0,c=s|0,a=i|0,s=n|0,i=o|0;let R=O.add3L(z,K,E);n=O.add3H(R,T,M,Y),o=R|0}({h:n,l:o}=O.add(this.Ah|0,this.Al|0,n|0,o|0)),{h:s,l:i}=O.add(this.Bh|0,this.Bl|0,s|0,i|0),{h:c,l:a}=O.add(this.Ch|0,this.Cl|0,c|0,a|0),{h:l,l:f}=O.add(this.Dh|0,this.Dl|0,l|0,f|0),{h:x,l:p}=O.add(this.Eh|0,this.El|0,x|0,p|0),{h:B,l:w}=O.add(this.Fh|0,this.Fl|0,B|0,w|0),{h:y,l:u}=O.add(this.Gh|0,this.Gl|0,y|0,u|0),{h:b,l:S}=O.add(this.Hh|0,this.Hl|0,b|0,S|0),this.set(n,o,s,i,c,a,l,f,x,p,B,w,y,u,b,S)}roundClean(){Lt.fill(0),Ut.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}};var Gn=He(()=>new Br);var ze={};it(ze,{aInRange:()=>ct,abool:()=>lt,abytes:()=>ae,bitGet:()=>Si,bitLen:()=>Ir,bitMask:()=>ge,bitSet:()=>vi,bytesToHex:()=>Bt,bytesToNumberBE:()=>St,bytesToNumberLE:()=>Nt,concatBytes:()=>vt,createHmacDrbg:()=>Tr,ensureBytes:()=>G,equalBytes:()=>Ei,hexToBytes:()=>zt,hexToNumber:()=>Ar,inRange:()=>ye,isBytes:()=>Ct,memoized:()=>Zt,notImplemented:()=>Ii,numberToBytesBE:()=>_t,numberToBytesLE:()=>Ft,numberToHexUnpadded:()=>Vt,numberToVarBytesBE:()=>wi,utf8ToBytes:()=>Bi,validateObject:()=>yt});var ke=BigInt(0),Ve=BigInt(1),gi=BigInt(2);function Ct(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function ae(e){if(!Ct(e))throw new Error("Uint8Array expected")}function lt(e,t){if(typeof t!="boolean")throw new Error(e+" boolean expected, got "+t)}var bi=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function Bt(e){ae(e);let t="";for(let r=0;r<e.length;r++)t+=bi[e[r]];return t}function Vt(e){let t=e.toString(16);return t.length&1?"0"+t:t}function Ar(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?ke:BigInt("0x"+e)}var Et={_0:48,_9:57,A:65,F:70,a:97,f:102};function jn(e){if(e>=Et._0&&e<=Et._9)return e-Et._0;if(e>=Et.A&&e<=Et.F)return e-(Et.A-10);if(e>=Et.a&&e<=Et.f)return e-(Et.a-10)}function zt(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);let t=e.length,r=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);let n=new Uint8Array(r);for(let o=0,s=0;o<r;o++,s+=2){let i=jn(e.charCodeAt(s)),c=jn(e.charCodeAt(s+1));if(i===void 0||c===void 0){let a=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+s)}n[o]=i*16+c}return n}function St(e){return Ar(Bt(e))}function Nt(e){return ae(e),Ar(Bt(Uint8Array.from(e).reverse()))}function _t(e,t){return zt(e.toString(16).padStart(t*2,"0"))}function Ft(e,t){return _t(e,t).reverse()}function wi(e){return zt(Vt(e))}function G(e,t,r){let n;if(typeof t=="string")try{n=zt(t)}catch(s){throw new Error(e+" must be hex string or Uint8Array, cause: "+s)}else if(Ct(t))n=Uint8Array.from(t);else throw new Error(e+" must be hex string or Uint8Array");let o=n.length;if(typeof r=="number"&&o!==r)throw new Error(e+" of length "+r+" expected, got "+o);return n}function vt(...e){let t=0;for(let n=0;n<e.length;n++){let o=e[n];ae(o),t+=o.length}let r=new Uint8Array(t);for(let n=0,o=0;n<e.length;n++){let s=e[n];r.set(s,o),o+=s.length}return r}function Ei(e,t){if(e.length!==t.length)return!1;let r=0;for(let n=0;n<e.length;n++)r|=e[n]^t[n];return r===0}function Bi(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}var Sr=e=>typeof e=="bigint"&&ke<=e;function ye(e,t,r){return Sr(e)&&Sr(t)&&Sr(r)&&t<=e&&e<r}function ct(e,t,r,n){if(!ye(t,r,n))throw new Error("expected valid "+e+": "+r+" <= n < "+n+", got "+t)}function Ir(e){let t;for(t=0;e>ke;e>>=Ve,t+=1);return t}function Si(e,t){return e>>BigInt(t)&Ve}function vi(e,t,r){return e|(r?Ve:ke)<<BigInt(t)}var ge=e=>(gi<<BigInt(e-1))-Ve,vr=e=>new Uint8Array(e),Yn=e=>Uint8Array.from(e);function Tr(e,t,r){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof r!="function")throw new Error("hmacFn must be a function");let n=vr(e),o=vr(e),s=0,i=()=>{n.fill(1),o.fill(0),s=0},c=(...x)=>r(o,n,...x),a=(x=vr())=>{o=c(Yn([0]),x),n=c(),x.length!==0&&(o=c(Yn([1]),x),n=c())},l=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let x=0,p=[];for(;x<t;){n=c();let B=n.slice();p.push(B),x+=n.length}return vt(...p)};return(x,p)=>{i(),a(x);let B;for(;!(B=p(l()));)a();return i(),B}}var Ai={bigint:e=>typeof e=="bigint",function:e=>typeof e=="function",boolean:e=>typeof e=="boolean",string:e=>typeof e=="string",stringOrUint8Array:e=>typeof e=="string"||Ct(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>typeof e=="function"&&Number.isSafeInteger(e.outputLen)};function yt(e,t,r={}){let n=(o,s,i)=>{let c=Ai[s];if(typeof c!="function")throw new Error("invalid validator function");let a=e[o];if(!(i&&a===void 0)&&!c(a,e))throw new Error("param "+String(o)+" is invalid. Expected "+s+", got "+a)};for(let[o,s]of Object.entries(t))n(o,s,!1);for(let[o,s]of Object.entries(r))n(o,s,!0);return e}var Ii=()=>{throw new Error("not implemented")};function Zt(e){let t=new WeakMap;return(r,...n)=>{let o=t.get(r);if(o!==void 0)return o;let s=e(r,...n);return t.set(r,s),s}}var W=BigInt(0),F=BigInt(1),Gt=BigInt(2),Ti=BigInt(3),Rr=BigInt(4),Wn=BigInt(5),Xn=BigInt(8),Ri=BigInt(9),Li=BigInt(16);function k(e,t){let r=e%t;return r>=W?r:t+r}function Ui(e,t,r){if(t<W)throw new Error("invalid exponent, negatives unsupported");if(r<=W)throw new Error("invalid modulus");if(r===F)return W;let n=F;for(;t>W;)t&F&&(n=n*e%r),e=e*e%r,t>>=F;return n}function Z(e,t,r){let n=e;for(;t-- >W;)n*=n,n%=r;return n}function Fe(e,t){if(e===W)throw new Error("invert: expected non-zero number");if(t<=W)throw new Error("invert: expected positive modulus, got "+t);let r=k(e,t),n=t,o=W,s=F,i=F,c=W;for(;r!==W;){let l=n/r,f=n%r,x=o-i*l,p=s-c*l;n=r,r=f,o=i,s=c,i=x,c=p}if(n!==F)throw new Error("invert: does not exist");return k(o,t)}function Ci(e){let t=(e-F)/Gt,r,n,o;for(r=e-F,n=0;r%Gt===W;r/=Gt,n++);for(o=Gt;o<e&&Ui(o,t,e)!==e-F;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(n===1){let i=(e+F)/Rr;return function(a,l){let f=a.pow(l,i);if(!a.eql(a.sqr(f),l))throw new Error("Cannot find square root");return f}}let s=(r+F)/Gt;return function(c,a){if(c.pow(a,t)===c.neg(c.ONE))throw new Error("Cannot find square root");let l=n,f=c.pow(c.mul(c.ONE,o),r),x=c.pow(a,s),p=c.pow(a,r);for(;!c.eql(p,c.ONE);){if(c.eql(p,c.ZERO))return c.ZERO;let B=1;for(let y=c.sqr(p);B<l&&!c.eql(y,c.ONE);B++)y=c.sqr(y);let w=c.pow(f,F<<BigInt(l-B-1));f=c.sqr(w),x=c.mul(x,w),p=c.mul(p,f),l=B}return x}}function Ni(e){if(e%Rr===Ti){let t=(e+F)/Rr;return function(n,o){let s=n.pow(o,t);if(!n.eql(n.sqr(s),o))throw new Error("Cannot find square root");return s}}if(e%Xn===Wn){let t=(e-Wn)/Xn;return function(n,o){let s=n.mul(o,Gt),i=n.pow(s,t),c=n.mul(o,i),a=n.mul(n.mul(c,Gt),i),l=n.mul(c,n.sub(a,n.ONE));if(!n.eql(n.sqr(l),o))throw new Error("Cannot find square root");return l}}return e%Li,Ci(e)}var $n=(e,t)=>(k(e,t)&F)===F,_i=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Lr(e){let t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},r=_i.reduce((n,o)=>(n[o]="function",n),t);return yt(e,r)}function Di(e,t,r){if(r<W)throw new Error("invalid exponent, negatives unsupported");if(r===W)return e.ONE;if(r===F)return t;let n=e.ONE,o=t;for(;r>W;)r&F&&(n=e.mul(n,o)),o=e.sqr(o),r>>=F;return n}function Oi(e,t){let r=new Array(t.length),n=t.reduce((s,i,c)=>e.is0(i)?s:(r[c]=s,e.mul(s,i)),e.ONE),o=e.inv(n);return t.reduceRight((s,i,c)=>e.is0(i)?s:(r[c]=e.mul(s,r[c]),e.mul(s,i)),o),r}function Ur(e,t){let r=t!==void 0?t:e.toString(2).length,n=Math.ceil(r/8);return{nBitLength:r,nByteLength:n}}function Dt(e,t,r=!1,n={}){if(e<=W)throw new Error("invalid field: expected ORDER > 0, got "+e);let{nBitLength:o,nByteLength:s}=Ur(e,t);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let i,c=Object.freeze({ORDER:e,isLE:r,BITS:o,BYTES:s,MASK:ge(o),ZERO:W,ONE:F,create:a=>k(a,e),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return W<=a&&a<e},is0:a=>a===W,isOdd:a=>(a&F)===F,neg:a=>k(-a,e),eql:(a,l)=>a===l,sqr:a=>k(a*a,e),add:(a,l)=>k(a+l,e),sub:(a,l)=>k(a-l,e),mul:(a,l)=>k(a*l,e),pow:(a,l)=>Di(c,a,l),div:(a,l)=>k(a*Fe(l,e),e),sqrN:a=>a*a,addN:(a,l)=>a+l,subN:(a,l)=>a-l,mulN:(a,l)=>a*l,inv:a=>Fe(a,e),sqrt:n.sqrt||(a=>(i||(i=Ni(e)),i(c,a))),invertBatch:a=>Oi(c,a),cmov:(a,l,f)=>f?l:a,toBytes:a=>r?Ft(a,s):_t(a,s),fromBytes:a=>{if(a.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+a.length);return r?Nt(a):St(a)}});return Object.freeze(c)}function Qn(e){if(typeof e!="bigint")throw new Error("field order must be bigint");let t=e.toString(2).length;return Math.ceil(t/8)}function Cr(e){let t=Qn(e);return t+Math.ceil(t/2)}function Jn(e,t,r=!1){let n=e.length,o=Qn(t),s=Cr(t);if(n<16||n<s||n>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+n);let i=r?Nt(e):St(e),c=k(i,t-F)+F;return r?Ft(c,o):_t(c,o)}var to=BigInt(0),Ze=BigInt(1);function Nr(e,t){let r=t.negate();return e?r:t}function eo(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function _r(e,t){eo(e,t);let r=Math.ceil(t/e)+1,n=2**(e-1);return{windows:r,windowSize:n}}function Ki(e,t){if(!Array.isArray(e))throw new Error("array expected");e.forEach((r,n)=>{if(!(r instanceof t))throw new Error("invalid point at index "+n)})}function Hi(e,t){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((r,n)=>{if(!t.isValid(r))throw new Error("invalid scalar at index "+n)})}var Dr=new WeakMap,ro=new WeakMap;function Or(e){return ro.get(e)||1}function Ge(e,t){return{constTimeNegate:Nr,hasPrecomputes(r){return Or(r)!==1},unsafeLadder(r,n,o=e.ZERO){let s=r;for(;n>to;)n&Ze&&(o=o.add(s)),s=s.double(),n>>=Ze;return o},precomputeWindow(r,n){let{windows:o,windowSize:s}=_r(n,t),i=[],c=r,a=c;for(let l=0;l<o;l++){a=c,i.push(a);for(let f=1;f<s;f++)a=a.add(c),i.push(a);c=a.double()}return i},wNAF(r,n,o){let{windows:s,windowSize:i}=_r(r,t),c=e.ZERO,a=e.BASE,l=BigInt(2**r-1),f=2**r,x=BigInt(r);for(let p=0;p<s;p++){let B=p*i,w=Number(o&l);o>>=x,w>i&&(w-=f,o+=Ze);let y=B,u=B+Math.abs(w)-1,b=p%2!==0,S=w<0;w===0?a=a.add(Nr(b,n[y])):c=c.add(Nr(S,n[u]))}return{p:c,f:a}},wNAFUnsafe(r,n,o,s=e.ZERO){let{windows:i,windowSize:c}=_r(r,t),a=BigInt(2**r-1),l=2**r,f=BigInt(r);for(let x=0;x<i;x++){let p=x*c;if(o===to)break;let B=Number(o&a);if(o>>=f,B>c&&(B-=l,o+=Ze),B===0)continue;let w=n[p+Math.abs(B)-1];B<0&&(w=w.negate()),s=s.add(w)}return s},getPrecomputes(r,n,o){let s=Dr.get(n);return s||(s=this.precomputeWindow(n,r),r!==1&&Dr.set(n,o(s))),s},wNAFCached(r,n,o){let s=Or(r);return this.wNAF(s,this.getPrecomputes(s,r,o),n)},wNAFCachedUnsafe(r,n,o,s){let i=Or(r);return i===1?this.unsafeLadder(r,n,s):this.wNAFUnsafe(i,this.getPrecomputes(i,r,o),n,s)},setWindowSize(r,n){eo(n,t),ro.set(r,n),Dr.delete(r)}}}function je(e,t,r,n){if(Ki(r,e),Hi(n,t),r.length!==n.length)throw new Error("arrays of points and scalars must have equal length");let o=e.ZERO,s=Ir(BigInt(r.length)),i=s>12?s-3:s>4?s-2:s?2:1,c=(1<<i)-1,a=new Array(c+1).fill(o),l=Math.floor((t.BITS-1)/i)*i,f=o;for(let x=l;x>=0;x-=i){a.fill(o);for(let B=0;B<n.length;B++){let w=n[B],y=Number(w>>BigInt(x)&BigInt(c));a[y]=a[y].add(r[B])}let p=o;for(let B=a.length-1,w=o;B>0;B--)w=w.add(a[B]),p=p.add(w);if(f=f.add(p),x!==0)for(let B=0;B<i;B++)f=f.double()}return f}function be(e){return Lr(e.Fp),yt(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Ur(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}var pt=BigInt(0),at=BigInt(1),Ye=BigInt(2),Mi=BigInt(8),qi={zip215:!0};function ki(e){let t=be(e);return yt(e,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}function no(e){let t=ki(e),{Fp:r,n,prehash:o,hash:s,randomBytes:i,nByteLength:c,h:a}=t,l=Ye<<BigInt(c*8)-at,f=r.create,x=Dt(t.n,t.nBitLength),p=t.uvRatio||((m,h)=>{try{return{isValid:!0,value:r.sqrt(m*r.inv(h))}}catch{return{isValid:!1,value:pt}}}),B=t.adjustScalarBytes||(m=>m),w=t.domain||((m,h,g)=>{if(lt("phflag",g),h.length||g)throw new Error("Contexts/pre-hash are not supported");return m});function y(m,h){ct("coordinate "+m,h,pt,l)}function u(m){if(!(m instanceof d))throw new Error("ExtendedPoint expected")}let b=Zt((m,h)=>{let{ex:g,ey:v,ez:N}=m,_=m.is0();h==null&&(h=_?Mi:r.inv(N));let P=f(g*h),H=f(v*h),D=f(N*h);if(_)return{x:pt,y:at};if(D!==at)throw new Error("invZ was invalid");return{x:P,y:H}}),S=Zt(m=>{let{a:h,d:g}=t;if(m.is0())throw new Error("bad point: ZERO");let{ex:v,ey:N,ez:_,et:P}=m,H=f(v*v),D=f(N*N),q=f(_*_),V=f(q*q),X=f(H*h),$=f(q*f(X+D)),tt=f(V+f(g*f(H*D)));if($!==tt)throw new Error("bad point: equation left != right (1)");let et=f(v*N),st=f(_*P);if(et!==st)throw new Error("bad point: equation left != right (2)");return!0});class d{constructor(h,g,v,N){this.ex=h,this.ey=g,this.ez=v,this.et=N,y("x",h),y("y",g),y("z",v),y("t",N),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(h){if(h instanceof d)throw new Error("extended point not allowed");let{x:g,y:v}=h||{};return y("x",g),y("y",v),new d(g,v,at,f(g*v))}static normalizeZ(h){let g=r.invertBatch(h.map(v=>v.ez));return h.map((v,N)=>v.toAffine(g[N])).map(d.fromAffine)}static msm(h,g){return je(d,x,h,g)}_setWindowSize(h){U.setWindowSize(this,h)}assertValidity(){S(this)}equals(h){u(h);let{ex:g,ey:v,ez:N}=this,{ex:_,ey:P,ez:H}=h,D=f(g*H),q=f(_*N),V=f(v*H),X=f(P*N);return D===q&&V===X}is0(){return this.equals(d.ZERO)}negate(){return new d(f(-this.ex),this.ey,this.ez,f(-this.et))}double(){let{a:h}=t,{ex:g,ey:v,ez:N}=this,_=f(g*g),P=f(v*v),H=f(Ye*f(N*N)),D=f(h*_),q=g+v,V=f(f(q*q)-_-P),X=D+P,$=X-H,tt=D-P,et=f(V*$),st=f(X*tt),nt=f(V*tt),xt=f($*X);return new d(et,st,xt,nt)}add(h){u(h);let{a:g,d:v}=t,{ex:N,ey:_,ez:P,et:H}=this,{ex:D,ey:q,ez:V,et:X}=h;if(g===BigInt(-1)){let yn=f((_-N)*(q+D)),gn=f((_+N)*(q-D)),cr=f(gn-yn);if(cr===pt)return this.double();let bn=f(P*Ye*X),wn=f(H*Ye*V),En=wn+bn,Bn=gn+yn,Sn=wn-bn,$o=f(En*cr),Qo=f(Bn*Sn),Jo=f(En*Sn),ts=f(cr*Bn);return new d($o,Qo,ts,Jo)}let $=f(N*D),tt=f(_*q),et=f(H*v*X),st=f(P*V),nt=f((N+_)*(D+q)-$-tt),xt=st-et,gt=st+et,ue=f(tt-g*$),jo=f(nt*xt),Yo=f(gt*ue),Wo=f(nt*ue),Xo=f(xt*gt);return new d(jo,Yo,Xo,Wo)}subtract(h){return this.add(h.negate())}wNAF(h){return U.wNAFCached(this,h,d.normalizeZ)}multiply(h){let g=h;ct("scalar",g,at,n);let{p:v,f:N}=this.wNAF(g);return d.normalizeZ([v,N])[0]}multiplyUnsafe(h,g=d.ZERO){let v=h;return ct("scalar",v,pt,n),v===pt?C:this.is0()||v===at?this:U.wNAFCachedUnsafe(this,v,d.normalizeZ,g)}isSmallOrder(){return this.multiplyUnsafe(a).is0()}isTorsionFree(){return U.unsafeLadder(this,n).is0()}toAffine(h){return b(this,h)}clearCofactor(){let{h}=t;return h===at?this:this.multiplyUnsafe(h)}static fromHex(h,g=!1){let{d:v,a:N}=t,_=r.BYTES;h=G("pointHex",h,_),lt("zip215",g);let P=h.slice(),H=h[_-1];P[_-1]=H&-129;let D=Nt(P),q=g?l:r.ORDER;ct("pointHex.y",D,pt,q);let V=f(D*D),X=f(V-at),$=f(v*V-N),{isValid:tt,value:et}=p(X,$);if(!tt)throw new Error("Point.fromHex: invalid y coordinate");let st=(et&at)===at,nt=(H&128)!==0;if(!g&&et===pt&&nt)throw new Error("Point.fromHex: x=0 and x_0=1");return nt!==st&&(et=f(-et)),d.fromAffine({x:et,y:D})}static fromPrivateKey(h){return T(h).point}toRawBytes(){let{x:h,y:g}=this.toAffine(),v=Ft(g,r.BYTES);return v[v.length-1]|=h&at?128:0,v}toHex(){return Bt(this.toRawBytes())}}d.BASE=new d(t.Gx,t.Gy,at,f(t.Gx*t.Gy)),d.ZERO=new d(pt,at,at,pt);let{BASE:A,ZERO:C}=d,U=Ge(d,c*8);function I(m){return k(m,n)}function L(m){return I(Nt(m))}function T(m){let h=r.BYTES;m=G("private key",m,h);let g=G("hashed private key",s(m),2*h),v=B(g.slice(0,h)),N=g.slice(h,2*h),_=L(v),P=A.multiply(_),H=P.toRawBytes();return{head:v,prefix:N,scalar:_,point:P,pointBytes:H}}function z(m){return T(m).pointBytes}function M(m=new Uint8Array,...h){let g=vt(...h);return L(s(w(g,G("context",m),!!o)))}function K(m,h,g={}){m=G("message",m),o&&(m=o(m));let{prefix:v,scalar:N,pointBytes:_}=T(h),P=M(g.context,v,m),H=A.multiply(P).toRawBytes(),D=M(g.context,H,_,m),q=I(P+D*N);ct("signature.s",q,pt,n);let V=vt(H,Ft(q,r.BYTES));return G("result",V,r.BYTES*2)}let Y=qi;function E(m,h,g,v=Y){let{context:N,zip215:_}=v,P=r.BYTES;m=G("signature",m,2*P),h=G("message",h),g=G("publicKey",g,P),_!==void 0&&lt("zip215",_),o&&(h=o(h));let H=Nt(m.slice(P,2*P)),D,q,V;try{D=d.fromHex(g,_),q=d.fromHex(m.slice(0,P),_),V=A.multiplyUnsafe(H)}catch{return!1}if(!_&&D.isSmallOrder())return!1;let X=M(N,q.toRawBytes(),D.toRawBytes(),h);return q.add(D.multiplyUnsafe(X)).subtract(V).clearCofactor().equals(d.ZERO)}return A._setWindowSize(8),{CURVE:t,getPublicKey:z,sign:K,verify:E,ExtendedPoint:d,utils:{getExtendedPublicKey:T,randomPrivateKey:()=>i(r.BYTES),precompute(m=8,h=d.BASE){return h._setWindowSize(m),h.multiply(BigInt(3)),h}}}}var Pr=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),oo=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),qa=BigInt(0),Vi=BigInt(1),so=BigInt(2),ka=BigInt(3),zi=BigInt(5),Fi=BigInt(8);function Zi(e){let t=BigInt(10),r=BigInt(20),n=BigInt(40),o=BigInt(80),s=Pr,c=e*e%s*e%s,a=Z(c,so,s)*c%s,l=Z(a,Vi,s)*e%s,f=Z(l,zi,s)*l%s,x=Z(f,t,s)*f%s,p=Z(x,r,s)*x%s,B=Z(p,n,s)*p%s,w=Z(B,o,s)*B%s,y=Z(w,o,s)*B%s,u=Z(y,t,s)*f%s;return{pow_p_5_8:Z(u,so,s)*e%s,b2:c}}function Gi(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}function ji(e,t){let r=Pr,n=k(t*t*t,r),o=k(n*n*t,r),s=Zi(e*o).pow_p_5_8,i=k(e*n*s,r),c=k(t*i*i,r),a=i,l=k(i*oo,r),f=c===e,x=c===k(-e,r),p=c===k(-e*oo,r);return f&&(i=a),(x||p)&&(i=l),$n(i,r)&&(i=k(-i,r)),{isValid:f||x,value:i}}var Yi=Dt(Pr,void 0,!0),Wi={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:Yi,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:Fi,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Gn,randomBytes:Me,adjustScalarBytes:Gi,uvRatio:ji},io=no(Wi);var We=32;function co(e,t,r){return io.verify(t,r instanceof Uint8Array?r:r.subarray(),e)}var Xe=class{type="Ed25519";raw;constructor(t){this.raw=Kr(t,We)}toMultihash(){return wt.digest($e(this))}toCID(){return ht.createV1(114,this.toMultihash())}toString(){return Q.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:qt(this.raw,t.raw)}verify(t,r){return co(this.raw,r,t)}};function fo(e){return e=Kr(e,We),new Xe(e)}function Kr(e,t){if(e=Uint8Array.from(e??[]),e.length!==t)throw new Xt(`Key must be a Uint8Array of length ${t}, got ${e.length}`);return e}function At(e=0){return new Uint8Array(e)}var $i=Math.pow(2,7),Qi=Math.pow(2,14),Ji=Math.pow(2,21),uo=Math.pow(2,28),ho=Math.pow(2,35),lo=Math.pow(2,42),po=Math.pow(2,49),ot=128,Ot=127;function we(e){if(e<$i)return 1;if(e<Qi)return 2;if(e<Ji)return 3;if(e<uo)return 4;if(e<ho)return 5;if(e<lo)return 6;if(e<po)return 7;if(Number.MAX_SAFE_INTEGER!=null&&e>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function mo(e,t,r=0){switch(we(e)){case 8:t[r++]=e&255|ot,e/=128;case 7:t[r++]=e&255|ot,e/=128;case 6:t[r++]=e&255|ot,e/=128;case 5:t[r++]=e&255|ot,e/=128;case 4:t[r++]=e&255|ot,e>>>=7;case 3:t[r++]=e&255|ot,e>>>=7;case 2:t[r++]=e&255|ot,e>>>=7;case 1:{t[r++]=e&255,e>>>=7;break}default:throw new Error("unreachable")}return t}function xo(e,t){let r=e[t],n=0;if(n+=r&Ot,r<ot||(r=e[t+1],n+=(r&Ot)<<7,r<ot)||(r=e[t+2],n+=(r&Ot)<<14,r<ot)||(r=e[t+3],n+=(r&Ot)<<21,r<ot)||(r=e[t+4],n+=(r&Ot)*uo,r<ot)||(r=e[t+5],n+=(r&Ot)*ho,r<ot)||(r=e[t+6],n+=(r&Ot)*lo,r<ot)||(r=e[t+7],n+=(r&Ot)*po,r<ot))return n;throw new RangeError("Could not decode varint")}var Hr=new Float32Array([-0]),Pt=new Uint8Array(Hr.buffer);function yo(e,t,r){Hr[0]=e,t[r]=Pt[0],t[r+1]=Pt[1],t[r+2]=Pt[2],t[r+3]=Pt[3]}function go(e,t){return Pt[0]=e[t],Pt[1]=e[t+1],Pt[2]=e[t+2],Pt[3]=e[t+3],Hr[0]}var Mr=new Float64Array([-0]),rt=new Uint8Array(Mr.buffer);function bo(e,t,r){Mr[0]=e,t[r]=rt[0],t[r+1]=rt[1],t[r+2]=rt[2],t[r+3]=rt[3],t[r+4]=rt[4],t[r+5]=rt[5],t[r+6]=rt[6],t[r+7]=rt[7]}function wo(e,t){return rt[0]=e[t],rt[1]=e[t+1],rt[2]=e[t+2],rt[3]=e[t+3],rt[4]=e[t+4],rt[5]=e[t+5],rt[6]=e[t+6],rt[7]=e[t+7],Mr[0]}var tc=BigInt(Number.MAX_SAFE_INTEGER),ec=BigInt(Number.MIN_SAFE_INTEGER),ft=class e{lo;hi;constructor(t,r){this.lo=t|0,this.hi=r|0}toNumber(t=!1){if(!t&&this.hi>>>31>0){let r=~this.lo+1>>>0,n=~this.hi>>>0;return r===0&&(n=n+1>>>0),-(r+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(t=!1){if(t)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){let r=~this.lo+1>>>0,n=~this.hi>>>0;return r===0&&(n=n+1>>>0),-(BigInt(r)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(t=!1){return this.toBigInt(t).toString()}zzEncode(){let t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this}zzDecode(){let t=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this}length(){let t=this.lo,r=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?r===0?t<16384?t<128?1:2:t<2097152?3:4:r<16384?r<128?5:6:r<2097152?7:8:n<128?9:10}static fromBigInt(t){if(t===0n)return jt;if(t<tc&&t>ec)return this.fromNumber(Number(t));let r=t<0n;r&&(t=-t);let n=t>>32n,o=t-(n<<32n);return r&&(n=~n|0n,o=~o|0n,++o>Eo&&(o=0n,++n>Eo&&(n=0n))),new e(Number(o),Number(n))}static fromNumber(t){if(t===0)return jt;let r=t<0;r&&(t=-t);let n=t>>>0,o=(t-n)/4294967296>>>0;return r&&(o=~o>>>0,n=~n>>>0,++n>4294967295&&(n=0,++o>4294967295&&(o=0))),new e(n,o)}static from(t){return typeof t=="number"?e.fromNumber(t):typeof t=="bigint"?e.fromBigInt(t):typeof t=="string"?e.fromBigInt(BigInt(t)):t.low!=null||t.high!=null?new e(t.low>>>0,t.high>>>0):jt}},jt=new ft(0,0);jt.toBigInt=function(){return 0n};jt.zzEncode=jt.zzDecode=function(){return this};jt.length=function(){return 1};var Eo=4294967296n;function Bo(e){let t=0,r=0;for(let n=0;n<e.length;++n)r=e.charCodeAt(n),r<128?t+=1:r<2048?t+=2:(r&64512)===55296&&(e.charCodeAt(n+1)&64512)===56320?(++n,t+=4):t+=3;return t}function So(e,t,r){if(r-t<1)return"";let o,s=[],i=0,c;for(;t<r;)c=e[t++],c<128?s[i++]=c:c>191&&c<224?s[i++]=(c&31)<<6|e[t++]&63:c>239&&c<365?(c=((c&7)<<18|(e[t++]&63)<<12|(e[t++]&63)<<6|e[t++]&63)-65536,s[i++]=55296+(c>>10),s[i++]=56320+(c&1023)):s[i++]=(c&15)<<12|(e[t++]&63)<<6|e[t++]&63,i>8191&&((o??(o=[])).push(String.fromCharCode.apply(String,s)),i=0);return o!=null?(i>0&&o.push(String.fromCharCode.apply(String,s.slice(0,i))),o.join("")):String.fromCharCode.apply(String,s.slice(0,i))}function qr(e,t,r){let n=r,o,s;for(let i=0;i<e.length;++i)o=e.charCodeAt(i),o<128?t[r++]=o:o<2048?(t[r++]=o>>6|192,t[r++]=o&63|128):(o&64512)===55296&&((s=e.charCodeAt(i+1))&64512)===56320?(o=65536+((o&1023)<<10)+(s&1023),++i,t[r++]=o>>18|240,t[r++]=o>>12&63|128,t[r++]=o>>6&63|128,t[r++]=o&63|128):(t[r++]=o>>12|224,t[r++]=o>>6&63|128,t[r++]=o&63|128);return r-n}function mt(e,t){return RangeError(`index out of range: ${e.pos} + ${t??1} > ${e.len}`)}function Qe(e,t){return(e[t-4]|e[t-3]<<8|e[t-2]<<16|e[t-1]<<24)>>>0}var kr=class{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(t){this.buf=t,this.pos=0,this.len=t.length}uint32(){let t=4294967295;if(t=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(t=(t|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return t;if((this.pos+=5)>this.len)throw this.pos=this.len,mt(this,10);return t}int32(){return this.uint32()|0}sint32(){let t=this.uint32();return t>>>1^-(t&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw mt(this,4);return Qe(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw mt(this,4);return Qe(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw mt(this,4);let t=go(this.buf,this.pos);return this.pos+=4,t}double(){if(this.pos+8>this.len)throw mt(this,4);let t=wo(this.buf,this.pos);return this.pos+=8,t}bytes(){let t=this.uint32(),r=this.pos,n=this.pos+t;if(n>this.len)throw mt(this,t);return this.pos+=t,r===n?new Uint8Array(0):this.buf.subarray(r,n)}string(){let t=this.bytes();return So(t,0,t.length)}skip(t){if(typeof t=="number"){if(this.pos+t>this.len)throw mt(this,t);this.pos+=t}else do if(this.pos>=this.len)throw mt(this);while(this.buf[this.pos++]&128);return this}skipType(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${t} at offset ${this.pos}`)}return this}readLongVarint(){let t=new ft(0,0),r=0;if(this.len-this.pos>4){for(;r<4;++r)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<r*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;r=0}else{for(;r<3;++r){if(this.pos>=this.len)throw mt(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<r*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<r*7)>>>0,t}if(this.len-this.pos>4){for(;r<5;++r)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<r*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;r<5;++r){if(this.pos>=this.len)throw mt(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<r*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw mt(this,8);let t=Qe(this.buf,this.pos+=4),r=Qe(this.buf,this.pos+=4);return new ft(t,r)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){let t=xo(this.buf,this.pos);return this.pos+=we(t),t}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}};function Vr(e){return new kr(e instanceof Uint8Array?e:e.subarray())}function Je(e,t,r){let n=Vr(e);return t.decode(n,void 0,r)}var zr={};it(zr,{base10:()=>rc});var rc=Rt({prefix:"9",name:"base10",alphabet:"0123456789"});var Fr={};it(Fr,{base16:()=>nc,base16upper:()=>oc});var nc=j({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),oc=j({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var Zr={};it(Zr,{base2:()=>sc});var sc=j({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var Gr={};it(Gr,{base256emoji:()=>uc});var Ao=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),ic=Ao.reduce((e,t,r)=>(e[r]=t,e),[]),cc=Ao.reduce((e,t,r)=>{let n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);return e[n]=r,e},[]);function ac(e){return e.reduce((t,r)=>(t+=ic[r],t),"")}function fc(e){let t=[];for(let r of e){let n=r.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${r}`);let o=cc[n];if(o==null)throw new Error(`Non-base256emoji character: ${r}`);t.push(o)}return new Uint8Array(t)}var uc=Qt({prefix:"\u{1F680}",name:"base256emoji",encode:ac,decode:fc});var jr={};it(jr,{base64:()=>hc,base64pad:()=>dc,base64url:()=>lc,base64urlpad:()=>pc});var hc=j({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),dc=j({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),lc=j({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),pc=j({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var Yr={};it(Yr,{base8:()=>mc});var mc=j({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var Wr={};it(Wr,{identity:()=>xc});var xc=Qt({prefix:"\0",name:"identity",encode:e=>In(e),decode:e=>An(e)});var Af=new TextEncoder,If=new TextDecoder;var Qr={};it(Qr,{sha256:()=>Ee,sha512:()=>bc});function $r({name:e,code:t,encode:r}){return new Xr(e,t,r)}var Xr=class{name;code;encode;constructor(t,r,n){this.name=t,this.code=r,this.encode=n}digest(t){if(t instanceof Uint8Array){let r=this.encode(t);return r instanceof Uint8Array?Mt(this.code,r):r.then(n=>Mt(this.code,n))}else throw Error("Unknown type, must be binary type")}};function To(e){return async t=>new Uint8Array(await crypto.subtle.digest(e,t))}var Ee=$r({name:"sha2-256",code:18,encode:To("SHA-256")}),bc=$r({name:"sha2-512",code:19,encode:To("SHA-512")});var Jr={...Wr,...Zr,...Yr,...zr,...Fr,...mr,...xr,...pr,...jr,...Gr},Hf={...Qr,...br};function Lo(e,t,r,n){return{name:e,prefix:t,encoder:{name:e,prefix:t,encode:r},decoder:{decode:n}}}var Ro=Lo("utf8","u",e=>"u"+new TextDecoder("utf8").decode(e),e=>new TextEncoder().encode(e.substring(1))),tn=Lo("ascii","a",e=>{let t="a";for(let r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return t},e=>{e=e.substring(1);let t=At(e.length);for(let r=0;r<e.length;r++)t[r]=e.charCodeAt(r);return t}),wc={utf8:Ro,"utf-8":Ro,hex:Jr.base16,latin1:tn,ascii:tn,binary:tn,...Jr},tr=wc;function Be(e,t="utf8"){let r=tr[t];if(r==null)throw new Error(`Unsupported encoding "${t}"`);return r.decoder.decode(`${r.prefix}${e}`)}function en(e){let t=e??8192,r=t>>>1,n,o=t;return function(i){if(i<1||i>r)return At(i);o+i>t&&(n=At(t),o=0);let c=n.subarray(o,o+=i);return o&7&&(o=(o|7)+1),c}}var Yt=class{fn;len;next;val;constructor(t,r,n){this.fn=t,this.len=r,this.next=void 0,this.val=n}};function rn(){}var on=class{head;tail;len;next;constructor(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}},Ec=en();function Bc(e){return globalThis.Buffer!=null?At(e):Ec(e)}var ve=class{len;head;tail;states;constructor(){this.len=0,this.head=new Yt(rn,0,0),this.tail=this.head,this.states=null}_push(t,r,n){return this.tail=this.tail.next=new Yt(t,r,n),this.len+=r,this}uint32(t){return this.len+=(this.tail=this.tail.next=new sn((t=t>>>0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this}int32(t){return t<0?this._push(er,10,ft.fromNumber(t)):this.uint32(t)}sint32(t){return this.uint32((t<<1^t>>31)>>>0)}uint64(t){let r=ft.fromBigInt(t);return this._push(er,r.length(),r)}uint64Number(t){return this._push(mo,we(t),t)}uint64String(t){return this.uint64(BigInt(t))}int64(t){return this.uint64(t)}int64Number(t){return this.uint64Number(t)}int64String(t){return this.uint64String(t)}sint64(t){let r=ft.fromBigInt(t).zzEncode();return this._push(er,r.length(),r)}sint64Number(t){let r=ft.fromNumber(t).zzEncode();return this._push(er,r.length(),r)}sint64String(t){return this.sint64(BigInt(t))}bool(t){return this._push(nn,1,t?1:0)}fixed32(t){return this._push(Se,4,t>>>0)}sfixed32(t){return this.fixed32(t)}fixed64(t){let r=ft.fromBigInt(t);return this._push(Se,4,r.lo)._push(Se,4,r.hi)}fixed64Number(t){let r=ft.fromNumber(t);return this._push(Se,4,r.lo)._push(Se,4,r.hi)}fixed64String(t){return this.fixed64(BigInt(t))}sfixed64(t){return this.fixed64(t)}sfixed64Number(t){return this.fixed64Number(t)}sfixed64String(t){return this.fixed64String(t)}float(t){return this._push(yo,4,t)}double(t){return this._push(bo,8,t)}bytes(t){let r=t.length>>>0;return r===0?this._push(nn,1,0):this.uint32(r)._push(vc,r,t)}string(t){let r=Bo(t);return r!==0?this.uint32(r)._push(qr,r,t):this._push(nn,1,0)}fork(){return this.states=new on(this),this.head=this.tail=new Yt(rn,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Yt(rn,0,0),this.len=0),this}ldelim(){let t=this.head,r=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=t.next,this.tail=r,this.len+=n),this}finish(){let t=this.head.next,r=Bc(this.len),n=0;for(;t!=null;)t.fn(t.val,r,n),n+=t.len,t=t.next;return r}};function nn(e,t,r){t[r]=e&255}function Sc(e,t,r){for(;e>127;)t[r++]=e&127|128,e>>>=7;t[r]=e}var sn=class extends Yt{next;constructor(t,r){super(Sc,t,r),this.next=void 0}};function er(e,t,r){for(;e.hi!==0;)t[r++]=e.lo&127|128,e.lo=(e.lo>>>7|e.hi<<25)>>>0,e.hi>>>=7;for(;e.lo>127;)t[r++]=e.lo&127|128,e.lo=e.lo>>>7;t[r++]=e.lo}function Se(e,t,r){t[r]=e&255,t[r+1]=e>>>8&255,t[r+2]=e>>>16&255,t[r+3]=e>>>24}function vc(e,t,r){t.set(e,r)}globalThis.Buffer!=null&&(ve.prototype.bytes=function(e){let t=e.length>>>0;return this.uint32(t),t>0&&this._push(Ac,t,e),this},ve.prototype.string=function(e){let t=globalThis.Buffer.byteLength(e);return this.uint32(t),t>0&&this._push(Ic,t,e),this});function Ac(e,t,r){t.set(e,r)}function Ic(e,t,r){e.length<40?qr(e,t,r):t.utf8Write!=null?t.utf8Write(e,r):t.set(Be(e),r)}function cn(){return new ve}function rr(e,t){let r=cn();return t.encode(e,r,{lengthDelimited:!1}),r.finish()}var fe;(function(e){e[e.VARINT=0]="VARINT",e[e.BIT64=1]="BIT64",e[e.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",e[e.START_GROUP=3]="START_GROUP",e[e.END_GROUP=4]="END_GROUP",e[e.BIT32=5]="BIT32"})(fe||(fe={}));function nr(e,t,r,n){return{name:e,type:t,encode:r,decode:n}}function an(e){function t(o){if(e[o.toString()]==null)throw new Error("Invalid enum value");return e[o]}let r=function(s,i){let c=t(s);i.int32(c)},n=function(s){let i=s.int32();return t(i)};return nr("enum",fe.VARINT,r,n)}function or(e,t){return nr("message",fe.LENGTH_DELIMITED,e,t)}var ut;(function(e){e.RSA="RSA",e.Ed25519="Ed25519",e.secp256k1="secp256k1"})(ut||(ut={}));var fn;(function(e){e[e.RSA=0]="RSA",e[e.Ed25519=1]="Ed25519",e[e.secp256k1=2]="secp256k1"})(fn||(fn={}));(function(e){e.codec=()=>an(fn)})(ut||(ut={}));var Ae;(function(e){let t;e.codec=()=>(t==null&&(t=or((r,n,o={})=>{o.lengthDelimited!==!1&&n.fork(),r.Type!=null&&(n.uint32(8),ut.codec().encode(r.Type,n)),r.Data!=null&&(n.uint32(18),n.bytes(r.Data)),o.lengthDelimited!==!1&&n.ldelim()},(r,n,o={})=>{let s={},i=n==null?r.len:r.pos+n;for(;r.pos<i;){let c=r.uint32();switch(c>>>3){case 1:{s.Type=ut.codec().decode(r);break}case 2:{s.Data=r.bytes();break}default:{r.skipType(c&7);break}}}return s})),t),e.encode=r=>rr(r,e.codec()),e.decode=(r,n)=>Je(r,e.codec(),n)})(Ae||(Ae={}));var un;(function(e){let t;e.codec=()=>(t==null&&(t=or((r,n,o={})=>{o.lengthDelimited!==!1&&n.fork(),r.Type!=null&&(n.uint32(8),ut.codec().encode(r.Type,n)),r.Data!=null&&(n.uint32(18),n.bytes(r.Data)),o.lengthDelimited!==!1&&n.ldelim()},(r,n,o={})=>{let s={},i=n==null?r.len:r.pos+n;for(;r.pos<i;){let c=r.uint32();switch(c>>>3){case 1:{s.Type=ut.codec().decode(r);break}case 2:{s.Data=r.bytes();break}default:{r.skipType(c&7);break}}}return s})),t),e.encode=r=>rr(r,e.codec()),e.decode=(r,n)=>Je(r,e.codec(),n)})(un||(un={}));var Rc=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Kt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Ht=new Uint32Array(64),hn=class extends ce{constructor(){super(64,32,8,!1),this.A=Kt[0]|0,this.B=Kt[1]|0,this.C=Kt[2]|0,this.D=Kt[3]|0,this.E=Kt[4]|0,this.F=Kt[5]|0,this.G=Kt[6]|0,this.H=Kt[7]|0}get(){let{A:t,B:r,C:n,D:o,E:s,F:i,G:c,H:a}=this;return[t,r,n,o,s,i,c,a]}set(t,r,n,o,s,i,c,a){this.A=t|0,this.B=r|0,this.C=n|0,this.D=o|0,this.E=s|0,this.F=i|0,this.G=c|0,this.H=a|0}process(t,r){for(let x=0;x<16;x++,r+=4)Ht[x]=t.getUint32(r,!1);for(let x=16;x<64;x++){let p=Ht[x-15],B=Ht[x-2],w=dt(p,7)^dt(p,18)^p>>>3,y=dt(B,17)^dt(B,19)^B>>>10;Ht[x]=y+Ht[x-7]+w+Ht[x-16]|0}let{A:n,B:o,C:s,D:i,E:c,F:a,G:l,H:f}=this;for(let x=0;x<64;x++){let p=dt(c,6)^dt(c,11)^dt(c,25),B=f+p+zn(c,a,l)+Rc[x]+Ht[x]|0,y=(dt(n,2)^dt(n,13)^dt(n,22))+Fn(n,o,s)|0;f=l,l=a,a=c,c=i+B|0,i=s,s=o,o=n,n=B+y|0}n=n+this.A|0,o=o+this.B|0,s=s+this.C|0,i=i+this.D|0,c=c+this.E|0,a=a+this.F|0,l=l+this.G|0,f=f+this.H|0,this.set(n,o,s,i,c,a,l,f)}roundClean(){Ht.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var Uo=He(()=>new hn);function Ie(e,t="utf8"){let r=tr[t];if(r==null)throw new Error(`Unsupported encoding "${t}"`);return r.encoder.encode(e).substring(1)}var Te=class extends Error{constructor(t="An error occurred while verifying a message"){super(t),this.name="VerificationError"}};var sr=class extends ie{constructor(t,r){super(),this.finished=!1,this.destroyed=!1,qn(t);let n=xe(r);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let o=this.blockLen,s=new Uint8Array(o);s.set(n.length>o?t.create().update(n).digest():n);for(let i=0;i<s.length;i++)s[i]^=54;this.iHash.update(s),this.oHash=t.create();for(let i=0;i<s.length;i++)s[i]^=106;this.oHash.update(s),s.fill(0)}update(t){return se(this),this.iHash.update(t),this}digestInto(t){se(this),oe(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){let t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));let{oHash:r,iHash:n,finished:o,destroyed:s,blockLen:i,outputLen:c}=this;return t=t,t.finished=o,t.destroyed=s,t.blockLen=i,t.outputLen=c,t.oHash=r._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},dn=(e,t,r)=>new sr(e,t).update(r).digest();dn.create=(e,t)=>new sr(e,t);function Co(e){e.lowS!==void 0&&lt("lowS",e.lowS),e.prehash!==void 0&&lt("prehash",e.prehash)}function Lc(e){let t=be(e);yt(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:r,Fp:n,a:o}=t;if(r){if(!n.eql(o,n.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof r!="object"||typeof r.beta!="bigint"||typeof r.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...t})}var{bytesToNumberBE:Uc,hexToBytes:Cc}=ze,ln=class extends Error{constructor(t=""){super(t)}},It={Err:ln,_tlv:{encode:(e,t)=>{let{Err:r}=It;if(e<0||e>256)throw new r("tlv.encode: wrong tag");if(t.length&1)throw new r("tlv.encode: unpadded data");let n=t.length/2,o=Vt(n);if(o.length/2&128)throw new r("tlv.encode: long form length too big");let s=n>127?Vt(o.length/2|128):"";return Vt(e)+s+o+t},decode(e,t){let{Err:r}=It,n=0;if(e<0||e>256)throw new r("tlv.encode: wrong tag");if(t.length<2||t[n++]!==e)throw new r("tlv.decode: wrong tlv");let o=t[n++],s=!!(o&128),i=0;if(!s)i=o;else{let a=o&127;if(!a)throw new r("tlv.decode(long): indefinite length not supported");if(a>4)throw new r("tlv.decode(long): byte length is too big");let l=t.subarray(n,n+a);if(l.length!==a)throw new r("tlv.decode: length bytes not complete");if(l[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(let f of l)i=i<<8|f;if(n+=a,i<128)throw new r("tlv.decode(long): not minimal encoding")}let c=t.subarray(n,n+i);if(c.length!==i)throw new r("tlv.decode: wrong value length");return{v:c,l:t.subarray(n+i)}}},_int:{encode(e){let{Err:t}=It;if(e<Tt)throw new t("integer: negative integers are not allowed");let r=Vt(e);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return r},decode(e){let{Err:t}=It;if(e[0]&128)throw new t("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return Uc(e)}},toSig(e){let{Err:t,_int:r,_tlv:n}=It,o=typeof e=="string"?Cc(e):e;ae(o);let{v:s,l:i}=n.decode(48,o);if(i.length)throw new t("invalid signature: left bytes after parsing");let{v:c,l:a}=n.decode(2,s),{v:l,l:f}=n.decode(2,a);if(f.length)throw new t("invalid signature: left bytes after parsing");return{r:r.decode(c),s:r.decode(l)}},hexFromSig(e){let{_tlv:t,_int:r}=It,n=t.encode(2,r.encode(e.r)),o=t.encode(2,r.encode(e.s)),s=n+o;return t.encode(48,s)}},Tt=BigInt(0),J=BigInt(1),Iu=BigInt(2),No=BigInt(3),Tu=BigInt(4);function Nc(e){let t=Lc(e),{Fp:r}=t,n=Dt(t.n,t.nBitLength),o=t.toBytes||((y,u,b)=>{let S=u.toAffine();return vt(Uint8Array.from([4]),r.toBytes(S.x),r.toBytes(S.y))}),s=t.fromBytes||(y=>{let u=y.subarray(1),b=r.fromBytes(u.subarray(0,r.BYTES)),S=r.fromBytes(u.subarray(r.BYTES,2*r.BYTES));return{x:b,y:S}});function i(y){let{a:u,b}=t,S=r.sqr(y),d=r.mul(S,y);return r.add(r.add(d,r.mul(y,u)),b)}if(!r.eql(r.sqr(t.Gy),i(t.Gx)))throw new Error("bad generator point: equation left != right");function c(y){return ye(y,J,t.n)}function a(y){let{allowedPrivateKeyLengths:u,nByteLength:b,wrapPrivateKey:S,n:d}=t;if(u&&typeof y!="bigint"){if(Ct(y)&&(y=Bt(y)),typeof y!="string"||!u.includes(y.length))throw new Error("invalid private key");y=y.padStart(b*2,"0")}let A;try{A=typeof y=="bigint"?y:St(G("private key",y,b))}catch{throw new Error("invalid private key, expected hex or "+b+" bytes, got "+typeof y)}return S&&(A=k(A,d)),ct("private key",A,J,d),A}function l(y){if(!(y instanceof p))throw new Error("ProjectivePoint expected")}let f=Zt((y,u)=>{let{px:b,py:S,pz:d}=y;if(r.eql(d,r.ONE))return{x:b,y:S};let A=y.is0();u==null&&(u=A?r.ONE:r.inv(d));let C=r.mul(b,u),U=r.mul(S,u),I=r.mul(d,u);if(A)return{x:r.ZERO,y:r.ZERO};if(!r.eql(I,r.ONE))throw new Error("invZ was invalid");return{x:C,y:U}}),x=Zt(y=>{if(y.is0()){if(t.allowInfinityPoint&&!r.is0(y.py))return;throw new Error("bad point: ZERO")}let{x:u,y:b}=y.toAffine();if(!r.isValid(u)||!r.isValid(b))throw new Error("bad point: x or y not FE");let S=r.sqr(b),d=i(u);if(!r.eql(S,d))throw new Error("bad point: equation left != right");if(!y.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class p{constructor(u,b,S){if(this.px=u,this.py=b,this.pz=S,u==null||!r.isValid(u))throw new Error("x required");if(b==null||!r.isValid(b))throw new Error("y required");if(S==null||!r.isValid(S))throw new Error("z required");Object.freeze(this)}static fromAffine(u){let{x:b,y:S}=u||{};if(!u||!r.isValid(b)||!r.isValid(S))throw new Error("invalid affine point");if(u instanceof p)throw new Error("projective point not allowed");let d=A=>r.eql(A,r.ZERO);return d(b)&&d(S)?p.ZERO:new p(b,S,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){let b=r.invertBatch(u.map(S=>S.pz));return u.map((S,d)=>S.toAffine(b[d])).map(p.fromAffine)}static fromHex(u){let b=p.fromAffine(s(G("pointHex",u)));return b.assertValidity(),b}static fromPrivateKey(u){return p.BASE.multiply(a(u))}static msm(u,b){return je(p,n,u,b)}_setWindowSize(u){w.setWindowSize(this,u)}assertValidity(){x(this)}hasEvenY(){let{y:u}=this.toAffine();if(r.isOdd)return!r.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){l(u);let{px:b,py:S,pz:d}=this,{px:A,py:C,pz:U}=u,I=r.eql(r.mul(b,U),r.mul(A,d)),L=r.eql(r.mul(S,U),r.mul(C,d));return I&&L}negate(){return new p(this.px,r.neg(this.py),this.pz)}double(){let{a:u,b}=t,S=r.mul(b,No),{px:d,py:A,pz:C}=this,U=r.ZERO,I=r.ZERO,L=r.ZERO,T=r.mul(d,d),z=r.mul(A,A),M=r.mul(C,C),K=r.mul(d,A);return K=r.add(K,K),L=r.mul(d,C),L=r.add(L,L),U=r.mul(u,L),I=r.mul(S,M),I=r.add(U,I),U=r.sub(z,I),I=r.add(z,I),I=r.mul(U,I),U=r.mul(K,U),L=r.mul(S,L),M=r.mul(u,M),K=r.sub(T,M),K=r.mul(u,K),K=r.add(K,L),L=r.add(T,T),T=r.add(L,T),T=r.add(T,M),T=r.mul(T,K),I=r.add(I,T),M=r.mul(A,C),M=r.add(M,M),T=r.mul(M,K),U=r.sub(U,T),L=r.mul(M,z),L=r.add(L,L),L=r.add(L,L),new p(U,I,L)}add(u){l(u);let{px:b,py:S,pz:d}=this,{px:A,py:C,pz:U}=u,I=r.ZERO,L=r.ZERO,T=r.ZERO,z=t.a,M=r.mul(t.b,No),K=r.mul(b,A),Y=r.mul(S,C),E=r.mul(d,U),R=r.add(b,S),m=r.add(A,C);R=r.mul(R,m),m=r.add(K,Y),R=r.sub(R,m),m=r.add(b,d);let h=r.add(A,U);return m=r.mul(m,h),h=r.add(K,E),m=r.sub(m,h),h=r.add(S,d),I=r.add(C,U),h=r.mul(h,I),I=r.add(Y,E),h=r.sub(h,I),T=r.mul(z,m),I=r.mul(M,E),T=r.add(I,T),I=r.sub(Y,T),T=r.add(Y,T),L=r.mul(I,T),Y=r.add(K,K),Y=r.add(Y,K),E=r.mul(z,E),m=r.mul(M,m),Y=r.add(Y,E),E=r.sub(K,E),E=r.mul(z,E),m=r.add(m,E),K=r.mul(Y,m),L=r.add(L,K),K=r.mul(h,m),I=r.mul(R,I),I=r.sub(I,K),K=r.mul(R,Y),T=r.mul(h,T),T=r.add(T,K),new p(I,L,T)}subtract(u){return this.add(u.negate())}is0(){return this.equals(p.ZERO)}wNAF(u){return w.wNAFCached(this,u,p.normalizeZ)}multiplyUnsafe(u){let{endo:b,n:S}=t;ct("scalar",u,Tt,S);let d=p.ZERO;if(u===Tt)return d;if(this.is0()||u===J)return this;if(!b||w.hasPrecomputes(this))return w.wNAFCachedUnsafe(this,u,p.normalizeZ);let{k1neg:A,k1:C,k2neg:U,k2:I}=b.splitScalar(u),L=d,T=d,z=this;for(;C>Tt||I>Tt;)C&J&&(L=L.add(z)),I&J&&(T=T.add(z)),z=z.double(),C>>=J,I>>=J;return A&&(L=L.negate()),U&&(T=T.negate()),T=new p(r.mul(T.px,b.beta),T.py,T.pz),L.add(T)}multiply(u){let{endo:b,n:S}=t;ct("scalar",u,J,S);let d,A;if(b){let{k1neg:C,k1:U,k2neg:I,k2:L}=b.splitScalar(u),{p:T,f:z}=this.wNAF(U),{p:M,f:K}=this.wNAF(L);T=w.constTimeNegate(C,T),M=w.constTimeNegate(I,M),M=new p(r.mul(M.px,b.beta),M.py,M.pz),d=T.add(M),A=z.add(K)}else{let{p:C,f:U}=this.wNAF(u);d=C,A=U}return p.normalizeZ([d,A])[0]}multiplyAndAddUnsafe(u,b,S){let d=p.BASE,A=(U,I)=>I===Tt||I===J||!U.equals(d)?U.multiplyUnsafe(I):U.multiply(I),C=A(this,b).add(A(u,S));return C.is0()?void 0:C}toAffine(u){return f(this,u)}isTorsionFree(){let{h:u,isTorsionFree:b}=t;if(u===J)return!0;if(b)return b(p,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:u,clearCofactor:b}=t;return u===J?this:b?b(p,this):this.multiplyUnsafe(t.h)}toRawBytes(u=!0){return lt("isCompressed",u),this.assertValidity(),o(p,this,u)}toHex(u=!0){return lt("isCompressed",u),Bt(this.toRawBytes(u))}}p.BASE=new p(t.Gx,t.Gy,r.ONE),p.ZERO=new p(r.ZERO,r.ONE,r.ZERO);let B=t.nBitLength,w=Ge(p,t.endo?Math.ceil(B/2):B);return{CURVE:t,ProjectivePoint:p,normPrivateKeyToScalar:a,weierstrassEquation:i,isWithinCurveOrder:c}}function _c(e){let t=be(e);return yt(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function _o(e){let t=_c(e),{Fp:r,n}=t,o=r.BYTES+1,s=2*r.BYTES+1;function i(E){return k(E,n)}function c(E){return Fe(E,n)}let{ProjectivePoint:a,normPrivateKeyToScalar:l,weierstrassEquation:f,isWithinCurveOrder:x}=Nc({...t,toBytes(E,R,m){let h=R.toAffine(),g=r.toBytes(h.x),v=vt;return lt("isCompressed",m),m?v(Uint8Array.from([R.hasEvenY()?2:3]),g):v(Uint8Array.from([4]),g,r.toBytes(h.y))},fromBytes(E){let R=E.length,m=E[0],h=E.subarray(1);if(R===o&&(m===2||m===3)){let g=St(h);if(!ye(g,J,r.ORDER))throw new Error("Point is not on curve");let v=f(g),N;try{N=r.sqrt(v)}catch(H){let D=H instanceof Error?": "+H.message:"";throw new Error("Point is not on curve"+D)}let _=(N&J)===J;return(m&1)===1!==_&&(N=r.neg(N)),{x:g,y:N}}else if(R===s&&m===4){let g=r.fromBytes(h.subarray(0,r.BYTES)),v=r.fromBytes(h.subarray(r.BYTES,2*r.BYTES));return{x:g,y:v}}else{let g=o,v=s;throw new Error("invalid Point, expected length of "+g+", or uncompressed "+v+", got "+R)}}}),p=E=>Bt(_t(E,t.nByteLength));function B(E){let R=n>>J;return E>R}function w(E){return B(E)?i(-E):E}let y=(E,R,m)=>St(E.slice(R,m));class u{constructor(R,m,h){this.r=R,this.s=m,this.recovery=h,this.assertValidity()}static fromCompact(R){let m=t.nByteLength;return R=G("compactSignature",R,m*2),new u(y(R,0,m),y(R,m,2*m))}static fromDER(R){let{r:m,s:h}=It.toSig(G("DER",R));return new u(m,h)}assertValidity(){ct("r",this.r,J,n),ct("s",this.s,J,n)}addRecoveryBit(R){return new u(this.r,this.s,R)}recoverPublicKey(R){let{r:m,s:h,recovery:g}=this,v=U(G("msgHash",R));if(g==null||![0,1,2,3].includes(g))throw new Error("recovery id invalid");let N=g===2||g===3?m+t.n:m;if(N>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");let _=g&1?"03":"02",P=a.fromHex(_+p(N)),H=c(N),D=i(-v*H),q=i(h*H),V=a.BASE.multiplyAndAddUnsafe(P,D,q);if(!V)throw new Error("point at infinify");return V.assertValidity(),V}hasHighS(){return B(this.s)}normalizeS(){return this.hasHighS()?new u(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return zt(this.toDERHex())}toDERHex(){return It.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return zt(this.toCompactHex())}toCompactHex(){return p(this.r)+p(this.s)}}let b={isValidPrivateKey(E){try{return l(E),!0}catch{return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{let E=Cr(t.n);return Jn(t.randomBytes(E),t.n)},precompute(E=8,R=a.BASE){return R._setWindowSize(E),R.multiply(BigInt(3)),R}};function S(E,R=!0){return a.fromPrivateKey(E).toRawBytes(R)}function d(E){let R=Ct(E),m=typeof E=="string",h=(R||m)&&E.length;return R?h===o||h===s:m?h===2*o||h===2*s:E instanceof a}function A(E,R,m=!0){if(d(E))throw new Error("first arg must be private key");if(!d(R))throw new Error("second arg must be public key");return a.fromHex(R).multiply(l(E)).toRawBytes(m)}let C=t.bits2int||function(E){if(E.length>8192)throw new Error("input is too large");let R=St(E),m=E.length*8-t.nBitLength;return m>0?R>>BigInt(m):R},U=t.bits2int_modN||function(E){return i(C(E))},I=ge(t.nBitLength);function L(E){return ct("num < 2^"+t.nBitLength,E,Tt,I),_t(E,t.nByteLength)}function T(E,R,m=z){if(["recovered","canonical"].some($=>$ in m))throw new Error("sign() legacy options not supported");let{hash:h,randomBytes:g}=t,{lowS:v,prehash:N,extraEntropy:_}=m;v==null&&(v=!0),E=G("msgHash",E),Co(m),N&&(E=G("prehashed msgHash",h(E)));let P=U(E),H=l(R),D=[L(H),L(P)];if(_!=null&&_!==!1){let $=_===!0?g(r.BYTES):_;D.push(G("extraEntropy",$))}let q=vt(...D),V=P;function X($){let tt=C($);if(!x(tt))return;let et=c(tt),st=a.BASE.multiply(tt).toAffine(),nt=i(st.x);if(nt===Tt)return;let xt=i(et*i(V+nt*H));if(xt===Tt)return;let gt=(st.x===nt?0:2)|Number(st.y&J),ue=xt;return v&&B(xt)&&(ue=w(xt),gt^=1),new u(nt,ue,gt)}return{seed:q,k2sig:X}}let z={lowS:t.lowS,prehash:!1},M={lowS:t.lowS,prehash:!1};function K(E,R,m=z){let{seed:h,k2sig:g}=T(E,R,m),v=t;return Tr(v.hash.outputLen,v.nByteLength,v.hmac)(h,g)}a.BASE._setWindowSize(8);function Y(E,R,m,h=M){let g=E;R=G("msgHash",R),m=G("publicKey",m);let{lowS:v,prehash:N,format:_}=h;if(Co(h),"strict"in h)throw new Error("options.strict was renamed to lowS");if(_!==void 0&&_!=="compact"&&_!=="der")throw new Error("format must be compact or der");let P=typeof g=="string"||Ct(g),H=!P&&!_&&typeof g=="object"&&g!==null&&typeof g.r=="bigint"&&typeof g.s=="bigint";if(!P&&!H)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let D,q;try{if(H&&(D=new u(g.r,g.s)),P){try{_!=="compact"&&(D=u.fromDER(g))}catch(gt){if(!(gt instanceof It.Err))throw gt}!D&&_!=="der"&&(D=u.fromCompact(g))}q=a.fromHex(m)}catch{return!1}if(!D||v&&D.hasHighS())return!1;N&&(R=t.hash(R));let{r:V,s:X}=D,$=U(R),tt=c(X),et=i($*tt),st=i(V*tt),nt=a.BASE.multiplyAndAddUnsafe(q,et,st)?.toAffine();return nt?i(nt.x)===V:!1}return{CURVE:t,getPublicKey:S,getSharedSecret:A,sign:K,verify:Y,ProjectivePoint:a,Signature:u,utils:b}}function Dc(e){return{hash:e,hmac:(t,...r)=>dn(e,t,wr(...r)),randomBytes:Me}}function Do(e,t){let r=n=>_o({...e,...Dc(n)});return{...r(t),create:r}}var Ko=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Oo=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Oc=BigInt(1),pn=BigInt(2),Po=(e,t)=>(e+t/pn)/t;function Pc(e){let t=Ko,r=BigInt(3),n=BigInt(6),o=BigInt(11),s=BigInt(22),i=BigInt(23),c=BigInt(44),a=BigInt(88),l=e*e*e%t,f=l*l*e%t,x=Z(f,r,t)*f%t,p=Z(x,r,t)*f%t,B=Z(p,pn,t)*l%t,w=Z(B,o,t)*B%t,y=Z(w,s,t)*w%t,u=Z(y,c,t)*y%t,b=Z(u,a,t)*u%t,S=Z(b,c,t)*y%t,d=Z(S,r,t)*f%t,A=Z(d,i,t)*w%t,C=Z(A,n,t)*l%t,U=Z(C,pn,t);if(!mn.eql(mn.sqr(U),e))throw new Error("Cannot find square root");return U}var mn=Dt(Ko,void 0,void 0,{sqrt:Pc}),Wt=Do({a:BigInt(0),b:BigInt(7),Fp:mn,n:Oo,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{let t=Oo,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Oc*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=r,i=BigInt("0x100000000000000000000000000000000"),c=Po(s*e,t),a=Po(-n*e,t),l=k(e-c*r-a*o,t),f=k(-c*n-a*s,t),x=l>i,p=f>i;if(x&&(l=t-l),p&&(f=t-f),l>i||f>i)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:x,k1:l,k2neg:p,k2:f}}}},Uo),Pu=BigInt(0);var Ku=Wt.ProjectivePoint;function Ho(e){return e==null?!1:typeof e.then=="function"&&typeof e.catch=="function"&&typeof e.finally=="function"}function Mo(e,t,r){let n=Ee.digest(r instanceof Uint8Array?r:r.subarray());if(Ho(n))return n.then(({digest:o})=>Wt.verify(t,o,e)).catch(o=>{throw new Te(String(o))});try{return Wt.verify(t,n.digest,e)}catch(o){throw new Te(String(o))}}var ir=class{type="secp256k1";raw;_key;constructor(t){this._key=ko(t),this.raw=qo(this._key)}toMultihash(){return wt.digest($e(this))}toCID(){return ht.createV1(114,this.toMultihash())}toString(){return Q.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:qt(this.raw,t.raw)}verify(t,r){return Mo(this._key,r,t)}};function Vo(e){return new ir(e)}function qo(e){return Wt.ProjectivePoint.fromHex(e).toRawBytes(!0)}function ko(e){try{return Wt.ProjectivePoint.fromHex(e),e}catch(t){throw new _e(String(t))}}function zo(e){let{Type:t,Data:r}=Ae.decode(e.digest),n=r??new Uint8Array;switch(t){case ut.Ed25519:return fo(n);case ut.secp256k1:return Vo(n);default:throw new $t}}function $e(e){return Ae.encode({Type:ut[e.type],Data:e.raw})}var Fo=Symbol.for("nodejs.util.inspect.custom"),Kc=114,Re=class{type;multihash;publicKey;string;constructor(t){this.type=t.type,this.multihash=t.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}[fr]=!0;toString(){return this.string==null&&(this.string=Q.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return ht.createV1(Kc,this.multihash)}toJSON(){return this.toString()}equals(t){if(t==null)return!1;if(t instanceof Uint8Array)return qt(this.multihash.bytes,t);if(typeof t=="string")return this.toString()===t;if(t?.toMultihash()?.bytes!=null)return qt(this.multihash.bytes,t.toMultihash().bytes);throw new Error("not valid Id")}[Fo](){return`PeerId(${this.toString()})`}},Le=class extends Re{type="RSA";publicKey;constructor(t){super({...t,type:"RSA"}),this.publicKey=t.publicKey}},Ue=class extends Re{type="Ed25519";publicKey;constructor(t){super({...t,type:"Ed25519"}),this.publicKey=t.publicKey}},Ce=class extends Re{type="secp256k1";publicKey;constructor(t){super({...t,type:"secp256k1"}),this.publicKey=t.publicKey}},Hc=2336,Ne=class{type="url";multihash;publicKey;url;constructor(t){this.url=t.toString(),this.multihash=wt.digest(Be(this.url))}[Fo](){return`PeerId(${this.url})`}[fr]=!0;toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return ht.createV1(Hc,this.toMultihash())}toJSON(){return this.toString()}equals(t){return t==null?!1:(t instanceof Uint8Array&&(t=Ie(t)),t.toString()===this.toString())}};var Mc=114,Zo=2336;function qc(e,t){let r;if(e.charAt(0)==="1"||e.charAt(0)==="Q")r=pe(Q.decode(`z${e}`));else{if(t==null)throw new Xt('Please pass a multibase decoder for strings that do not start with "1" or "Q"');r=pe(t.decode(e))}return xn(r)}function Go(e){if(e.type==="Ed25519")return new Ue({multihash:e.toCID().multihash,publicKey:e});if(e.type==="secp256k1")return new Ce({multihash:e.toCID().multihash,publicKey:e});if(e.type==="RSA")return new Le({multihash:e.toCID().multihash,publicKey:e});throw new $t}function kc(e){return Go(e.publicKey)}function xn(e){if(Fc(e))return new Le({multihash:e});if(zc(e))try{let t=zo(e);if(t.type==="Ed25519")return new Ue({multihash:e,publicKey:t});if(t.type==="secp256k1")return new Ce({multihash:e,publicKey:t})}catch{let r=Ie(e.digest);return new Ne(new URL(r))}throw new Oe("Supplied PeerID Multihash is invalid")}function Vc(e){if(e?.multihash==null||e.version==null||e.version===1&&e.code!==Mc&&e.code!==Zo)throw new De("Supplied PeerID CID is invalid");if(e.code===Zo){let t=Ie(e.multihash.digest);return new Ne(new URL(t))}return xn(e.multihash)}function zc(e){return e.code===wt.code}function Fc(e){return e.code===Ee.code}return ss(Zc);})();
./node_modules/@libp2p/ping/dist/index.min.js:2:"use strict";var Libp2PPing=(()=>{var S=Object.defineProperty;var W=Object.getOwnPropertyDescriptor;var $=Object.getOwnPropertyNames;var H=Object.prototype.hasOwnProperty;var K=(o,t)=>{for(var e in t)S(o,e,{get:t[e],enumerable:!0})},z=(o,t,e,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of $(t))!H.call(o,n)&&n!==e&&S(o,n,{get:()=>t[n],enumerable:!(r=W(t,n))||r.enumerable});return o};var J=o=>z(S({},"__esModule",{value:!0}),o);var et={};K(et,{PING_PROTOCOL:()=>j,ping:()=>tt});var g=class extends Error{static name="InvalidParametersError";constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}};var y=class extends Error{static name="ProtocolError";constructor(t="Protocol error"){super(t),this.name="ProtocolError"}},x=class extends Error{static name="TimeoutError";constructor(t="Timed out"){super(t),this.name="TimeoutError"}};var I=(o,...t)=>{try{[...t]}catch{}};function E(o,t){if(o===t)return!0;if(o.byteLength!==t.byteLength)return!1;for(let e=0;e<o.byteLength;e++)if(o[e]!==t[e])return!1;return!0}var m=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function M(o=32){if(m&&typeof m.getRandomValues=="function")return m.getRandomValues(new Uint8Array(o));if(m&&typeof m.randomBytes=="function")return m.randomBytes(o);throw new Error("crypto.getRandomValues must be defined")}function p(o=0){return new Uint8Array(o)}function b(o=0){return new Uint8Array(o)}function L(o){if(isNaN(o)||o<=0)throw new g("random bytes length must be a Number bigger than 0");return M(o)}function T(o,t){t==null&&(t=o.reduce((n,a)=>n+a.length,0));let e=b(t),r=0;for(let n of o)e.set(n,r),r+=n.length;return e}function d(){let o={};return o.promise=new Promise((t,e)=>{o.resolve=t,o.reject=e}),o}var O=class extends Error{type;code;constructor(t,e,r){super(t??"The operation was aborted"),this.type="aborted",this.name=r??"AbortError",this.code=e??"ABORT_ERR"}};async function _(o,t,e){if(t==null)return o;if(t.aborted)return Promise.reject(new O(e?.errorMessage,e?.errorCode,e?.errorName));let r,n=new O(e?.errorMessage,e?.errorCode,e?.errorName);try{return await Promise.race([o,new Promise((a,s)=>{r=()=>{s(n)},t.addEventListener("abort",r)})])}finally{r!=null&&t.removeEventListener("abort",r)}}var P=class{readNext;haveNext;ended;nextResult;constructor(){this.ended=!1,this.readNext=d(),this.haveNext=d()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");let t=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=d(),t}async throw(t){return this.ended=!0,t!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(t)),{done:!0,value:void 0}}async return(){let t={done:!0,value:void 0};return await this._push(void 0),t}async push(t,e){await this._push(t,e)}async end(t,e){t!=null?await this.throw(t):await this._push(void 0,e)}async _push(t,e){if(t!=null&&this.ended)throw new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;t!=null?this.nextResult={done:!1,value:t}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=d(),await _(this.readNext.promise,e?.signal,e)}};function V(){return new P}var F=Symbol.for("@achingbrain/uint8arraylist");function k(o,t){if(t==null||t<0)throw new RangeError("index is out of bounds");let e=0;for(let r of o){let n=e+r.byteLength;if(t<n)return{buf:r,index:t-e};e=n}throw new RangeError("index is out of bounds")}function U(o){return!!o?.[F]}var w=class o{bufs;length;[F]=!0;constructor(...t){this.bufs=[],this.length=0,t.length>0&&this.appendAll(t)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...t){this.appendAll(t)}appendAll(t){let e=0;for(let r of t)if(r instanceof Uint8Array)e+=r.byteLength,this.bufs.push(r);else if(U(r))e+=r.byteLength,this.bufs.push(...r.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}prepend(...t){this.prependAll(t)}prependAll(t){let e=0;for(let r of t.reverse())if(r instanceof Uint8Array)e+=r.byteLength,this.bufs.unshift(r);else if(U(r))e+=r.byteLength,this.bufs.unshift(...r.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}get(t){let e=k(this.bufs,t);return e.buf[e.index]}set(t,e){let r=k(this.bufs,t);r.buf[r.index]=e}write(t,e=0){if(t instanceof Uint8Array)for(let r=0;r<t.length;r++)this.set(e+r,t[r]);else if(U(t))for(let r=0;r<t.length;r++)this.set(e+r,t.get(r));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(t){if(t=Math.trunc(t),!(Number.isNaN(t)||t<=0)){if(t===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(t>=this.bufs[0].byteLength)t-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(t),this.length-=t;break}}}slice(t,e){let{bufs:r,length:n}=this._subList(t,e);return T(r,n)}subarray(t,e){let{bufs:r,length:n}=this._subList(t,e);return r.length===1?r[0]:T(r,n)}sublist(t,e){let{bufs:r,length:n}=this._subList(t,e),a=new o;return a.length=n,a.bufs=[...r],a}_subList(t,e){if(t=t??0,e=e??this.length,t<0&&(t=this.length+t),e<0&&(e=this.length+e),t<0||e>this.length)throw new RangeError("index is out of bounds");if(t===e)return{bufs:[],length:0};if(t===0&&e===this.length)return{bufs:this.bufs,length:this.length};let r=[],n=0;for(let a=0;a<this.bufs.length;a++){let s=this.bufs[a],i=n,c=i+s.byteLength;if(n=c,t>=c)continue;let f=t>=i&&t<c,l=e>i&&e<=c;if(f&&l){if(t===i&&e===c){r.push(s);break}let u=t-i;r.push(s.subarray(u,u+(e-t)));break}if(f){if(t===0){r.push(s);continue}r.push(s.subarray(t-i));continue}if(l){if(e===c){r.push(s);break}r.push(s.subarray(0,e-i));break}r.push(s)}return{bufs:r,length:e-t}}indexOf(t,e=0){if(!U(t)&&!(t instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');let r=t instanceof Uint8Array?t:t.subarray();if(e=Number(e??0),isNaN(e)&&(e=0),e<0&&(e=this.length+e),e<0&&(e=0),t.length===0)return e>this.length?this.length:e;let n=r.byteLength;if(n===0)throw new TypeError("search must be at least 1 byte long");let a=256,s=new Int32Array(a);for(let u=0;u<a;u++)s[u]=-1;for(let u=0;u<n;u++)s[r[u]]=u;let i=s,c=this.byteLength-r.byteLength,f=r.byteLength-1,l;for(let u=e;u<=c;u+=l){l=0;for(let h=f;h>=0;h--){let C=this.get(u+h);if(r[h]!==C){l=Math.max(1,h-i[C]);break}}if(l===0)return u}return-1}getInt8(t){let e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getInt8(0)}setInt8(t,e){let r=b(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setInt8(0,e),this.write(r,t)}getInt16(t,e){let r=this.subarray(t,t+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt16(0,e)}setInt16(t,e,r){let n=p(2);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt16(0,e,r),this.write(n,t)}getInt32(t,e){let r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt32(0,e)}setInt32(t,e,r){let n=p(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt32(0,e,r),this.write(n,t)}getBigInt64(t,e){let r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigInt64(0,e)}setBigInt64(t,e,r){let n=p(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setBigInt64(0,e,r),this.write(n,t)}getUint8(t){let e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getUint8(0)}setUint8(t,e){let r=b(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setUint8(0,e),this.write(r,t)}getUint16(t,e){let r=this.subarray(t,t+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint16(0,e)}setUint16(t,e,r){let n=p(2);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint16(0,e,r),this.write(n,t)}getUint32(t,e){let r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint32(0,e)}setUint32(t,e,r){let n=p(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint32(0,e,r),this.write(n,t)}getBigUint64(t,e){let r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigUint64(0,e)}setBigUint64(t,e,r){let n=p(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setBigUint64(0,e,r),this.write(n,t)}getFloat32(t,e){let r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat32(0,e)}setFloat32(t,e,r){let n=p(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setFloat32(0,e,r),this.write(n,t)}getFloat64(t,e){let r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat64(0,e)}setFloat64(t,e,r){let n=p(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setFloat64(0,e,r),this.write(n,t)}equals(t){if(t==null||!(t instanceof o)||t.bufs.length!==this.bufs.length)return!1;for(let e=0;e<this.bufs.length;e++)if(!E(this.bufs[e],t.bufs[e]))return!1;return!0}static fromUint8Arrays(t,e){let r=new o;return r.bufs=t,e==null&&(e=t.reduce((n,a)=>n+a.byteLength,0)),r.length=e,r}};var v=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};var N=class extends Error{code;constructor(t,e){super(t),this.code=e}},R=class extends N{type;constructor(t){super(t,"ABORT_ERR"),this.type="aborted",this.name="AbortError"}};function D(o,t){let e=V();o.sink(e).catch(async s=>{await e.end(s)}),o.sink=async s=>{for await(let i of s)await e.push(i);await e.end()};let r=o.source;o.source[Symbol.iterator]!=null?r=o.source[Symbol.iterator]():o.source[Symbol.asyncIterator]!=null&&(r=o.source[Symbol.asyncIterator]());let n=new w;return{read:async(s,i)=>{i?.signal?.throwIfAborted();let c,f=new Promise((l,u)=>{c=()=>{u(new R("Read aborted"))},i?.signal?.addEventListener("abort",c)});try{if(s==null){let{done:u,value:h}=await Promise.race([r.next(),f]);return u===!0?new w:h}for(;n.byteLength<s;){let{value:u,done:h}=await Promise.race([r.next(),f]);if(h===!0)throw new v("unexpected end of input");n.append(u)}let l=n.sublist(0,s);return n.consume(s),l}finally{c!=null&&i?.signal?.removeEventListener("abort",c)}},write:async(s,i)=>{i?.signal?.throwIfAborted(),s instanceof Uint8Array?await e.push(s,i):await e.push(s.subarray(),i)},unwrap:()=>{if(n.byteLength>0){let s=o.source;o.source=async function*(){t?.yieldBytes===!1?yield n:yield*n,yield*s}()}return o}}}var j="/ipfs/ping/1.0.0";var X="1.0.0",q="ping",G="ipfs";var A=class{protocol;components;started;timeout;maxInboundStreams;maxOutboundStreams;runOnLimitedConnection;log;constructor(t,e={}){this.components=t,this.log=t.logger.forComponent("libp2p:ping"),this.started=!1,this.protocol=`/${e.protocolPrefix??G}/${q}/${X}`,this.timeout=e.timeout??1e4,this.maxInboundStreams=e.maxInboundStreams??2,this.maxOutboundStreams=e.maxOutboundStreams??1,this.runOnLimitedConnection=e.runOnLimitedConnection??!0,this.handleMessage=this.handleMessage.bind(this)}[Symbol.toStringTag]="@libp2p/ping";async start(){await this.components.registrar.handle(this.protocol,this.handleMessage,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}isStarted(){return this.started}handleMessage(t){this.log("incoming ping from %p",t.connection.remotePeer);let{stream:e}=t,r=Date.now(),n=D(e),a=!1;Promise.resolve().then(async()=>{for(;;){let s=AbortSignal.timeout(this.timeout);I(1/0,s),s.addEventListener("abort",()=>{e?.abort(new x("ping timeout"))});let i=await n.read(32,{signal:s});await n.write(i,{signal:s}),a=!0}}).catch(s=>{a&&s.name==="UnexpectedEOFError"&&e.readStatus!=="ready"||(this.log.error("incoming ping from %p failed with error - %e",t.connection.remotePeer,s),e?.abort(s))}).finally(()=>{let s=Date.now()-r;this.log("incoming ping from %p complete in %dms",t.connection.remotePeer,s);let i=AbortSignal.timeout(this.timeout);I(1/0,i),e.close({signal:i}).catch(c=>{this.log.error("error closing ping stream from %p - %e",t.connection.remotePeer,c),e?.abort(c)})})}async ping(t,e={}){this.log("pinging %p",t);let r=Date.now(),n=L(32),a=await this.components.connectionManager.openConnection(t,e),s;if(e.signal==null){let i=AbortSignal.timeout(this.timeout);e={...e,signal:i}}try{s=await a.newStream(this.protocol,{...e,runOnLimitedConnection:this.runOnLimitedConnection});let i=D(s),[,c]=await Promise.all([i.write(n,e),i.read(32,e)]),f=Date.now()-r;if(!E(n,c.subarray()))throw new y(`Received wrong ping ack after ${f}ms`);return this.log("ping %p complete in %dms",a.remotePeer,f),f}catch(i){throw this.log.error("error while pinging %p",a.remotePeer,i),s?.abort(i),i}finally{s!=null&&await s.close(e)}}};function tt(o={}){return t=>new A(t,o)}return J(et);})();
./node_modules/@libp2p/bootstrap/dist/index.min.js:2:"use strict";var Libp2PBootstrap=(()=>{var Ur=Object.defineProperty;var gi=Object.getOwnPropertyDescriptor;var bi=Object.getOwnPropertyNames;var yi=Object.prototype.hasOwnProperty;var ht=(r,t)=>{for(var e in t)Ur(r,e,{get:t[e],enumerable:!0})},wi=(r,t,e,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of bi(t))!yi.call(r,o)&&o!==e&&Ur(r,o,{get:()=>t[o],enumerable:!(n=gi(t,o))||n.enumerable});return r};var Ei=r=>wi(Ur({},"__esModule",{value:!0}),r);var Ou={};ht(Ou,{bootstrap:()=>Du});var yo=Symbol.for("@libp2p/peer-discovery");var Nr=Symbol.for("@libp2p/peer-id");var he=class extends Error{static name="InvalidParametersError";constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}},Ge=class extends Error{static name="InvalidPublicKeyError";constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}};var Ze=class extends Error{static name="InvalidMultihashError";constructor(t="Invalid Multihash"){super(t),this.name="InvalidMultihashError"}};var Ce=class extends Error{static name="UnsupportedKeyTypeError";constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}};var wo=(r,...t)=>{try{[...t]}catch{}};var je=class extends EventTarget{#t=new Map;constructor(){super(),wo(1/0,this)}listenerCount(t){let e=this.#t.get(t);return e==null?0:e.length}addEventListener(t,e,n){super.addEventListener(t,e,n);let o=this.#t.get(t);o==null&&(o=[],this.#t.set(t,o)),o.push({callback:e,once:(n!==!0&&n!==!1&&n?.once)??!1})}removeEventListener(t,e,n){super.removeEventListener(t.toString(),e??null,n);let o=this.#t.get(t);o!=null&&(o=o.filter(({callback:s})=>s!==e),this.#t.set(t,o))}dispatchEvent(t){let e=super.dispatchEvent(t),n=this.#t.get(t.type);return n==null||(n=n.filter(({once:o})=>!o),this.#t.set(t.type,n)),e}safeDispatchEvent(t,e={}){return this.dispatchEvent(new CustomEvent(t,e))}};var Eo=Symbol.for("@libp2p/service-capabilities"),Fu=Symbol.for("@libp2p/service-dependencies");var Mr={};ht(Mr,{base58btc:()=>Q,base58flickr:()=>Ti});var mf=new Uint8Array(0);function vo(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function Lt(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function So(r){return new TextEncoder().encode(r)}function Bo(r){return new TextDecoder().decode(r)}function vi(r,t){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),n=0;n<e.length;n++)e[n]=255;for(var o=0;o<r.length;o++){var s=r.charAt(o),i=s.charCodeAt(0);if(e[i]!==255)throw new TypeError(s+" is ambiguous");e[i]=o}var c=r.length,a=r.charAt(0),d=Math.log(c)/Math.log(256),u=Math.log(256)/Math.log(c);function m(y){if(y instanceof Uint8Array||(ArrayBuffer.isView(y)?y=new Uint8Array(y.buffer,y.byteOffset,y.byteLength):Array.isArray(y)&&(y=Uint8Array.from(y))),!(y instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(y.length===0)return"";for(var g=0,f=0,w=0,B=y.length;w!==B&&y[w]===0;)w++,g++;for(var h=(B-w)*u+1>>>0,I=new Uint8Array(h);w!==B;){for(var N=y[w],P=0,T=h-1;(N!==0||P<f)&&T!==-1;T--,P++)N+=256*I[T]>>>0,I[T]=N%c>>>0,N=N/c>>>0;if(N!==0)throw new Error("Non-zero carry");f=P,w++}for(var R=h-f;R!==h&&I[R]===0;)R++;for(var L=a.repeat(g);R<h;++R)L+=r.charAt(I[R]);return L}function p(y){if(typeof y!="string")throw new TypeError("Expected String");if(y.length===0)return new Uint8Array;var g=0;if(y[g]!==" "){for(var f=0,w=0;y[g]===a;)f++,g++;for(var B=(y.length-g)*d+1>>>0,h=new Uint8Array(B);y[g];){var I=e[y.charCodeAt(g)];if(I===255)return;for(var N=0,P=B-1;(I!==0||N<w)&&P!==-1;P--,N++)I+=c*h[P]>>>0,h[P]=I%256>>>0,I=I/256>>>0;if(I!==0)throw new Error("Non-zero carry");w=N,g++}if(y[g]!==" "){for(var T=B-w;T!==B&&h[T]===0;)T++;for(var R=new Uint8Array(f+(B-T)),L=f;T!==B;)R[L++]=h[T++];return R}}}function E(y){var g=p(y);if(g)return g;throw new Error(`Non-${t} character`)}return{encode:m,decodeUnsafe:p,decode:E}}var Si=vi,Bi=Si,Io=Bi;var _r=class{name;prefix;baseEncode;constructor(t,e,n){this.name=t,this.prefix=e,this.baseEncode=n}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}},Dr=class{name;prefix;baseDecode;prefixCodePoint;constructor(t,e,n){this.name=t,this.prefix=e;let o=e.codePointAt(0);if(o===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=o,this.baseDecode=n}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return To(this,t)}},Or=class{decoders;constructor(t){this.decoders=t}or(t){return To(this,t)}decode(t){let e=t[0],n=this.decoders[e];if(n!=null)return n.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};function To(r,t){return new Or({...r.decoders??{[r.prefix]:r},...t.decoders??{[t.prefix]:t}})}var kr=class{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(t,e,n,o){this.name=t,this.prefix=e,this.baseEncode=n,this.baseDecode=o,this.encoder=new _r(t,e,n),this.decoder=new Dr(t,e,o)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}};function pe({name:r,prefix:t,encode:e,decode:n}){return new kr(r,t,e,n)}function Ht({name:r,prefix:t,alphabet:e}){let{encode:n,decode:o}=Io(e,r);return pe({prefix:t,name:r,encode:n,decode:s=>Lt(o(s))})}function Ai(r,t,e,n){let o={};for(let u=0;u<t.length;++u)o[t[u]]=u;let s=r.length;for(;r[s-1]==="=";)--s;let i=new Uint8Array(s*e/8|0),c=0,a=0,d=0;for(let u=0;u<s;++u){let m=o[r[u]];if(m===void 0)throw new SyntaxError(`Non-${n} character`);a=a<<e|m,c+=e,c>=8&&(c-=8,i[d++]=255&a>>c)}if(c>=e||255&a<<8-c)throw new SyntaxError("Unexpected end of data");return i}function Ii(r,t,e){let n=t[t.length-1]==="=",o=(1<<e)-1,s="",i=0,c=0;for(let a=0;a<r.length;++a)for(c=c<<8|r[a],i+=8;i>e;)i-=e,s+=t[o&c>>i];if(i!==0&&(s+=t[o&c<<e-i]),n)for(;s.length*e&7;)s+="=";return s}function X({name:r,prefix:t,bitsPerChar:e,alphabet:n}){return pe({prefix:t,name:r,encode(o){return Ii(o,n,e)},decode(o){return Ai(o,n,e,r)}})}var Q=Ht({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Ti=Ht({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var Hr={};ht(Hr,{base32:()=>Ct,base32hex:()=>Pi,base32hexpad:()=>Ni,base32hexpadupper:()=>_i,base32hexupper:()=>Ui,base32pad:()=>Ci,base32padupper:()=>Ri,base32upper:()=>Li,base32z:()=>Di});var Ct=X({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Li=X({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Ci=X({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Ri=X({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Pi=X({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Ui=X({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Ni=X({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),_i=X({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Di=X({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var Kr={};ht(Kr,{base36:()=>Re,base36upper:()=>Oi});var Re=Ht({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Oi=Ht({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var ki=Ro,Lo=128,Mi=127,Hi=~Mi,Ki=Math.pow(2,31);function Ro(r,t,e){t=t||[],e=e||0;for(var n=e;r>=Ki;)t[e++]=r&255|Lo,r/=128;for(;r&Hi;)t[e++]=r&255|Lo,r>>>=7;return t[e]=r|0,Ro.bytes=e-n+1,t}var qi=qr,Vi=128,Co=127;function qr(r,n){var e=0,n=n||0,o=0,s=n,i,c=r.length;do{if(s>=c)throw qr.bytes=0,new RangeError("Could not decode varint");i=r[s++],e+=o<28?(i&Co)<<o:(i&Co)*Math.pow(2,o),o+=7}while(i>=Vi);return qr.bytes=s-n,e}var zi=Math.pow(2,7),Fi=Math.pow(2,14),Gi=Math.pow(2,21),Zi=Math.pow(2,28),ji=Math.pow(2,35),Wi=Math.pow(2,42),$i=Math.pow(2,49),Yi=Math.pow(2,56),Xi=Math.pow(2,63),Qi=function(r){return r<zi?1:r<Fi?2:r<Gi?3:r<Zi?4:r<ji?5:r<Wi?6:r<$i?7:r<Yi?8:r<Xi?9:10},Ji={encode:ki,decode:qi,encodingLength:Qi},tc=Ji,Pe=tc;function Ue(r,t=0){return[Pe.decode(r,t),Pe.decode.bytes]}function me(r,t,e=0){return Pe.encode(r,t,e),t}function xe(r){return Pe.encodingLength(r)}function Xt(r,t){let e=t.byteLength,n=xe(r),o=n+xe(e),s=new Uint8Array(o+e);return me(r,s,0),me(e,s,n),s.set(t,o),new ge(r,e,t,s)}function Qt(r){let t=Lt(r),[e,n]=Ue(t),[o,s]=Ue(t.subarray(n)),i=t.subarray(n+s);if(i.byteLength!==o)throw new Error("Incorrect length");return new ge(e,o,i,t)}function Po(r,t){if(r===t)return!0;{let e=t;return r.code===e.code&&r.size===e.size&&e.bytes instanceof Uint8Array&&vo(r.bytes,e.bytes)}}var ge=class{code;size;digest;bytes;constructor(t,e,n,o){this.code=t,this.size=e,this.digest=n,this.bytes=o}};function Uo(r,t){let{bytes:e,version:n}=r;switch(n){case 0:return rc(e,Vr(r),t??Q.encoder);default:return nc(e,Vr(r),t??Ct.encoder)}}var No=new WeakMap;function Vr(r){let t=No.get(r);if(t==null){let e=new Map;return No.set(r,e),e}return t}var lt=class r{code;version;multihash;bytes;"/";constructor(t,e,n,o){this.code=e,this.version=t,this.multihash=n,this.bytes=o,this["/"]=o}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{let{code:t,multihash:e}=this;if(t!==Ne)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==oc)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return r.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{let{code:t,digest:e}=this.multihash,n=Xt(t,e);return r.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return r.equals(this,t)}static equals(t,e){let n=e;return n!=null&&t.code===n.code&&t.version===n.version&&Po(t.multihash,n.multihash)}toString(t){return Uo(this,t)}toJSON(){return{"/":Uo(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;let e=t;if(e instanceof r)return e;if(e["/"]!=null&&e["/"]===e.bytes||e.asCID===e){let{version:n,code:o,multihash:s,bytes:i}=e;return new r(n,o,s,i??_o(n,o,s.bytes))}else if(e[sc]===!0){let{version:n,multihash:o,code:s}=e,i=Qt(o);return r.create(n,s,i)}else return null}static create(t,e,n){if(typeof e!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(e!==Ne)throw new Error(`Version 0 CID must use dag-pb (code: ${Ne}) block encoding`);return new r(t,e,n,n.bytes)}case 1:{let o=_o(t,e,n.bytes);return new r(t,e,n,o)}default:throw new Error("Invalid version")}}static createV0(t){return r.create(0,Ne,t)}static createV1(t,e){return r.create(1,t,e)}static decode(t){let[e,n]=r.decodeFirst(t);if(n.length!==0)throw new Error("Incorrect length");return e}static decodeFirst(t){let e=r.inspectBytes(t),n=e.size-e.multihashSize,o=Lt(t.subarray(n,n+e.multihashSize));if(o.byteLength!==e.multihashSize)throw new Error("Incorrect length");let s=o.subarray(e.multihashSize-e.digestSize),i=new ge(e.multihashCode,e.digestSize,s,o);return[e.version===0?r.createV0(i):r.createV1(e.codec,i),t.subarray(e.size)]}static inspectBytes(t){let e=0,n=()=>{let[m,p]=Ue(t.subarray(e));return e+=p,m},o=n(),s=Ne;if(o===18?(o=0,e=0):s=n(),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);let i=e,c=n(),a=n(),d=e+a,u=d-i;return{version:o,codec:s,multihashCode:c,digestSize:a,multihashSize:u,size:d}}static parse(t,e){let[n,o]=ec(t,e),s=r.decode(o);if(s.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Vr(s).set(n,t),s}};function ec(r,t){switch(r[0]){case"Q":{let e=t??Q;return[Q.prefix,e.decode(`${Q.prefix}${r}`)]}case Q.prefix:{let e=t??Q;return[Q.prefix,e.decode(r)]}case Ct.prefix:{let e=t??Ct;return[Ct.prefix,e.decode(r)]}case Re.prefix:{let e=t??Re;return[Re.prefix,e.decode(r)]}default:{if(t==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],t.decode(r)]}}}function rc(r,t,e){let{prefix:n}=e;if(n!==Q.prefix)throw Error(`Cannot string encode V0 in ${e.name} encoding`);let o=t.get(n);if(o==null){let s=e.encode(r).slice(1);return t.set(n,s),s}else return o}function nc(r,t,e){let{prefix:n}=e,o=t.get(n);if(o==null){let s=e.encode(r);return t.set(n,s),s}else return o}var Ne=112,oc=18;function _o(r,t,e){let n=xe(r),o=n+xe(t),s=new Uint8Array(o+e.byteLength);return me(r,s,0),me(t,s,n),s.set(e,o),s}var sc=Symbol.for("@ipld/js-cid/CID");var zr={};ht(zr,{identity:()=>Rt});var Do=0,ic="identity",Oo=Lt;function cc(r){return Xt(Do,Oo(r))}var Rt={code:Do,name:ic,encode:Oo,digest:cc};function Pt(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function ko(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function ac(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function be(r,...t){if(!ac(r))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(r.length))throw new Error("Uint8Array expected of length "+t+", got length="+r.length)}function Mo(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");ko(r.outputLen),ko(r.blockLen)}function ye(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function Ho(r,t){be(r);let e=t.outputLen;if(r.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}var te=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var $e=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),yt=(r,t)=>r<<32-t|r>>>t;function Ko(r){if(typeof r!="string")throw new Error("utf8ToBytes expected string, got "+typeof r);return new Uint8Array(new TextEncoder().encode(r))}function _e(r){return typeof r=="string"&&(r=Ko(r)),be(r),r}function Fr(...r){let t=0;for(let n=0;n<r.length;n++){let o=r[n];be(o),t+=o.length}let e=new Uint8Array(t);for(let n=0,o=0;n<r.length;n++){let s=r[n];e.set(s,o),o+=s.length}return e}var we=class{clone(){return this._cloneInto()}};function Ye(r){let t=n=>r().update(_e(n)).digest(),e=r();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>r(),t}function Xe(r=32){if(te&&typeof te.getRandomValues=="function")return te.getRandomValues(new Uint8Array(r));if(te&&typeof te.randomBytes=="function")return te.randomBytes(r);throw new Error("crypto.getRandomValues must be defined")}function uc(r,t,e,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(t,e,n);let o=BigInt(32),s=BigInt(4294967295),i=Number(e>>o&s),c=Number(e&s),a=n?4:0,d=n?0:4;r.setUint32(t+a,i,n),r.setUint32(t+d,c,n)}var qo=(r,t,e)=>r&t^~r&e,Vo=(r,t,e)=>r&t^r&e^t&e,Ee=class extends we{constructor(t,e,n,o){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=$e(this.buffer)}update(t){ye(this);let{view:e,buffer:n,blockLen:o}=this;t=_e(t);let s=t.length;for(let i=0;i<s;){let c=Math.min(o-this.pos,s-i);if(c===o){let a=$e(t);for(;o<=s-i;i+=o)this.process(a,i);continue}n.set(t.subarray(i,i+c),this.pos),this.pos+=c,i+=c,this.pos===o&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){ye(this),Ho(t,this),this.finished=!0;let{buffer:e,view:n,blockLen:o,isLE:s}=this,{pos:i}=this;e[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>o-i&&(this.process(n,0),i=0);for(let m=i;m<o;m++)e[m]=0;uc(n,o-8,BigInt(this.length*8),s),this.process(n,0);let c=$e(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let d=a/4,u=this.get();if(d>u.length)throw new Error("_sha2: outputLen bigger than state");for(let m=0;m<d;m++)c.setUint32(4*m,u[m],s)}digest(){let{buffer:t,outputLen:e}=this;this.digestInto(t);let n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:e,buffer:n,length:o,finished:s,destroyed:i,pos:c}=this;return t.length=o,t.pos=c,t.finished=s,t.destroyed=i,o%e&&t.buffer.set(n),t}};var Qe=BigInt(4294967295),Gr=BigInt(32);function zo(r,t=!1){return t?{h:Number(r&Qe),l:Number(r>>Gr&Qe)}:{h:Number(r>>Gr&Qe)|0,l:Number(r&Qe)|0}}function fc(r,t=!1){let e=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let o=0;o<r.length;o++){let{h:s,l:i}=zo(r[o],t);[e[o],n[o]]=[s,i]}return[e,n]}var lc=(r,t)=>BigInt(r>>>0)<<Gr|BigInt(t>>>0),dc=(r,t,e)=>r>>>e,hc=(r,t,e)=>r<<32-e|t>>>e,pc=(r,t,e)=>r>>>e|t<<32-e,mc=(r,t,e)=>r<<32-e|t>>>e,xc=(r,t,e)=>r<<64-e|t>>>e-32,gc=(r,t,e)=>r>>>e-32|t<<64-e,bc=(r,t)=>t,yc=(r,t)=>r,wc=(r,t,e)=>r<<e|t>>>32-e,Ec=(r,t,e)=>t<<e|r>>>32-e,vc=(r,t,e)=>t<<e-32|r>>>64-e,Sc=(r,t,e)=>r<<e-32|t>>>64-e;function Bc(r,t,e,n){let o=(t>>>0)+(n>>>0);return{h:r+e+(o/2**32|0)|0,l:o|0}}var Ac=(r,t,e)=>(r>>>0)+(t>>>0)+(e>>>0),Ic=(r,t,e,n)=>t+e+n+(r/2**32|0)|0,Tc=(r,t,e,n)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0),Lc=(r,t,e,n,o)=>t+e+n+o+(r/2**32|0)|0,Cc=(r,t,e,n,o)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(o>>>0),Rc=(r,t,e,n,o,s)=>t+e+n+o+s+(r/2**32|0)|0;var Pc={fromBig:zo,split:fc,toBig:lc,shrSH:dc,shrSL:hc,rotrSH:pc,rotrSL:mc,rotrBH:xc,rotrBL:gc,rotr32H:bc,rotr32L:yc,rotlSH:wc,rotlSL:Ec,rotlBH:vc,rotlBL:Sc,add:Bc,add3L:Ac,add3H:Ic,add4L:Tc,add4H:Lc,add5H:Rc,add5L:Cc},k=Pc;var[Uc,Nc]=k.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),Kt=new Uint32Array(80),qt=new Uint32Array(80),Zr=class extends Ee{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){let{Ah:t,Al:e,Bh:n,Bl:o,Ch:s,Cl:i,Dh:c,Dl:a,Eh:d,El:u,Fh:m,Fl:p,Gh:E,Gl:y,Hh:g,Hl:f}=this;return[t,e,n,o,s,i,c,a,d,u,m,p,E,y,g,f]}set(t,e,n,o,s,i,c,a,d,u,m,p,E,y,g,f){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=o|0,this.Ch=s|0,this.Cl=i|0,this.Dh=c|0,this.Dl=a|0,this.Eh=d|0,this.El=u|0,this.Fh=m|0,this.Fl=p|0,this.Gh=E|0,this.Gl=y|0,this.Hh=g|0,this.Hl=f|0}process(t,e){for(let h=0;h<16;h++,e+=4)Kt[h]=t.getUint32(e),qt[h]=t.getUint32(e+=4);for(let h=16;h<80;h++){let I=Kt[h-15]|0,N=qt[h-15]|0,P=k.rotrSH(I,N,1)^k.rotrSH(I,N,8)^k.shrSH(I,N,7),T=k.rotrSL(I,N,1)^k.rotrSL(I,N,8)^k.shrSL(I,N,7),R=Kt[h-2]|0,L=qt[h-2]|0,j=k.rotrSH(R,L,19)^k.rotrBH(R,L,61)^k.shrSH(R,L,6),q=k.rotrSL(R,L,19)^k.rotrBL(R,L,61)^k.shrSL(R,L,6),H=k.add4L(T,q,qt[h-7],qt[h-16]),tt=k.add4H(H,P,j,Kt[h-7],Kt[h-16]);Kt[h]=tt|0,qt[h]=H|0}let{Ah:n,Al:o,Bh:s,Bl:i,Ch:c,Cl:a,Dh:d,Dl:u,Eh:m,El:p,Fh:E,Fl:y,Gh:g,Gl:f,Hh:w,Hl:B}=this;for(let h=0;h<80;h++){let I=k.rotrSH(m,p,14)^k.rotrSH(m,p,18)^k.rotrBH(m,p,41),N=k.rotrSL(m,p,14)^k.rotrSL(m,p,18)^k.rotrBL(m,p,41),P=m&E^~m&g,T=p&y^~p&f,R=k.add5L(B,N,T,Nc[h],qt[h]),L=k.add5H(R,w,I,P,Uc[h],Kt[h]),j=R|0,q=k.rotrSH(n,o,28)^k.rotrBH(n,o,34)^k.rotrBH(n,o,39),H=k.rotrSL(n,o,28)^k.rotrBL(n,o,34)^k.rotrBL(n,o,39),tt=n&s^n&c^s&c,S=o&i^o&a^i&a;w=g|0,B=f|0,g=E|0,f=y|0,E=m|0,y=p|0,{h:m,l:p}=k.add(d|0,u|0,L|0,j|0),d=c|0,u=a|0,c=s|0,a=i|0,s=n|0,i=o|0;let C=k.add3L(j,H,S);n=k.add3H(C,L,q,tt),o=C|0}({h:n,l:o}=k.add(this.Ah|0,this.Al|0,n|0,o|0)),{h:s,l:i}=k.add(this.Bh|0,this.Bl|0,s|0,i|0),{h:c,l:a}=k.add(this.Ch|0,this.Cl|0,c|0,a|0),{h:d,l:u}=k.add(this.Dh|0,this.Dl|0,d|0,u|0),{h:m,l:p}=k.add(this.Eh|0,this.El|0,m|0,p|0),{h:E,l:y}=k.add(this.Fh|0,this.Fl|0,E|0,y|0),{h:g,l:f}=k.add(this.Gh|0,this.Gl|0,g|0,f|0),{h:w,l:B}=k.add(this.Hh|0,this.Hl|0,w|0,B|0),this.set(n,o,s,i,c,a,d,u,m,p,E,y,g,f,w,B)}roundClean(){Kt.fill(0),qt.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}};var Fo=Ye(()=>new Zr);var er={};ht(er,{aInRange:()=>pt,abool:()=>wt,abytes:()=>ve,bitGet:()=>Hc,bitLen:()=>Yr,bitMask:()=>Oe,bitSet:()=>Kc,bytesToHex:()=>Nt,bytesToNumberBE:()=>_t,bytesToNumberLE:()=>zt,concatBytes:()=>Dt,createHmacDrbg:()=>Xr,ensureBytes:()=>Y,equalBytes:()=>kc,hexToBytes:()=>re,hexToNumber:()=>$r,inRange:()=>De,isBytes:()=>Vt,memoized:()=>oe,notImplemented:()=>Vc,numberToBytesBE:()=>Ft,numberToBytesLE:()=>ne,numberToHexUnpadded:()=>ee,numberToVarBytesBE:()=>Oc,utf8ToBytes:()=>Mc,validateObject:()=>At});var Je=BigInt(0),tr=BigInt(1),_c=BigInt(2);function Vt(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function ve(r){if(!Vt(r))throw new Error("Uint8Array expected")}function wt(r,t){if(typeof t!="boolean")throw new Error(r+" boolean expected, got "+t)}var Dc=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function Nt(r){ve(r);let t="";for(let e=0;e<r.length;e++)t+=Dc[r[e]];return t}function ee(r){let t=r.toString(16);return t.length&1?"0"+t:t}function $r(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?Je:BigInt("0x"+r)}var Ut={_0:48,_9:57,A:65,F:70,a:97,f:102};function Go(r){if(r>=Ut._0&&r<=Ut._9)return r-Ut._0;if(r>=Ut.A&&r<=Ut.F)return r-(Ut.A-10);if(r>=Ut.a&&r<=Ut.f)return r-(Ut.a-10)}function re(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);let t=r.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);let n=new Uint8Array(e);for(let o=0,s=0;o<e;o++,s+=2){let i=Go(r.charCodeAt(s)),c=Go(r.charCodeAt(s+1));if(i===void 0||c===void 0){let a=r[s]+r[s+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+s)}n[o]=i*16+c}return n}function _t(r){return $r(Nt(r))}function zt(r){return ve(r),$r(Nt(Uint8Array.from(r).reverse()))}function Ft(r,t){return re(r.toString(16).padStart(t*2,"0"))}function ne(r,t){return Ft(r,t).reverse()}function Oc(r){return re(ee(r))}function Y(r,t,e){let n;if(typeof t=="string")try{n=re(t)}catch(s){throw new Error(r+" must be hex string or Uint8Array, cause: "+s)}else if(Vt(t))n=Uint8Array.from(t);else throw new Error(r+" must be hex string or Uint8Array");let o=n.length;if(typeof e=="number"&&o!==e)throw new Error(r+" of length "+e+" expected, got "+o);return n}function Dt(...r){let t=0;for(let n=0;n<r.length;n++){let o=r[n];ve(o),t+=o.length}let e=new Uint8Array(t);for(let n=0,o=0;n<r.length;n++){let s=r[n];e.set(s,o),o+=s.length}return e}function kc(r,t){if(r.length!==t.length)return!1;let e=0;for(let n=0;n<r.length;n++)e|=r[n]^t[n];return e===0}function Mc(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}var jr=r=>typeof r=="bigint"&&Je<=r;function De(r,t,e){return jr(r)&&jr(t)&&jr(e)&&t<=r&&r<e}function pt(r,t,e,n){if(!De(t,e,n))throw new Error("expected valid "+r+": "+e+" <= n < "+n+", got "+t)}function Yr(r){let t;for(t=0;r>Je;r>>=tr,t+=1);return t}function Hc(r,t){return r>>BigInt(t)&tr}function Kc(r,t,e){return r|(e?tr:Je)<<BigInt(t)}var Oe=r=>(_c<<BigInt(r-1))-tr,Wr=r=>new Uint8Array(r),Zo=r=>Uint8Array.from(r);function Xr(r,t,e){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let n=Wr(r),o=Wr(r),s=0,i=()=>{n.fill(1),o.fill(0),s=0},c=(...m)=>e(o,n,...m),a=(m=Wr())=>{o=c(Zo([0]),m),n=c(),m.length!==0&&(o=c(Zo([1]),m),n=c())},d=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let m=0,p=[];for(;m<t;){n=c();let E=n.slice();p.push(E),m+=n.length}return Dt(...p)};return(m,p)=>{i(),a(m);let E;for(;!(E=p(d()));)a();return i(),E}}var qc={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||Vt(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,t)=>t.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function At(r,t,e={}){let n=(o,s,i)=>{let c=qc[s];if(typeof c!="function")throw new Error("invalid validator function");let a=r[o];if(!(i&&a===void 0)&&!c(a,r))throw new Error("param "+String(o)+" is invalid. Expected "+s+", got "+a)};for(let[o,s]of Object.entries(t))n(o,s,!1);for(let[o,s]of Object.entries(e))n(o,s,!0);return r}var Vc=()=>{throw new Error("not implemented")};function oe(r){let t=new WeakMap;return(e,...n)=>{let o=t.get(e);if(o!==void 0)return o;let s=r(e,...n);return t.set(e,s),s}}var et=BigInt(0),W=BigInt(1),se=BigInt(2),zc=BigInt(3),Qr=BigInt(4),jo=BigInt(5),Wo=BigInt(8),Fc=BigInt(9),Gc=BigInt(16);function F(r,t){let e=r%t;return e>=et?e:t+e}function Zc(r,t,e){if(t<et)throw new Error("invalid exponent, negatives unsupported");if(e<=et)throw new Error("invalid modulus");if(e===W)return et;let n=W;for(;t>et;)t&W&&(n=n*r%e),r=r*r%e,t>>=W;return n}function $(r,t,e){let n=r;for(;t-- >et;)n*=n,n%=e;return n}function rr(r,t){if(r===et)throw new Error("invert: expected non-zero number");if(t<=et)throw new Error("invert: expected positive modulus, got "+t);let e=F(r,t),n=t,o=et,s=W,i=W,c=et;for(;e!==et;){let d=n/e,u=n%e,m=o-i*d,p=s-c*d;n=e,e=u,o=i,s=c,i=m,c=p}if(n!==W)throw new Error("invert: does not exist");return F(o,t)}function jc(r){let t=(r-W)/se,e,n,o;for(e=r-W,n=0;e%se===et;e/=se,n++);for(o=se;o<r&&Zc(o,t,r)!==r-W;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(n===1){let i=(r+W)/Qr;return function(a,d){let u=a.pow(d,i);if(!a.eql(a.sqr(u),d))throw new Error("Cannot find square root");return u}}let s=(e+W)/se;return function(c,a){if(c.pow(a,t)===c.neg(c.ONE))throw new Error("Cannot find square root");let d=n,u=c.pow(c.mul(c.ONE,o),e),m=c.pow(a,s),p=c.pow(a,e);for(;!c.eql(p,c.ONE);){if(c.eql(p,c.ZERO))return c.ZERO;let E=1;for(let g=c.sqr(p);E<d&&!c.eql(g,c.ONE);E++)g=c.sqr(g);let y=c.pow(u,W<<BigInt(d-E-1));u=c.sqr(y),m=c.mul(m,y),p=c.mul(p,u),d=E}return m}}function Wc(r){if(r%Qr===zc){let t=(r+W)/Qr;return function(n,o){let s=n.pow(o,t);if(!n.eql(n.sqr(s),o))throw new Error("Cannot find square root");return s}}if(r%Wo===jo){let t=(r-jo)/Wo;return function(n,o){let s=n.mul(o,se),i=n.pow(s,t),c=n.mul(o,i),a=n.mul(n.mul(c,se),i),d=n.mul(c,n.sub(a,n.ONE));if(!n.eql(n.sqr(d),o))throw new Error("Cannot find square root");return d}}return r%Gc,jc(r)}var $o=(r,t)=>(F(r,t)&W)===W,$c=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Jr(r){let t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=$c.reduce((n,o)=>(n[o]="function",n),t);return At(r,e)}function Yc(r,t,e){if(e<et)throw new Error("invalid exponent, negatives unsupported");if(e===et)return r.ONE;if(e===W)return t;let n=r.ONE,o=t;for(;e>et;)e&W&&(n=r.mul(n,o)),o=r.sqr(o),e>>=W;return n}function Xc(r,t){let e=new Array(t.length),n=t.reduce((s,i,c)=>r.is0(i)?s:(e[c]=s,r.mul(s,i)),r.ONE),o=r.inv(n);return t.reduceRight((s,i,c)=>r.is0(i)?s:(e[c]=r.mul(s,e[c]),r.mul(s,i)),o),e}function tn(r,t){let e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}function Gt(r,t,e=!1,n={}){if(r<=et)throw new Error("invalid field: expected ORDER > 0, got "+r);let{nBitLength:o,nByteLength:s}=tn(r,t);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let i,c=Object.freeze({ORDER:r,isLE:e,BITS:o,BYTES:s,MASK:Oe(o),ZERO:et,ONE:W,create:a=>F(a,r),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return et<=a&&a<r},is0:a=>a===et,isOdd:a=>(a&W)===W,neg:a=>F(-a,r),eql:(a,d)=>a===d,sqr:a=>F(a*a,r),add:(a,d)=>F(a+d,r),sub:(a,d)=>F(a-d,r),mul:(a,d)=>F(a*d,r),pow:(a,d)=>Yc(c,a,d),div:(a,d)=>F(a*rr(d,r),r),sqrN:a=>a*a,addN:(a,d)=>a+d,subN:(a,d)=>a-d,mulN:(a,d)=>a*d,inv:a=>rr(a,r),sqrt:n.sqrt||(a=>(i||(i=Wc(r)),i(c,a))),invertBatch:a=>Xc(c,a),cmov:(a,d,u)=>u?d:a,toBytes:a=>e?ne(a,s):Ft(a,s),fromBytes:a=>{if(a.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+a.length);return e?zt(a):_t(a)}});return Object.freeze(c)}function Yo(r){if(typeof r!="bigint")throw new Error("field order must be bigint");let t=r.toString(2).length;return Math.ceil(t/8)}function en(r){let t=Yo(r);return t+Math.ceil(t/2)}function Xo(r,t,e=!1){let n=r.length,o=Yo(t),s=en(t);if(n<16||n<s||n>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+n);let i=e?zt(r):_t(r),c=F(i,t-W)+W;return e?ne(c,o):Ft(c,o)}var Qo=BigInt(0),nr=BigInt(1);function rn(r,t){let e=t.negate();return r?e:t}function Jo(r,t){if(!Number.isSafeInteger(r)||r<=0||r>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+r)}function nn(r,t){Jo(r,t);let e=Math.ceil(t/r)+1,n=2**(r-1);return{windows:e,windowSize:n}}function Jc(r,t){if(!Array.isArray(r))throw new Error("array expected");r.forEach((e,n)=>{if(!(e instanceof t))throw new Error("invalid point at index "+n)})}function ta(r,t){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((e,n)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+n)})}var on=new WeakMap,ts=new WeakMap;function sn(r){return ts.get(r)||1}function or(r,t){return{constTimeNegate:rn,hasPrecomputes(e){return sn(e)!==1},unsafeLadder(e,n,o=r.ZERO){let s=e;for(;n>Qo;)n&nr&&(o=o.add(s)),s=s.double(),n>>=nr;return o},precomputeWindow(e,n){let{windows:o,windowSize:s}=nn(n,t),i=[],c=e,a=c;for(let d=0;d<o;d++){a=c,i.push(a);for(let u=1;u<s;u++)a=a.add(c),i.push(a);c=a.double()}return i},wNAF(e,n,o){let{windows:s,windowSize:i}=nn(e,t),c=r.ZERO,a=r.BASE,d=BigInt(2**e-1),u=2**e,m=BigInt(e);for(let p=0;p<s;p++){let E=p*i,y=Number(o&d);o>>=m,y>i&&(y-=u,o+=nr);let g=E,f=E+Math.abs(y)-1,w=p%2!==0,B=y<0;y===0?a=a.add(rn(w,n[g])):c=c.add(rn(B,n[f]))}return{p:c,f:a}},wNAFUnsafe(e,n,o,s=r.ZERO){let{windows:i,windowSize:c}=nn(e,t),a=BigInt(2**e-1),d=2**e,u=BigInt(e);for(let m=0;m<i;m++){let p=m*c;if(o===Qo)break;let E=Number(o&a);if(o>>=u,E>c&&(E-=d,o+=nr),E===0)continue;let y=n[p+Math.abs(E)-1];E<0&&(y=y.negate()),s=s.add(y)}return s},getPrecomputes(e,n,o){let s=on.get(n);return s||(s=this.precomputeWindow(n,e),e!==1&&on.set(n,o(s))),s},wNAFCached(e,n,o){let s=sn(e);return this.wNAF(s,this.getPrecomputes(s,e,o),n)},wNAFCachedUnsafe(e,n,o,s){let i=sn(e);return i===1?this.unsafeLadder(e,n,s):this.wNAFUnsafe(i,this.getPrecomputes(i,e,o),n,s)},setWindowSize(e,n){Jo(n,t),ts.set(e,n),on.delete(e)}}}function sr(r,t,e,n){if(Jc(e,r),ta(n,t),e.length!==n.length)throw new Error("arrays of points and scalars must have equal length");let o=r.ZERO,s=Yr(BigInt(e.length)),i=s>12?s-3:s>4?s-2:s?2:1,c=(1<<i)-1,a=new Array(c+1).fill(o),d=Math.floor((t.BITS-1)/i)*i,u=o;for(let m=d;m>=0;m-=i){a.fill(o);for(let E=0;E<n.length;E++){let y=n[E],g=Number(y>>BigInt(m)&BigInt(c));a[g]=a[g].add(e[E])}let p=o;for(let E=a.length-1,y=o;E>0;E--)y=y.add(a[E]),p=p.add(y);if(u=u.add(p),m!==0)for(let E=0;E<i;E++)u=u.double()}return u}function ke(r){return Jr(r.Fp),At(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...tn(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}var Et=BigInt(0),mt=BigInt(1),ir=BigInt(2),ea=BigInt(8),ra={zip215:!0};function na(r){let t=ke(r);return At(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}function es(r){let t=na(r),{Fp:e,n,prehash:o,hash:s,randomBytes:i,nByteLength:c,h:a}=t,d=ir<<BigInt(c*8)-mt,u=e.create,m=Gt(t.n,t.nBitLength),p=t.uvRatio||((x,l)=>{try{return{isValid:!0,value:e.sqrt(x*e.inv(l))}}catch{return{isValid:!1,value:Et}}}),E=t.adjustScalarBytes||(x=>x),y=t.domain||((x,l,b)=>{if(wt("phflag",b),l.length||b)throw new Error("Contexts/pre-hash are not supported");return x});function g(x,l){pt("coordinate "+x,l,Et,d)}function f(x){if(!(x instanceof h))throw new Error("ExtendedPoint expected")}let w=oe((x,l)=>{let{ex:b,ey:A,ez:_}=x,D=x.is0();l==null&&(l=D?ea:e.inv(_));let M=u(b*l),K=u(A*l),O=u(_*l);if(D)return{x:Et,y:mt};if(O!==mt)throw new Error("invZ was invalid");return{x:M,y:K}}),B=oe(x=>{let{a:l,d:b}=t;if(x.is0())throw new Error("bad point: ZERO");let{ex:A,ey:_,ez:D,et:M}=x,K=u(A*A),O=u(_*_),z=u(D*D),Z=u(z*z),nt=u(K*l),ot=u(z*u(nt+O)),it=u(Z+u(b*u(K*O)));if(ot!==it)throw new Error("bad point: equation left != right (1)");let ct=u(A*_),dt=u(D*M);if(ct!==dt)throw new Error("bad point: equation left != right (2)");return!0});class h{constructor(l,b,A,_){this.ex=l,this.ey=b,this.ez=A,this.et=_,g("x",l),g("y",b),g("z",A),g("t",_),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(l){if(l instanceof h)throw new Error("extended point not allowed");let{x:b,y:A}=l||{};return g("x",b),g("y",A),new h(b,A,mt,u(b*A))}static normalizeZ(l){let b=e.invertBatch(l.map(A=>A.ez));return l.map((A,_)=>A.toAffine(b[_])).map(h.fromAffine)}static msm(l,b){return sr(h,m,l,b)}_setWindowSize(l){P.setWindowSize(this,l)}assertValidity(){B(this)}equals(l){f(l);let{ex:b,ey:A,ez:_}=this,{ex:D,ey:M,ez:K}=l,O=u(b*K),z=u(D*_),Z=u(A*K),nt=u(M*_);return O===z&&Z===nt}is0(){return this.equals(h.ZERO)}negate(){return new h(u(-this.ex),this.ey,this.ez,u(-this.et))}double(){let{a:l}=t,{ex:b,ey:A,ez:_}=this,D=u(b*b),M=u(A*A),K=u(ir*u(_*_)),O=u(l*D),z=b+A,Z=u(u(z*z)-D-M),nt=O+M,ot=nt-K,it=O-M,ct=u(Z*ot),dt=u(nt*it),ft=u(Z*it),Bt=u(ot*nt);return new h(ct,dt,Bt,ft)}add(l){f(l);let{a:b,d:A}=t,{ex:_,ey:D,ez:M,et:K}=this,{ex:O,ey:z,ez:Z,et:nt}=l;if(b===BigInt(-1)){let lo=u((D-_)*(z+O)),ho=u((D+_)*(z-O)),Pr=u(ho-lo);if(Pr===Et)return this.double();let po=u(M*ir*nt),mo=u(K*ir*Z),xo=mo+po,go=ho+lo,bo=mo-po,hi=u(xo*Pr),pi=u(go*bo),mi=u(xo*bo),xi=u(Pr*go);return new h(hi,pi,xi,mi)}let ot=u(_*O),it=u(D*z),ct=u(K*A*nt),dt=u(M*Z),ft=u((_+D)*(O+z)-ot-it),Bt=dt-ct,Tt=dt+ct,Le=u(it-b*ot),ui=u(ft*Bt),fi=u(Tt*Le),li=u(ft*Le),di=u(Bt*Tt);return new h(ui,fi,di,li)}subtract(l){return this.add(l.negate())}wNAF(l){return P.wNAFCached(this,l,h.normalizeZ)}multiply(l){let b=l;pt("scalar",b,mt,n);let{p:A,f:_}=this.wNAF(b);return h.normalizeZ([A,_])[0]}multiplyUnsafe(l,b=h.ZERO){let A=l;return pt("scalar",A,Et,n),A===Et?N:this.is0()||A===mt?this:P.wNAFCachedUnsafe(this,A,h.normalizeZ,b)}isSmallOrder(){return this.multiplyUnsafe(a).is0()}isTorsionFree(){return P.unsafeLadder(this,n).is0()}toAffine(l){return w(this,l)}clearCofactor(){let{h:l}=t;return l===mt?this:this.multiplyUnsafe(l)}static fromHex(l,b=!1){let{d:A,a:_}=t,D=e.BYTES;l=Y("pointHex",l,D),wt("zip215",b);let M=l.slice(),K=l[D-1];M[D-1]=K&-129;let O=zt(M),z=b?d:e.ORDER;pt("pointHex.y",O,Et,z);let Z=u(O*O),nt=u(Z-mt),ot=u(A*Z-_),{isValid:it,value:ct}=p(nt,ot);if(!it)throw new Error("Point.fromHex: invalid y coordinate");let dt=(ct&mt)===mt,ft=(K&128)!==0;if(!b&&ct===Et&&ft)throw new Error("Point.fromHex: x=0 and x_0=1");return ft!==dt&&(ct=u(-ct)),h.fromAffine({x:ct,y:O})}static fromPrivateKey(l){return L(l).point}toRawBytes(){let{x:l,y:b}=this.toAffine(),A=ne(b,e.BYTES);return A[A.length-1]|=l&mt?128:0,A}toHex(){return Nt(this.toRawBytes())}}h.BASE=new h(t.Gx,t.Gy,mt,u(t.Gx*t.Gy)),h.ZERO=new h(Et,mt,mt,Et);let{BASE:I,ZERO:N}=h,P=or(h,c*8);function T(x){return F(x,n)}function R(x){return T(zt(x))}function L(x){let l=e.BYTES;x=Y("private key",x,l);let b=Y("hashed private key",s(x),2*l),A=E(b.slice(0,l)),_=b.slice(l,2*l),D=R(A),M=I.multiply(D),K=M.toRawBytes();return{head:A,prefix:_,scalar:D,point:M,pointBytes:K}}function j(x){return L(x).pointBytes}function q(x=new Uint8Array,...l){let b=Dt(...l);return R(s(y(b,Y("context",x),!!o)))}function H(x,l,b={}){x=Y("message",x),o&&(x=o(x));let{prefix:A,scalar:_,pointBytes:D}=L(l),M=q(b.context,A,x),K=I.multiply(M).toRawBytes(),O=q(b.context,K,D,x),z=T(M+O*_);pt("signature.s",z,Et,n);let Z=Dt(K,ne(z,e.BYTES));return Y("result",Z,e.BYTES*2)}let tt=ra;function S(x,l,b,A=tt){let{context:_,zip215:D}=A,M=e.BYTES;x=Y("signature",x,2*M),l=Y("message",l),b=Y("publicKey",b,M),D!==void 0&&wt("zip215",D),o&&(l=o(l));let K=zt(x.slice(M,2*M)),O,z,Z;try{O=h.fromHex(b,D),z=h.fromHex(x.slice(0,M),D),Z=I.multiplyUnsafe(K)}catch{return!1}if(!D&&O.isSmallOrder())return!1;let nt=q(_,z.toRawBytes(),O.toRawBytes(),l);return z.add(O.multiplyUnsafe(nt)).subtract(Z).clearCofactor().equals(h.ZERO)}return I._setWindowSize(8),{CURVE:t,getPublicKey:j,sign:H,verify:S,ExtendedPoint:h,utils:{getExtendedPublicKey:L,randomPrivateKey:()=>i(e.BYTES),precompute(x=8,l=h.BASE){return l._setWindowSize(x),l.multiply(BigInt(3)),l}}}}var cn=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),rs=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),il=BigInt(0),oa=BigInt(1),ns=BigInt(2),cl=BigInt(3),sa=BigInt(5),ia=BigInt(8);function ca(r){let t=BigInt(10),e=BigInt(20),n=BigInt(40),o=BigInt(80),s=cn,c=r*r%s*r%s,a=$(c,ns,s)*c%s,d=$(a,oa,s)*r%s,u=$(d,sa,s)*d%s,m=$(u,t,s)*u%s,p=$(m,e,s)*m%s,E=$(p,n,s)*p%s,y=$(E,o,s)*E%s,g=$(y,o,s)*E%s,f=$(g,t,s)*u%s;return{pow_p_5_8:$(f,ns,s)*r%s,b2:c}}function aa(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function ua(r,t){let e=cn,n=F(t*t*t,e),o=F(n*n*t,e),s=ca(r*o).pow_p_5_8,i=F(r*n*s,e),c=F(t*i*i,e),a=i,d=F(i*rs,e),u=c===r,m=c===F(-r,e),p=c===F(-r*rs,e);return u&&(i=a),(m||p)&&(i=d),$o(i,e)&&(i=F(-i,e)),{isValid:u||m,value:i}}var fa=Gt(cn,void 0,!0),la={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:fa,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:ia,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Fo,randomBytes:Xe,adjustScalarBytes:aa,uvRatio:ua},os=es(la);var cr=32;function ss(r,t,e){return os.verify(t,e instanceof Uint8Array?e:e.subarray(),r)}var ar=class{type="Ed25519";raw;constructor(t){this.raw=an(t,cr)}toMultihash(){return Rt.digest(ur(this))}toCID(){return lt.createV1(114,this.toMultihash())}toString(){return Q.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:Pt(this.raw,t.raw)}verify(t,e){return ss(this.raw,e,t)}};function cs(r){return r=an(r,cr),new ar(r)}function an(r,t){if(r=Uint8Array.from(r??[]),r.length!==t)throw new he(`Key must be a Uint8Array of length ${t}, got ${r.length}`);return r}function vt(r=0){return new Uint8Array(r)}var ha=Math.pow(2,7),pa=Math.pow(2,14),ma=Math.pow(2,21),un=Math.pow(2,28),fn=Math.pow(2,35),ln=Math.pow(2,42),dn=Math.pow(2,49),V=128,at=127;function xt(r){if(r<ha)return 1;if(r<pa)return 2;if(r<ma)return 3;if(r<un)return 4;if(r<fn)return 5;if(r<ln)return 6;if(r<dn)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function hn(r,t,e=0){switch(xt(r)){case 8:t[e++]=r&255|V,r/=128;case 7:t[e++]=r&255|V,r/=128;case 6:t[e++]=r&255|V,r/=128;case 5:t[e++]=r&255|V,r/=128;case 4:t[e++]=r&255|V,r>>>=7;case 3:t[e++]=r&255|V,r>>>=7;case 2:t[e++]=r&255|V,r>>>=7;case 1:{t[e++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return t}function xa(r,t,e=0){switch(xt(r)){case 8:t.set(e++,r&255|V),r/=128;case 7:t.set(e++,r&255|V),r/=128;case 6:t.set(e++,r&255|V),r/=128;case 5:t.set(e++,r&255|V),r/=128;case 4:t.set(e++,r&255|V),r>>>=7;case 3:t.set(e++,r&255|V),r>>>=7;case 2:t.set(e++,r&255|V),r>>>=7;case 1:{t.set(e++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return t}function pn(r,t){let e=r[t],n=0;if(n+=e&at,e<V||(e=r[t+1],n+=(e&at)<<7,e<V)||(e=r[t+2],n+=(e&at)<<14,e<V)||(e=r[t+3],n+=(e&at)<<21,e<V)||(e=r[t+4],n+=(e&at)*un,e<V)||(e=r[t+5],n+=(e&at)*fn,e<V)||(e=r[t+6],n+=(e&at)*ln,e<V)||(e=r[t+7],n+=(e&at)*dn,e<V))return n;throw new RangeError("Could not decode varint")}function ga(r,t){let e=r.get(t),n=0;if(n+=e&at,e<V||(e=r.get(t+1),n+=(e&at)<<7,e<V)||(e=r.get(t+2),n+=(e&at)<<14,e<V)||(e=r.get(t+3),n+=(e&at)<<21,e<V)||(e=r.get(t+4),n+=(e&at)*un,e<V)||(e=r.get(t+5),n+=(e&at)*fn,e<V)||(e=r.get(t+6),n+=(e&at)*ln,e<V)||(e=r.get(t+7),n+=(e&at)*dn,e<V))return n;throw new RangeError("Could not decode varint")}function Se(r,t,e=0){return t==null&&(t=vt(xt(r))),t instanceof Uint8Array?hn(r,t,e):xa(r,t,e)}function ie(r,t=0){return r instanceof Uint8Array?pn(r,t):ga(r,t)}var mn=new Float32Array([-0]),Zt=new Uint8Array(mn.buffer);function us(r,t,e){mn[0]=r,t[e]=Zt[0],t[e+1]=Zt[1],t[e+2]=Zt[2],t[e+3]=Zt[3]}function fs(r,t){return Zt[0]=r[t],Zt[1]=r[t+1],Zt[2]=r[t+2],Zt[3]=r[t+3],mn[0]}var xn=new Float64Array([-0]),ut=new Uint8Array(xn.buffer);function ls(r,t,e){xn[0]=r,t[e]=ut[0],t[e+1]=ut[1],t[e+2]=ut[2],t[e+3]=ut[3],t[e+4]=ut[4],t[e+5]=ut[5],t[e+6]=ut[6],t[e+7]=ut[7]}function ds(r,t){return ut[0]=r[t],ut[1]=r[t+1],ut[2]=r[t+2],ut[3]=r[t+3],ut[4]=r[t+4],ut[5]=r[t+5],ut[6]=r[t+6],ut[7]=r[t+7],xn[0]}var ba=BigInt(Number.MAX_SAFE_INTEGER),ya=BigInt(Number.MIN_SAFE_INTEGER),gt=class r{lo;hi;constructor(t,e){this.lo=t|0,this.hi=e|0}toNumber(t=!1){if(!t&&this.hi>>>31>0){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(e+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(t=!1){if(t)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(BigInt(e)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(t=!1){return this.toBigInt(t).toString()}zzEncode(){let t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this}zzDecode(){let t=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this}length(){let t=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?e===0?t<16384?t<128?1:2:t<2097152?3:4:e<16384?e<128?5:6:e<2097152?7:8:n<128?9:10}static fromBigInt(t){if(t===0n)return ce;if(t<ba&&t>ya)return this.fromNumber(Number(t));let e=t<0n;e&&(t=-t);let n=t>>32n,o=t-(n<<32n);return e&&(n=~n|0n,o=~o|0n,++o>hs&&(o=0n,++n>hs&&(n=0n))),new r(Number(o),Number(n))}static fromNumber(t){if(t===0)return ce;let e=t<0;e&&(t=-t);let n=t>>>0,o=(t-n)/4294967296>>>0;return e&&(o=~o>>>0,n=~n>>>0,++n>4294967295&&(n=0,++o>4294967295&&(o=0))),new r(n,o)}static from(t){return typeof t=="number"?r.fromNumber(t):typeof t=="bigint"?r.fromBigInt(t):typeof t=="string"?r.fromBigInt(BigInt(t)):t.low!=null||t.high!=null?new r(t.low>>>0,t.high>>>0):ce}},ce=new gt(0,0);ce.toBigInt=function(){return 0n};ce.zzEncode=ce.zzDecode=function(){return this};ce.length=function(){return 1};var hs=4294967296n;function ps(r){let t=0,e=0;for(let n=0;n<r.length;++n)e=r.charCodeAt(n),e<128?t+=1:e<2048?t+=2:(e&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,t+=4):t+=3;return t}function ms(r,t,e){if(e-t<1)return"";let o,s=[],i=0,c;for(;t<e;)c=r[t++],c<128?s[i++]=c:c>191&&c<224?s[i++]=(c&31)<<6|r[t++]&63:c>239&&c<365?(c=((c&7)<<18|(r[t++]&63)<<12|(r[t++]&63)<<6|r[t++]&63)-65536,s[i++]=55296+(c>>10),s[i++]=56320+(c&1023)):s[i++]=(c&15)<<12|(r[t++]&63)<<6|r[t++]&63,i>8191&&((o??(o=[])).push(String.fromCharCode.apply(String,s)),i=0);return o!=null?(i>0&&o.push(String.fromCharCode.apply(String,s.slice(0,i))),o.join("")):String.fromCharCode.apply(String,s.slice(0,i))}function gn(r,t,e){let n=e,o,s;for(let i=0;i<r.length;++i)o=r.charCodeAt(i),o<128?t[e++]=o:o<2048?(t[e++]=o>>6|192,t[e++]=o&63|128):(o&64512)===55296&&((s=r.charCodeAt(i+1))&64512)===56320?(o=65536+((o&1023)<<10)+(s&1023),++i,t[e++]=o>>18|240,t[e++]=o>>12&63|128,t[e++]=o>>6&63|128,t[e++]=o&63|128):(t[e++]=o>>12|224,t[e++]=o>>6&63|128,t[e++]=o&63|128);return e-n}function St(r,t){return RangeError(`index out of range: ${r.pos} + ${t??1} > ${r.len}`)}function fr(r,t){return(r[t-4]|r[t-3]<<8|r[t-2]<<16|r[t-1]<<24)>>>0}var bn=class{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(t){this.buf=t,this.pos=0,this.len=t.length}uint32(){let t=4294967295;if(t=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(t=(t|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return t;if((this.pos+=5)>this.len)throw this.pos=this.len,St(this,10);return t}int32(){return this.uint32()|0}sint32(){let t=this.uint32();return t>>>1^-(t&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw St(this,4);return fr(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw St(this,4);return fr(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw St(this,4);let t=fs(this.buf,this.pos);return this.pos+=4,t}double(){if(this.pos+8>this.len)throw St(this,4);let t=ds(this.buf,this.pos);return this.pos+=8,t}bytes(){let t=this.uint32(),e=this.pos,n=this.pos+t;if(n>this.len)throw St(this,t);return this.pos+=t,e===n?new Uint8Array(0):this.buf.subarray(e,n)}string(){let t=this.bytes();return ms(t,0,t.length)}skip(t){if(typeof t=="number"){if(this.pos+t>this.len)throw St(this,t);this.pos+=t}else do if(this.pos>=this.len)throw St(this);while(this.buf[this.pos++]&128);return this}skipType(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${t} at offset ${this.pos}`)}return this}readLongVarint(){let t=new gt(0,0),e=0;if(this.len-this.pos>4){for(;e<4;++e)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw St(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,t}if(this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw St(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw St(this,8);let t=fr(this.buf,this.pos+=4),e=fr(this.buf,this.pos+=4);return new gt(t,e)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){let t=pn(this.buf,this.pos);return this.pos+=xt(t),t}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}};function yn(r){return new bn(r instanceof Uint8Array?r:r.subarray())}function lr(r,t,e){let n=yn(r);return t.decode(n,void 0,e)}var wn={};ht(wn,{base10:()=>wa});var wa=Ht({prefix:"9",name:"base10",alphabet:"0123456789"});var En={};ht(En,{base16:()=>Ea,base16upper:()=>va});var Ea=X({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),va=X({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var vn={};ht(vn,{base2:()=>Sa});var Sa=X({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var Sn={};ht(Sn,{base256emoji:()=>La});var gs=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),Ba=gs.reduce((r,t,e)=>(r[e]=t,r),[]),Aa=gs.reduce((r,t,e)=>{let n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);return r[n]=e,r},[]);function Ia(r){return r.reduce((t,e)=>(t+=Ba[e],t),"")}function Ta(r){let t=[];for(let e of r){let n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);let o=Aa[n];if(o==null)throw new Error(`Non-base256emoji character: ${e}`);t.push(o)}return new Uint8Array(t)}var La=pe({prefix:"\u{1F680}",name:"base256emoji",encode:Ia,decode:Ta});var Bn={};ht(Bn,{base64:()=>Ca,base64pad:()=>Ra,base64url:()=>Pa,base64urlpad:()=>Ua});var Ca=X({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Ra=X({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Pa=X({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Ua=X({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var An={};ht(An,{base8:()=>Na});var Na=X({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var In={};ht(In,{identity:()=>_a});var _a=pe({prefix:"\0",name:"identity",encode:r=>Bo(r),decode:r=>So(r)});var zl=new TextEncoder,Fl=new TextDecoder;var Cn={};ht(Cn,{sha256:()=>Me,sha512:()=>ka});function Ln({name:r,code:t,encode:e}){return new Tn(r,t,e)}var Tn=class{name;code;encode;constructor(t,e,n){this.name=t,this.code=e,this.encode=n}digest(t){if(t instanceof Uint8Array){let e=this.encode(t);return e instanceof Uint8Array?Xt(this.code,e):e.then(n=>Xt(this.code,n))}else throw Error("Unknown type, must be binary type")}};function ys(r){return async t=>new Uint8Array(await crypto.subtle.digest(r,t))}var Me=Ln({name:"sha2-256",code:18,encode:ys("SHA-256")}),ka=Ln({name:"sha2-512",code:19,encode:ys("SHA-512")});var He={...In,...vn,...An,...wn,...En,...Hr,...Kr,...Mr,...Bn,...Sn},rd={...Cn,...zr};function Es(r,t,e,n){return{name:r,prefix:t,encoder:{name:r,prefix:t,encode:e},decoder:{decode:n}}}var ws=Es("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),Rn=Es("ascii","a",r=>{let t="a";for(let e=0;e<r.length;e++)t+=String.fromCharCode(r[e]);return t},r=>{r=r.substring(1);let t=vt(r.length);for(let e=0;e<r.length;e++)t[e]=r.charCodeAt(e);return t}),Ma={utf8:ws,"utf-8":ws,hex:He.base16,latin1:Rn,ascii:Rn,binary:Rn,...He},dr=Ma;function Ot(r,t="utf8"){let e=dr[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.decoder.decode(`${e.prefix}${r}`)}function Pn(r){let t=r??8192,e=t>>>1,n,o=t;return function(i){if(i<1||i>e)return vt(i);o+i>t&&(n=vt(t),o=0);let c=n.subarray(o,o+=i);return o&7&&(o=(o|7)+1),c}}var ae=class{fn;len;next;val;constructor(t,e,n){this.fn=t,this.len=e,this.next=void 0,this.val=n}};function Un(){}var _n=class{head;tail;len;next;constructor(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}},Ha=Pn();function Ka(r){return globalThis.Buffer!=null?vt(r):Ha(r)}var qe=class{len;head;tail;states;constructor(){this.len=0,this.head=new ae(Un,0,0),this.tail=this.head,this.states=null}_push(t,e,n){return this.tail=this.tail.next=new ae(t,e,n),this.len+=e,this}uint32(t){return this.len+=(this.tail=this.tail.next=new Dn((t=t>>>0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this}int32(t){return t<0?this._push(hr,10,gt.fromNumber(t)):this.uint32(t)}sint32(t){return this.uint32((t<<1^t>>31)>>>0)}uint64(t){let e=gt.fromBigInt(t);return this._push(hr,e.length(),e)}uint64Number(t){return this._push(hn,xt(t),t)}uint64String(t){return this.uint64(BigInt(t))}int64(t){return this.uint64(t)}int64Number(t){return this.uint64Number(t)}int64String(t){return this.uint64String(t)}sint64(t){let e=gt.fromBigInt(t).zzEncode();return this._push(hr,e.length(),e)}sint64Number(t){let e=gt.fromNumber(t).zzEncode();return this._push(hr,e.length(),e)}sint64String(t){return this.sint64(BigInt(t))}bool(t){return this._push(Nn,1,t?1:0)}fixed32(t){return this._push(Ke,4,t>>>0)}sfixed32(t){return this.fixed32(t)}fixed64(t){let e=gt.fromBigInt(t);return this._push(Ke,4,e.lo)._push(Ke,4,e.hi)}fixed64Number(t){let e=gt.fromNumber(t);return this._push(Ke,4,e.lo)._push(Ke,4,e.hi)}fixed64String(t){return this.fixed64(BigInt(t))}sfixed64(t){return this.fixed64(t)}sfixed64Number(t){return this.fixed64Number(t)}sfixed64String(t){return this.fixed64String(t)}float(t){return this._push(us,4,t)}double(t){return this._push(ls,8,t)}bytes(t){let e=t.length>>>0;return e===0?this._push(Nn,1,0):this.uint32(e)._push(Va,e,t)}string(t){let e=ps(t);return e!==0?this.uint32(e)._push(gn,e,t):this._push(Nn,1,0)}fork(){return this.states=new _n(this),this.head=this.tail=new ae(Un,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new ae(Un,0,0),this.len=0),this}ldelim(){let t=this.head,e=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=t.next,this.tail=e,this.len+=n),this}finish(){let t=this.head.next,e=Ka(this.len),n=0;for(;t!=null;)t.fn(t.val,e,n),n+=t.len,t=t.next;return e}};function Nn(r,t,e){t[e]=r&255}function qa(r,t,e){for(;r>127;)t[e++]=r&127|128,r>>>=7;t[e]=r}var Dn=class extends ae{next;constructor(t,e){super(qa,t,e),this.next=void 0}};function hr(r,t,e){for(;r.hi!==0;)t[e++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)t[e++]=r.lo&127|128,r.lo=r.lo>>>7;t[e++]=r.lo}function Ke(r,t,e){t[e]=r&255,t[e+1]=r>>>8&255,t[e+2]=r>>>16&255,t[e+3]=r>>>24}function Va(r,t,e){t.set(r,e)}globalThis.Buffer!=null&&(qe.prototype.bytes=function(r){let t=r.length>>>0;return this.uint32(t),t>0&&this._push(za,t,r),this},qe.prototype.string=function(r){let t=globalThis.Buffer.byteLength(r);return this.uint32(t),t>0&&this._push(Fa,t,r),this});function za(r,t,e){t.set(r,e)}function Fa(r,t,e){r.length<40?gn(r,t,e):t.utf8Write!=null?t.utf8Write(r,e):t.set(Ot(r),e)}function On(){return new qe}function pr(r,t){let e=On();return t.encode(r,e,{lengthDelimited:!1}),e.finish()}var Be;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(Be||(Be={}));function mr(r,t,e,n){return{name:r,type:t,encode:e,decode:n}}function kn(r){function t(o){if(r[o.toString()]==null)throw new Error("Invalid enum value");return r[o]}let e=function(s,i){let c=t(s);i.int32(c)},n=function(s){let i=s.int32();return t(i)};return mr("enum",Be.VARINT,e,n)}function xr(r,t){return mr("message",Be.LENGTH_DELIMITED,r,t)}var bt;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1"})(bt||(bt={}));var Mn;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1"})(Mn||(Mn={}));(function(r){r.codec=()=>kn(Mn)})(bt||(bt={}));var Ve;(function(r){let t;r.codec=()=>(t==null&&(t=xr((e,n,o={})=>{o.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),bt.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),o.lengthDelimited!==!1&&n.ldelim()},(e,n,o={})=>{let s={},i=n==null?e.len:e.pos+n;for(;e.pos<i;){let c=e.uint32();switch(c>>>3){case 1:{s.Type=bt.codec().decode(e);break}case 2:{s.Data=e.bytes();break}default:{e.skipType(c&7);break}}}return s})),t),r.encode=e=>pr(e,r.codec()),r.decode=(e,n)=>lr(e,r.codec(),n)})(Ve||(Ve={}));var Hn;(function(r){let t;r.codec=()=>(t==null&&(t=xr((e,n,o={})=>{o.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),bt.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),o.lengthDelimited!==!1&&n.ldelim()},(e,n,o={})=>{let s={},i=n==null?e.len:e.pos+n;for(;e.pos<i;){let c=e.uint32();switch(c>>>3){case 1:{s.Type=bt.codec().decode(e);break}case 2:{s.Data=e.bytes();break}default:{e.skipType(c&7);break}}}return s})),t),r.encode=e=>pr(e,r.codec()),r.decode=(e,n)=>lr(e,r.codec(),n)})(Hn||(Hn={}));var Za=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),jt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Wt=new Uint32Array(64),Kn=class extends Ee{constructor(){super(64,32,8,!1),this.A=jt[0]|0,this.B=jt[1]|0,this.C=jt[2]|0,this.D=jt[3]|0,this.E=jt[4]|0,this.F=jt[5]|0,this.G=jt[6]|0,this.H=jt[7]|0}get(){let{A:t,B:e,C:n,D:o,E:s,F:i,G:c,H:a}=this;return[t,e,n,o,s,i,c,a]}set(t,e,n,o,s,i,c,a){this.A=t|0,this.B=e|0,this.C=n|0,this.D=o|0,this.E=s|0,this.F=i|0,this.G=c|0,this.H=a|0}process(t,e){for(let m=0;m<16;m++,e+=4)Wt[m]=t.getUint32(e,!1);for(let m=16;m<64;m++){let p=Wt[m-15],E=Wt[m-2],y=yt(p,7)^yt(p,18)^p>>>3,g=yt(E,17)^yt(E,19)^E>>>10;Wt[m]=g+Wt[m-7]+y+Wt[m-16]|0}let{A:n,B:o,C:s,D:i,E:c,F:a,G:d,H:u}=this;for(let m=0;m<64;m++){let p=yt(c,6)^yt(c,11)^yt(c,25),E=u+p+qo(c,a,d)+Za[m]+Wt[m]|0,g=(yt(n,2)^yt(n,13)^yt(n,22))+Vo(n,o,s)|0;u=d,d=a,a=c,c=i+E|0,i=s,s=o,o=n,n=E+g|0}n=n+this.A|0,o=o+this.B|0,s=s+this.C|0,i=i+this.D|0,c=c+this.E|0,a=a+this.F|0,d=d+this.G|0,u=u+this.H|0,this.set(n,o,s,i,c,a,d,u)}roundClean(){Wt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var vs=Ye(()=>new Kn);function rt(r,t="utf8"){let e=dr[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.encoder.encode(r).substring(1)}var ze=class extends Error{constructor(t="An error occurred while verifying a message"){super(t),this.name="VerificationError"}};var gr=class extends we{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,Mo(t);let n=_e(e);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let o=this.blockLen,s=new Uint8Array(o);s.set(n.length>o?t.create().update(n).digest():n);for(let i=0;i<s.length;i++)s[i]^=54;this.iHash.update(s),this.oHash=t.create();for(let i=0;i<s.length;i++)s[i]^=106;this.oHash.update(s),s.fill(0)}update(t){return ye(this),this.iHash.update(t),this}digestInto(t){ye(this),be(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){let t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));let{oHash:e,iHash:n,finished:o,destroyed:s,blockLen:i,outputLen:c}=this;return t=t,t.finished=o,t.destroyed=s,t.blockLen=i,t.outputLen=c,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},qn=(r,t,e)=>new gr(r,t).update(e).digest();qn.create=(r,t)=>new gr(r,t);function Ss(r){r.lowS!==void 0&&wt("lowS",r.lowS),r.prehash!==void 0&&wt("prehash",r.prehash)}function ja(r){let t=ke(r);At(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:e,Fp:n,a:o}=t;if(e){if(!n.eql(o,n.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...t})}var{bytesToNumberBE:Wa,hexToBytes:$a}=er,Vn=class extends Error{constructor(t=""){super(t)}},kt={Err:Vn,_tlv:{encode:(r,t)=>{let{Err:e}=kt;if(r<0||r>256)throw new e("tlv.encode: wrong tag");if(t.length&1)throw new e("tlv.encode: unpadded data");let n=t.length/2,o=ee(n);if(o.length/2&128)throw new e("tlv.encode: long form length too big");let s=n>127?ee(o.length/2|128):"";return ee(r)+s+o+t},decode(r,t){let{Err:e}=kt,n=0;if(r<0||r>256)throw new e("tlv.encode: wrong tag");if(t.length<2||t[n++]!==r)throw new e("tlv.decode: wrong tlv");let o=t[n++],s=!!(o&128),i=0;if(!s)i=o;else{let a=o&127;if(!a)throw new e("tlv.decode(long): indefinite length not supported");if(a>4)throw new e("tlv.decode(long): byte length is too big");let d=t.subarray(n,n+a);if(d.length!==a)throw new e("tlv.decode: length bytes not complete");if(d[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(let u of d)i=i<<8|u;if(n+=a,i<128)throw new e("tlv.decode(long): not minimal encoding")}let c=t.subarray(n,n+i);if(c.length!==i)throw new e("tlv.decode: wrong value length");return{v:c,l:t.subarray(n+i)}}},_int:{encode(r){let{Err:t}=kt;if(r<Mt)throw new t("integer: negative integers are not allowed");let e=ee(r);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return e},decode(r){let{Err:t}=kt;if(r[0]&128)throw new t("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return Wa(r)}},toSig(r){let{Err:t,_int:e,_tlv:n}=kt,o=typeof r=="string"?$a(r):r;ve(o);let{v:s,l:i}=n.decode(48,o);if(i.length)throw new t("invalid signature: left bytes after parsing");let{v:c,l:a}=n.decode(2,s),{v:d,l:u}=n.decode(2,a);if(u.length)throw new t("invalid signature: left bytes after parsing");return{r:e.decode(c),s:e.decode(d)}},hexFromSig(r){let{_tlv:t,_int:e}=kt,n=t.encode(2,e.encode(r.r)),o=t.encode(2,e.encode(r.s)),s=n+o;return t.encode(48,s)}},Mt=BigInt(0),st=BigInt(1),Fd=BigInt(2),Bs=BigInt(3),Gd=BigInt(4);function Ya(r){let t=ja(r),{Fp:e}=t,n=Gt(t.n,t.nBitLength),o=t.toBytes||((g,f,w)=>{let B=f.toAffine();return Dt(Uint8Array.from([4]),e.toBytes(B.x),e.toBytes(B.y))}),s=t.fromBytes||(g=>{let f=g.subarray(1),w=e.fromBytes(f.subarray(0,e.BYTES)),B=e.fromBytes(f.subarray(e.BYTES,2*e.BYTES));return{x:w,y:B}});function i(g){let{a:f,b:w}=t,B=e.sqr(g),h=e.mul(B,g);return e.add(e.add(h,e.mul(g,f)),w)}if(!e.eql(e.sqr(t.Gy),i(t.Gx)))throw new Error("bad generator point: equation left != right");function c(g){return De(g,st,t.n)}function a(g){let{allowedPrivateKeyLengths:f,nByteLength:w,wrapPrivateKey:B,n:h}=t;if(f&&typeof g!="bigint"){if(Vt(g)&&(g=Nt(g)),typeof g!="string"||!f.includes(g.length))throw new Error("invalid private key");g=g.padStart(w*2,"0")}let I;try{I=typeof g=="bigint"?g:_t(Y("private key",g,w))}catch{throw new Error("invalid private key, expected hex or "+w+" bytes, got "+typeof g)}return B&&(I=F(I,h)),pt("private key",I,st,h),I}function d(g){if(!(g instanceof p))throw new Error("ProjectivePoint expected")}let u=oe((g,f)=>{let{px:w,py:B,pz:h}=g;if(e.eql(h,e.ONE))return{x:w,y:B};let I=g.is0();f==null&&(f=I?e.ONE:e.inv(h));let N=e.mul(w,f),P=e.mul(B,f),T=e.mul(h,f);if(I)return{x:e.ZERO,y:e.ZERO};if(!e.eql(T,e.ONE))throw new Error("invZ was invalid");return{x:N,y:P}}),m=oe(g=>{if(g.is0()){if(t.allowInfinityPoint&&!e.is0(g.py))return;throw new Error("bad point: ZERO")}let{x:f,y:w}=g.toAffine();if(!e.isValid(f)||!e.isValid(w))throw new Error("bad point: x or y not FE");let B=e.sqr(w),h=i(f);if(!e.eql(B,h))throw new Error("bad point: equation left != right");if(!g.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class p{constructor(f,w,B){if(this.px=f,this.py=w,this.pz=B,f==null||!e.isValid(f))throw new Error("x required");if(w==null||!e.isValid(w))throw new Error("y required");if(B==null||!e.isValid(B))throw new Error("z required");Object.freeze(this)}static fromAffine(f){let{x:w,y:B}=f||{};if(!f||!e.isValid(w)||!e.isValid(B))throw new Error("invalid affine point");if(f instanceof p)throw new Error("projective point not allowed");let h=I=>e.eql(I,e.ZERO);return h(w)&&h(B)?p.ZERO:new p(w,B,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(f){let w=e.invertBatch(f.map(B=>B.pz));return f.map((B,h)=>B.toAffine(w[h])).map(p.fromAffine)}static fromHex(f){let w=p.fromAffine(s(Y("pointHex",f)));return w.assertValidity(),w}static fromPrivateKey(f){return p.BASE.multiply(a(f))}static msm(f,w){return sr(p,n,f,w)}_setWindowSize(f){y.setWindowSize(this,f)}assertValidity(){m(this)}hasEvenY(){let{y:f}=this.toAffine();if(e.isOdd)return!e.isOdd(f);throw new Error("Field doesn't support isOdd")}equals(f){d(f);let{px:w,py:B,pz:h}=this,{px:I,py:N,pz:P}=f,T=e.eql(e.mul(w,P),e.mul(I,h)),R=e.eql(e.mul(B,P),e.mul(N,h));return T&&R}negate(){return new p(this.px,e.neg(this.py),this.pz)}double(){let{a:f,b:w}=t,B=e.mul(w,Bs),{px:h,py:I,pz:N}=this,P=e.ZERO,T=e.ZERO,R=e.ZERO,L=e.mul(h,h),j=e.mul(I,I),q=e.mul(N,N),H=e.mul(h,I);return H=e.add(H,H),R=e.mul(h,N),R=e.add(R,R),P=e.mul(f,R),T=e.mul(B,q),T=e.add(P,T),P=e.sub(j,T),T=e.add(j,T),T=e.mul(P,T),P=e.mul(H,P),R=e.mul(B,R),q=e.mul(f,q),H=e.sub(L,q),H=e.mul(f,H),H=e.add(H,R),R=e.add(L,L),L=e.add(R,L),L=e.add(L,q),L=e.mul(L,H),T=e.add(T,L),q=e.mul(I,N),q=e.add(q,q),L=e.mul(q,H),P=e.sub(P,L),R=e.mul(q,j),R=e.add(R,R),R=e.add(R,R),new p(P,T,R)}add(f){d(f);let{px:w,py:B,pz:h}=this,{px:I,py:N,pz:P}=f,T=e.ZERO,R=e.ZERO,L=e.ZERO,j=t.a,q=e.mul(t.b,Bs),H=e.mul(w,I),tt=e.mul(B,N),S=e.mul(h,P),C=e.add(w,B),x=e.add(I,N);C=e.mul(C,x),x=e.add(H,tt),C=e.sub(C,x),x=e.add(w,h);let l=e.add(I,P);return x=e.mul(x,l),l=e.add(H,S),x=e.sub(x,l),l=e.add(B,h),T=e.add(N,P),l=e.mul(l,T),T=e.add(tt,S),l=e.sub(l,T),L=e.mul(j,x),T=e.mul(q,S),L=e.add(T,L),T=e.sub(tt,L),L=e.add(tt,L),R=e.mul(T,L),tt=e.add(H,H),tt=e.add(tt,H),S=e.mul(j,S),x=e.mul(q,x),tt=e.add(tt,S),S=e.sub(H,S),S=e.mul(j,S),x=e.add(x,S),H=e.mul(tt,x),R=e.add(R,H),H=e.mul(l,x),T=e.mul(C,T),T=e.sub(T,H),H=e.mul(C,tt),L=e.mul(l,L),L=e.add(L,H),new p(T,R,L)}subtract(f){return this.add(f.negate())}is0(){return this.equals(p.ZERO)}wNAF(f){return y.wNAFCached(this,f,p.normalizeZ)}multiplyUnsafe(f){let{endo:w,n:B}=t;pt("scalar",f,Mt,B);let h=p.ZERO;if(f===Mt)return h;if(this.is0()||f===st)return this;if(!w||y.hasPrecomputes(this))return y.wNAFCachedUnsafe(this,f,p.normalizeZ);let{k1neg:I,k1:N,k2neg:P,k2:T}=w.splitScalar(f),R=h,L=h,j=this;for(;N>Mt||T>Mt;)N&st&&(R=R.add(j)),T&st&&(L=L.add(j)),j=j.double(),N>>=st,T>>=st;return I&&(R=R.negate()),P&&(L=L.negate()),L=new p(e.mul(L.px,w.beta),L.py,L.pz),R.add(L)}multiply(f){let{endo:w,n:B}=t;pt("scalar",f,st,B);let h,I;if(w){let{k1neg:N,k1:P,k2neg:T,k2:R}=w.splitScalar(f),{p:L,f:j}=this.wNAF(P),{p:q,f:H}=this.wNAF(R);L=y.constTimeNegate(N,L),q=y.constTimeNegate(T,q),q=new p(e.mul(q.px,w.beta),q.py,q.pz),h=L.add(q),I=j.add(H)}else{let{p:N,f:P}=this.wNAF(f);h=N,I=P}return p.normalizeZ([h,I])[0]}multiplyAndAddUnsafe(f,w,B){let h=p.BASE,I=(P,T)=>T===Mt||T===st||!P.equals(h)?P.multiplyUnsafe(T):P.multiply(T),N=I(this,w).add(I(f,B));return N.is0()?void 0:N}toAffine(f){return u(this,f)}isTorsionFree(){let{h:f,isTorsionFree:w}=t;if(f===st)return!0;if(w)return w(p,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:f,clearCofactor:w}=t;return f===st?this:w?w(p,this):this.multiplyUnsafe(t.h)}toRawBytes(f=!0){return wt("isCompressed",f),this.assertValidity(),o(p,this,f)}toHex(f=!0){return wt("isCompressed",f),Nt(this.toRawBytes(f))}}p.BASE=new p(t.Gx,t.Gy,e.ONE),p.ZERO=new p(e.ZERO,e.ONE,e.ZERO);let E=t.nBitLength,y=or(p,t.endo?Math.ceil(E/2):E);return{CURVE:t,ProjectivePoint:p,normPrivateKeyToScalar:a,weierstrassEquation:i,isWithinCurveOrder:c}}function Xa(r){let t=ke(r);return At(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function As(r){let t=Xa(r),{Fp:e,n}=t,o=e.BYTES+1,s=2*e.BYTES+1;function i(S){return F(S,n)}function c(S){return rr(S,n)}let{ProjectivePoint:a,normPrivateKeyToScalar:d,weierstrassEquation:u,isWithinCurveOrder:m}=Ya({...t,toBytes(S,C,x){let l=C.toAffine(),b=e.toBytes(l.x),A=Dt;return wt("isCompressed",x),x?A(Uint8Array.from([C.hasEvenY()?2:3]),b):A(Uint8Array.from([4]),b,e.toBytes(l.y))},fromBytes(S){let C=S.length,x=S[0],l=S.subarray(1);if(C===o&&(x===2||x===3)){let b=_t(l);if(!De(b,st,e.ORDER))throw new Error("Point is not on curve");let A=u(b),_;try{_=e.sqrt(A)}catch(K){let O=K instanceof Error?": "+K.message:"";throw new Error("Point is not on curve"+O)}let D=(_&st)===st;return(x&1)===1!==D&&(_=e.neg(_)),{x:b,y:_}}else if(C===s&&x===4){let b=e.fromBytes(l.subarray(0,e.BYTES)),A=e.fromBytes(l.subarray(e.BYTES,2*e.BYTES));return{x:b,y:A}}else{let b=o,A=s;throw new Error("invalid Point, expected length of "+b+", or uncompressed "+A+", got "+C)}}}),p=S=>Nt(Ft(S,t.nByteLength));function E(S){let C=n>>st;return S>C}function y(S){return E(S)?i(-S):S}let g=(S,C,x)=>_t(S.slice(C,x));class f{constructor(C,x,l){this.r=C,this.s=x,this.recovery=l,this.assertValidity()}static fromCompact(C){let x=t.nByteLength;return C=Y("compactSignature",C,x*2),new f(g(C,0,x),g(C,x,2*x))}static fromDER(C){let{r:x,s:l}=kt.toSig(Y("DER",C));return new f(x,l)}assertValidity(){pt("r",this.r,st,n),pt("s",this.s,st,n)}addRecoveryBit(C){return new f(this.r,this.s,C)}recoverPublicKey(C){let{r:x,s:l,recovery:b}=this,A=P(Y("msgHash",C));if(b==null||![0,1,2,3].includes(b))throw new Error("recovery id invalid");let _=b===2||b===3?x+t.n:x;if(_>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");let D=b&1?"03":"02",M=a.fromHex(D+p(_)),K=c(_),O=i(-A*K),z=i(l*K),Z=a.BASE.multiplyAndAddUnsafe(M,O,z);if(!Z)throw new Error("point at infinify");return Z.assertValidity(),Z}hasHighS(){return E(this.s)}normalizeS(){return this.hasHighS()?new f(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return re(this.toDERHex())}toDERHex(){return kt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return re(this.toCompactHex())}toCompactHex(){return p(this.r)+p(this.s)}}let w={isValidPrivateKey(S){try{return d(S),!0}catch{return!1}},normPrivateKeyToScalar:d,randomPrivateKey:()=>{let S=en(t.n);return Xo(t.randomBytes(S),t.n)},precompute(S=8,C=a.BASE){return C._setWindowSize(S),C.multiply(BigInt(3)),C}};function B(S,C=!0){return a.fromPrivateKey(S).toRawBytes(C)}function h(S){let C=Vt(S),x=typeof S=="string",l=(C||x)&&S.length;return C?l===o||l===s:x?l===2*o||l===2*s:S instanceof a}function I(S,C,x=!0){if(h(S))throw new Error("first arg must be private key");if(!h(C))throw new Error("second arg must be public key");return a.fromHex(C).multiply(d(S)).toRawBytes(x)}let N=t.bits2int||function(S){if(S.length>8192)throw new Error("input is too large");let C=_t(S),x=S.length*8-t.nBitLength;return x>0?C>>BigInt(x):C},P=t.bits2int_modN||function(S){return i(N(S))},T=Oe(t.nBitLength);function R(S){return pt("num < 2^"+t.nBitLength,S,Mt,T),Ft(S,t.nByteLength)}function L(S,C,x=j){if(["recovered","canonical"].some(ot=>ot in x))throw new Error("sign() legacy options not supported");let{hash:l,randomBytes:b}=t,{lowS:A,prehash:_,extraEntropy:D}=x;A==null&&(A=!0),S=Y("msgHash",S),Ss(x),_&&(S=Y("prehashed msgHash",l(S)));let M=P(S),K=d(C),O=[R(K),R(M)];if(D!=null&&D!==!1){let ot=D===!0?b(e.BYTES):D;O.push(Y("extraEntropy",ot))}let z=Dt(...O),Z=M;function nt(ot){let it=N(ot);if(!m(it))return;let ct=c(it),dt=a.BASE.multiply(it).toAffine(),ft=i(dt.x);if(ft===Mt)return;let Bt=i(ct*i(Z+ft*K));if(Bt===Mt)return;let Tt=(dt.x===ft?0:2)|Number(dt.y&st),Le=Bt;return A&&E(Bt)&&(Le=y(Bt),Tt^=1),new f(ft,Le,Tt)}return{seed:z,k2sig:nt}}let j={lowS:t.lowS,prehash:!1},q={lowS:t.lowS,prehash:!1};function H(S,C,x=j){let{seed:l,k2sig:b}=L(S,C,x),A=t;return Xr(A.hash.outputLen,A.nByteLength,A.hmac)(l,b)}a.BASE._setWindowSize(8);function tt(S,C,x,l=q){let b=S;C=Y("msgHash",C),x=Y("publicKey",x);let{lowS:A,prehash:_,format:D}=l;if(Ss(l),"strict"in l)throw new Error("options.strict was renamed to lowS");if(D!==void 0&&D!=="compact"&&D!=="der")throw new Error("format must be compact or der");let M=typeof b=="string"||Vt(b),K=!M&&!D&&typeof b=="object"&&b!==null&&typeof b.r=="bigint"&&typeof b.s=="bigint";if(!M&&!K)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let O,z;try{if(K&&(O=new f(b.r,b.s)),M){try{D!=="compact"&&(O=f.fromDER(b))}catch(Tt){if(!(Tt instanceof kt.Err))throw Tt}!O&&D!=="der"&&(O=f.fromCompact(b))}z=a.fromHex(x)}catch{return!1}if(!O||A&&O.hasHighS())return!1;_&&(C=t.hash(C));let{r:Z,s:nt}=O,ot=P(C),it=c(nt),ct=i(ot*it),dt=i(Z*it),ft=a.BASE.multiplyAndAddUnsafe(z,ct,dt)?.toAffine();return ft?i(ft.x)===Z:!1}return{CURVE:t,getPublicKey:B,getSharedSecret:I,sign:H,verify:tt,ProjectivePoint:a,Signature:f,utils:w}}function Qa(r){return{hash:r,hmac:(t,...e)=>qn(r,t,Fr(...e)),randomBytes:Xe}}function Is(r,t){let e=n=>As({...r,...Qa(n)});return{...e(t),create:e}}var Cs=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Ts=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Ja=BigInt(1),zn=BigInt(2),Ls=(r,t)=>(r+t/zn)/t;function tu(r){let t=Cs,e=BigInt(3),n=BigInt(6),o=BigInt(11),s=BigInt(22),i=BigInt(23),c=BigInt(44),a=BigInt(88),d=r*r*r%t,u=d*d*r%t,m=$(u,e,t)*u%t,p=$(m,e,t)*u%t,E=$(p,zn,t)*d%t,y=$(E,o,t)*E%t,g=$(y,s,t)*y%t,f=$(g,c,t)*g%t,w=$(f,a,t)*f%t,B=$(w,c,t)*g%t,h=$(B,e,t)*u%t,I=$(h,i,t)*y%t,N=$(I,n,t)*d%t,P=$(N,zn,t);if(!Fn.eql(Fn.sqr(P),r))throw new Error("Cannot find square root");return P}var Fn=Gt(Cs,void 0,void 0,{sqrt:tu}),ue=Is({a:BigInt(0),b:BigInt(7),Fp:Fn,n:Ts,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{let t=Ts,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Ja*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=e,i=BigInt("0x100000000000000000000000000000000"),c=Ls(s*r,t),a=Ls(-n*r,t),d=F(r-c*e-a*o,t),u=F(-c*n-a*s,t),m=d>i,p=u>i;if(m&&(d=t-d),p&&(u=t-u),d>i||u>i)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:m,k1:d,k2neg:p,k2:u}}}},vs),th=BigInt(0);var eh=ue.ProjectivePoint;function It(r,t){t==null&&(t=r.reduce((o,s)=>o+s.length,0));let e=vt(t),n=0;for(let o of r)e.set(o,n),n+=o.length;return e}function Rs(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}function Ps(r,t,e){let n=Me.digest(e instanceof Uint8Array?e:e.subarray());if(Rs(n))return n.then(({digest:o})=>ue.verify(t,o,r)).catch(o=>{throw new ze(String(o))});try{return ue.verify(t,n.digest,r)}catch(o){throw new ze(String(o))}}var br=class{type="secp256k1";raw;_key;constructor(t){this._key=Ns(t),this.raw=Us(this._key)}toMultihash(){return Rt.digest(ur(this))}toCID(){return lt.createV1(114,this.toMultihash())}toString(){return Q.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:Pt(this.raw,t.raw)}verify(t,e){return Ps(this._key,e,t)}};function _s(r){return new br(r)}function Us(r){return ue.ProjectivePoint.fromHex(r).toRawBytes(!0)}function Ns(r){try{return ue.ProjectivePoint.fromHex(r),r}catch(t){throw new Ge(String(t))}}function Ds(r){let{Type:t,Data:e}=Ve.decode(r.digest),n=e??new Uint8Array;switch(t){case bt.Ed25519:return cs(n);case bt.secp256k1:return _s(n);default:throw new Ce}}function ur(r){return Ve.encode({Type:bt[r.type],Data:r.raw})}var Os=Symbol.for("nodejs.util.inspect.custom"),eu=114,Fe=class{type;multihash;publicKey;string;constructor(t){this.type=t.type,this.multihash=t.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}[Nr]=!0;toString(){return this.string==null&&(this.string=Q.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return lt.createV1(eu,this.multihash)}toJSON(){return this.toString()}equals(t){if(t==null)return!1;if(t instanceof Uint8Array)return Pt(this.multihash.bytes,t);if(typeof t=="string")return this.toString()===t;if(t?.toMultihash()?.bytes!=null)return Pt(this.multihash.bytes,t.toMultihash().bytes);throw new Error("not valid Id")}[Os](){return`PeerId(${this.toString()})`}},yr=class extends Fe{type="RSA";publicKey;constructor(t){super({...t,type:"RSA"}),this.publicKey=t.publicKey}},wr=class extends Fe{type="Ed25519";publicKey;constructor(t){super({...t,type:"Ed25519"}),this.publicKey=t.publicKey}},Er=class extends Fe{type="secp256k1";publicKey;constructor(t){super({...t,type:"secp256k1"}),this.publicKey=t.publicKey}},ru=2336,vr=class{type="url";multihash;publicKey;url;constructor(t){this.url=t.toString(),this.multihash=Rt.digest(Ot(this.url))}[Os](){return`PeerId(${this.url})`}[Nr]=!0;toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return lt.createV1(ru,this.toMultihash())}toJSON(){return this.toString()}equals(t){return t==null?!1:(t instanceof Uint8Array&&(t=rt(t)),t.toString()===this.toString())}};function ks(r,t){let e;if(r.charAt(0)==="1"||r.charAt(0)==="Q")e=Qt(Q.decode(`z${r}`));else{if(t==null)throw new he('Please pass a multibase decoder for strings that do not start with "1" or "Q"');e=Qt(t.decode(r))}return nu(e)}function nu(r){if(su(r))return new yr({multihash:r});if(ou(r))try{let t=Ds(r);if(t.type==="Ed25519")return new wr({multihash:r,publicKey:t});if(t.type==="secp256k1")return new Er({multihash:r,publicKey:t})}catch{let e=rt(r.digest);return new vr(new URL(e))}throw new Ze("Supplied PeerID Multihash is invalid")}function ou(r){return r.code===Rt.code}function su(r){return r.code===Me.code}var Sr=class{index=0;input="";new(t){return this.index=0,this.input=t,this}readAtomically(t){let e=this.index,n=t();return n===void 0&&(this.index=e),n}parseWith(t){let e=t();if(this.index===this.input.length)return e}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(t){return this.readAtomically(()=>{let e=this.readChar();if(e===t)return e})}readSeparator(t,e,n){return this.readAtomically(()=>{if(!(e>0&&this.readGivenChar(t)===void 0))return n()})}readNumber(t,e,n,o){return this.readAtomically(()=>{let s=0,i=0,c=this.peekChar();if(c===void 0)return;let a=c==="0",d=2**(8*o)-1;for(;;){let u=this.readAtomically(()=>{let m=this.readChar();if(m===void 0)return;let p=Number.parseInt(m,t);if(!Number.isNaN(p))return p});if(u===void 0)break;if(s*=t,s+=u,s>d||(i+=1,e!==void 0&&i>e))return}if(i!==0)return!n&&a&&i>1?void 0:s})}readIPv4Addr(){return this.readAtomically(()=>{let t=new Uint8Array(4);for(let e=0;e<t.length;e++){let n=this.readSeparator(".",e,()=>this.readNumber(10,3,!1,1));if(n===void 0)return;t[e]=n}return t})}readIPv6Addr(){let t=e=>{for(let n=0;n<e.length/2;n++){let o=n*2;if(n<e.length-3){let i=this.readSeparator(":",n,()=>this.readIPv4Addr());if(i!==void 0)return e[o]=i[0],e[o+1]=i[1],e[o+2]=i[2],e[o+3]=i[3],[o+4,!0]}let s=this.readSeparator(":",n,()=>this.readNumber(16,4,!0,2));if(s===void 0)return[o,!1];e[o]=s>>8,e[o+1]=s&255}return[e.length,!1]};return this.readAtomically(()=>{let e=new Uint8Array(16),[n,o]=t(e);if(n===16)return e;if(o||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;let s=new Uint8Array(14),i=16-(n+2),[c]=t(s.subarray(0,i));return e.set(s.subarray(0,c),16-c),e})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}};var Ms=45,iu=15,Ae=new Sr;function Gn(r){if(!(r.length>iu))return Ae.new(r).parseWith(()=>Ae.readIPv4Addr())}function Zn(r){if(r.includes("%")&&(r=r.split("%")[0]),!(r.length>Ms))return Ae.new(r).parseWith(()=>Ae.readIPv6Addr())}function Br(r){if(r.includes("%")&&(r=r.split("%")[0]),!(r.length>Ms))return Ae.new(r).parseWith(()=>Ae.readIPAddr())}var xp=parseInt("0xFFFF",16),gp=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function qs(r){return!!Gn(r)}function Vs(r){return!!Zn(r)}function Ar(r){return!!Br(r)}var zs=qs,lu=Vs,jn=function(r){let t=0;if(r=r.toString().trim(),zs(r)){let e=new Uint8Array(t+4);return r.split(/\./g).forEach(n=>{e[t++]=parseInt(n,10)&255}),e}if(lu(r)){let e=r.split(":",8),n;for(n=0;n<e.length;n++){let s=zs(e[n]),i;s&&(i=jn(e[n]),e[n]=rt(i.slice(0,2),"base16")),i!=null&&++n<8&&e.splice(n,0,rt(i.slice(2,4),"base16"))}if(e[0]==="")for(;e.length<8;)e.unshift("0");else if(e[e.length-1]==="")for(;e.length<8;)e.push("0");else if(e.length<8){for(n=0;n<e.length&&e[n]!=="";n++);let s=[n,1];for(n=9-e.length;n>0;n--)s.push("0");e.splice.apply(e,s)}let o=new Uint8Array(t+16);for(n=0;n<e.length;n++){let s=parseInt(e[n],16);o[t++]=s>>8&255,o[t++]=s&255}return o}throw new Error("invalid ip address")},Fs=function(r,t=0,e){t=~~t,e=e??r.length-t;let n=new DataView(r.buffer);if(e===4){let o=[];for(let s=0;s<e;s++)o.push(r[t+s]);return o.join(".")}if(e===16){let o=[];for(let s=0;s<e;s+=2)o.push(n.getUint16(t+s).toString(16));return o.join(":").replace(/(^|:)0(:0)*:0(:|$)/,"$1::$3").replace(/:{3,4}/,"::")}return""};var Ie={},Wn={},hu=[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,-1,"ip6zone"],[43,8,"ipcidr"],[53,-1,"dns",!0],[54,-1,"dns4",!0],[55,-1,"dns6",!0],[56,-1,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc-direct"],[281,0,"webrtc"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,-1,"unix",!1,!0],[421,-1,"ipfs"],[421,-1,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,-1,"garlic64"],[448,0,"tls"],[449,-1,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,-1,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[481,-1,"http-path"],[777,-1,"memory"]];hu.forEach(r=>{let t=pu(...r);Wn[t.code]=t,Ie[t.name]=t});function pu(r,t,e,n,o){return{code:r,size:t,name:e,resolvable:!!n,path:!!o}}function G(r){if(typeof r=="number"){if(Wn[r]!=null)return Wn[r];throw new Error(`no protocol with code: ${r}`)}else if(typeof r=="string"){if(Ie[r]!=null)return Ie[r];throw new Error(`no protocol with name: ${r}`)}throw new Error(`invalid protocol id type: ${typeof r}`)}var t0=G("ip4"),e0=G("ip6"),r0=G("ipcidr");function Qn(r,t){switch(G(r).code){case 4:case 41:return xu(t);case 42:return Xn(t);case 43:return rt(t,"base10");case 6:case 273:case 33:case 132:return js(t).toString();case 53:case 54:case 55:case 56:case 400:case 449:case 777:return Xn(t);case 421:return wu(t);case 444:return Zs(t);case 445:return Zs(t);case 466:return yu(t);case 481:return globalThis.encodeURIComponent(Xn(t));default:return rt(t,"base16")}}function Jn(r,t){switch(G(r).code){case 4:return Gs(t);case 41:return Gs(t);case 42:return Yn(t);case 43:return Ot(t,"base10");case 6:case 273:case 33:case 132:return to(parseInt(t,10));case 53:case 54:case 55:case 56:case 400:case 449:case 777:return Yn(t);case 421:return gu(t);case 444:return Eu(t);case 445:return vu(t);case 466:return bu(t);case 481:return Yn(globalThis.decodeURIComponent(t));default:return Ot(t,"base16")}}var $n=Object.values(He).map(r=>r.decoder),mu=function(){let r=$n[0].or($n[1]);return $n.slice(2).forEach(t=>r=r.or(t)),r}();function Gs(r){if(!Ar(r))throw new Error("invalid ip address");return jn(r)}function xu(r){let t=Fs(r,0,r.length);if(t==null)throw new Error("ipBuff is required");if(!Ar(t))throw new Error("invalid ip address");return t}function to(r){let t=new ArrayBuffer(2);return new DataView(t).setUint16(0,r),new Uint8Array(t)}function js(r){return new DataView(r.buffer).getUint16(r.byteOffset)}function Yn(r){let t=Ot(r),e=Uint8Array.from(Se(t.length));return It([e,t],e.length+t.length)}function Xn(r){let t=ie(r);if(r=r.slice(xt(t)),r.length!==t)throw new Error("inconsistent lengths");return rt(r)}function gu(r){let t;r[0]==="Q"||r[0]==="1"?t=Qt(Q.decode(`z${r}`)).bytes:t=lt.parse(r).multihash.bytes;let e=Uint8Array.from(Se(t.length));return It([e,t],e.length+t.length)}function bu(r){let t=mu.decode(r),e=Uint8Array.from(Se(t.length));return It([e,t],e.length+t.length)}function yu(r){let t=ie(r),e=r.slice(xt(t));if(e.length!==t)throw new Error("inconsistent lengths");return"u"+rt(e,"base64url")}function wu(r){let t=ie(r),e=r.slice(xt(t));if(e.length!==t)throw new Error("inconsistent lengths");return rt(e,"base58btc")}function Eu(r){let t=r.split(":");if(t.length!==2)throw new Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(t[0].length!==16)throw new Error(`failed to parse onion addr: ${t[0]} not a Tor onion address.`);let e=Ct.decode("b"+t[0]),n=parseInt(t[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");let o=to(n);return It([e,o],e.length+o.length)}function vu(r){let t=r.split(":");if(t.length!==2)throw new Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(t[0].length!==56)throw new Error(`failed to parse onion addr: ${t[0]} not a Tor onion3 address.`);let e=Ct.decode(`b${t[0]}`),n=parseInt(t[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");let o=to(n);return It([e,o],e.length+o.length)}function Zs(r){let t=r.slice(0,r.length-2),e=r.slice(r.length-2),n=rt(t,"base32"),o=js(e);return`${n}:${o}`}function Ws(r){r=eo(r);let t=[],e=[],n=null,o=r.split("/").slice(1);if(o.length===1&&o[0]==="")return{bytes:new Uint8Array,string:"/",tuples:[],stringTuples:[],path:null};for(let s=0;s<o.length;s++){let i=o[s],c=G(i);if(c.size===0){t.push([c.code]),e.push([c.code]);continue}if(s++,s>=o.length)throw Ys("invalid address: "+r);if(c.path===!0){n=eo(o.slice(s).join("/")),t.push([c.code,Jn(c.code,n)]),e.push([c.code,n]);break}let a=Jn(c.code,o[s]);t.push([c.code,a]),e.push([c.code,Qn(c.code,a)])}return{string:$s(e),bytes:no(t),tuples:t,stringTuples:e,path:n}}function ro(r){let t=[],e=[],n=null,o=0;for(;o<r.length;){let s=ie(r,o),i=xt(s),c=G(s),a=Su(c,r.slice(o+i));if(a===0){t.push([s]),e.push([s]),o+=i;continue}let d=r.slice(o+i,o+i+a);if(o+=a+i,o>r.length)throw Ys("Invalid address Uint8Array: "+rt(r,"base16"));t.push([s,d]);let u=Qn(s,d);if(e.push([s,u]),c.path===!0){n=u;break}}return{bytes:Uint8Array.from(r),string:$s(e),tuples:t,stringTuples:e,path:n}}function $s(r){let t=[];return r.map(e=>{let n=G(e[0]);return t.push(n.name),e.length>1&&e[1]!=null&&t.push(e[1]),null}),eo(t.join("/"))}function no(r){return It(r.map(t=>{let e=G(t[0]),n=Uint8Array.from(Se(e.code));return t.length>1&&t[1]!=null&&(n=It([n,t[1]])),n}))}function Su(r,t){if(r.size>0)return r.size/8;if(r.size===0)return 0;{let e=ie(t instanceof Uint8Array?t:Uint8Array.from(t));return e+xt(e)}}function eo(r){return"/"+r.trim().split("/").filter(t=>t).join("/")}function Ys(r){return new Error("Error parsing address: "+r)}var Bu=Symbol.for("nodejs.util.inspect.custom"),so=Symbol.for("@multiformats/js-multiaddr/multiaddr"),Au=[G("dns").code,G("dns4").code,G("dns6").code,G("dnsaddr").code],oo=class extends Error{constructor(t="No available resolver"){super(t),this.name="NoAvailableResolverError"}},Ir=class r{bytes;#t;#e;#r;#n;[so]=!0;constructor(t){t==null&&(t="");let e;if(t instanceof Uint8Array)e=ro(t);else if(typeof t=="string"){if(t.length>0&&t.charAt(0)!=="/")throw new Error(`multiaddr "${t}" must start with a "/"`);e=Ws(t)}else if(Qs(t))e=ro(t.bytes);else throw new Error("addr must be a string, Buffer, or another Multiaddr");this.bytes=e.bytes,this.#t=e.string,this.#e=e.tuples,this.#r=e.stringTuples,this.#n=e.path}toString(){return this.#t}toJSON(){return this.toString()}toOptions(){let t,e,n,o,s="",i=G("tcp"),c=G("udp"),a=G("ip4"),d=G("ip6"),u=G("dns6"),m=G("ip6zone");for(let[E,y]of this.stringTuples())E===m.code&&(s=`%${y??""}`),Au.includes(E)&&(e=i.name,o=443,n=`${y??""}${s}`,t=E===u.code?6:4),(E===i.code||E===c.code)&&(e=G(E).name,o=parseInt(y??"")),(E===a.code||E===d.code)&&(e=G(E).name,n=`${y??""}${s}`,t=E===d.code?6:4);if(t==null||e==null||n==null||o==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:t,host:n,transport:e,port:o}}protos(){return this.#e.map(([t])=>Object.assign({},G(t)))}protoCodes(){return this.#e.map(([t])=>t)}protoNames(){return this.#e.map(([t])=>G(t).name)}tuples(){return this.#e.map(([t,e])=>e==null?[t]:[t,e])}stringTuples(){return this.#r.map(([t,e])=>e==null?[t]:[t,e])}encapsulate(t){return t=new r(t),new r(this.toString()+t.toString())}decapsulate(t){let e=t.toString(),n=this.toString(),o=n.lastIndexOf(e);if(o<0)throw new Error(`Address ${this.toString()} does not contain subaddress: ${t.toString()}`);return new r(n.slice(0,o))}decapsulateCode(t){let e=this.tuples();for(let n=e.length-1;n>=0;n--)if(e[n][0]===t)return new r(no(e.slice(0,n)));return this}getPeerId(){try{let t=[];this.stringTuples().forEach(([n,o])=>{n===Ie.p2p.code&&t.push([n,o]),n===Ie["p2p-circuit"].code&&(t=[])});let e=t.pop();if(e?.[1]!=null){let n=e[1];return n[0]==="Q"||n[0]==="1"?rt(Q.decode(`z${n}`),"base58btc"):rt(lt.parse(n).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){return this.#n}equals(t){return Pt(this.bytes,t.bytes)}async resolve(t){let e=this.protos().find(s=>s.resolvable);if(e==null)return[this];let n=Xs.get(e.name);if(n==null)throw new oo(`no available resolver for ${e.name}`);return(await n(this,t)).map(s=>$t(s))}nodeAddress(){let t=this.toOptions();if(t.transport!=="tcp"&&t.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${t.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:t.family,address:t.host,port:t.port}}isThinWaistAddress(t){let e=(t??this).protos();return!(e.length!==2||e[0].code!==4&&e[0].code!==41||e[1].code!==6&&e[1].code!==273)}[Bu](){return`Multiaddr(${this.#t})`}};var Xs=new Map;function Qs(r){return!!r?.[so]}function $t(r){return new Ir(r)}var Iu=v("dns4"),Tu=v("dns6"),Lu=v("dnsaddr"),le=J(v("dns"),Lu,Iu,Tu),Cr=J(v("ip4"),v("ip6")),Te=J(U(Cr,v("tcp")),U(le,v("tcp"))),Rr=U(Cr,v("udp")),Cu=U(Rr,v("utp")),Ru=U(Rr,v("quic")),Pu=U(Rr,v("quic-v1")),io=J(U(Te,v("ws")),U(le,v("ws"))),Tr=J(U(io,v("p2p")),io),co=J(U(Te,v("wss")),U(le,v("wss")),U(Te,v("tls"),v("ws")),U(le,v("tls"),v("ws"))),Lr=J(U(co,v("p2p")),co),ao=J(U(Te,v("http")),U(Cr,v("http")),U(le,v("http"))),uo=J(U(Te,v("https")),U(Cr,v("https")),U(le,v("https"))),Js=U(Rr,v("webrtc-direct"),v("certhash")),ri=J(U(Js,v("p2p")),Js),ti=U(Pu,v("webtransport"),v("certhash"),v("certhash")),ni=J(U(ti,v("p2p")),ti),oi=J(U(Tr,v("p2p-webrtc-star"),v("p2p")),U(Lr,v("p2p-webrtc-star"),v("p2p")),U(Tr,v("p2p-webrtc-star")),U(Lr,v("p2p-webrtc-star"))),T0=J(U(Tr,v("p2p-websocket-star"),v("p2p")),U(Lr,v("p2p-websocket-star"),v("p2p")),U(Tr,v("p2p-websocket-star")),U(Lr,v("p2p-websocket-star"))),si=J(U(ao,v("p2p-webrtc-direct"),v("p2p")),U(uo,v("p2p-webrtc-direct"),v("p2p")),U(ao,v("p2p-webrtc-direct")),U(uo,v("p2p-webrtc-direct"))),de=J(io,co,ao,uo,oi,si,Te,Cu,Ru,le,ri,ni),L0=J(U(de,v("p2p-stardust"),v("p2p")),U(de,v("p2p-stardust"))),Yt=J(U(de,v("p2p")),oi,si,ri,ni,v("p2p")),ei=J(U(Yt,v("p2p-circuit"),Yt),U(Yt,v("p2p-circuit")),U(v("p2p-circuit"),Yt),U(de,v("p2p-circuit")),U(v("p2p-circuit"),de),v("p2p-circuit")),ii=()=>J(U(ei,ii),ei),fe=ii(),ci=J(U(fe,Yt,fe),U(Yt,fe),U(fe,Yt),fe,Yt);var C0=J(U(fe,v("webrtc"),v("p2p")),U(fe,v("webrtc")),U(de,v("webrtc"),v("p2p")),U(de,v("webrtc")),v("webrtc"));function ai(r){function t(e){let n;try{n=$t(e)}catch{return!1}let o=r(n.protoNames());return o===null?!1:o===!0||o===!1?o:o.length===0}return t}function U(...r){function t(e){if(e.length<r.length)return null;let n=e;return r.some(o=>(n=typeof o=="function"?o().partialMatch(e):o.partialMatch(e),Array.isArray(n)&&(e=n),n===null)),n}return{toString:function(){return"{ "+r.join(" ")+" }"},input:r,matches:ai(t),partialMatch:t}}function J(...r){function t(n){let o=null;return r.some(s=>{let i=typeof s=="function"?s().partialMatch(n):s.partialMatch(n);return i!=null?(o=i,!0):!1}),o}return{toString:function(){return"{ "+r.join(" ")+" }"},input:r,matches:ai(t),partialMatch:t}}function v(r){let t=r;function e(o){let s;try{s=$t(o)}catch{return!1}let i=s.protoNames();return i.length===1&&i[0]===t}function n(o){return o.length===0?null:o[0]===t?o.slice(1):null}return{toString:function(){return t},matches:e,partialMatch:n}}var Uu="bootstrap",Nu=50,_u=1e3,fo=class extends je{static tag="bootstrap";log;timer;list;timeout;components;_init;constructor(t,e={list:[]}){if(e.list==null||e.list.length===0)throw new Error("Bootstrap requires a list of peer addresses");super(),this.components=t,this.log=t.logger.forComponent("libp2p:bootstrap"),this.timeout=e.timeout??_u,this.list=[];for(let n of e.list){if(!ci.matches(n)){this.log.error("Invalid multiaddr");continue}let o=$t(n),s=o.getPeerId();if(s==null){this.log.error("Invalid bootstrap multiaddr without peer id");continue}let i={id:ks(s),multiaddrs:[o]};this.list.push(i)}this._init=e}[yo]=this;[Symbol.toStringTag]="@libp2p/bootstrap";[Eo]=["@libp2p/peer-discovery"];isStarted(){return!!this.timer}start(){this.isStarted()||(this.log("Starting bootstrap node discovery, discovering peers after %s ms",this.timeout),this.timer=setTimeout(()=>{this._discoverBootstrapPeers().catch(t=>{this.log.error(t)})},this.timeout))}async _discoverBootstrapPeers(){if(this.timer!=null)for(let t of this.list){if(await this.components.peerStore.merge(t.id,{tags:{[this._init.tagName??Uu]:{value:this._init.tagValue??Nu,ttl:this._init.tagTTL}},multiaddrs:t.multiaddrs}),this.timer==null)return;this.safeDispatchEvent("peer",{detail:t}),this.components.connectionManager.openConnection(t.id).catch(e=>{this.log.error("could not dial bootstrap peer %p",t.id,e)})}}stop(){this.timer!=null&&clearTimeout(this.timer),this.timer=void 0}};function Du(r){return t=>new fo(t,r)}return Ei(Ou);})();
./node_modules/@libp2p/http-fetch/dist/src/auth/client.js:18:        crypto.getRandomValues(randomBytes);
./node_modules/@libp2p/http-fetch/dist/src/auth/server.js:217:        crypto.getRandomValues(randomBytes);
./node_modules/@libp2p/http-fetch/dist/src/ping.js:34:    crypto.getRandomValues(buf);
./node_modules/@libp2p/http-fetch/src/ping.ts:41:  crypto.getRandomValues(buf)
./node_modules/@libp2p/http-fetch/src/auth/client.ts:71:    crypto.getRandomValues(randomBytes)
./node_modules/@libp2p/http-fetch/src/auth/server.ts:251:    crypto.getRandomValues(randomBytes)
./node_modules/@libp2p/peer-store/dist/index.min.js:2:"use strict";var Libp2PPeerStore=(()=>{var Gl=Object.create;var Qr=Object.defineProperty;var Wl=Object.getOwnPropertyDescriptor;var Zl=Object.getOwnPropertyNames;var jl=Object.getPrototypeOf,Yl=Object.prototype.hasOwnProperty;var qo=(r,t)=>()=>(t||r((t={exports:{}}).exports,t),t.exports),xt=(r,t)=>{for(var e in t)Qr(r,e,{get:t[e],enumerable:!0})},zo=(r,t,e,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of Zl(t))!Yl.call(r,s)&&s!==e&&Qr(r,s,{get:()=>t[s],enumerable:!(n=Wl(t,s))||n.enumerable});return r};var $o=(r,t,e)=>(e=r!=null?Gl(jl(r)):{},zo(t||!r||!r.__esModule?Qr(e,"default",{value:r,enumerable:!0}):e,r)),Jl=r=>zo(Qr({},"__esModule",{value:!0}),r);var Ga=qo(nr=>{"use strict";var Bh="[object ArrayBuffer]",ne=class r{static isArrayBuffer(t){return Object.prototype.toString.call(t)===Bh}static toArrayBuffer(t){return this.isArrayBuffer(t)?t:t.byteLength===t.buffer.byteLength||t.byteOffset===0&&t.byteLength===t.buffer.byteLength?t.buffer:this.toUint8Array(t.buffer).slice(t.byteOffset,t.byteOffset+t.byteLength).buffer}static toUint8Array(t){return this.toView(t,Uint8Array)}static toView(t,e){if(t.constructor===e)return t;if(this.isArrayBuffer(t))return new e(t);if(this.isArrayBufferView(t))return new e(t.buffer,t.byteOffset,t.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(t){return this.isArrayBufferView(t)||this.isArrayBuffer(t)}static isArrayBufferView(t){return ArrayBuffer.isView(t)||t&&this.isArrayBuffer(t.buffer)}static isEqual(t,e){let n=r.toUint8Array(t),s=r.toUint8Array(e);if(n.length!==s.byteLength)return!1;for(let i=0;i<n.length;i++)if(n[i]!==s[i])return!1;return!0}static concat(...t){let e;Array.isArray(t[0])&&!(t[1]instanceof Function)||Array.isArray(t[0])&&t[1]instanceof Function?e=t[0]:t[t.length-1]instanceof Function?e=t.slice(0,t.length-1):e=t;let n=0;for(let o of e)n+=o.byteLength;let s=new Uint8Array(n),i=0;for(let o of e){let a=this.toUint8Array(o);s.set(a,i),i+=a.length}return t[t.length-1]instanceof Function?this.toView(s,t[t.length-1]):s.buffer}},zi="string",Ah=/^[0-9a-f\s]+$/i,kh=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,Sh=/^[a-zA-Z0-9-_]+$/,Bn=class{static fromString(t){let e=unescape(encodeURIComponent(t)),n=new Uint8Array(e.length);for(let s=0;s<e.length;s++)n[s]=e.charCodeAt(s);return n.buffer}static toString(t){let e=ne.toUint8Array(t),n="";for(let i=0;i<e.length;i++)n+=String.fromCharCode(e[i]);return decodeURIComponent(escape(n))}},_t=class{static toString(t,e=!1){let n=ne.toArrayBuffer(t),s=new DataView(n),i="";for(let o=0;o<n.byteLength;o+=2){let a=s.getUint16(o,e);i+=String.fromCharCode(a)}return i}static fromString(t,e=!1){let n=new ArrayBuffer(t.length*2),s=new DataView(n);for(let i=0;i<t.length;i++)s.setUint16(i*2,t.charCodeAt(i),e);return n}},An=class r{static isHex(t){return typeof t===zi&&Ah.test(t)}static isBase64(t){return typeof t===zi&&kh.test(t)}static isBase64Url(t){return typeof t===zi&&Sh.test(t)}static ToString(t,e="utf8"){let n=ne.toUint8Array(t);switch(e.toLowerCase()){case"utf8":return this.ToUtf8String(n);case"binary":return this.ToBinary(n);case"hex":return this.ToHex(n);case"base64":return this.ToBase64(n);case"base64url":return this.ToBase64Url(n);case"utf16le":return _t.toString(n,!0);case"utf16":case"utf16be":return _t.toString(n);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromString(t,e="utf8"){if(!t)return new ArrayBuffer(0);switch(e.toLowerCase()){case"utf8":return this.FromUtf8String(t);case"binary":return this.FromBinary(t);case"hex":return this.FromHex(t);case"base64":return this.FromBase64(t);case"base64url":return this.FromBase64Url(t);case"utf16le":return _t.fromString(t,!0);case"utf16":case"utf16be":return _t.fromString(t);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToBase64(t){let e=ne.toUint8Array(t);if(typeof btoa<"u"){let n=this.ToString(e,"binary");return btoa(n)}else return Buffer.from(e).toString("base64")}static FromBase64(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isBase64(e))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return typeof atob<"u"?this.FromBinary(atob(e)):new Uint8Array(Buffer.from(e,"base64")).buffer}static FromBase64Url(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isBase64Url(e))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(e.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(t){return this.ToBase64(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(t,e=r.DEFAULT_UTF8_ENCODING){switch(e){case"ascii":return this.FromBinary(t);case"utf8":return Bn.fromString(t);case"utf16":case"utf16be":return _t.fromString(t);case"utf16le":case"usc2":return _t.fromString(t,!0);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToUtf8String(t,e=r.DEFAULT_UTF8_ENCODING){switch(e){case"ascii":return this.ToBinary(t);case"utf8":return Bn.toString(t);case"utf16":case"utf16be":return _t.toString(t);case"utf16le":case"usc2":return _t.toString(t,!0);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromBinary(t){let e=t.length,n=new Uint8Array(e);for(let s=0;s<e;s++)n[s]=t.charCodeAt(s);return n.buffer}static ToBinary(t){let e=ne.toUint8Array(t),n="";for(let s=0;s<e.length;s++)n+=String.fromCharCode(e[s]);return n}static ToHex(t){let e=ne.toUint8Array(t),n="",s=e.length;for(let i=0;i<s;i++){let o=e[i];o<16&&(n+="0"),n+=o.toString(16)}return n}static FromHex(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isHex(e))throw new TypeError("Argument 'hexString' is not HEX encoded");e.length%2&&(e=`0${e}`);let n=new Uint8Array(e.length/2);for(let s=0;s<e.length;s=s+2){let i=e.slice(s,s+2);n[s/2]=parseInt(i,16)}return n.buffer}static ToUtf16String(t,e=!1){return _t.toString(t,e)}static FromUtf16String(t,e=!1){return _t.fromString(t,e)}static Base64Padding(t){let e=4-t.length%4;if(e<4)for(let n=0;n<e;n++)t+="=";return t}static formatString(t){return t?.replace(/[\n\r\t ]/g,"")||""}};An.DEFAULT_UTF8_ENCODING="utf8";function Ih(r,...t){let e=arguments[0];for(let n=1;n<arguments.length;n++){let s=arguments[n];for(let i in s)e[i]=s[i]}return e}function Th(...r){let t=r.map(s=>s.byteLength).reduce((s,i)=>s+i),e=new Uint8Array(t),n=0;return r.map(s=>new Uint8Array(s)).forEach(s=>{for(let i of s)e[n++]=i}),e.buffer}function Ch(r,t){if(!(r&&t)||r.byteLength!==t.byteLength)return!1;let e=new Uint8Array(r),n=new Uint8Array(t);for(let s=0;s<r.byteLength;s++)if(e[s]!==n[s])return!1;return!0}nr.BufferSourceConverter=ne;nr.Convert=An;nr.assign=Ih;nr.combine=Th;nr.isEqual=Ch});var Sl=qo((zb,vo)=>{"use strict";var wd=Object.prototype.hasOwnProperty,kt="~";function jr(){}Object.create&&(jr.prototype=Object.create(null),new jr().__proto__||(kt=!1));function xd(r,t,e){this.fn=r,this.context=t,this.once=e||!1}function kl(r,t,e,n,s){if(typeof e!="function")throw new TypeError("The listener must be a function");var i=new xd(e,n||r,s),o=kt?kt+t:t;return r._events[o]?r._events[o].fn?r._events[o]=[r._events[o],i]:r._events[o].push(i):(r._events[o]=i,r._eventsCount++),r}function Ss(r,t){--r._eventsCount===0?r._events=new jr:delete r._events[t]}function bt(){this._events=new jr,this._eventsCount=0}bt.prototype.eventNames=function(){var t=[],e,n;if(this._eventsCount===0)return t;for(n in e=this._events)wd.call(e,n)&&t.push(kt?n.slice(1):n);return Object.getOwnPropertySymbols?t.concat(Object.getOwnPropertySymbols(e)):t};bt.prototype.listeners=function(t){var e=kt?kt+t:t,n=this._events[e];if(!n)return[];if(n.fn)return[n.fn];for(var s=0,i=n.length,o=new Array(i);s<i;s++)o[s]=n[s].fn;return o};bt.prototype.listenerCount=function(t){var e=kt?kt+t:t,n=this._events[e];return n?n.fn?1:n.length:0};bt.prototype.emit=function(t,e,n,s,i,o){var a=kt?kt+t:t;if(!this._events[a])return!1;var c=this._events[a],f=arguments.length,l,u;if(c.fn){switch(c.once&&this.removeListener(t,c.fn,void 0,!0),f){case 1:return c.fn.call(c.context),!0;case 2:return c.fn.call(c.context,e),!0;case 3:return c.fn.call(c.context,e,n),!0;case 4:return c.fn.call(c.context,e,n,s),!0;case 5:return c.fn.call(c.context,e,n,s,i),!0;case 6:return c.fn.call(c.context,e,n,s,i,o),!0}for(u=1,l=new Array(f-1);u<f;u++)l[u-1]=arguments[u];c.fn.apply(c.context,l)}else{var h=c.length,p;for(u=0;u<h;u++)switch(c[u].once&&this.removeListener(t,c[u].fn,void 0,!0),f){case 1:c[u].fn.call(c[u].context);break;case 2:c[u].fn.call(c[u].context,e);break;case 3:c[u].fn.call(c[u].context,e,n);break;case 4:c[u].fn.call(c[u].context,e,n,s);break;default:if(!l)for(p=1,l=new Array(f-1);p<f;p++)l[p-1]=arguments[p];c[u].fn.apply(c[u].context,l)}}return!0};bt.prototype.on=function(t,e,n){return kl(this,t,e,n,!1)};bt.prototype.once=function(t,e,n){return kl(this,t,e,n,!0)};bt.prototype.removeListener=function(t,e,n,s){var i=kt?kt+t:t;if(!this._events[i])return this;if(!e)return Ss(this,i),this;var o=this._events[i];if(o.fn)o.fn===e&&(!s||o.once)&&(!n||o.context===n)&&Ss(this,i);else{for(var a=0,c=[],f=o.length;a<f;a++)(o[a].fn!==e||s&&!o[a].once||n&&o[a].context!==n)&&c.push(o[a]);c.length?this._events[i]=c.length===1?c[0]:c:Ss(this,i)}return this};bt.prototype.removeAllListeners=function(t){var e;return t?(e=kt?kt+t:t,this._events[e]&&Ss(this,e)):(this._events=new jr,this._eventsCount=0),this};bt.prototype.off=bt.prototype.removeListener;bt.prototype.addListener=bt.prototype.on;bt.prefixed=kt;bt.EventEmitter=bt;typeof vo<"u"&&(vo.exports=bt)});var Cd={};xt(Cd,{persistentPeerStore:()=>Td});var tn=Symbol.for("@libp2p/peer-id");function Go(r){return!!r?.[tn]}var K=class extends Error{static name="InvalidParametersError";constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}},$e=class extends Error{static name="InvalidPublicKeyError";constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}};var en=class extends Error{static name="InvalidCIDError";constructor(t="Invalid CID"){super(t),this.name="InvalidCIDError"}},rn=class extends Error{static name="InvalidMultihashError";constructor(t="Invalid Multihash"){super(t),this.name="InvalidMultihashError"}};var Ce=class extends Error{static name="UnsupportedKeyTypeError";constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}};var Hs={};xt(Hs,{base58btc:()=>Q,base58flickr:()=>nu});var Rd=new Uint8Array(0);function Wo(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function Jt(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function Zo(r){return new TextEncoder().encode(r)}function jo(r){return new TextDecoder().decode(r)}function Xl(r,t){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),n=0;n<e.length;n++)e[n]=255;for(var s=0;s<r.length;s++){var i=r.charAt(s),o=i.charCodeAt(0);if(e[o]!==255)throw new TypeError(i+" is ambiguous");e[o]=s}var a=r.length,c=r.charAt(0),f=Math.log(a)/Math.log(256),l=Math.log(256)/Math.log(a);function u(b){if(b instanceof Uint8Array||(ArrayBuffer.isView(b)?b=new Uint8Array(b.buffer,b.byteOffset,b.byteLength):Array.isArray(b)&&(b=Uint8Array.from(b))),!(b instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(b.length===0)return"";for(var w=0,d=0,v=0,A=b.length;v!==A&&b[v]===0;)v++,w++;for(var g=(A-v)*l+1>>>0,S=new Uint8Array(g);v!==A;){for(var U=b[v],L=0,I=g-1;(U!==0||L<d)&&I!==-1;I--,L++)U+=256*S[I]>>>0,S[I]=U%a>>>0,U=U/a>>>0;if(U!==0)throw new Error("Non-zero carry");d=L,v++}for(var N=g-d;N!==g&&S[N]===0;)N++;for(var T=c.repeat(w);N<g;++N)T+=r.charAt(S[N]);return T}function h(b){if(typeof b!="string")throw new TypeError("Expected String");if(b.length===0)return new Uint8Array;var w=0;if(b[w]!==" "){for(var d=0,v=0;b[w]===c;)d++,w++;for(var A=(b.length-w)*f+1>>>0,g=new Uint8Array(A);b[w];){var S=e[b.charCodeAt(w)];if(S===255)return;for(var U=0,L=A-1;(S!==0||U<v)&&L!==-1;L--,U++)S+=a*g[L]>>>0,g[L]=S%256>>>0,S=S/256>>>0;if(S!==0)throw new Error("Non-zero carry");v=U,w++}if(b[w]!==" "){for(var I=A-v;I!==A&&g[I]===0;)I++;for(var N=new Uint8Array(d+(A-I)),T=d;I!==A;)N[T++]=g[I++];return N}}}function p(b){var w=h(b);if(w)return w;throw new Error(`Non-${t} character`)}return{encode:u,decodeUnsafe:h,decode:p}}var Ql=Xl,tu=Ql,Jo=tu;var Os=class{name;prefix;baseEncode;constructor(t,e,n){this.name=t,this.prefix=e,this.baseEncode=n}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}},Ds=class{name;prefix;baseDecode;prefixCodePoint;constructor(t,e,n){this.name=t,this.prefix=e;let s=e.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=n}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return Xo(this,t)}},Ps=class{decoders;constructor(t){this.decoders=t}or(t){return Xo(this,t)}decode(t){let e=t[0],n=this.decoders[e];if(n!=null)return n.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};function Xo(r,t){return new Ps({...r.decoders??{[r.prefix]:r},...t.decoders??{[t.prefix]:t}})}var Ms=class{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(t,e,n,s){this.name=t,this.prefix=e,this.baseEncode=n,this.baseDecode=s,this.encoder=new Os(t,e,n),this.decoder=new Ds(t,e,s)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}};function Ge({name:r,prefix:t,encode:e,decode:n}){return new Ms(r,t,e,n)}function de({name:r,prefix:t,alphabet:e}){let{encode:n,decode:s}=Jo(e,r);return Ge({prefix:t,name:r,encode:n,decode:i=>Jt(s(i))})}function eu(r,t,e,n){let s={};for(let l=0;l<t.length;++l)s[t[l]]=l;let i=r.length;for(;r[i-1]==="=";)--i;let o=new Uint8Array(i*e/8|0),a=0,c=0,f=0;for(let l=0;l<i;++l){let u=s[r[l]];if(u===void 0)throw new SyntaxError(`Non-${n} character`);c=c<<e|u,a+=e,a>=8&&(a-=8,o[f++]=255&c>>a)}if(a>=e||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return o}function ru(r,t,e){let n=t[t.length-1]==="=",s=(1<<e)-1,i="",o=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],o+=8;o>e;)o-=e,i+=t[s&a>>o];if(o!==0&&(i+=t[s&a<<e-o]),n)for(;i.length*e&7;)i+="=";return i}function et({name:r,prefix:t,bitsPerChar:e,alphabet:n}){return Ge({prefix:t,name:r,encode(s){return ru(s,n,e)},decode(s){return eu(s,n,e,r)}})}var Q=de({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),nu=de({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var Fs={};xt(Fs,{base32:()=>Vt,base32hex:()=>au,base32hexpad:()=>lu,base32hexpadupper:()=>uu,base32hexupper:()=>cu,base32pad:()=>iu,base32padupper:()=>ou,base32upper:()=>su,base32z:()=>fu});var Vt=et({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),su=et({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),iu=et({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),ou=et({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),au=et({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),cu=et({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),lu=et({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),uu=et({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),fu=et({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var Ks={};xt(Ks,{base36:()=>br,base36upper:()=>hu});var br=de({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),hu=de({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var du=ea,Qo=128,pu=127,mu=~pu,gu=Math.pow(2,31);function ea(r,t,e){t=t||[],e=e||0;for(var n=e;r>=gu;)t[e++]=r&255|Qo,r/=128;for(;r&mu;)t[e++]=r&255|Qo,r>>>=7;return t[e]=r|0,ea.bytes=e-n+1,t}var yu=qs,bu=128,ta=127;function qs(r,n){var e=0,n=n||0,s=0,i=n,o,a=r.length;do{if(i>=a)throw qs.bytes=0,new RangeError("Could not decode varint");o=r[i++],e+=s<28?(o&ta)<<s:(o&ta)*Math.pow(2,s),s+=7}while(o>=bu);return qs.bytes=i-n,e}var wu=Math.pow(2,7),xu=Math.pow(2,14),vu=Math.pow(2,21),Eu=Math.pow(2,28),Bu=Math.pow(2,35),Au=Math.pow(2,42),ku=Math.pow(2,49),Su=Math.pow(2,56),Iu=Math.pow(2,63),Tu=function(r){return r<wu?1:r<xu?2:r<vu?3:r<Eu?4:r<Bu?5:r<Au?6:r<ku?7:r<Su?8:r<Iu?9:10},Cu={encode:du,decode:yu,encodingLength:Tu},Nu=Cu,wr=Nu;function xr(r,t=0){return[wr.decode(r,t),wr.decode.bytes]}function We(r,t,e=0){return wr.encode(r,t,e),t}function Ze(r){return wr.encodingLength(r)}function Ot(r,t){let e=t.byteLength,n=Ze(r),s=n+Ze(e),i=new Uint8Array(s+e);return We(r,i,0),We(e,i,n),i.set(t,s),new je(r,e,t,i)}function Ne(r){let t=Jt(r),[e,n]=xr(t),[s,i]=xr(t.subarray(n)),o=t.subarray(n+i);if(o.byteLength!==s)throw new Error("Incorrect length");return new je(e,s,o,t)}function ra(r,t){if(r===t)return!0;{let e=t;return r.code===e.code&&r.size===e.size&&e.bytes instanceof Uint8Array&&Wo(r.bytes,e.bytes)}}var je=class{code;size;digest;bytes;constructor(t,e,n,s){this.code=t,this.size=e,this.digest=n,this.bytes=s}};function na(r,t){let{bytes:e,version:n}=r;switch(n){case 0:return Uu(e,zs(r),t??Q.encoder);default:return Ru(e,zs(r),t??Vt.encoder)}}var sa=new WeakMap;function zs(r){let t=sa.get(r);if(t==null){let e=new Map;return sa.set(r,e),e}return t}var st=class r{code;version;multihash;bytes;"/";constructor(t,e,n,s){this.code=e,this.version=t,this.multihash=n,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{let{code:t,multihash:e}=this;if(t!==vr)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==_u)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return r.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{let{code:t,digest:e}=this.multihash,n=Ot(t,e);return r.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return r.equals(this,t)}static equals(t,e){let n=e;return n!=null&&t.code===n.code&&t.version===n.version&&ra(t.multihash,n.multihash)}toString(t){return na(this,t)}toJSON(){return{"/":na(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;let e=t;if(e instanceof r)return e;if(e["/"]!=null&&e["/"]===e.bytes||e.asCID===e){let{version:n,code:s,multihash:i,bytes:o}=e;return new r(n,s,i,o??ia(n,s,i.bytes))}else if(e[Vu]===!0){let{version:n,multihash:s,code:i}=e,o=Ne(s);return r.create(n,i,o)}else return null}static create(t,e,n){if(typeof e!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(e!==vr)throw new Error(`Version 0 CID must use dag-pb (code: ${vr}) block encoding`);return new r(t,e,n,n.bytes)}case 1:{let s=ia(t,e,n.bytes);return new r(t,e,n,s)}default:throw new Error("Invalid version")}}static createV0(t){return r.create(0,vr,t)}static createV1(t,e){return r.create(1,t,e)}static decode(t){let[e,n]=r.decodeFirst(t);if(n.length!==0)throw new Error("Incorrect length");return e}static decodeFirst(t){let e=r.inspectBytes(t),n=e.size-e.multihashSize,s=Jt(t.subarray(n,n+e.multihashSize));if(s.byteLength!==e.multihashSize)throw new Error("Incorrect length");let i=s.subarray(e.multihashSize-e.digestSize),o=new je(e.multihashCode,e.digestSize,i,s);return[e.version===0?r.createV0(o):r.createV1(e.codec,o),t.subarray(e.size)]}static inspectBytes(t){let e=0,n=()=>{let[u,h]=xr(t.subarray(e));return e+=h,u},s=n(),i=vr;if(s===18?(s=0,e=0):i=n(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);let o=e,a=n(),c=n(),f=e+c,l=f-o;return{version:s,codec:i,multihashCode:a,digestSize:c,multihashSize:l,size:f}}static parse(t,e){let[n,s]=Lu(t,e),i=r.decode(s);if(i.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return zs(i).set(n,t),i}};function Lu(r,t){switch(r[0]){case"Q":{let e=t??Q;return[Q.prefix,e.decode(`${Q.prefix}${r}`)]}case Q.prefix:{let e=t??Q;return[Q.prefix,e.decode(r)]}case Vt.prefix:{let e=t??Vt;return[Vt.prefix,e.decode(r)]}case br.prefix:{let e=t??br;return[br.prefix,e.decode(r)]}default:{if(t==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],t.decode(r)]}}}function Uu(r,t,e){let{prefix:n}=e;if(n!==Q.prefix)throw Error(`Cannot string encode V0 in ${e.name} encoding`);let s=t.get(n);if(s==null){let i=e.encode(r).slice(1);return t.set(n,i),i}else return s}function Ru(r,t,e){let{prefix:n}=e,s=t.get(n);if(s==null){let i=e.encode(r);return t.set(n,i),i}else return s}var vr=112,_u=18;function ia(r,t,e){let n=Ze(r),s=n+Ze(t),i=new Uint8Array(s+e.byteLength);return We(r,i,0),We(t,i,n),i.set(e,s),i}var Vu=Symbol.for("@ipld/js-cid/CID");var $s={};xt($s,{identity:()=>Xt});var oa=0,Ou="identity",aa=Jt;function Du(r){return Ot(oa,aa(r))}var Xt={code:oa,name:Ou,encode:aa,digest:Du};function lt(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function ca(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function Pu(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Ye(r,...t){if(!Pu(r))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(r.length))throw new Error("Uint8Array expected of length "+t+", got length="+r.length)}function la(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");ca(r.outputLen),ca(r.blockLen)}function Je(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function ua(r,t){Ye(r);let e=t.outputLen;if(r.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}var Le=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var sn=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),Dt=(r,t)=>r<<32-t|r>>>t;function fa(r){if(typeof r!="string")throw new Error("utf8ToBytes expected string, got "+typeof r);return new Uint8Array(new TextEncoder().encode(r))}function Er(r){return typeof r=="string"&&(r=fa(r)),Ye(r),r}function Gs(...r){let t=0;for(let n=0;n<r.length;n++){let s=r[n];Ye(s),t+=s.length}let e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){let i=r[n];e.set(i,s),s+=i.length}return e}var Xe=class{clone(){return this._cloneInto()}};function on(r){let t=n=>r().update(Er(n)).digest(),e=r();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>r(),t}function an(r=32){if(Le&&typeof Le.getRandomValues=="function")return Le.getRandomValues(new Uint8Array(r));if(Le&&typeof Le.randomBytes=="function")return Le.randomBytes(r);throw new Error("crypto.getRandomValues must be defined")}function Mu(r,t,e,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(t,e,n);let s=BigInt(32),i=BigInt(4294967295),o=Number(e>>s&i),a=Number(e&i),c=n?4:0,f=n?0:4;r.setUint32(t+c,o,n),r.setUint32(t+f,a,n)}var ha=(r,t,e)=>r&t^~r&e,da=(r,t,e)=>r&t^r&e^t&e,Qe=class extends Xe{constructor(t,e,n,s){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=sn(this.buffer)}update(t){Je(this);let{view:e,buffer:n,blockLen:s}=this;t=Er(t);let i=t.length;for(let o=0;o<i;){let a=Math.min(s-this.pos,i-o);if(a===s){let c=sn(t);for(;s<=i-o;o+=s)this.process(c,o);continue}n.set(t.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Je(this),ua(t,this),this.finished=!0;let{buffer:e,view:n,blockLen:s,isLE:i}=this,{pos:o}=this;e[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>s-o&&(this.process(n,0),o=0);for(let u=o;u<s;u++)e[u]=0;Mu(n,s-8,BigInt(this.length*8),i),this.process(n,0);let a=sn(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let f=c/4,l=this.get();if(f>l.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<f;u++)a.setUint32(4*u,l[u],i)}digest(){let{buffer:t,outputLen:e}=this;this.digestInto(t);let n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:e,buffer:n,length:s,finished:i,destroyed:o,pos:a}=this;return t.length=s,t.pos=a,t.finished=i,t.destroyed=o,s%e&&t.buffer.set(n),t}};var cn=BigInt(4294967295),Ws=BigInt(32);function pa(r,t=!1){return t?{h:Number(r&cn),l:Number(r>>Ws&cn)}:{h:Number(r>>Ws&cn)|0,l:Number(r&cn)|0}}function Hu(r,t=!1){let e=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let s=0;s<r.length;s++){let{h:i,l:o}=pa(r[s],t);[e[s],n[s]]=[i,o]}return[e,n]}var Fu=(r,t)=>BigInt(r>>>0)<<Ws|BigInt(t>>>0),Ku=(r,t,e)=>r>>>e,qu=(r,t,e)=>r<<32-e|t>>>e,zu=(r,t,e)=>r>>>e|t<<32-e,$u=(r,t,e)=>r<<32-e|t>>>e,Gu=(r,t,e)=>r<<64-e|t>>>e-32,Wu=(r,t,e)=>r>>>e-32|t<<64-e,Zu=(r,t)=>t,ju=(r,t)=>r,Yu=(r,t,e)=>r<<e|t>>>32-e,Ju=(r,t,e)=>t<<e|r>>>32-e,Xu=(r,t,e)=>t<<e-32|r>>>64-e,Qu=(r,t,e)=>r<<e-32|t>>>64-e;function tf(r,t,e,n){let s=(t>>>0)+(n>>>0);return{h:r+e+(s/2**32|0)|0,l:s|0}}var ef=(r,t,e)=>(r>>>0)+(t>>>0)+(e>>>0),rf=(r,t,e,n)=>t+e+n+(r/2**32|0)|0,nf=(r,t,e,n)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0),sf=(r,t,e,n,s)=>t+e+n+s+(r/2**32|0)|0,of=(r,t,e,n,s)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(s>>>0),af=(r,t,e,n,s,i)=>t+e+n+s+i+(r/2**32|0)|0;var cf={fromBig:pa,split:Hu,toBig:Fu,shrSH:Ku,shrSL:qu,rotrSH:zu,rotrSL:$u,rotrBH:Gu,rotrBL:Wu,rotr32H:Zu,rotr32L:ju,rotlSH:Yu,rotlSL:Ju,rotlBH:Xu,rotlBL:Qu,add:tf,add3L:ef,add3H:rf,add4L:nf,add4H:sf,add5H:af,add5L:of},O=cf;var[lf,uf]=O.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),me=new Uint32Array(80),ge=new Uint32Array(80),Zs=class extends Qe{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){let{Ah:t,Al:e,Bh:n,Bl:s,Ch:i,Cl:o,Dh:a,Dl:c,Eh:f,El:l,Fh:u,Fl:h,Gh:p,Gl:b,Hh:w,Hl:d}=this;return[t,e,n,s,i,o,a,c,f,l,u,h,p,b,w,d]}set(t,e,n,s,i,o,a,c,f,l,u,h,p,b,w,d){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=f|0,this.El=l|0,this.Fh=u|0,this.Fl=h|0,this.Gh=p|0,this.Gl=b|0,this.Hh=w|0,this.Hl=d|0}process(t,e){for(let g=0;g<16;g++,e+=4)me[g]=t.getUint32(e),ge[g]=t.getUint32(e+=4);for(let g=16;g<80;g++){let S=me[g-15]|0,U=ge[g-15]|0,L=O.rotrSH(S,U,1)^O.rotrSH(S,U,8)^O.shrSH(S,U,7),I=O.rotrSL(S,U,1)^O.rotrSL(S,U,8)^O.shrSL(S,U,7),N=me[g-2]|0,T=ge[g-2]|0,j=O.rotrSH(N,T,19)^O.rotrBH(N,T,61)^O.shrSH(N,T,6),F=O.rotrSL(N,T,19)^O.rotrBL(N,T,61)^O.shrSL(N,T,6),P=O.add4L(I,F,ge[g-7],ge[g-16]),nt=O.add4H(P,L,j,me[g-7],me[g-16]);me[g]=nt|0,ge[g]=P|0}let{Ah:n,Al:s,Bh:i,Bl:o,Ch:a,Cl:c,Dh:f,Dl:l,Eh:u,El:h,Fh:p,Fl:b,Gh:w,Gl:d,Hh:v,Hl:A}=this;for(let g=0;g<80;g++){let S=O.rotrSH(u,h,14)^O.rotrSH(u,h,18)^O.rotrBH(u,h,41),U=O.rotrSL(u,h,14)^O.rotrSL(u,h,18)^O.rotrBL(u,h,41),L=u&p^~u&w,I=h&b^~h&d,N=O.add5L(A,U,I,uf[g],ge[g]),T=O.add5H(N,v,S,L,lf[g],me[g]),j=N|0,F=O.rotrSH(n,s,28)^O.rotrBH(n,s,34)^O.rotrBH(n,s,39),P=O.rotrSL(n,s,28)^O.rotrBL(n,s,34)^O.rotrBL(n,s,39),nt=n&i^n&a^i&a,E=s&o^s&c^o&c;v=w|0,A=d|0,w=p|0,d=b|0,p=u|0,b=h|0,{h:u,l:h}=O.add(f|0,l|0,T|0,j|0),f=a|0,l=c|0,a=i|0,c=o|0,i=n|0,o=s|0;let C=O.add3L(j,P,E);n=O.add3H(C,T,F,nt),s=C|0}({h:n,l:s}=O.add(this.Ah|0,this.Al|0,n|0,s|0)),{h:i,l:o}=O.add(this.Bh|0,this.Bl|0,i|0,o|0),{h:a,l:c}=O.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:f,l}=O.add(this.Dh|0,this.Dl|0,f|0,l|0),{h:u,l:h}=O.add(this.Eh|0,this.El|0,u|0,h|0),{h:p,l:b}=O.add(this.Fh|0,this.Fl|0,p|0,b|0),{h:w,l:d}=O.add(this.Gh|0,this.Gl|0,w|0,d|0),{h:v,l:A}=O.add(this.Hh|0,this.Hl|0,v|0,A|0),this.set(n,s,i,o,a,c,f,l,u,h,p,b,w,d,v,A)}roundClean(){me.fill(0),ge.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}};var ma=on(()=>new Zs);var fn={};xt(fn,{aInRange:()=>It,abool:()=>Pt,abytes:()=>tr,bitGet:()=>gf,bitLen:()=>Xs,bitMask:()=>Ar,bitSet:()=>yf,bytesToHex:()=>te,bytesToNumberBE:()=>ee,bytesToNumberLE:()=>be,concatBytes:()=>re,createHmacDrbg:()=>Qs,ensureBytes:()=>tt,equalBytes:()=>pf,hexToBytes:()=>Re,hexToNumber:()=>Js,inRange:()=>Br,isBytes:()=>ye,memoized:()=>Ve,notImplemented:()=>wf,numberToBytesBE:()=>we,numberToBytesLE:()=>_e,numberToHexUnpadded:()=>Ue,numberToVarBytesBE:()=>df,utf8ToBytes:()=>mf,validateObject:()=>qt});var ln=BigInt(0),un=BigInt(1),ff=BigInt(2);function ye(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function tr(r){if(!ye(r))throw new Error("Uint8Array expected")}function Pt(r,t){if(typeof t!="boolean")throw new Error(r+" boolean expected, got "+t)}var hf=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function te(r){tr(r);let t="";for(let e=0;e<r.length;e++)t+=hf[r[e]];return t}function Ue(r){let t=r.toString(16);return t.length&1?"0"+t:t}function Js(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?ln:BigInt("0x"+r)}var Qt={_0:48,_9:57,A:65,F:70,a:97,f:102};function ga(r){if(r>=Qt._0&&r<=Qt._9)return r-Qt._0;if(r>=Qt.A&&r<=Qt.F)return r-(Qt.A-10);if(r>=Qt.a&&r<=Qt.f)return r-(Qt.a-10)}function Re(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);let t=r.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);let n=new Uint8Array(e);for(let s=0,i=0;s<e;s++,i+=2){let o=ga(r.charCodeAt(i)),a=ga(r.charCodeAt(i+1));if(o===void 0||a===void 0){let c=r[i]+r[i+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+i)}n[s]=o*16+a}return n}function ee(r){return Js(te(r))}function be(r){return tr(r),Js(te(Uint8Array.from(r).reverse()))}function we(r,t){return Re(r.toString(16).padStart(t*2,"0"))}function _e(r,t){return we(r,t).reverse()}function df(r){return Re(Ue(r))}function tt(r,t,e){let n;if(typeof t=="string")try{n=Re(t)}catch(i){throw new Error(r+" must be hex string or Uint8Array, cause: "+i)}else if(ye(t))n=Uint8Array.from(t);else throw new Error(r+" must be hex string or Uint8Array");let s=n.length;if(typeof e=="number"&&s!==e)throw new Error(r+" of length "+e+" expected, got "+s);return n}function re(...r){let t=0;for(let n=0;n<r.length;n++){let s=r[n];tr(s),t+=s.length}let e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){let i=r[n];e.set(i,s),s+=i.length}return e}function pf(r,t){if(r.length!==t.length)return!1;let e=0;for(let n=0;n<r.length;n++)e|=r[n]^t[n];return e===0}function mf(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}var js=r=>typeof r=="bigint"&&ln<=r;function Br(r,t,e){return js(r)&&js(t)&&js(e)&&t<=r&&r<e}function It(r,t,e,n){if(!Br(t,e,n))throw new Error("expected valid "+r+": "+e+" <= n < "+n+", got "+t)}function Xs(r){let t;for(t=0;r>ln;r>>=un,t+=1);return t}function gf(r,t){return r>>BigInt(t)&un}function yf(r,t,e){return r|(e?un:ln)<<BigInt(t)}var Ar=r=>(ff<<BigInt(r-1))-un,Ys=r=>new Uint8Array(r),ya=r=>Uint8Array.from(r);function Qs(r,t,e){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let n=Ys(r),s=Ys(r),i=0,o=()=>{n.fill(1),s.fill(0),i=0},a=(...u)=>e(s,n,...u),c=(u=Ys())=>{s=a(ya([0]),u),n=a(),u.length!==0&&(s=a(ya([1]),u),n=a())},f=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let u=0,h=[];for(;u<t;){n=a();let p=n.slice();h.push(p),u+=n.length}return re(...h)};return(u,h)=>{o(),c(u);let p;for(;!(p=h(f()));)c();return o(),p}}var bf={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||ye(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,t)=>t.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function qt(r,t,e={}){let n=(s,i,o)=>{let a=bf[i];if(typeof a!="function")throw new Error("invalid validator function");let c=r[s];if(!(o&&c===void 0)&&!a(c,r))throw new Error("param "+String(s)+" is invalid. Expected "+i+", got "+c)};for(let[s,i]of Object.entries(t))n(s,i,!1);for(let[s,i]of Object.entries(e))n(s,i,!0);return r}var wf=()=>{throw new Error("not implemented")};function Ve(r){let t=new WeakMap;return(e,...n)=>{let s=t.get(e);if(s!==void 0)return s;let i=r(e,...n);return t.set(e,i),i}}var it=BigInt(0),Y=BigInt(1),Oe=BigInt(2),xf=BigInt(3),ti=BigInt(4),ba=BigInt(5),wa=BigInt(8),vf=BigInt(9),Ef=BigInt(16);function $(r,t){let e=r%t;return e>=it?e:t+e}function Bf(r,t,e){if(t<it)throw new Error("invalid exponent, negatives unsupported");if(e<=it)throw new Error("invalid modulus");if(e===Y)return it;let n=Y;for(;t>it;)t&Y&&(n=n*r%e),r=r*r%e,t>>=Y;return n}function J(r,t,e){let n=r;for(;t-- >it;)n*=n,n%=e;return n}function hn(r,t){if(r===it)throw new Error("invert: expected non-zero number");if(t<=it)throw new Error("invert: expected positive modulus, got "+t);let e=$(r,t),n=t,s=it,i=Y,o=Y,a=it;for(;e!==it;){let f=n/e,l=n%e,u=s-o*f,h=i-a*f;n=e,e=l,s=o,i=a,o=u,a=h}if(n!==Y)throw new Error("invert: does not exist");return $(s,t)}function Af(r){let t=(r-Y)/Oe,e,n,s;for(e=r-Y,n=0;e%Oe===it;e/=Oe,n++);for(s=Oe;s<r&&Bf(s,t,r)!==r-Y;s++)if(s>1e3)throw new Error("Cannot find square root: likely non-prime P");if(n===1){let o=(r+Y)/ti;return function(c,f){let l=c.pow(f,o);if(!c.eql(c.sqr(l),f))throw new Error("Cannot find square root");return l}}let i=(e+Y)/Oe;return function(a,c){if(a.pow(c,t)===a.neg(a.ONE))throw new Error("Cannot find square root");let f=n,l=a.pow(a.mul(a.ONE,s),e),u=a.pow(c,i),h=a.pow(c,e);for(;!a.eql(h,a.ONE);){if(a.eql(h,a.ZERO))return a.ZERO;let p=1;for(let w=a.sqr(h);p<f&&!a.eql(w,a.ONE);p++)w=a.sqr(w);let b=a.pow(l,Y<<BigInt(f-p-1));l=a.sqr(b),u=a.mul(u,b),h=a.mul(h,l),f=p}return u}}function kf(r){if(r%ti===xf){let t=(r+Y)/ti;return function(n,s){let i=n.pow(s,t);if(!n.eql(n.sqr(i),s))throw new Error("Cannot find square root");return i}}if(r%wa===ba){let t=(r-ba)/wa;return function(n,s){let i=n.mul(s,Oe),o=n.pow(i,t),a=n.mul(s,o),c=n.mul(n.mul(a,Oe),o),f=n.mul(a,n.sub(c,n.ONE));if(!n.eql(n.sqr(f),s))throw new Error("Cannot find square root");return f}}return r%Ef,Af(r)}var xa=(r,t)=>($(r,t)&Y)===Y,Sf=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ei(r){let t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Sf.reduce((n,s)=>(n[s]="function",n),t);return qt(r,e)}function If(r,t,e){if(e<it)throw new Error("invalid exponent, negatives unsupported");if(e===it)return r.ONE;if(e===Y)return t;let n=r.ONE,s=t;for(;e>it;)e&Y&&(n=r.mul(n,s)),s=r.sqr(s),e>>=Y;return n}function Tf(r,t){let e=new Array(t.length),n=t.reduce((i,o,a)=>r.is0(o)?i:(e[a]=i,r.mul(i,o)),r.ONE),s=r.inv(n);return t.reduceRight((i,o,a)=>r.is0(o)?i:(e[a]=r.mul(i,e[a]),r.mul(i,o)),s),e}function ri(r,t){let e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}function xe(r,t,e=!1,n={}){if(r<=it)throw new Error("invalid field: expected ORDER > 0, got "+r);let{nBitLength:s,nByteLength:i}=ri(r,t);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o,a=Object.freeze({ORDER:r,isLE:e,BITS:s,BYTES:i,MASK:Ar(s),ZERO:it,ONE:Y,create:c=>$(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return it<=c&&c<r},is0:c=>c===it,isOdd:c=>(c&Y)===Y,neg:c=>$(-c,r),eql:(c,f)=>c===f,sqr:c=>$(c*c,r),add:(c,f)=>$(c+f,r),sub:(c,f)=>$(c-f,r),mul:(c,f)=>$(c*f,r),pow:(c,f)=>If(a,c,f),div:(c,f)=>$(c*hn(f,r),r),sqrN:c=>c*c,addN:(c,f)=>c+f,subN:(c,f)=>c-f,mulN:(c,f)=>c*f,inv:c=>hn(c,r),sqrt:n.sqrt||(c=>(o||(o=kf(r)),o(a,c))),invertBatch:c=>Tf(a,c),cmov:(c,f,l)=>l?f:c,toBytes:c=>e?_e(c,i):we(c,i),fromBytes:c=>{if(c.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+c.length);return e?be(c):ee(c)}});return Object.freeze(a)}function va(r){if(typeof r!="bigint")throw new Error("field order must be bigint");let t=r.toString(2).length;return Math.ceil(t/8)}function ni(r){let t=va(r);return t+Math.ceil(t/2)}function Ea(r,t,e=!1){let n=r.length,s=va(t),i=ni(t);if(n<16||n<i||n>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+n);let o=e?be(r):ee(r),a=$(o,t-Y)+Y;return e?_e(a,s):we(a,s)}var Ba=BigInt(0),dn=BigInt(1);function si(r,t){let e=t.negate();return r?e:t}function Aa(r,t){if(!Number.isSafeInteger(r)||r<=0||r>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+r)}function ii(r,t){Aa(r,t);let e=Math.ceil(t/r)+1,n=2**(r-1);return{windows:e,windowSize:n}}function Nf(r,t){if(!Array.isArray(r))throw new Error("array expected");r.forEach((e,n)=>{if(!(e instanceof t))throw new Error("invalid point at index "+n)})}function Lf(r,t){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((e,n)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+n)})}var oi=new WeakMap,ka=new WeakMap;function ai(r){return ka.get(r)||1}function pn(r,t){return{constTimeNegate:si,hasPrecomputes(e){return ai(e)!==1},unsafeLadder(e,n,s=r.ZERO){let i=e;for(;n>Ba;)n&dn&&(s=s.add(i)),i=i.double(),n>>=dn;return s},precomputeWindow(e,n){let{windows:s,windowSize:i}=ii(n,t),o=[],a=e,c=a;for(let f=0;f<s;f++){c=a,o.push(c);for(let l=1;l<i;l++)c=c.add(a),o.push(c);a=c.double()}return o},wNAF(e,n,s){let{windows:i,windowSize:o}=ii(e,t),a=r.ZERO,c=r.BASE,f=BigInt(2**e-1),l=2**e,u=BigInt(e);for(let h=0;h<i;h++){let p=h*o,b=Number(s&f);s>>=u,b>o&&(b-=l,s+=dn);let w=p,d=p+Math.abs(b)-1,v=h%2!==0,A=b<0;b===0?c=c.add(si(v,n[w])):a=a.add(si(A,n[d]))}return{p:a,f:c}},wNAFUnsafe(e,n,s,i=r.ZERO){let{windows:o,windowSize:a}=ii(e,t),c=BigInt(2**e-1),f=2**e,l=BigInt(e);for(let u=0;u<o;u++){let h=u*a;if(s===Ba)break;let p=Number(s&c);if(s>>=l,p>a&&(p-=f,s+=dn),p===0)continue;let b=n[h+Math.abs(p)-1];p<0&&(b=b.negate()),i=i.add(b)}return i},getPrecomputes(e,n,s){let i=oi.get(n);return i||(i=this.precomputeWindow(n,e),e!==1&&oi.set(n,s(i))),i},wNAFCached(e,n,s){let i=ai(e);return this.wNAF(i,this.getPrecomputes(i,e,s),n)},wNAFCachedUnsafe(e,n,s,i){let o=ai(e);return o===1?this.unsafeLadder(e,n,i):this.wNAFUnsafe(o,this.getPrecomputes(o,e,s),n,i)},setWindowSize(e,n){Aa(n,t),ka.set(e,n),oi.delete(e)}}}function mn(r,t,e,n){if(Nf(e,r),Lf(n,t),e.length!==n.length)throw new Error("arrays of points and scalars must have equal length");let s=r.ZERO,i=Xs(BigInt(e.length)),o=i>12?i-3:i>4?i-2:i?2:1,a=(1<<o)-1,c=new Array(a+1).fill(s),f=Math.floor((t.BITS-1)/o)*o,l=s;for(let u=f;u>=0;u-=o){c.fill(s);for(let p=0;p<n.length;p++){let b=n[p],w=Number(b>>BigInt(u)&BigInt(a));c[w]=c[w].add(e[p])}let h=s;for(let p=c.length-1,b=s;p>0;p--)b=b.add(c[p]),h=h.add(b);if(l=l.add(h),u!==0)for(let p=0;p<o;p++)l=l.double()}return l}function kr(r){return ei(r.Fp),qt(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...ri(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}var Mt=BigInt(0),Tt=BigInt(1),gn=BigInt(2),Uf=BigInt(8),Rf={zip215:!0};function _f(r){let t=kr(r);return qt(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}function Sa(r){let t=_f(r),{Fp:e,n,prehash:s,hash:i,randomBytes:o,nByteLength:a,h:c}=t,f=gn<<BigInt(a*8)-Tt,l=e.create,u=xe(t.n,t.nBitLength),h=t.uvRatio||((y,m)=>{try{return{isValid:!0,value:e.sqrt(y*e.inv(m))}}catch{return{isValid:!1,value:Mt}}}),p=t.adjustScalarBytes||(y=>y),b=t.domain||((y,m,x)=>{if(Pt("phflag",x),m.length||x)throw new Error("Contexts/pre-hash are not supported");return y});function w(y,m){It("coordinate "+y,m,Mt,f)}function d(y){if(!(y instanceof g))throw new Error("ExtendedPoint expected")}let v=Ve((y,m)=>{let{ex:x,ey:k,ez:R}=y,_=y.is0();m==null&&(m=_?Uf:e.inv(R));let D=l(x*m),H=l(k*m),V=l(R*m);if(_)return{x:Mt,y:Tt};if(V!==Tt)throw new Error("invZ was invalid");return{x:D,y:H}}),A=Ve(y=>{let{a:m,d:x}=t;if(y.is0())throw new Error("bad point: ZERO");let{ex:k,ey:R,ez:_,et:D}=y,H=l(k*k),V=l(R*R),z=l(_*_),W=l(z*z),at=l(H*m),ct=l(z*l(at+V)),ft=l(W+l(x*l(H*V)));if(ct!==ft)throw new Error("bad point: equation left != right (1)");let pt=l(k*R),St=l(_*D);if(pt!==St)throw new Error("bad point: equation left != right (2)");return!0});class g{constructor(m,x,k,R){this.ex=m,this.ey=x,this.ez=k,this.et=R,w("x",m),w("y",x),w("z",k),w("t",R),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(m){if(m instanceof g)throw new Error("extended point not allowed");let{x,y:k}=m||{};return w("x",x),w("y",k),new g(x,k,Tt,l(x*k))}static normalizeZ(m){let x=e.invertBatch(m.map(k=>k.ez));return m.map((k,R)=>k.toAffine(x[R])).map(g.fromAffine)}static msm(m,x){return mn(g,u,m,x)}_setWindowSize(m){L.setWindowSize(this,m)}assertValidity(){A(this)}equals(m){d(m);let{ex:x,ey:k,ez:R}=this,{ex:_,ey:D,ez:H}=m,V=l(x*H),z=l(_*R),W=l(k*H),at=l(D*R);return V===z&&W===at}is0(){return this.equals(g.ZERO)}negate(){return new g(l(-this.ex),this.ey,this.ez,l(-this.et))}double(){let{a:m}=t,{ex:x,ey:k,ez:R}=this,_=l(x*x),D=l(k*k),H=l(gn*l(R*R)),V=l(m*_),z=x+k,W=l(l(z*z)-_-D),at=V+D,ct=at-H,ft=V-D,pt=l(W*ct),St=l(at*ft),wt=l(W*ft),Kt=l(ct*at);return new g(pt,St,Kt,wt)}add(m){d(m);let{a:x,d:k}=t,{ex:R,ey:_,ez:D,et:H}=this,{ex:V,ey:z,ez:W,et:at}=m;if(x===BigInt(-1)){let Oo=l((_-R)*(z+V)),Do=l((_+R)*(z-V)),Vs=l(Do-Oo);if(Vs===Mt)return this.double();let Po=l(D*gn*at),Mo=l(H*gn*W),Ho=Mo+Po,Fo=Do+Oo,Ko=Mo-Po,Kl=l(Ho*Vs),ql=l(Fo*Ko),zl=l(Ho*Ko),$l=l(Vs*Fo);return new g(Kl,ql,$l,zl)}let ct=l(R*V),ft=l(_*z),pt=l(H*k*at),St=l(D*W),wt=l((R+_)*(V+z)-ct-ft),Kt=St-pt,Yt=St+pt,yr=l(ft-x*ct),Pl=l(wt*Kt),Ml=l(Yt*yr),Hl=l(wt*yr),Fl=l(Kt*Yt);return new g(Pl,Ml,Fl,Hl)}subtract(m){return this.add(m.negate())}wNAF(m){return L.wNAFCached(this,m,g.normalizeZ)}multiply(m){let x=m;It("scalar",x,Tt,n);let{p:k,f:R}=this.wNAF(x);return g.normalizeZ([k,R])[0]}multiplyUnsafe(m,x=g.ZERO){let k=m;return It("scalar",k,Mt,n),k===Mt?U:this.is0()||k===Tt?this:L.wNAFCachedUnsafe(this,k,g.normalizeZ,x)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return L.unsafeLadder(this,n).is0()}toAffine(m){return v(this,m)}clearCofactor(){let{h:m}=t;return m===Tt?this:this.multiplyUnsafe(m)}static fromHex(m,x=!1){let{d:k,a:R}=t,_=e.BYTES;m=tt("pointHex",m,_),Pt("zip215",x);let D=m.slice(),H=m[_-1];D[_-1]=H&-129;let V=be(D),z=x?f:e.ORDER;It("pointHex.y",V,Mt,z);let W=l(V*V),at=l(W-Tt),ct=l(k*W-R),{isValid:ft,value:pt}=h(at,ct);if(!ft)throw new Error("Point.fromHex: invalid y coordinate");let St=(pt&Tt)===Tt,wt=(H&128)!==0;if(!x&&pt===Mt&&wt)throw new Error("Point.fromHex: x=0 and x_0=1");return wt!==St&&(pt=l(-pt)),g.fromAffine({x:pt,y:V})}static fromPrivateKey(m){return T(m).point}toRawBytes(){let{x:m,y:x}=this.toAffine(),k=_e(x,e.BYTES);return k[k.length-1]|=m&Tt?128:0,k}toHex(){return te(this.toRawBytes())}}g.BASE=new g(t.Gx,t.Gy,Tt,l(t.Gx*t.Gy)),g.ZERO=new g(Mt,Tt,Tt,Mt);let{BASE:S,ZERO:U}=g,L=pn(g,a*8);function I(y){return $(y,n)}function N(y){return I(be(y))}function T(y){let m=e.BYTES;y=tt("private key",y,m);let x=tt("hashed private key",i(y),2*m),k=p(x.slice(0,m)),R=x.slice(m,2*m),_=N(k),D=S.multiply(_),H=D.toRawBytes();return{head:k,prefix:R,scalar:_,point:D,pointBytes:H}}function j(y){return T(y).pointBytes}function F(y=new Uint8Array,...m){let x=re(...m);return N(i(b(x,tt("context",y),!!s)))}function P(y,m,x={}){y=tt("message",y),s&&(y=s(y));let{prefix:k,scalar:R,pointBytes:_}=T(m),D=F(x.context,k,y),H=S.multiply(D).toRawBytes(),V=F(x.context,H,_,y),z=I(D+V*R);It("signature.s",z,Mt,n);let W=re(H,_e(z,e.BYTES));return tt("result",W,e.BYTES*2)}let nt=Rf;function E(y,m,x,k=nt){let{context:R,zip215:_}=k,D=e.BYTES;y=tt("signature",y,2*D),m=tt("message",m),x=tt("publicKey",x,D),_!==void 0&&Pt("zip215",_),s&&(m=s(m));let H=be(y.slice(D,2*D)),V,z,W;try{V=g.fromHex(x,_),z=g.fromHex(y.slice(0,D),_),W=S.multiplyUnsafe(H)}catch{return!1}if(!_&&V.isSmallOrder())return!1;let at=F(R,z.toRawBytes(),V.toRawBytes(),m);return z.add(V.multiplyUnsafe(at)).subtract(W).clearCofactor().equals(g.ZERO)}return S._setWindowSize(8),{CURVE:t,getPublicKey:j,sign:P,verify:E,ExtendedPoint:g,utils:{getExtendedPublicKey:T,randomPrivateKey:()=>o(e.BYTES),precompute(y=8,m=g.BASE){return m._setWindowSize(y),m.multiply(BigInt(3)),m}}}}var ci=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Ia=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),A0=BigInt(0),Vf=BigInt(1),Ta=BigInt(2),k0=BigInt(3),Of=BigInt(5),Df=BigInt(8);function Pf(r){let t=BigInt(10),e=BigInt(20),n=BigInt(40),s=BigInt(80),i=ci,a=r*r%i*r%i,c=J(a,Ta,i)*a%i,f=J(c,Vf,i)*r%i,l=J(f,Of,i)*f%i,u=J(l,t,i)*l%i,h=J(u,e,i)*u%i,p=J(h,n,i)*h%i,b=J(p,s,i)*p%i,w=J(b,s,i)*p%i,d=J(w,t,i)*l%i;return{pow_p_5_8:J(d,Ta,i)*r%i,b2:a}}function Mf(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function Hf(r,t){let e=ci,n=$(t*t*t,e),s=$(n*n*t,e),i=Pf(r*s).pow_p_5_8,o=$(r*n*i,e),a=$(t*o*o,e),c=o,f=$(o*Ia,e),l=a===r,u=a===$(-r,e),h=a===$(-r*Ia,e);return l&&(o=c),(u||h)&&(o=f),xa(o,e)&&(o=$(-o,e)),{isValid:l||u,value:o}}var Ff=xe(ci,void 0,!0),Kf={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:Ff,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:Df,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:ma,randomBytes:an,adjustScalarBytes:Mf,uvRatio:Hf},Ca=Sa(Kf);var yn=32;function Na(r,t,e){return Ca.verify(t,e instanceof Uint8Array?e:e.subarray(),r)}var bn=class{type="Ed25519";raw;constructor(t){this.raw=li(t,yn)}toMultihash(){return Xt.digest(zt(this))}toCID(){return st.createV1(114,this.toMultihash())}toString(){return Q.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:lt(this.raw,t.raw)}verify(t,e){return Na(this.raw,e,t)}};function ui(r){return r=li(r,yn),new bn(r)}function li(r,t){if(r=Uint8Array.from(r??[]),r.length!==t)throw new K(`Key must be a Uint8Array of length ${t}, got ${r.length}`);return r}function rt(r=0){return new Uint8Array(r)}function Ct(r=0){return new Uint8Array(r)}var zf=Math.pow(2,7),$f=Math.pow(2,14),Gf=Math.pow(2,21),fi=Math.pow(2,28),hi=Math.pow(2,35),di=Math.pow(2,42),pi=Math.pow(2,49),q=128,mt=127;function Nt(r){if(r<zf)return 1;if(r<$f)return 2;if(r<Gf)return 3;if(r<fi)return 4;if(r<hi)return 5;if(r<di)return 6;if(r<pi)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function mi(r,t,e=0){switch(Nt(r)){case 8:t[e++]=r&255|q,r/=128;case 7:t[e++]=r&255|q,r/=128;case 6:t[e++]=r&255|q,r/=128;case 5:t[e++]=r&255|q,r/=128;case 4:t[e++]=r&255|q,r>>>=7;case 3:t[e++]=r&255|q,r>>>=7;case 2:t[e++]=r&255|q,r>>>=7;case 1:{t[e++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return t}function Wf(r,t,e=0){switch(Nt(r)){case 8:t.set(e++,r&255|q),r/=128;case 7:t.set(e++,r&255|q),r/=128;case 6:t.set(e++,r&255|q),r/=128;case 5:t.set(e++,r&255|q),r/=128;case 4:t.set(e++,r&255|q),r>>>=7;case 3:t.set(e++,r&255|q),r>>>=7;case 2:t.set(e++,r&255|q),r>>>=7;case 1:{t.set(e++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return t}function gi(r,t){let e=r[t],n=0;if(n+=e&mt,e<q||(e=r[t+1],n+=(e&mt)<<7,e<q)||(e=r[t+2],n+=(e&mt)<<14,e<q)||(e=r[t+3],n+=(e&mt)<<21,e<q)||(e=r[t+4],n+=(e&mt)*fi,e<q)||(e=r[t+5],n+=(e&mt)*hi,e<q)||(e=r[t+6],n+=(e&mt)*di,e<q)||(e=r[t+7],n+=(e&mt)*pi,e<q))return n;throw new RangeError("Could not decode varint")}function Zf(r,t){let e=r.get(t),n=0;if(n+=e&mt,e<q||(e=r.get(t+1),n+=(e&mt)<<7,e<q)||(e=r.get(t+2),n+=(e&mt)<<14,e<q)||(e=r.get(t+3),n+=(e&mt)<<21,e<q)||(e=r.get(t+4),n+=(e&mt)*fi,e<q)||(e=r.get(t+5),n+=(e&mt)*hi,e<q)||(e=r.get(t+6),n+=(e&mt)*di,e<q)||(e=r.get(t+7),n+=(e&mt)*pi,e<q))return n;throw new RangeError("Could not decode varint")}function $t(r,t,e=0){return t==null&&(t=Ct(Nt(r))),t instanceof Uint8Array?mi(r,t,e):Wf(r,t,e)}function De(r,t=0){return r instanceof Uint8Array?gi(r,t):Zf(r,t)}var bi=new Float32Array([-0]),ve=new Uint8Array(bi.buffer);function Ua(r,t,e){bi[0]=r,t[e]=ve[0],t[e+1]=ve[1],t[e+2]=ve[2],t[e+3]=ve[3]}function Ra(r,t){return ve[0]=r[t],ve[1]=r[t+1],ve[2]=r[t+2],ve[3]=r[t+3],bi[0]}var wi=new Float64Array([-0]),gt=new Uint8Array(wi.buffer);function _a(r,t,e){wi[0]=r,t[e]=gt[0],t[e+1]=gt[1],t[e+2]=gt[2],t[e+3]=gt[3],t[e+4]=gt[4],t[e+5]=gt[5],t[e+6]=gt[6],t[e+7]=gt[7]}function Va(r,t){return gt[0]=r[t],gt[1]=r[t+1],gt[2]=r[t+2],gt[3]=r[t+3],gt[4]=r[t+4],gt[5]=r[t+5],gt[6]=r[t+6],gt[7]=r[t+7],wi[0]}var jf=BigInt(Number.MAX_SAFE_INTEGER),Yf=BigInt(Number.MIN_SAFE_INTEGER),Ut=class r{lo;hi;constructor(t,e){this.lo=t|0,this.hi=e|0}toNumber(t=!1){if(!t&&this.hi>>>31>0){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(e+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(t=!1){if(t)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(BigInt(e)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(t=!1){return this.toBigInt(t).toString()}zzEncode(){let t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this}zzDecode(){let t=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this}length(){let t=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?e===0?t<16384?t<128?1:2:t<2097152?3:4:e<16384?e<128?5:6:e<2097152?7:8:n<128?9:10}static fromBigInt(t){if(t===0n)return Pe;if(t<jf&&t>Yf)return this.fromNumber(Number(t));let e=t<0n;e&&(t=-t);let n=t>>32n,s=t-(n<<32n);return e&&(n=~n|0n,s=~s|0n,++s>Oa&&(s=0n,++n>Oa&&(n=0n))),new r(Number(s),Number(n))}static fromNumber(t){if(t===0)return Pe;let e=t<0;e&&(t=-t);let n=t>>>0,s=(t-n)/4294967296>>>0;return e&&(s=~s>>>0,n=~n>>>0,++n>4294967295&&(n=0,++s>4294967295&&(s=0))),new r(n,s)}static from(t){return typeof t=="number"?r.fromNumber(t):typeof t=="bigint"?r.fromBigInt(t):typeof t=="string"?r.fromBigInt(BigInt(t)):t.low!=null||t.high!=null?new r(t.low>>>0,t.high>>>0):Pe}},Pe=new Ut(0,0);Pe.toBigInt=function(){return 0n};Pe.zzEncode=Pe.zzDecode=function(){return this};Pe.length=function(){return 1};var Oa=4294967296n;function Da(r){let t=0,e=0;for(let n=0;n<r.length;++n)e=r.charCodeAt(n),e<128?t+=1:e<2048?t+=2:(e&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,t+=4):t+=3;return t}function Pa(r,t,e){if(e-t<1)return"";let s,i=[],o=0,a;for(;t<e;)a=r[t++],a<128?i[o++]=a:a>191&&a<224?i[o++]=(a&31)<<6|r[t++]&63:a>239&&a<365?(a=((a&7)<<18|(r[t++]&63)<<12|(r[t++]&63)<<6|r[t++]&63)-65536,i[o++]=55296+(a>>10),i[o++]=56320+(a&1023)):i[o++]=(a&15)<<12|(r[t++]&63)<<6|r[t++]&63,o>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,i)),o=0);return s!=null?(o>0&&s.push(String.fromCharCode.apply(String,i.slice(0,o))),s.join("")):String.fromCharCode.apply(String,i.slice(0,o))}function xi(r,t,e){let n=e,s,i;for(let o=0;o<r.length;++o)s=r.charCodeAt(o),s<128?t[e++]=s:s<2048?(t[e++]=s>>6|192,t[e++]=s&63|128):(s&64512)===55296&&((i=r.charCodeAt(o+1))&64512)===56320?(s=65536+((s&1023)<<10)+(i&1023),++o,t[e++]=s>>18|240,t[e++]=s>>12&63|128,t[e++]=s>>6&63|128,t[e++]=s&63|128):(t[e++]=s>>12|224,t[e++]=s>>6&63|128,t[e++]=s&63|128);return e-n}function Ht(r,t){return RangeError(`index out of range: ${r.pos} + ${t??1} > ${r.len}`)}function wn(r,t){return(r[t-4]|r[t-3]<<8|r[t-2]<<16|r[t-1]<<24)>>>0}var vi=class{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(t){this.buf=t,this.pos=0,this.len=t.length}uint32(){let t=4294967295;if(t=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(t=(t|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return t;if((this.pos+=5)>this.len)throw this.pos=this.len,Ht(this,10);return t}int32(){return this.uint32()|0}sint32(){let t=this.uint32();return t>>>1^-(t&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw Ht(this,4);return wn(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw Ht(this,4);return wn(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw Ht(this,4);let t=Ra(this.buf,this.pos);return this.pos+=4,t}double(){if(this.pos+8>this.len)throw Ht(this,4);let t=Va(this.buf,this.pos);return this.pos+=8,t}bytes(){let t=this.uint32(),e=this.pos,n=this.pos+t;if(n>this.len)throw Ht(this,t);return this.pos+=t,e===n?new Uint8Array(0):this.buf.subarray(e,n)}string(){let t=this.bytes();return Pa(t,0,t.length)}skip(t){if(typeof t=="number"){if(this.pos+t>this.len)throw Ht(this,t);this.pos+=t}else do if(this.pos>=this.len)throw Ht(this);while(this.buf[this.pos++]&128);return this}skipType(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${t} at offset ${this.pos}`)}return this}readLongVarint(){let t=new Ut(0,0),e=0;if(this.len-this.pos>4){for(;e<4;++e)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw Ht(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,t}if(this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw Ht(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw Ht(this,8);let t=wn(this.buf,this.pos+=4),e=wn(this.buf,this.pos+=4);return new Ut(t,e)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){let t=gi(this.buf,this.pos);return this.pos+=Nt(t),t}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}};function Ei(r){return new vi(r instanceof Uint8Array?r:r.subarray())}function vt(r,t,e){let n=Ei(r);return t.decode(n,void 0,e)}var Bi={};xt(Bi,{base10:()=>Jf});var Jf=de({prefix:"9",name:"base10",alphabet:"0123456789"});var Ai={};xt(Ai,{base16:()=>Xf,base16upper:()=>Qf});var Xf=et({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Qf=et({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var ki={};xt(ki,{base2:()=>th});var th=et({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var Si={};xt(Si,{base256emoji:()=>ih});var Ha=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),eh=Ha.reduce((r,t,e)=>(r[e]=t,r),[]),rh=Ha.reduce((r,t,e)=>{let n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);return r[n]=e,r},[]);function nh(r){return r.reduce((t,e)=>(t+=eh[e],t),"")}function sh(r){let t=[];for(let e of r){let n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);let s=rh[n];if(s==null)throw new Error(`Non-base256emoji character: ${e}`);t.push(s)}return new Uint8Array(t)}var ih=Ge({prefix:"\u{1F680}",name:"base256emoji",encode:nh,decode:sh});var Ii={};xt(Ii,{base64:()=>oh,base64pad:()=>ah,base64url:()=>ch,base64urlpad:()=>lh});var oh=et({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),ah=et({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),ch=et({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),lh=et({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var Ti={};xt(Ti,{base8:()=>uh});var uh=et({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var Ci={};xt(Ci,{identity:()=>fh});var fh=Ge({prefix:"\0",name:"identity",encode:r=>jo(r),decode:r=>Zo(r)});var ap=new TextEncoder,cp=new TextDecoder;var Ui={};xt(Ui,{sha256:()=>Sr,sha512:()=>ph});function Li({name:r,code:t,encode:e}){return new Ni(r,t,e)}var Ni=class{name;code;encode;constructor(t,e,n){this.name=t,this.code=e,this.encode=n}digest(t){if(t instanceof Uint8Array){let e=this.encode(t);return e instanceof Uint8Array?Ot(this.code,e):e.then(n=>Ot(this.code,n))}else throw Error("Unknown type, must be binary type")}};function Ka(r){return async t=>new Uint8Array(await crypto.subtle.digest(r,t))}var Sr=Li({name:"sha2-256",code:18,encode:Ka("SHA-256")}),ph=Li({name:"sha2-512",code:19,encode:Ka("SHA-512")});var Ir={...Ci,...ki,...Ti,...Bi,...Ai,...Fs,...Ks,...Hs,...Ii,...Si},xp={...Ui,...$s};function za(r,t,e,n){return{name:r,prefix:t,encoder:{name:r,prefix:t,encode:e},decoder:{decode:n}}}var qa=za("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),Ri=za("ascii","a",r=>{let t="a";for(let e=0;e<r.length;e++)t+=String.fromCharCode(r[e]);return t},r=>{r=r.substring(1);let t=Ct(r.length);for(let e=0;e<r.length;e++)t[e]=r.charCodeAt(e);return t}),mh={utf8:qa,"utf-8":qa,hex:Ir.base16,latin1:Ri,ascii:Ri,binary:Ri,...Ir},xn=mh;function Z(r,t="utf8"){let e=xn[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.decoder.decode(`${e.prefix}${r}`)}function _i(r){let t=r??8192,e=t>>>1,n,s=t;return function(o){if(o<1||o>e)return Ct(o);s+o>t&&(n=Ct(t),s=0);let a=n.subarray(s,s+=o);return s&7&&(s=(s|7)+1),a}}var Me=class{fn;len;next;val;constructor(t,e,n){this.fn=t,this.len=e,this.next=void 0,this.val=n}};function Vi(){}var Di=class{head;tail;len;next;constructor(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}},gh=_i();function yh(r){return globalThis.Buffer!=null?Ct(r):gh(r)}var Cr=class{len;head;tail;states;constructor(){this.len=0,this.head=new Me(Vi,0,0),this.tail=this.head,this.states=null}_push(t,e,n){return this.tail=this.tail.next=new Me(t,e,n),this.len+=e,this}uint32(t){return this.len+=(this.tail=this.tail.next=new Pi((t=t>>>0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this}int32(t){return t<0?this._push(vn,10,Ut.fromNumber(t)):this.uint32(t)}sint32(t){return this.uint32((t<<1^t>>31)>>>0)}uint64(t){let e=Ut.fromBigInt(t);return this._push(vn,e.length(),e)}uint64Number(t){return this._push(mi,Nt(t),t)}uint64String(t){return this.uint64(BigInt(t))}int64(t){return this.uint64(t)}int64Number(t){return this.uint64Number(t)}int64String(t){return this.uint64String(t)}sint64(t){let e=Ut.fromBigInt(t).zzEncode();return this._push(vn,e.length(),e)}sint64Number(t){let e=Ut.fromNumber(t).zzEncode();return this._push(vn,e.length(),e)}sint64String(t){return this.sint64(BigInt(t))}bool(t){return this._push(Oi,1,t?1:0)}fixed32(t){return this._push(Tr,4,t>>>0)}sfixed32(t){return this.fixed32(t)}fixed64(t){let e=Ut.fromBigInt(t);return this._push(Tr,4,e.lo)._push(Tr,4,e.hi)}fixed64Number(t){let e=Ut.fromNumber(t);return this._push(Tr,4,e.lo)._push(Tr,4,e.hi)}fixed64String(t){return this.fixed64(BigInt(t))}sfixed64(t){return this.fixed64(t)}sfixed64Number(t){return this.fixed64Number(t)}sfixed64String(t){return this.fixed64String(t)}float(t){return this._push(Ua,4,t)}double(t){return this._push(_a,8,t)}bytes(t){let e=t.length>>>0;return e===0?this._push(Oi,1,0):this.uint32(e)._push(wh,e,t)}string(t){let e=Da(t);return e!==0?this.uint32(e)._push(xi,e,t):this._push(Oi,1,0)}fork(){return this.states=new Di(this),this.head=this.tail=new Me(Vi,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Me(Vi,0,0),this.len=0),this}ldelim(){let t=this.head,e=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=t.next,this.tail=e,this.len+=n),this}finish(){let t=this.head.next,e=yh(this.len),n=0;for(;t!=null;)t.fn(t.val,e,n),n+=t.len,t=t.next;return e}};function Oi(r,t,e){t[e]=r&255}function bh(r,t,e){for(;r>127;)t[e++]=r&127|128,r>>>=7;t[e]=r}var Pi=class extends Me{next;constructor(t,e){super(bh,t,e),this.next=void 0}};function vn(r,t,e){for(;r.hi!==0;)t[e++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)t[e++]=r.lo&127|128,r.lo=r.lo>>>7;t[e++]=r.lo}function Tr(r,t,e){t[e]=r&255,t[e+1]=r>>>8&255,t[e+2]=r>>>16&255,t[e+3]=r>>>24}function wh(r,t,e){t.set(r,e)}globalThis.Buffer!=null&&(Cr.prototype.bytes=function(r){let t=r.length>>>0;return this.uint32(t),t>0&&this._push(xh,t,r),this},Cr.prototype.string=function(r){let t=globalThis.Buffer.byteLength(r);return this.uint32(t),t>0&&this._push(vh,t,r),this});function xh(r,t,e){t.set(r,e)}function vh(r,t,e){r.length<40?xi(r,t,e):t.utf8Write!=null?t.utf8Write(r,e):t.set(Z(r),e)}function Mi(){return new Cr}function Et(r,t){let e=Mi();return t.encode(r,e,{lengthDelimited:!1}),e.finish()}var er;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(er||(er={}));function En(r,t,e,n){return{name:r,type:t,encode:e,decode:n}}function Hi(r){function t(s){if(r[s.toString()]==null)throw new Error("Invalid enum value");return r[s]}let e=function(i,o){let a=t(i);o.int32(a)},n=function(i){let o=i.int32();return t(o)};return En("enum",er.VARINT,e,n)}function Bt(r,t){return En("message",er.LENGTH_DELIMITED,r,t)}var He=class extends Error{code="ERR_MAX_LENGTH";name="MaxLengthError"},Nr=class extends Error{code="ERR_MAX_SIZE";name="MaxSizeError"};var ot;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1"})(ot||(ot={}));var Fi;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1"})(Fi||(Fi={}));(function(r){r.codec=()=>Hi(Fi)})(ot||(ot={}));var Gt;(function(r){let t;r.codec=()=>(t==null&&(t=Bt((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),ot.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{let i={},o=n==null?e.len:e.pos+n;for(;e.pos<o;){let a=e.uint32();switch(a>>>3){case 1:{i.Type=ot.codec().decode(e);break}case 2:{i.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>Et(e,r.codec()),r.decode=(e,n)=>vt(e,r.codec(),n)})(Gt||(Gt={}));var Ki;(function(r){let t;r.codec=()=>(t==null&&(t=Bt((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),ot.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{let i={},o=n==null?e.len:e.pos+n;for(;e.pos<o;){let a=e.uint32();switch(a>>>3){case 1:{i.Type=ot.codec().decode(e);break}case 2:{i.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>Et(e,r.codec()),r.decode=(e,n)=>vt(e,r.codec(),n)})(Ki||(Ki={}));var Hr={};xt(Hr,{MAX_RSA_KEY_SIZE:()=>ds,generateRSAKeyPair:()=>Fc,jwkToJWKKeyPair:()=>Kc,jwkToPkcs1:()=>Dh,jwkToPkix:()=>Ji,jwkToRSAPrivateKey:()=>Hc,pkcs1ToJwk:()=>Dc,pkcs1ToRSAPrivateKey:()=>Mc,pkixToJwk:()=>Pc,pkixToRSAPublicKey:()=>Xi});var Eh=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Ee=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Be=new Uint32Array(64),qi=class extends Qe{constructor(){super(64,32,8,!1),this.A=Ee[0]|0,this.B=Ee[1]|0,this.C=Ee[2]|0,this.D=Ee[3]|0,this.E=Ee[4]|0,this.F=Ee[5]|0,this.G=Ee[6]|0,this.H=Ee[7]|0}get(){let{A:t,B:e,C:n,D:s,E:i,F:o,G:a,H:c}=this;return[t,e,n,s,i,o,a,c]}set(t,e,n,s,i,o,a,c){this.A=t|0,this.B=e|0,this.C=n|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=a|0,this.H=c|0}process(t,e){for(let u=0;u<16;u++,e+=4)Be[u]=t.getUint32(e,!1);for(let u=16;u<64;u++){let h=Be[u-15],p=Be[u-2],b=Dt(h,7)^Dt(h,18)^h>>>3,w=Dt(p,17)^Dt(p,19)^p>>>10;Be[u]=w+Be[u-7]+b+Be[u-16]|0}let{A:n,B:s,C:i,D:o,E:a,F:c,G:f,H:l}=this;for(let u=0;u<64;u++){let h=Dt(a,6)^Dt(a,11)^Dt(a,25),p=l+h+ha(a,c,f)+Eh[u]+Be[u]|0,w=(Dt(n,2)^Dt(n,13)^Dt(n,22))+da(n,s,i)|0;l=f,f=c,c=a,a=o+p|0,o=i,i=s,s=n,n=p+w|0}n=n+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,f=f+this.G|0,l=l+this.H|0,this.set(n,s,i,o,a,c,f,l)}roundClean(){Be.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var rr=on(()=>new qi);var M=$o(Ga());function Fe(r,t){let e=0;if(r.length===1)return r[0];for(let n=r.length-1;n>=0;n--)e+=r[r.length-1-n]*Math.pow(2,t*n);return e}function Ae(r,t,e=-1){let n=e,s=r,i=0,o=Math.pow(2,t);for(let a=1;a<8;a++){if(r<o){let c;if(n<0)c=new ArrayBuffer(a),i=a;else{if(n<a)return new ArrayBuffer(0);c=new ArrayBuffer(n),i=n}let f=new Uint8Array(c);for(let l=a-1;l>=0;l--){let u=Math.pow(2,l*t);f[i-l-1]=Math.floor(s/u),s-=f[i-l-1]*u}return c}o*=Math.pow(2,t)}return new ArrayBuffer(0)}function kn(...r){let t=0,e=0;for(let i of r)t+=i.length;let n=new ArrayBuffer(t),s=new Uint8Array(n);for(let i of r)s.set(i,e),e+=i.length;return s}function $i(){let r=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){let a=r[0]===255&&r[1]&128,c=r[0]===0&&(r[1]&128)===0;(a||c)&&this.warnings.push("Needlessly long format")}let t=new ArrayBuffer(this.valueHex.byteLength),e=new Uint8Array(t);for(let a=0;a<this.valueHex.byteLength;a++)e[a]=0;e[0]=r[0]&128;let n=Fe(e,8),s=new ArrayBuffer(this.valueHex.byteLength),i=new Uint8Array(s);for(let a=0;a<this.valueHex.byteLength;a++)i[a]=r[a];return i[0]&=127,Fe(i,8)-n}function Wa(r){let t=r<0?r*-1:r,e=128;for(let n=1;n<8;n++){if(t<=e){if(r<0){let o=e-t,a=Ae(o,8,n),c=new Uint8Array(a);return c[0]|=128,a}let s=Ae(t,8,n),i=new Uint8Array(s);if(i[0]&128){let o=s.slice(0),a=new Uint8Array(o);s=new ArrayBuffer(s.byteLength+1),i=new Uint8Array(s);for(let c=0;c<o.byteLength;c++)i[c+1]=a[c];i[0]=0}return s}e*=Math.pow(2,8)}return new ArrayBuffer(0)}function Za(r,t){if(r.byteLength!==t.byteLength)return!1;let e=new Uint8Array(r),n=new Uint8Array(t);for(let s=0;s<e.length;s++)if(e[s]!==n[s])return!1;return!0}function Lt(r,t){let e=r.toString(10);if(t<e.length)return"";let n=t-e.length,s=new Array(n);for(let o=0;o<n;o++)s[o]="0";return s.join("").concat(e)}var em=Math.log(2);function Sn(){if(typeof BigInt>"u")throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function Gi(r){let t=0,e=0;for(let s=0;s<r.length;s++){let i=r[s];t+=i.byteLength}let n=new Uint8Array(t);for(let s=0;s<r.length;s++){let i=r[s];n.set(new Uint8Array(i),e),e+=i.byteLength}return n.buffer}function ae(r,t,e,n){return t instanceof Uint8Array?t.byteLength?e<0?(r.error="Wrong parameter: inputOffset less than zero",!1):n<0?(r.error="Wrong parameter: inputLength less than zero",!1):t.byteLength-e-n<0?(r.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):!0:(r.error="Wrong parameter: inputBuffer has zero length",!1):(r.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}var Ur=class{constructor(){this.items=[]}write(t){this.items.push(t)}final(){return Gi(this.items)}},Lr=[new Uint8Array([1])],ja="0123456789";var ar="",Ft=new ArrayBuffer(0),Wi=new Uint8Array(0),Rr="EndOfContent",Ja="OCTET STRING",Xa="BIT STRING";function ce(r){var t;return t=class extends r{constructor(...n){var s;super(...n);let i=n[0]||{};this.isHexOnly=(s=i.isHexOnly)!==null&&s!==void 0?s:!1,this.valueHexView=i.valueHex?M.BufferSourceConverter.toUint8Array(i.valueHex):Wi}get valueHex(){return this.valueHexView.slice().buffer}set valueHex(n){this.valueHexView=new Uint8Array(n)}fromBER(n,s,i){let o=n instanceof ArrayBuffer?new Uint8Array(n):n;if(!ae(this,o,s,i))return-1;let a=s+i;return this.valueHexView=o.subarray(s,a),this.valueHexView.length?(this.blockLength=i,a):(this.warnings.push("Zero buffer length"),s)}toBER(n=!1){return this.isHexOnly?n?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",Ft)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:M.Convert.ToHex(this.valueHexView)}}},t.NAME="hexBlock",t}var se=class{constructor({blockLength:t=0,error:e=ar,warnings:n=[],valueBeforeDecode:s=Wi}={}){this.blockLength=t,this.error=e,this.warnings=n,this.valueBeforeDecodeView=M.BufferSourceConverter.toUint8Array(s)}static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(t){this.valueBeforeDecodeView=new Uint8Array(t)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:M.Convert.ToHex(this.valueBeforeDecodeView)}}};se.NAME="baseBlock";var yt=class extends se{fromBER(t,e,n){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(t,e){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}};yt.NAME="valueBlock";var In=class extends ce(se){constructor({idBlock:t={}}={}){var e,n,s,i;super(),t?(this.isHexOnly=(e=t.isHexOnly)!==null&&e!==void 0?e:!1,this.valueHexView=t.valueHex?M.BufferSourceConverter.toUint8Array(t.valueHex):Wi,this.tagClass=(n=t.tagClass)!==null&&n!==void 0?n:-1,this.tagNumber=(s=t.tagNumber)!==null&&s!==void 0?s:-1,this.isConstructed=(i=t.isConstructed)!==null&&i!==void 0?i:!1):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(t=!1){let e=0;switch(this.tagClass){case 1:e|=0;break;case 2:e|=64;break;case 3:e|=128;break;case 4:e|=192;break;default:return this.error="Unknown tag class",Ft}if(this.isConstructed&&(e|=32),this.tagNumber<31&&!this.isHexOnly){let s=new Uint8Array(1);if(!t){let i=this.tagNumber;i&=31,e|=i,s[0]=e}return s.buffer}if(!this.isHexOnly){let s=Ae(this.tagNumber,7),i=new Uint8Array(s),o=s.byteLength,a=new Uint8Array(o+1);if(a[0]=e|31,!t){for(let c=0;c<o-1;c++)a[c+1]=i[c]|128;a[o]=i[o-1]}return a.buffer}let n=new Uint8Array(this.valueHexView.byteLength+1);if(n[0]=e|31,!t){let s=this.valueHexView;for(let i=0;i<s.length-1;i++)n[i+1]=s[i]|128;n[this.valueHexView.byteLength]=s[s.length-1]}return n.buffer}fromBER(t,e,n){let s=M.BufferSourceConverter.toUint8Array(t);if(!ae(this,s,e,n))return-1;let i=s.subarray(e,e+n);if(i.length===0)return this.error="Zero buffer length",-1;switch(i[0]&192){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=(i[0]&32)===32,this.isHexOnly=!1;let a=i[0]&31;if(a!==31)this.tagNumber=a,this.blockLength=1;else{let c=1,f=this.valueHexView=new Uint8Array(255),l=255;for(;i[c]&128;){if(f[c-1]=i[c]&127,c++,c>=i.length)return this.error="End of input reached before message was fully decoded",-1;if(c===l){l+=255;let h=new Uint8Array(l);for(let p=0;p<f.length;p++)h[p]=f[p];f=this.valueHexView=new Uint8Array(l)}}this.blockLength=c+1,f[c-1]=i[c]&127;let u=new Uint8Array(c);for(let h=0;h<c;h++)u[h]=f[h];f=this.valueHexView=new Uint8Array(c),f.set(u),this.blockLength<=9?this.tagNumber=Fe(f,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(this.tagClass===1&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return e+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}};In.NAME="identificationBlock";var Tn=class extends se{constructor({lenBlock:t={}}={}){var e,n,s;super(),this.isIndefiniteForm=(e=t.isIndefiniteForm)!==null&&e!==void 0?e:!1,this.longFormUsed=(n=t.longFormUsed)!==null&&n!==void 0?n:!1,this.length=(s=t.length)!==null&&s!==void 0?s:0}fromBER(t,e,n){let s=M.BufferSourceConverter.toUint8Array(t);if(!ae(this,s,e,n))return-1;let i=s.subarray(e,e+n);if(i.length===0)return this.error="Zero buffer length",-1;if(i[0]===255)return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=i[0]===128,this.isIndefiniteForm)return this.blockLength=1,e+this.blockLength;if(this.longFormUsed=!!(i[0]&128),this.longFormUsed===!1)return this.length=i[0],this.blockLength=1,e+this.blockLength;let o=i[0]&127;if(o>8)return this.error="Too big integer",-1;if(o+1>i.length)return this.error="End of input reached before message was fully decoded",-1;let a=e+1,c=s.subarray(a,a+o);return c[o-1]===0&&this.warnings.push("Needlessly long encoded length"),this.length=Fe(c,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=o+1,e+this.blockLength}toBER(t=!1){let e,n;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return e=new ArrayBuffer(1),t===!1&&(n=new Uint8Array(e),n[0]=128),e;if(this.longFormUsed){let s=Ae(this.length,8);if(s.byteLength>127)return this.error="Too big length",Ft;if(e=new ArrayBuffer(s.byteLength+1),t)return e;let i=new Uint8Array(s);n=new Uint8Array(e),n[0]=s.byteLength|128;for(let o=0;o<s.byteLength;o++)n[o+1]=i[o];return e}return e=new ArrayBuffer(1),t===!1&&(n=new Uint8Array(e),n[0]=this.length),e}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}};Tn.NAME="lengthBlock";var B={},ht=class extends se{constructor({name:t=ar,optional:e=!1,primitiveSchema:n,...s}={},i){super(s),this.name=t,this.optional=e,n&&(this.primitiveSchema=n),this.idBlock=new In(s),this.lenBlock=new Tn(s),this.valueBlock=i?new i(s):new yt(s)}fromBER(t,e,n){let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}toBER(t,e){let n=e||new Ur;e||Qa(this);let s=this.idBlock.toBER(t);if(n.write(s),this.lenBlock.isIndefiniteForm)n.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(t,n),n.write(new ArrayBuffer(2));else{let i=this.valueBlock.toBER(t);this.lenBlock.length=i.byteLength;let o=this.lenBlock.toBER(t);n.write(o),n.write(i)}return e?Ft:n.final()}toJSON(){let t={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(t.primitiveSchema=this.primitiveSchema.toJSON()),t}toString(t="ascii"){return t==="ascii"?this.onAsciiEncoding():M.Convert.ToHex(this.toBER())}onAsciiEncoding(){return`${this.constructor.NAME} : ${M.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`}isEqual(t){if(this===t)return!0;if(!(t instanceof this.constructor))return!1;let e=this.toBER(),n=t.toBER();return Za(e,n)}};ht.NAME="BaseBlock";function Qa(r){if(r instanceof B.Constructed)for(let t of r.valueBlock.value)Qa(t)&&(r.lenBlock.isIndefiniteForm=!0);return!!r.lenBlock.isIndefiniteForm}var Cn=class extends ht{constructor({value:t=ar,...e}={},n){super(e,n),t&&this.fromString(t)}getValue(){return this.valueBlock.value}setValue(t){this.valueBlock.value=t}fromBER(t,e,n){let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}};Cn.NAME="BaseStringBlock";var Nn=class extends ce(yt){constructor({isHexOnly:t=!0,...e}={}){super(e),this.isHexOnly=t}};Nn.NAME="PrimitiveValueBlock";var tc,Ln=class extends ht{constructor(t={}){super(t,Nn),this.idBlock.isConstructed=!1}};tc=Ln;B.Primitive=tc;Ln.NAME="PRIMITIVE";function Lh(r,t){if(r instanceof t)return r;let e=new t;return e.idBlock=r.idBlock,e.lenBlock=r.lenBlock,e.warnings=r.warnings,e.valueBeforeDecodeView=r.valueBeforeDecodeView,e}function fs(r,t=0,e=r.length){let n=t,s=new ht({},yt),i=new se;if(!ae(i,r,t,e))return s.error=i.error,{offset:-1,result:s};if(!r.subarray(t,t+e).length)return s.error="Zero buffer length",{offset:-1,result:s};let a=s.idBlock.fromBER(r,t,e);if(s.idBlock.warnings.length&&s.warnings.concat(s.idBlock.warnings),a===-1)return s.error=s.idBlock.error,{offset:-1,result:s};if(t=a,e-=s.idBlock.blockLength,a=s.lenBlock.fromBER(r,t,e),s.lenBlock.warnings.length&&s.warnings.concat(s.lenBlock.warnings),a===-1)return s.error=s.lenBlock.error,{offset:-1,result:s};if(t=a,e-=s.lenBlock.blockLength,!s.idBlock.isConstructed&&s.lenBlock.isIndefiniteForm)return s.error="Indefinite length form used for primitive encoding form",{offset:-1,result:s};let c=ht;switch(s.idBlock.tagClass){case 1:if(s.idBlock.tagNumber>=37&&s.idBlock.isHexOnly===!1)return s.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:s};switch(s.idBlock.tagNumber){case 0:if(s.idBlock.isConstructed&&s.lenBlock.length>0)return s.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:s};c=B.EndOfContent;break;case 1:c=B.Boolean;break;case 2:c=B.Integer;break;case 3:c=B.BitString;break;case 4:c=B.OctetString;break;case 5:c=B.Null;break;case 6:c=B.ObjectIdentifier;break;case 10:c=B.Enumerated;break;case 12:c=B.Utf8String;break;case 13:c=B.RelativeObjectIdentifier;break;case 14:c=B.TIME;break;case 15:return s.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:s};case 16:c=B.Sequence;break;case 17:c=B.Set;break;case 18:c=B.NumericString;break;case 19:c=B.PrintableString;break;case 20:c=B.TeletexString;break;case 21:c=B.VideotexString;break;case 22:c=B.IA5String;break;case 23:c=B.UTCTime;break;case 24:c=B.GeneralizedTime;break;case 25:c=B.GraphicString;break;case 26:c=B.VisibleString;break;case 27:c=B.GeneralString;break;case 28:c=B.UniversalString;break;case 29:c=B.CharacterString;break;case 30:c=B.BmpString;break;case 31:c=B.DATE;break;case 32:c=B.TimeOfDay;break;case 33:c=B.DateTime;break;case 34:c=B.Duration;break;default:{let f=s.idBlock.isConstructed?new B.Constructed:new B.Primitive;f.idBlock=s.idBlock,f.lenBlock=s.lenBlock,f.warnings=s.warnings,s=f}}break;case 2:case 3:case 4:default:c=s.idBlock.isConstructed?B.Constructed:B.Primitive}return s=Lh(s,c),a=s.fromBER(r,t,s.lenBlock.isIndefiniteForm?e:s.lenBlock.length),s.valueBeforeDecodeView=r.subarray(n,n+s.blockLength),{offset:a,result:s}}function Zi(r){if(!r.byteLength){let t=new ht({},yt);return t.error="Input buffer has zero length",{offset:-1,result:t}}return fs(M.BufferSourceConverter.toUint8Array(r).slice(),0,r.byteLength)}function Uh(r,t){return r?1:t}var Wt=class extends yt{constructor({value:t=[],isIndefiniteForm:e=!1,...n}={}){super(n),this.value=t,this.isIndefiniteForm=e}fromBER(t,e,n){let s=M.BufferSourceConverter.toUint8Array(t);if(!ae(this,s,e,n))return-1;if(this.valueBeforeDecodeView=s.subarray(e,e+n),this.valueBeforeDecodeView.length===0)return this.warnings.push("Zero buffer length"),e;let i=e;for(;Uh(this.isIndefiniteForm,n)>0;){let o=fs(s,i,n);if(o.offset===-1)return this.error=o.result.error,this.warnings.concat(o.result.warnings),-1;if(i=o.offset,this.blockLength+=o.result.blockLength,n-=o.result.blockLength,this.value.push(o.result),this.isIndefiniteForm&&o.result.constructor.NAME===Rr)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===Rr?this.value.pop():this.warnings.push("No EndOfContent block encoded")),i}toBER(t,e){let n=e||new Ur;for(let s=0;s<this.value.length;s++)this.value[s].toBER(t,n);return e?Ft:n.final()}toJSON(){let t={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(let e of this.value)t.value.push(e.toJSON());return t}};Wt.NAME="ConstructedValueBlock";var ec,ke=class extends ht{constructor(t={}){super(t,Wt),this.idBlock.isConstructed=!0}fromBER(t,e,n){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){let t=[];for(let n of this.valueBlock.value)t.push(n.toString("ascii").split(`
./node_modules/@libp2p/peer-record/dist/index.min.js:2:"use strict";var Libp2PPeerRecord=(()=>{var Pc=Object.create;var Tr=Object.defineProperty;var Mc=Object.getOwnPropertyDescriptor;var Fc=Object.getOwnPropertyNames;var Kc=Object.getPrototypeOf,qc=Object.prototype.hasOwnProperty;var zc=(r,t)=>()=>(t||r((t={exports:{}}).exports,t),t.exports),bt=(r,t)=>{for(var e in t)Tr(r,e,{get:t[e],enumerable:!0})},Xo=(r,t,e,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of Fc(t))!qc.call(r,s)&&s!==e&&Tr(r,s,{get:()=>t[s],enumerable:!(n=Mc(t,s))||n.enumerable});return r};var $c=(r,t,e)=>(e=r!=null?Pc(Kc(r)):{},Xo(t||!r||!r.__esModule?Tr(e,"default",{value:r,enumerable:!0}):e,r)),Gc=r=>Xo(Tr({},"__esModule",{value:!0}),r);var Xi=zc(Ze=>{"use strict";var bf="[object ArrayBuffer]",te=class r{static isArrayBuffer(t){return Object.prototype.toString.call(t)===bf}static toArrayBuffer(t){return this.isArrayBuffer(t)?t:t.byteLength===t.buffer.byteLength||t.byteOffset===0&&t.byteLength===t.buffer.byteLength?t.buffer:this.toUint8Array(t.buffer).slice(t.byteOffset,t.byteOffset+t.byteLength).buffer}static toUint8Array(t){return this.toView(t,Uint8Array)}static toView(t,e){if(t.constructor===e)return t;if(this.isArrayBuffer(t))return new e(t);if(this.isArrayBufferView(t))return new e(t.buffer,t.byteOffset,t.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(t){return this.isArrayBufferView(t)||this.isArrayBuffer(t)}static isArrayBufferView(t){return ArrayBuffer.isView(t)||t&&this.isArrayBuffer(t.buffer)}static isEqual(t,e){let n=r.toUint8Array(t),s=r.toUint8Array(e);if(n.length!==s.byteLength)return!1;for(let o=0;o<n.length;o++)if(n[o]!==s[o])return!1;return!0}static concat(...t){let e;Array.isArray(t[0])&&!(t[1]instanceof Function)||Array.isArray(t[0])&&t[1]instanceof Function?e=t[0]:t[t.length-1]instanceof Function?e=t.slice(0,t.length-1):e=t;let n=0;for(let i of e)n+=i.byteLength;let s=new Uint8Array(n),o=0;for(let i of e){let a=this.toUint8Array(i);s.set(a,o),o+=a.length}return t[t.length-1]instanceof Function?this.toView(s,t[t.length-1]):s.buffer}},mo="string",wf=/^[0-9a-f\s]+$/i,xf=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,vf=/^[a-zA-Z0-9-_]+$/,Xr=class{static fromString(t){let e=unescape(encodeURIComponent(t)),n=new Uint8Array(e.length);for(let s=0;s<e.length;s++)n[s]=e.charCodeAt(s);return n.buffer}static toString(t){let e=te.toUint8Array(t),n="";for(let o=0;o<e.length;o++)n+=String.fromCharCode(e[o]);return decodeURIComponent(escape(n))}},Ct=class{static toString(t,e=!1){let n=te.toArrayBuffer(t),s=new DataView(n),o="";for(let i=0;i<n.byteLength;i+=2){let a=s.getUint16(i,e);o+=String.fromCharCode(a)}return o}static fromString(t,e=!1){let n=new ArrayBuffer(t.length*2),s=new DataView(n);for(let o=0;o<t.length;o++)s.setUint16(o*2,t.charCodeAt(o),e);return n}},Qr=class r{static isHex(t){return typeof t===mo&&wf.test(t)}static isBase64(t){return typeof t===mo&&xf.test(t)}static isBase64Url(t){return typeof t===mo&&vf.test(t)}static ToString(t,e="utf8"){let n=te.toUint8Array(t);switch(e.toLowerCase()){case"utf8":return this.ToUtf8String(n);case"binary":return this.ToBinary(n);case"hex":return this.ToHex(n);case"base64":return this.ToBase64(n);case"base64url":return this.ToBase64Url(n);case"utf16le":return Ct.toString(n,!0);case"utf16":case"utf16be":return Ct.toString(n);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromString(t,e="utf8"){if(!t)return new ArrayBuffer(0);switch(e.toLowerCase()){case"utf8":return this.FromUtf8String(t);case"binary":return this.FromBinary(t);case"hex":return this.FromHex(t);case"base64":return this.FromBase64(t);case"base64url":return this.FromBase64Url(t);case"utf16le":return Ct.fromString(t,!0);case"utf16":case"utf16be":return Ct.fromString(t);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToBase64(t){let e=te.toUint8Array(t);if(typeof btoa<"u"){let n=this.ToString(e,"binary");return btoa(n)}else return Buffer.from(e).toString("base64")}static FromBase64(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isBase64(e))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return typeof atob<"u"?this.FromBinary(atob(e)):new Uint8Array(Buffer.from(e,"base64")).buffer}static FromBase64Url(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isBase64Url(e))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(e.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(t){return this.ToBase64(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(t,e=r.DEFAULT_UTF8_ENCODING){switch(e){case"ascii":return this.FromBinary(t);case"utf8":return Xr.fromString(t);case"utf16":case"utf16be":return Ct.fromString(t);case"utf16le":case"usc2":return Ct.fromString(t,!0);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToUtf8String(t,e=r.DEFAULT_UTF8_ENCODING){switch(e){case"ascii":return this.ToBinary(t);case"utf8":return Xr.toString(t);case"utf16":case"utf16be":return Ct.toString(t);case"utf16le":case"usc2":return Ct.toString(t,!0);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromBinary(t){let e=t.length,n=new Uint8Array(e);for(let s=0;s<e;s++)n[s]=t.charCodeAt(s);return n.buffer}static ToBinary(t){let e=te.toUint8Array(t),n="";for(let s=0;s<e.length;s++)n+=String.fromCharCode(e[s]);return n}static ToHex(t){let e=te.toUint8Array(t),n="",s=e.length;for(let o=0;o<s;o++){let i=e[o];i<16&&(n+="0"),n+=i.toString(16)}return n}static FromHex(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isHex(e))throw new TypeError("Argument 'hexString' is not HEX encoded");e.length%2&&(e=`0${e}`);let n=new Uint8Array(e.length/2);for(let s=0;s<e.length;s=s+2){let o=e.slice(s,s+2);n[s/2]=parseInt(o,16)}return n.buffer}static ToUtf16String(t,e=!1){return Ct.toString(t,e)}static FromUtf16String(t,e=!1){return Ct.fromString(t,e)}static Base64Padding(t){let e=4-t.length%4;if(e<4)for(let n=0;n<e;n++)t+="=";return t}static formatString(t){return t?.replace(/[\n\r\t ]/g,"")||""}};Qr.DEFAULT_UTF8_ENCODING="utf8";function Bf(r,...t){let e=arguments[0];for(let n=1;n<arguments.length;n++){let s=arguments[n];for(let o in s)e[o]=s[o]}return e}function Ef(...r){let t=r.map(s=>s.byteLength).reduce((s,o)=>s+o),e=new Uint8Array(t),n=0;return r.map(s=>new Uint8Array(s)).forEach(s=>{for(let o of s)e[n++]=o}),e.buffer}function Af(r,t){if(!(r&&t)||r.byteLength!==t.byteLength)return!1;let e=new Uint8Array(r),n=new Uint8Array(t);for(let s=0;s<r.byteLength;s++)if(e[s]!==n[s])return!1;return!0}Ze.BufferSourceConverter=te;Ze.Convert=Qr;Ze.assign=Bf;Ze.combine=Ef;Ze.isEqual=Af});var fh={};bt(fh,{PeerRecord:()=>ss,RecordEnvelope:()=>Wn});var is=Symbol.for("@libp2p/peer-id");var wt=class extends Error{static name="InvalidParametersError";constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}},Ve=class extends Error{static name="InvalidPublicKeyError";constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}};var Ur=class extends Error{static name="InvalidMultihashError";constructor(t="Invalid Multihash"){super(t),this.name="InvalidMultihashError"}};var He=class extends Error{static name="UnsupportedKeyTypeError";constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}};var fs={};bt(fs,{base58btc:()=>Y,base58flickr:()=>Xc});var gh=new Uint8Array(0);function Qo(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function zt(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function ti(r){return new TextEncoder().encode(r)}function ei(r){return new TextDecoder().decode(r)}function jc(r,t){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),n=0;n<e.length;n++)e[n]=255;for(var s=0;s<r.length;s++){var o=r.charAt(s),i=o.charCodeAt(0);if(e[i]!==255)throw new TypeError(o+" is ambiguous");e[i]=s}var a=r.length,c=r.charAt(0),f=Math.log(a)/Math.log(256),l=Math.log(256)/Math.log(a);function u(b){if(b instanceof Uint8Array||(ArrayBuffer.isView(b)?b=new Uint8Array(b.buffer,b.byteOffset,b.byteLength):Array.isArray(b)&&(b=Uint8Array.from(b))),!(b instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(b.length===0)return"";for(var w=0,d=0,v=0,A=b.length;v!==A&&b[v]===0;)v++,w++;for(var g=(A-v)*l+1>>>0,k=new Uint8Array(g);v!==A;){for(var L=b[v],U=0,I=g-1;(L!==0||U<d)&&I!==-1;I--,U++)L+=256*k[I]>>>0,k[I]=L%a>>>0,L=L/a>>>0;if(L!==0)throw new Error("Non-zero carry");d=U,v++}for(var T=g-d;T!==g&&k[T]===0;)T++;for(var N=c.repeat(w);T<g;++T)N+=r.charAt(k[T]);return N}function h(b){if(typeof b!="string")throw new TypeError("Expected String");if(b.length===0)return new Uint8Array;var w=0;if(b[w]!==" "){for(var d=0,v=0;b[w]===c;)d++,w++;for(var A=(b.length-w)*f+1>>>0,g=new Uint8Array(A);b[w];){var k=e[b.charCodeAt(w)];if(k===255)return;for(var L=0,U=A-1;(k!==0||L<v)&&U!==-1;U--,L++)k+=a*g[U]>>>0,g[U]=k%256>>>0,k=k/256>>>0;if(k!==0)throw new Error("Non-zero carry");v=L,w++}if(b[w]!==" "){for(var I=A-v;I!==A&&g[I]===0;)I++;for(var T=new Uint8Array(d+(A-I)),N=d;I!==A;)T[N++]=g[I++];return T}}}function y(b){var w=h(b);if(w)return w;throw new Error(`Non-${t} character`)}return{encode:u,decodeUnsafe:h,decode:y}}var Zc=jc,Wc=Zc,ni=Wc;var as=class{name;prefix;baseEncode;constructor(t,e,n){this.name=t,this.prefix=e,this.baseEncode=n}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}},cs=class{name;prefix;baseDecode;prefixCodePoint;constructor(t,e,n){this.name=t,this.prefix=e;let s=e.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=n}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return si(this,t)}},ls=class{decoders;constructor(t){this.decoders=t}or(t){return si(this,t)}decode(t){let e=t[0],n=this.decoders[e];if(n!=null)return n.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};function si(r,t){return new ls({...r.decoders??{[r.prefix]:r},...t.decoders??{[t.prefix]:t}})}var us=class{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(t,e,n,s){this.name=t,this.prefix=e,this.baseEncode=n,this.baseDecode=s,this.encoder=new as(t,e,n),this.decoder=new cs(t,e,s)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}};function _e({name:r,prefix:t,encode:e,decode:n}){return new us(r,t,e,n)}function ce({name:r,prefix:t,alphabet:e}){let{encode:n,decode:s}=ni(e,r);return _e({prefix:t,name:r,encode:n,decode:o=>zt(s(o))})}function Jc(r,t,e,n){let s={};for(let l=0;l<t.length;++l)s[t[l]]=l;let o=r.length;for(;r[o-1]==="=";)--o;let i=new Uint8Array(o*e/8|0),a=0,c=0,f=0;for(let l=0;l<o;++l){let u=s[r[l]];if(u===void 0)throw new SyntaxError(`Non-${n} character`);c=c<<e|u,a+=e,a>=8&&(a-=8,i[f++]=255&c>>a)}if(a>=e||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return i}function Yc(r,t,e){let n=t[t.length-1]==="=",s=(1<<e)-1,o="",i=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],i+=8;i>e;)i-=e,o+=t[s&a>>i];if(i!==0&&(o+=t[s&a<<e-i]),n)for(;o.length*e&7;)o+="=";return o}function Q({name:r,prefix:t,bitsPerChar:e,alphabet:n}){return _e({prefix:t,name:r,encode(s){return Yc(s,n,e)},decode(s){return Jc(s,n,e,r)}})}var Y=ce({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Xc=ce({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var hs={};bt(hs,{base32:()=>$t,base32hex:()=>rl,base32hexpad:()=>sl,base32hexpadupper:()=>ol,base32hexupper:()=>nl,base32pad:()=>tl,base32padupper:()=>el,base32upper:()=>Qc,base32z:()=>il});var $t=Q({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Qc=Q({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),tl=Q({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),el=Q({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),rl=Q({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),nl=Q({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),sl=Q({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),ol=Q({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),il=Q({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var ds={};bt(ds,{base36:()=>nr,base36upper:()=>al});var nr=ce({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),al=ce({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var cl=ai,oi=128,ll=127,ul=~ll,fl=Math.pow(2,31);function ai(r,t,e){t=t||[],e=e||0;for(var n=e;r>=fl;)t[e++]=r&255|oi,r/=128;for(;r&ul;)t[e++]=r&255|oi,r>>>=7;return t[e]=r|0,ai.bytes=e-n+1,t}var hl=ps,dl=128,ii=127;function ps(r,n){var e=0,n=n||0,s=0,o=n,i,a=r.length;do{if(o>=a)throw ps.bytes=0,new RangeError("Could not decode varint");i=r[o++],e+=s<28?(i&ii)<<s:(i&ii)*Math.pow(2,s),s+=7}while(i>=dl);return ps.bytes=o-n,e}var pl=Math.pow(2,7),gl=Math.pow(2,14),ml=Math.pow(2,21),yl=Math.pow(2,28),bl=Math.pow(2,35),wl=Math.pow(2,42),xl=Math.pow(2,49),vl=Math.pow(2,56),Bl=Math.pow(2,63),El=function(r){return r<pl?1:r<gl?2:r<ml?3:r<yl?4:r<bl?5:r<wl?6:r<xl?7:r<vl?8:r<Bl?9:10},Al={encode:cl,decode:hl,encodingLength:El},Sl=Al,sr=Sl;function or(r,t=0){return[sr.decode(r,t),sr.decode.bytes]}function De(r,t,e=0){return sr.encode(r,t,e),t}function Oe(r){return sr.encodingLength(r)}function Tt(r,t){let e=t.byteLength,n=Oe(r),s=n+Oe(e),o=new Uint8Array(s+e);return De(r,o,0),De(e,o,n),o.set(t,s),new Pe(r,e,t,o)}function Be(r){let t=zt(r),[e,n]=or(t),[s,o]=or(t.subarray(n)),i=t.subarray(n+o);if(i.byteLength!==s)throw new Error("Incorrect length");return new Pe(e,s,i,t)}function ci(r,t){if(r===t)return!0;{let e=t;return r.code===e.code&&r.size===e.size&&e.bytes instanceof Uint8Array&&Qo(r.bytes,e.bytes)}}var Pe=class{code;size;digest;bytes;constructor(t,e,n,s){this.code=t,this.size=e,this.digest=n,this.bytes=s}};function li(r,t){let{bytes:e,version:n}=r;switch(n){case 0:return Il(e,gs(r),t??Y.encoder);default:return Nl(e,gs(r),t??$t.encoder)}}var ui=new WeakMap;function gs(r){let t=ui.get(r);if(t==null){let e=new Map;return ui.set(r,e),e}return t}var ct=class r{code;version;multihash;bytes;"/";constructor(t,e,n,s){this.code=e,this.version=t,this.multihash=n,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{let{code:t,multihash:e}=this;if(t!==ir)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==Cl)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return r.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{let{code:t,digest:e}=this.multihash,n=Tt(t,e);return r.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return r.equals(this,t)}static equals(t,e){let n=e;return n!=null&&t.code===n.code&&t.version===n.version&&ci(t.multihash,n.multihash)}toString(t){return li(this,t)}toJSON(){return{"/":li(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;let e=t;if(e instanceof r)return e;if(e["/"]!=null&&e["/"]===e.bytes||e.asCID===e){let{version:n,code:s,multihash:o,bytes:i}=e;return new r(n,s,o,i??fi(n,s,o.bytes))}else if(e[Tl]===!0){let{version:n,multihash:s,code:o}=e,i=Be(s);return r.create(n,o,i)}else return null}static create(t,e,n){if(typeof e!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(e!==ir)throw new Error(`Version 0 CID must use dag-pb (code: ${ir}) block encoding`);return new r(t,e,n,n.bytes)}case 1:{let s=fi(t,e,n.bytes);return new r(t,e,n,s)}default:throw new Error("Invalid version")}}static createV0(t){return r.create(0,ir,t)}static createV1(t,e){return r.create(1,t,e)}static decode(t){let[e,n]=r.decodeFirst(t);if(n.length!==0)throw new Error("Incorrect length");return e}static decodeFirst(t){let e=r.inspectBytes(t),n=e.size-e.multihashSize,s=zt(t.subarray(n,n+e.multihashSize));if(s.byteLength!==e.multihashSize)throw new Error("Incorrect length");let o=s.subarray(e.multihashSize-e.digestSize),i=new Pe(e.multihashCode,e.digestSize,o,s);return[e.version===0?r.createV0(i):r.createV1(e.codec,i),t.subarray(e.size)]}static inspectBytes(t){let e=0,n=()=>{let[u,h]=or(t.subarray(e));return e+=h,u},s=n(),o=ir;if(s===18?(s=0,e=0):o=n(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);let i=e,a=n(),c=n(),f=e+c,l=f-i;return{version:s,codec:o,multihashCode:a,digestSize:c,multihashSize:l,size:f}}static parse(t,e){let[n,s]=kl(t,e),o=r.decode(s);if(o.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return gs(o).set(n,t),o}};function kl(r,t){switch(r[0]){case"Q":{let e=t??Y;return[Y.prefix,e.decode(`${Y.prefix}${r}`)]}case Y.prefix:{let e=t??Y;return[Y.prefix,e.decode(r)]}case $t.prefix:{let e=t??$t;return[$t.prefix,e.decode(r)]}case nr.prefix:{let e=t??nr;return[nr.prefix,e.decode(r)]}default:{if(t==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],t.decode(r)]}}}function Il(r,t,e){let{prefix:n}=e;if(n!==Y.prefix)throw Error(`Cannot string encode V0 in ${e.name} encoding`);let s=t.get(n);if(s==null){let o=e.encode(r).slice(1);return t.set(n,o),o}else return s}function Nl(r,t,e){let{prefix:n}=e,s=t.get(n);if(s==null){let o=e.encode(r);return t.set(n,o),o}else return s}var ir=112,Cl=18;function fi(r,t,e){let n=Oe(r),s=n+Oe(t),o=new Uint8Array(s+e.byteLength);return De(r,o,0),De(t,o,n),o.set(e,s),o}var Tl=Symbol.for("@ipld/js-cid/CID");var ms={};bt(ms,{identity:()=>Gt});var hi=0,Ul="identity",di=zt;function Ll(r){return Tt(hi,di(r))}var Gt={code:hi,name:Ul,encode:di,digest:Ll};function dt(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function pi(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function Rl(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Me(r,...t){if(!Rl(r))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(r.length))throw new Error("Uint8Array expected of length "+t+", got length="+r.length)}function gi(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");pi(r.outputLen),pi(r.blockLen)}function Fe(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function mi(r,t){Me(r);let e=t.outputLen;if(r.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}var Ee=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var Rr=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),Ut=(r,t)=>r<<32-t|r>>>t;function yi(r){if(typeof r!="string")throw new Error("utf8ToBytes expected string, got "+typeof r);return new Uint8Array(new TextEncoder().encode(r))}function ar(r){return typeof r=="string"&&(r=yi(r)),Me(r),r}function ys(...r){let t=0;for(let n=0;n<r.length;n++){let s=r[n];Me(s),t+=s.length}let e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){let o=r[n];e.set(o,s),s+=o.length}return e}var Ke=class{clone(){return this._cloneInto()}};function Vr(r){let t=n=>r().update(ar(n)).digest(),e=r();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>r(),t}function Hr(r=32){if(Ee&&typeof Ee.getRandomValues=="function")return Ee.getRandomValues(new Uint8Array(r));if(Ee&&typeof Ee.randomBytes=="function")return Ee.randomBytes(r);throw new Error("crypto.getRandomValues must be defined")}function Vl(r,t,e,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(t,e,n);let s=BigInt(32),o=BigInt(4294967295),i=Number(e>>s&o),a=Number(e&o),c=n?4:0,f=n?0:4;r.setUint32(t+c,i,n),r.setUint32(t+f,a,n)}var bi=(r,t,e)=>r&t^~r&e,wi=(r,t,e)=>r&t^r&e^t&e,qe=class extends Ke{constructor(t,e,n,s){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=Rr(this.buffer)}update(t){Fe(this);let{view:e,buffer:n,blockLen:s}=this;t=ar(t);let o=t.length;for(let i=0;i<o;){let a=Math.min(s-this.pos,o-i);if(a===s){let c=Rr(t);for(;s<=o-i;i+=s)this.process(c,i);continue}n.set(t.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Fe(this),mi(t,this),this.finished=!0;let{buffer:e,view:n,blockLen:s,isLE:o}=this,{pos:i}=this;e[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>s-i&&(this.process(n,0),i=0);for(let u=i;u<s;u++)e[u]=0;Vl(n,s-8,BigInt(this.length*8),o),this.process(n,0);let a=Rr(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let f=c/4,l=this.get();if(f>l.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<f;u++)a.setUint32(4*u,l[u],o)}digest(){let{buffer:t,outputLen:e}=this;this.digestInto(t);let n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:e,buffer:n,length:s,finished:o,destroyed:i,pos:a}=this;return t.length=s,t.pos=a,t.finished=o,t.destroyed=i,s%e&&t.buffer.set(n),t}};var _r=BigInt(4294967295),bs=BigInt(32);function xi(r,t=!1){return t?{h:Number(r&_r),l:Number(r>>bs&_r)}:{h:Number(r>>bs&_r)|0,l:Number(r&_r)|0}}function Hl(r,t=!1){let e=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let s=0;s<r.length;s++){let{h:o,l:i}=xi(r[s],t);[e[s],n[s]]=[o,i]}return[e,n]}var _l=(r,t)=>BigInt(r>>>0)<<bs|BigInt(t>>>0),Dl=(r,t,e)=>r>>>e,Ol=(r,t,e)=>r<<32-e|t>>>e,Pl=(r,t,e)=>r>>>e|t<<32-e,Ml=(r,t,e)=>r<<32-e|t>>>e,Fl=(r,t,e)=>r<<64-e|t>>>e-32,Kl=(r,t,e)=>r>>>e-32|t<<64-e,ql=(r,t)=>t,zl=(r,t)=>r,$l=(r,t,e)=>r<<e|t>>>32-e,Gl=(r,t,e)=>t<<e|r>>>32-e,jl=(r,t,e)=>t<<e-32|r>>>64-e,Zl=(r,t,e)=>r<<e-32|t>>>64-e;function Wl(r,t,e,n){let s=(t>>>0)+(n>>>0);return{h:r+e+(s/2**32|0)|0,l:s|0}}var Jl=(r,t,e)=>(r>>>0)+(t>>>0)+(e>>>0),Yl=(r,t,e,n)=>t+e+n+(r/2**32|0)|0,Xl=(r,t,e,n)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0),Ql=(r,t,e,n,s)=>t+e+n+s+(r/2**32|0)|0,tu=(r,t,e,n,s)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(s>>>0),eu=(r,t,e,n,s,o)=>t+e+n+s+o+(r/2**32|0)|0;var ru={fromBig:xi,split:Hl,toBig:_l,shrSH:Dl,shrSL:Ol,rotrSH:Pl,rotrSL:Ml,rotrBH:Fl,rotrBL:Kl,rotr32H:ql,rotr32L:zl,rotlSH:$l,rotlSL:Gl,rotlBH:jl,rotlBL:Zl,add:Wl,add3L:Jl,add3H:Yl,add4L:Xl,add4H:Ql,add5H:eu,add5L:tu},_=ru;var[nu,su]=_.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),ue=new Uint32Array(80),fe=new Uint32Array(80),ws=class extends qe{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){let{Ah:t,Al:e,Bh:n,Bl:s,Ch:o,Cl:i,Dh:a,Dl:c,Eh:f,El:l,Fh:u,Fl:h,Gh:y,Gl:b,Hh:w,Hl:d}=this;return[t,e,n,s,o,i,a,c,f,l,u,h,y,b,w,d]}set(t,e,n,s,o,i,a,c,f,l,u,h,y,b,w,d){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=a|0,this.Dl=c|0,this.Eh=f|0,this.El=l|0,this.Fh=u|0,this.Fl=h|0,this.Gh=y|0,this.Gl=b|0,this.Hh=w|0,this.Hl=d|0}process(t,e){for(let g=0;g<16;g++,e+=4)ue[g]=t.getUint32(e),fe[g]=t.getUint32(e+=4);for(let g=16;g<80;g++){let k=ue[g-15]|0,L=fe[g-15]|0,U=_.rotrSH(k,L,1)^_.rotrSH(k,L,8)^_.shrSH(k,L,7),I=_.rotrSL(k,L,1)^_.rotrSL(k,L,8)^_.shrSL(k,L,7),T=ue[g-2]|0,N=fe[g-2]|0,j=_.rotrSH(T,N,19)^_.rotrBH(T,N,61)^_.shrSH(T,N,6),F=_.rotrSL(T,N,19)^_.rotrBL(T,N,61)^_.shrSL(T,N,6),O=_.add4L(I,F,fe[g-7],fe[g-16]),et=_.add4H(O,U,j,ue[g-7],ue[g-16]);ue[g]=et|0,fe[g]=O|0}let{Ah:n,Al:s,Bh:o,Bl:i,Ch:a,Cl:c,Dh:f,Dl:l,Eh:u,El:h,Fh:y,Fl:b,Gh:w,Gl:d,Hh:v,Hl:A}=this;for(let g=0;g<80;g++){let k=_.rotrSH(u,h,14)^_.rotrSH(u,h,18)^_.rotrBH(u,h,41),L=_.rotrSL(u,h,14)^_.rotrSL(u,h,18)^_.rotrBL(u,h,41),U=u&y^~u&w,I=h&b^~h&d,T=_.add5L(A,L,I,su[g],fe[g]),N=_.add5H(T,v,k,U,nu[g],ue[g]),j=T|0,F=_.rotrSH(n,s,28)^_.rotrBH(n,s,34)^_.rotrBH(n,s,39),O=_.rotrSL(n,s,28)^_.rotrBL(n,s,34)^_.rotrBL(n,s,39),et=n&o^n&a^o&a,B=s&i^s&c^i&c;v=w|0,A=d|0,w=y|0,d=b|0,y=u|0,b=h|0,{h:u,l:h}=_.add(f|0,l|0,N|0,j|0),f=a|0,l=c|0,a=o|0,c=i|0,o=n|0,i=s|0;let C=_.add3L(j,O,B);n=_.add3H(C,N,F,et),s=C|0}({h:n,l:s}=_.add(this.Ah|0,this.Al|0,n|0,s|0)),{h:o,l:i}=_.add(this.Bh|0,this.Bl|0,o|0,i|0),{h:a,l:c}=_.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:f,l}=_.add(this.Dh|0,this.Dl|0,f|0,l|0),{h:u,l:h}=_.add(this.Eh|0,this.El|0,u|0,h|0),{h:y,l:b}=_.add(this.Fh|0,this.Fl|0,y|0,b|0),{h:w,l:d}=_.add(this.Gh|0,this.Gl|0,w|0,d|0),{h:v,l:A}=_.add(this.Hh|0,this.Hl|0,v|0,A|0),this.set(n,s,o,i,a,c,f,l,u,h,y,b,w,d,v,A)}roundClean(){ue.fill(0),fe.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}};var vi=Vr(()=>new ws);var Pr={};bt(Pr,{aInRange:()=>Bt,abool:()=>Lt,abytes:()=>ze,bitGet:()=>uu,bitLen:()=>Es,bitMask:()=>lr,bitSet:()=>fu,bytesToHex:()=>Zt,bytesToNumberBE:()=>Wt,bytesToNumberLE:()=>de,concatBytes:()=>Jt,createHmacDrbg:()=>As,ensureBytes:()=>X,equalBytes:()=>cu,hexToBytes:()=>Se,hexToNumber:()=>Bs,inRange:()=>cr,isBytes:()=>he,memoized:()=>Ie,notImplemented:()=>du,numberToBytesBE:()=>pe,numberToBytesLE:()=>ke,numberToHexUnpadded:()=>Ae,numberToVarBytesBE:()=>au,utf8ToBytes:()=>lu,validateObject:()=>Dt});var Dr=BigInt(0),Or=BigInt(1),ou=BigInt(2);function he(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function ze(r){if(!he(r))throw new Error("Uint8Array expected")}function Lt(r,t){if(typeof t!="boolean")throw new Error(r+" boolean expected, got "+t)}var iu=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function Zt(r){ze(r);let t="";for(let e=0;e<r.length;e++)t+=iu[r[e]];return t}function Ae(r){let t=r.toString(16);return t.length&1?"0"+t:t}function Bs(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?Dr:BigInt("0x"+r)}var jt={_0:48,_9:57,A:65,F:70,a:97,f:102};function Bi(r){if(r>=jt._0&&r<=jt._9)return r-jt._0;if(r>=jt.A&&r<=jt.F)return r-(jt.A-10);if(r>=jt.a&&r<=jt.f)return r-(jt.a-10)}function Se(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);let t=r.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);let n=new Uint8Array(e);for(let s=0,o=0;s<e;s++,o+=2){let i=Bi(r.charCodeAt(o)),a=Bi(r.charCodeAt(o+1));if(i===void 0||a===void 0){let c=r[o]+r[o+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+o)}n[s]=i*16+a}return n}function Wt(r){return Bs(Zt(r))}function de(r){return ze(r),Bs(Zt(Uint8Array.from(r).reverse()))}function pe(r,t){return Se(r.toString(16).padStart(t*2,"0"))}function ke(r,t){return pe(r,t).reverse()}function au(r){return Se(Ae(r))}function X(r,t,e){let n;if(typeof t=="string")try{n=Se(t)}catch(o){throw new Error(r+" must be hex string or Uint8Array, cause: "+o)}else if(he(t))n=Uint8Array.from(t);else throw new Error(r+" must be hex string or Uint8Array");let s=n.length;if(typeof e=="number"&&s!==e)throw new Error(r+" of length "+e+" expected, got "+s);return n}function Jt(...r){let t=0;for(let n=0;n<r.length;n++){let s=r[n];ze(s),t+=s.length}let e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){let o=r[n];e.set(o,s),s+=o.length}return e}function cu(r,t){if(r.length!==t.length)return!1;let e=0;for(let n=0;n<r.length;n++)e|=r[n]^t[n];return e===0}function lu(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}var xs=r=>typeof r=="bigint"&&Dr<=r;function cr(r,t,e){return xs(r)&&xs(t)&&xs(e)&&t<=r&&r<e}function Bt(r,t,e,n){if(!cr(t,e,n))throw new Error("expected valid "+r+": "+e+" <= n < "+n+", got "+t)}function Es(r){let t;for(t=0;r>Dr;r>>=Or,t+=1);return t}function uu(r,t){return r>>BigInt(t)&Or}function fu(r,t,e){return r|(e?Or:Dr)<<BigInt(t)}var lr=r=>(ou<<BigInt(r-1))-Or,vs=r=>new Uint8Array(r),Ei=r=>Uint8Array.from(r);function As(r,t,e){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let n=vs(r),s=vs(r),o=0,i=()=>{n.fill(1),s.fill(0),o=0},a=(...u)=>e(s,n,...u),c=(u=vs())=>{s=a(Ei([0]),u),n=a(),u.length!==0&&(s=a(Ei([1]),u),n=a())},f=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let u=0,h=[];for(;u<t;){n=a();let y=n.slice();h.push(y),u+=n.length}return Jt(...h)};return(u,h)=>{i(),c(u);let y;for(;!(y=h(f()));)c();return i(),y}}var hu={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||he(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,t)=>t.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function Dt(r,t,e={}){let n=(s,o,i)=>{let a=hu[o];if(typeof a!="function")throw new Error("invalid validator function");let c=r[s];if(!(i&&c===void 0)&&!a(c,r))throw new Error("param "+String(s)+" is invalid. Expected "+o+", got "+c)};for(let[s,o]of Object.entries(t))n(s,o,!1);for(let[s,o]of Object.entries(e))n(s,o,!0);return r}var du=()=>{throw new Error("not implemented")};function Ie(r){let t=new WeakMap;return(e,...n)=>{let s=t.get(e);if(s!==void 0)return s;let o=r(e,...n);return t.set(e,o),o}}var rt=BigInt(0),Z=BigInt(1),Ne=BigInt(2),pu=BigInt(3),Ss=BigInt(4),Ai=BigInt(5),Si=BigInt(8),gu=BigInt(9),mu=BigInt(16);function z(r,t){let e=r%t;return e>=rt?e:t+e}function yu(r,t,e){if(t<rt)throw new Error("invalid exponent, negatives unsupported");if(e<=rt)throw new Error("invalid modulus");if(e===Z)return rt;let n=Z;for(;t>rt;)t&Z&&(n=n*r%e),r=r*r%e,t>>=Z;return n}function W(r,t,e){let n=r;for(;t-- >rt;)n*=n,n%=e;return n}function Mr(r,t){if(r===rt)throw new Error("invert: expected non-zero number");if(t<=rt)throw new Error("invert: expected positive modulus, got "+t);let e=z(r,t),n=t,s=rt,o=Z,i=Z,a=rt;for(;e!==rt;){let f=n/e,l=n%e,u=s-i*f,h=o-a*f;n=e,e=l,s=i,o=a,i=u,a=h}if(n!==Z)throw new Error("invert: does not exist");return z(s,t)}function bu(r){let t=(r-Z)/Ne,e,n,s;for(e=r-Z,n=0;e%Ne===rt;e/=Ne,n++);for(s=Ne;s<r&&yu(s,t,r)!==r-Z;s++)if(s>1e3)throw new Error("Cannot find square root: likely non-prime P");if(n===1){let i=(r+Z)/Ss;return function(c,f){let l=c.pow(f,i);if(!c.eql(c.sqr(l),f))throw new Error("Cannot find square root");return l}}let o=(e+Z)/Ne;return function(a,c){if(a.pow(c,t)===a.neg(a.ONE))throw new Error("Cannot find square root");let f=n,l=a.pow(a.mul(a.ONE,s),e),u=a.pow(c,o),h=a.pow(c,e);for(;!a.eql(h,a.ONE);){if(a.eql(h,a.ZERO))return a.ZERO;let y=1;for(let w=a.sqr(h);y<f&&!a.eql(w,a.ONE);y++)w=a.sqr(w);let b=a.pow(l,Z<<BigInt(f-y-1));l=a.sqr(b),u=a.mul(u,b),h=a.mul(h,l),f=y}return u}}function wu(r){if(r%Ss===pu){let t=(r+Z)/Ss;return function(n,s){let o=n.pow(s,t);if(!n.eql(n.sqr(o),s))throw new Error("Cannot find square root");return o}}if(r%Si===Ai){let t=(r-Ai)/Si;return function(n,s){let o=n.mul(s,Ne),i=n.pow(o,t),a=n.mul(s,i),c=n.mul(n.mul(a,Ne),i),f=n.mul(a,n.sub(c,n.ONE));if(!n.eql(n.sqr(f),s))throw new Error("Cannot find square root");return f}}return r%mu,bu(r)}var ki=(r,t)=>(z(r,t)&Z)===Z,xu=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ks(r){let t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=xu.reduce((n,s)=>(n[s]="function",n),t);return Dt(r,e)}function vu(r,t,e){if(e<rt)throw new Error("invalid exponent, negatives unsupported");if(e===rt)return r.ONE;if(e===Z)return t;let n=r.ONE,s=t;for(;e>rt;)e&Z&&(n=r.mul(n,s)),s=r.sqr(s),e>>=Z;return n}function Bu(r,t){let e=new Array(t.length),n=t.reduce((o,i,a)=>r.is0(i)?o:(e[a]=o,r.mul(o,i)),r.ONE),s=r.inv(n);return t.reduceRight((o,i,a)=>r.is0(i)?o:(e[a]=r.mul(o,e[a]),r.mul(o,i)),s),e}function Is(r,t){let e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}function ge(r,t,e=!1,n={}){if(r<=rt)throw new Error("invalid field: expected ORDER > 0, got "+r);let{nBitLength:s,nByteLength:o}=Is(r,t);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let i,a=Object.freeze({ORDER:r,isLE:e,BITS:s,BYTES:o,MASK:lr(s),ZERO:rt,ONE:Z,create:c=>z(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return rt<=c&&c<r},is0:c=>c===rt,isOdd:c=>(c&Z)===Z,neg:c=>z(-c,r),eql:(c,f)=>c===f,sqr:c=>z(c*c,r),add:(c,f)=>z(c+f,r),sub:(c,f)=>z(c-f,r),mul:(c,f)=>z(c*f,r),pow:(c,f)=>vu(a,c,f),div:(c,f)=>z(c*Mr(f,r),r),sqrN:c=>c*c,addN:(c,f)=>c+f,subN:(c,f)=>c-f,mulN:(c,f)=>c*f,inv:c=>Mr(c,r),sqrt:n.sqrt||(c=>(i||(i=wu(r)),i(a,c))),invertBatch:c=>Bu(a,c),cmov:(c,f,l)=>l?f:c,toBytes:c=>e?ke(c,o):pe(c,o),fromBytes:c=>{if(c.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+c.length);return e?de(c):Wt(c)}});return Object.freeze(a)}function Ii(r){if(typeof r!="bigint")throw new Error("field order must be bigint");let t=r.toString(2).length;return Math.ceil(t/8)}function Ns(r){let t=Ii(r);return t+Math.ceil(t/2)}function Ni(r,t,e=!1){let n=r.length,s=Ii(t),o=Ns(t);if(n<16||n<o||n>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+n);let i=e?de(r):Wt(r),a=z(i,t-Z)+Z;return e?ke(a,s):pe(a,s)}var Ci=BigInt(0),Fr=BigInt(1);function Cs(r,t){let e=t.negate();return r?e:t}function Ti(r,t){if(!Number.isSafeInteger(r)||r<=0||r>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+r)}function Ts(r,t){Ti(r,t);let e=Math.ceil(t/r)+1,n=2**(r-1);return{windows:e,windowSize:n}}function Au(r,t){if(!Array.isArray(r))throw new Error("array expected");r.forEach((e,n)=>{if(!(e instanceof t))throw new Error("invalid point at index "+n)})}function Su(r,t){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((e,n)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+n)})}var Us=new WeakMap,Ui=new WeakMap;function Ls(r){return Ui.get(r)||1}function Kr(r,t){return{constTimeNegate:Cs,hasPrecomputes(e){return Ls(e)!==1},unsafeLadder(e,n,s=r.ZERO){let o=e;for(;n>Ci;)n&Fr&&(s=s.add(o)),o=o.double(),n>>=Fr;return s},precomputeWindow(e,n){let{windows:s,windowSize:o}=Ts(n,t),i=[],a=e,c=a;for(let f=0;f<s;f++){c=a,i.push(c);for(let l=1;l<o;l++)c=c.add(a),i.push(c);a=c.double()}return i},wNAF(e,n,s){let{windows:o,windowSize:i}=Ts(e,t),a=r.ZERO,c=r.BASE,f=BigInt(2**e-1),l=2**e,u=BigInt(e);for(let h=0;h<o;h++){let y=h*i,b=Number(s&f);s>>=u,b>i&&(b-=l,s+=Fr);let w=y,d=y+Math.abs(b)-1,v=h%2!==0,A=b<0;b===0?c=c.add(Cs(v,n[w])):a=a.add(Cs(A,n[d]))}return{p:a,f:c}},wNAFUnsafe(e,n,s,o=r.ZERO){let{windows:i,windowSize:a}=Ts(e,t),c=BigInt(2**e-1),f=2**e,l=BigInt(e);for(let u=0;u<i;u++){let h=u*a;if(s===Ci)break;let y=Number(s&c);if(s>>=l,y>a&&(y-=f,s+=Fr),y===0)continue;let b=n[h+Math.abs(y)-1];y<0&&(b=b.negate()),o=o.add(b)}return o},getPrecomputes(e,n,s){let o=Us.get(n);return o||(o=this.precomputeWindow(n,e),e!==1&&Us.set(n,s(o))),o},wNAFCached(e,n,s){let o=Ls(e);return this.wNAF(o,this.getPrecomputes(o,e,s),n)},wNAFCachedUnsafe(e,n,s,o){let i=Ls(e);return i===1?this.unsafeLadder(e,n,o):this.wNAFUnsafe(i,this.getPrecomputes(i,e,s),n,o)},setWindowSize(e,n){Ti(n,t),Ui.set(e,n),Us.delete(e)}}}function qr(r,t,e,n){if(Au(e,r),Su(n,t),e.length!==n.length)throw new Error("arrays of points and scalars must have equal length");let s=r.ZERO,o=Es(BigInt(e.length)),i=o>12?o-3:o>4?o-2:o?2:1,a=(1<<i)-1,c=new Array(a+1).fill(s),f=Math.floor((t.BITS-1)/i)*i,l=s;for(let u=f;u>=0;u-=i){c.fill(s);for(let y=0;y<n.length;y++){let b=n[y],w=Number(b>>BigInt(u)&BigInt(a));c[w]=c[w].add(e[y])}let h=s;for(let y=c.length-1,b=s;y>0;y--)b=b.add(c[y]),h=h.add(b);if(l=l.add(h),u!==0)for(let y=0;y<i;y++)l=l.double()}return l}function ur(r){return ks(r.Fp),Dt(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Is(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}var Rt=BigInt(0),Et=BigInt(1),zr=BigInt(2),ku=BigInt(8),Iu={zip215:!0};function Nu(r){let t=ur(r);return Dt(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}function Li(r){let t=Nu(r),{Fp:e,n,prehash:s,hash:o,randomBytes:i,nByteLength:a,h:c}=t,f=zr<<BigInt(a*8)-Et,l=e.create,u=ge(t.n,t.nBitLength),h=t.uvRatio||((m,p)=>{try{return{isValid:!0,value:e.sqrt(m*e.inv(p))}}catch{return{isValid:!1,value:Rt}}}),y=t.adjustScalarBytes||(m=>m),b=t.domain||((m,p,x)=>{if(Lt("phflag",x),p.length||x)throw new Error("Contexts/pre-hash are not supported");return m});function w(m,p){Bt("coordinate "+m,p,Rt,f)}function d(m){if(!(m instanceof g))throw new Error("ExtendedPoint expected")}let v=Ie((m,p)=>{let{ex:x,ey:S,ez:R}=m,V=m.is0();p==null&&(p=V?ku:e.inv(R));let D=l(x*p),M=l(S*p),H=l(R*p);if(V)return{x:Rt,y:Et};if(H!==Et)throw new Error("invZ was invalid");return{x:D,y:M}}),A=Ie(m=>{let{a:p,d:x}=t;if(m.is0())throw new Error("bad point: ZERO");let{ex:S,ey:R,ez:V,et:D}=m,M=l(S*S),H=l(R*R),q=l(V*V),G=l(q*q),st=l(M*p),ot=l(q*l(st+H)),at=l(G+l(x*l(M*H)));if(ot!==at)throw new Error("bad point: equation left != right (1)");let ht=l(S*R),vt=l(V*D);if(ht!==vt)throw new Error("bad point: equation left != right (2)");return!0});class g{constructor(p,x,S,R){this.ex=p,this.ey=x,this.ez=S,this.et=R,w("x",p),w("y",x),w("z",S),w("t",R),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(p){if(p instanceof g)throw new Error("extended point not allowed");let{x,y:S}=p||{};return w("x",x),w("y",S),new g(x,S,Et,l(x*S))}static normalizeZ(p){let x=e.invertBatch(p.map(S=>S.ez));return p.map((S,R)=>S.toAffine(x[R])).map(g.fromAffine)}static msm(p,x){return qr(g,u,p,x)}_setWindowSize(p){U.setWindowSize(this,p)}assertValidity(){A(this)}equals(p){d(p);let{ex:x,ey:S,ez:R}=this,{ex:V,ey:D,ez:M}=p,H=l(x*M),q=l(V*R),G=l(S*M),st=l(D*R);return H===q&&G===st}is0(){return this.equals(g.ZERO)}negate(){return new g(l(-this.ex),this.ey,this.ez,l(-this.et))}double(){let{a:p}=t,{ex:x,ey:S,ez:R}=this,V=l(x*x),D=l(S*S),M=l(zr*l(R*R)),H=l(p*V),q=x+S,G=l(l(q*q)-V-D),st=H+D,ot=st-M,at=H-D,ht=l(G*ot),vt=l(st*at),yt=l(G*at),_t=l(ot*st);return new g(ht,vt,_t,yt)}add(p){d(p);let{a:x,d:S}=t,{ex:R,ey:V,ez:D,et:M}=this,{ex:H,ey:q,ez:G,et:st}=p;if(x===BigInt(-1)){let $o=l((V-R)*(q+H)),Go=l((V+R)*(q-H)),os=l(Go-$o);if(os===Rt)return this.double();let jo=l(D*zr*st),Zo=l(M*zr*G),Wo=Zo+jo,Jo=Go+$o,Yo=Zo-jo,Hc=l(Wo*os),_c=l(Jo*Yo),Dc=l(Wo*Yo),Oc=l(os*Jo);return new g(Hc,_c,Oc,Dc)}let ot=l(R*H),at=l(V*q),ht=l(M*S*st),vt=l(D*G),yt=l((R+V)*(H+q)-ot-at),_t=vt-ht,qt=vt+ht,rr=l(at-x*ot),Uc=l(yt*_t),Lc=l(qt*rr),Rc=l(yt*rr),Vc=l(_t*qt);return new g(Uc,Lc,Vc,Rc)}subtract(p){return this.add(p.negate())}wNAF(p){return U.wNAFCached(this,p,g.normalizeZ)}multiply(p){let x=p;Bt("scalar",x,Et,n);let{p:S,f:R}=this.wNAF(x);return g.normalizeZ([S,R])[0]}multiplyUnsafe(p,x=g.ZERO){let S=p;return Bt("scalar",S,Rt,n),S===Rt?L:this.is0()||S===Et?this:U.wNAFCachedUnsafe(this,S,g.normalizeZ,x)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return U.unsafeLadder(this,n).is0()}toAffine(p){return v(this,p)}clearCofactor(){let{h:p}=t;return p===Et?this:this.multiplyUnsafe(p)}static fromHex(p,x=!1){let{d:S,a:R}=t,V=e.BYTES;p=X("pointHex",p,V),Lt("zip215",x);let D=p.slice(),M=p[V-1];D[V-1]=M&-129;let H=de(D),q=x?f:e.ORDER;Bt("pointHex.y",H,Rt,q);let G=l(H*H),st=l(G-Et),ot=l(S*G-R),{isValid:at,value:ht}=h(st,ot);if(!at)throw new Error("Point.fromHex: invalid y coordinate");let vt=(ht&Et)===Et,yt=(M&128)!==0;if(!x&&ht===Rt&&yt)throw new Error("Point.fromHex: x=0 and x_0=1");return yt!==vt&&(ht=l(-ht)),g.fromAffine({x:ht,y:H})}static fromPrivateKey(p){return N(p).point}toRawBytes(){let{x:p,y:x}=this.toAffine(),S=ke(x,e.BYTES);return S[S.length-1]|=p&Et?128:0,S}toHex(){return Zt(this.toRawBytes())}}g.BASE=new g(t.Gx,t.Gy,Et,l(t.Gx*t.Gy)),g.ZERO=new g(Rt,Et,Et,Rt);let{BASE:k,ZERO:L}=g,U=Kr(g,a*8);function I(m){return z(m,n)}function T(m){return I(de(m))}function N(m){let p=e.BYTES;m=X("private key",m,p);let x=X("hashed private key",o(m),2*p),S=y(x.slice(0,p)),R=x.slice(p,2*p),V=T(S),D=k.multiply(V),M=D.toRawBytes();return{head:S,prefix:R,scalar:V,point:D,pointBytes:M}}function j(m){return N(m).pointBytes}function F(m=new Uint8Array,...p){let x=Jt(...p);return T(o(b(x,X("context",m),!!s)))}function O(m,p,x={}){m=X("message",m),s&&(m=s(m));let{prefix:S,scalar:R,pointBytes:V}=N(p),D=F(x.context,S,m),M=k.multiply(D).toRawBytes(),H=F(x.context,M,V,m),q=I(D+H*R);Bt("signature.s",q,Rt,n);let G=Jt(M,ke(q,e.BYTES));return X("result",G,e.BYTES*2)}let et=Iu;function B(m,p,x,S=et){let{context:R,zip215:V}=S,D=e.BYTES;m=X("signature",m,2*D),p=X("message",p),x=X("publicKey",x,D),V!==void 0&&Lt("zip215",V),s&&(p=s(p));let M=de(m.slice(D,2*D)),H,q,G;try{H=g.fromHex(x,V),q=g.fromHex(m.slice(0,D),V),G=k.multiplyUnsafe(M)}catch{return!1}if(!V&&H.isSmallOrder())return!1;let st=F(R,q.toRawBytes(),H.toRawBytes(),p);return q.add(H.multiplyUnsafe(st)).subtract(G).clearCofactor().equals(g.ZERO)}return k._setWindowSize(8),{CURVE:t,getPublicKey:j,sign:O,verify:B,ExtendedPoint:g,utils:{getExtendedPublicKey:N,randomPrivateKey:()=>i(e.BYTES),precompute(m=8,p=g.BASE){return p._setWindowSize(m),p.multiply(BigInt(3)),p}}}}var Rs=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Ri=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),id=BigInt(0),Cu=BigInt(1),Vi=BigInt(2),ad=BigInt(3),Tu=BigInt(5),Uu=BigInt(8);function Lu(r){let t=BigInt(10),e=BigInt(20),n=BigInt(40),s=BigInt(80),o=Rs,a=r*r%o*r%o,c=W(a,Vi,o)*a%o,f=W(c,Cu,o)*r%o,l=W(f,Tu,o)*f%o,u=W(l,t,o)*l%o,h=W(u,e,o)*u%o,y=W(h,n,o)*h%o,b=W(y,s,o)*y%o,w=W(b,s,o)*y%o,d=W(w,t,o)*l%o;return{pow_p_5_8:W(d,Vi,o)*r%o,b2:a}}function Ru(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function Vu(r,t){let e=Rs,n=z(t*t*t,e),s=z(n*n*t,e),o=Lu(r*s).pow_p_5_8,i=z(r*n*o,e),a=z(t*i*i,e),c=i,f=z(i*Ri,e),l=a===r,u=a===z(-r,e),h=a===z(-r*Ri,e);return l&&(i=c),(u||h)&&(i=f),ki(i,e)&&(i=z(-i,e)),{isValid:l||u,value:i}}var Hu=ge(Rs,void 0,!0),_u={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:Hu,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:Uu,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:vi,randomBytes:Hr,adjustScalarBytes:Ru,uvRatio:Vu},Hi=Li(_u);var $r=32;function _i(r,t,e){return Hi.verify(t,e instanceof Uint8Array?e:e.subarray(),r)}var Gr=class{type="Ed25519";raw;constructor(t){this.raw=Vs(t,$r)}toMultihash(){return Gt.digest($e(this))}toCID(){return ct.createV1(114,this.toMultihash())}toString(){return Y.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:dt(this.raw,t.raw)}verify(t,e){return _i(this.raw,e,t)}};function Hs(r){return r=Vs(r,$r),new Gr(r)}function Vs(r,t){if(r=Uint8Array.from(r??[]),r.length!==t)throw new wt(`Key must be a Uint8Array of length ${t}, got ${r.length}`);return r}function lt(r=0){return new Uint8Array(r)}function At(r=0){return new Uint8Array(r)}var Ou=Math.pow(2,7),Pu=Math.pow(2,14),Mu=Math.pow(2,21),_s=Math.pow(2,28),Ds=Math.pow(2,35),Os=Math.pow(2,42),Ps=Math.pow(2,49),K=128,pt=127;function St(r){if(r<Ou)return 1;if(r<Pu)return 2;if(r<Mu)return 3;if(r<_s)return 4;if(r<Ds)return 5;if(r<Os)return 6;if(r<Ps)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function Ms(r,t,e=0){switch(St(r)){case 8:t[e++]=r&255|K,r/=128;case 7:t[e++]=r&255|K,r/=128;case 6:t[e++]=r&255|K,r/=128;case 5:t[e++]=r&255|K,r/=128;case 4:t[e++]=r&255|K,r>>>=7;case 3:t[e++]=r&255|K,r>>>=7;case 2:t[e++]=r&255|K,r>>>=7;case 1:{t[e++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return t}function Fu(r,t,e=0){switch(St(r)){case 8:t.set(e++,r&255|K),r/=128;case 7:t.set(e++,r&255|K),r/=128;case 6:t.set(e++,r&255|K),r/=128;case 5:t.set(e++,r&255|K),r/=128;case 4:t.set(e++,r&255|K),r>>>=7;case 3:t.set(e++,r&255|K),r>>>=7;case 2:t.set(e++,r&255|K),r>>>=7;case 1:{t.set(e++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return t}function Fs(r,t){let e=r[t],n=0;if(n+=e&pt,e<K||(e=r[t+1],n+=(e&pt)<<7,e<K)||(e=r[t+2],n+=(e&pt)<<14,e<K)||(e=r[t+3],n+=(e&pt)<<21,e<K)||(e=r[t+4],n+=(e&pt)*_s,e<K)||(e=r[t+5],n+=(e&pt)*Ds,e<K)||(e=r[t+6],n+=(e&pt)*Os,e<K)||(e=r[t+7],n+=(e&pt)*Ps,e<K))return n;throw new RangeError("Could not decode varint")}function Ku(r,t){let e=r.get(t),n=0;if(n+=e&pt,e<K||(e=r.get(t+1),n+=(e&pt)<<7,e<K)||(e=r.get(t+2),n+=(e&pt)<<14,e<K)||(e=r.get(t+3),n+=(e&pt)<<21,e<K)||(e=r.get(t+4),n+=(e&pt)*_s,e<K)||(e=r.get(t+5),n+=(e&pt)*Ds,e<K)||(e=r.get(t+6),n+=(e&pt)*Os,e<K)||(e=r.get(t+7),n+=(e&pt)*Ps,e<K))return n;throw new RangeError("Could not decode varint")}function Ot(r,t,e=0){return t==null&&(t=At(St(r))),t instanceof Uint8Array?Ms(r,t,e):Fu(r,t,e)}function Ce(r,t=0){return r instanceof Uint8Array?Fs(r,t):Ku(r,t)}var qs=new Float32Array([-0]),me=new Uint8Array(qs.buffer);function Oi(r,t,e){qs[0]=r,t[e]=me[0],t[e+1]=me[1],t[e+2]=me[2],t[e+3]=me[3]}function Pi(r,t){return me[0]=r[t],me[1]=r[t+1],me[2]=r[t+2],me[3]=r[t+3],qs[0]}var zs=new Float64Array([-0]),gt=new Uint8Array(zs.buffer);function Mi(r,t,e){zs[0]=r,t[e]=gt[0],t[e+1]=gt[1],t[e+2]=gt[2],t[e+3]=gt[3],t[e+4]=gt[4],t[e+5]=gt[5],t[e+6]=gt[6],t[e+7]=gt[7]}function Fi(r,t){return gt[0]=r[t],gt[1]=r[t+1],gt[2]=r[t+2],gt[3]=r[t+3],gt[4]=r[t+4],gt[5]=r[t+5],gt[6]=r[t+6],gt[7]=r[t+7],zs[0]}var qu=BigInt(Number.MAX_SAFE_INTEGER),zu=BigInt(Number.MIN_SAFE_INTEGER),It=class r{lo;hi;constructor(t,e){this.lo=t|0,this.hi=e|0}toNumber(t=!1){if(!t&&this.hi>>>31>0){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(e+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(t=!1){if(t)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(BigInt(e)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(t=!1){return this.toBigInt(t).toString()}zzEncode(){let t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this}zzDecode(){let t=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this}length(){let t=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?e===0?t<16384?t<128?1:2:t<2097152?3:4:e<16384?e<128?5:6:e<2097152?7:8:n<128?9:10}static fromBigInt(t){if(t===0n)return Te;if(t<qu&&t>zu)return this.fromNumber(Number(t));let e=t<0n;e&&(t=-t);let n=t>>32n,s=t-(n<<32n);return e&&(n=~n|0n,s=~s|0n,++s>Ki&&(s=0n,++n>Ki&&(n=0n))),new r(Number(s),Number(n))}static fromNumber(t){if(t===0)return Te;let e=t<0;e&&(t=-t);let n=t>>>0,s=(t-n)/4294967296>>>0;return e&&(s=~s>>>0,n=~n>>>0,++n>4294967295&&(n=0,++s>4294967295&&(s=0))),new r(n,s)}static from(t){return typeof t=="number"?r.fromNumber(t):typeof t=="bigint"?r.fromBigInt(t):typeof t=="string"?r.fromBigInt(BigInt(t)):t.low!=null||t.high!=null?new r(t.low>>>0,t.high>>>0):Te}},Te=new It(0,0);Te.toBigInt=function(){return 0n};Te.zzEncode=Te.zzDecode=function(){return this};Te.length=function(){return 1};var Ki=4294967296n;function qi(r){let t=0,e=0;for(let n=0;n<r.length;++n)e=r.charCodeAt(n),e<128?t+=1:e<2048?t+=2:(e&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,t+=4):t+=3;return t}function zi(r,t,e){if(e-t<1)return"";let s,o=[],i=0,a;for(;t<e;)a=r[t++],a<128?o[i++]=a:a>191&&a<224?o[i++]=(a&31)<<6|r[t++]&63:a>239&&a<365?(a=((a&7)<<18|(r[t++]&63)<<12|(r[t++]&63)<<6|r[t++]&63)-65536,o[i++]=55296+(a>>10),o[i++]=56320+(a&1023)):o[i++]=(a&15)<<12|(r[t++]&63)<<6|r[t++]&63,i>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,o)),i=0);return s!=null?(i>0&&s.push(String.fromCharCode.apply(String,o.slice(0,i))),s.join("")):String.fromCharCode.apply(String,o.slice(0,i))}function $s(r,t,e){let n=e,s,o;for(let i=0;i<r.length;++i)s=r.charCodeAt(i),s<128?t[e++]=s:s<2048?(t[e++]=s>>6|192,t[e++]=s&63|128):(s&64512)===55296&&((o=r.charCodeAt(i+1))&64512)===56320?(s=65536+((s&1023)<<10)+(o&1023),++i,t[e++]=s>>18|240,t[e++]=s>>12&63|128,t[e++]=s>>6&63|128,t[e++]=s&63|128):(t[e++]=s>>12|224,t[e++]=s>>6&63|128,t[e++]=s&63|128);return e-n}function Vt(r,t){return RangeError(`index out of range: ${r.pos} + ${t??1} > ${r.len}`)}function jr(r,t){return(r[t-4]|r[t-3]<<8|r[t-2]<<16|r[t-1]<<24)>>>0}var Gs=class{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(t){this.buf=t,this.pos=0,this.len=t.length}uint32(){let t=4294967295;if(t=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(t=(t|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return t;if((this.pos+=5)>this.len)throw this.pos=this.len,Vt(this,10);return t}int32(){return this.uint32()|0}sint32(){let t=this.uint32();return t>>>1^-(t&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw Vt(this,4);return jr(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw Vt(this,4);return jr(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw Vt(this,4);let t=Pi(this.buf,this.pos);return this.pos+=4,t}double(){if(this.pos+8>this.len)throw Vt(this,4);let t=Fi(this.buf,this.pos);return this.pos+=8,t}bytes(){let t=this.uint32(),e=this.pos,n=this.pos+t;if(n>this.len)throw Vt(this,t);return this.pos+=t,e===n?new Uint8Array(0):this.buf.subarray(e,n)}string(){let t=this.bytes();return zi(t,0,t.length)}skip(t){if(typeof t=="number"){if(this.pos+t>this.len)throw Vt(this,t);this.pos+=t}else do if(this.pos>=this.len)throw Vt(this);while(this.buf[this.pos++]&128);return this}skipType(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${t} at offset ${this.pos}`)}return this}readLongVarint(){let t=new It(0,0),e=0;if(this.len-this.pos>4){for(;e<4;++e)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw Vt(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,t}if(this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw Vt(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw Vt(this,8);let t=jr(this.buf,this.pos+=4),e=jr(this.buf,this.pos+=4);return new It(t,e)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){let t=Fs(this.buf,this.pos);return this.pos+=St(t),t}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}};function js(r){return new Gs(r instanceof Uint8Array?r:r.subarray())}function Yt(r,t,e){let n=js(r);return t.decode(n,void 0,e)}var Zs={};bt(Zs,{base10:()=>$u});var $u=ce({prefix:"9",name:"base10",alphabet:"0123456789"});var Ws={};bt(Ws,{base16:()=>Gu,base16upper:()=>ju});var Gu=Q({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),ju=Q({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var Js={};bt(Js,{base2:()=>Zu});var Zu=Q({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var Ys={};bt(Ys,{base256emoji:()=>Qu});var Gi=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),Wu=Gi.reduce((r,t,e)=>(r[e]=t,r),[]),Ju=Gi.reduce((r,t,e)=>{let n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);return r[n]=e,r},[]);function Yu(r){return r.reduce((t,e)=>(t+=Wu[e],t),"")}function Xu(r){let t=[];for(let e of r){let n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);let s=Ju[n];if(s==null)throw new Error(`Non-base256emoji character: ${e}`);t.push(s)}return new Uint8Array(t)}var Qu=_e({prefix:"\u{1F680}",name:"base256emoji",encode:Yu,decode:Xu});var Xs={};bt(Xs,{base64:()=>tf,base64pad:()=>ef,base64url:()=>rf,base64urlpad:()=>nf});var tf=Q({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),ef=Q({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),rf=Q({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),nf=Q({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var Qs={};bt(Qs,{base8:()=>sf});var sf=Q({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var to={};bt(to,{identity:()=>of});var of=_e({prefix:"\0",name:"identity",encode:r=>ei(r),decode:r=>ti(r)});var qd=new TextEncoder,zd=new TextDecoder;var no={};bt(no,{sha256:()=>fr,sha512:()=>lf});function ro({name:r,code:t,encode:e}){return new eo(r,t,e)}var eo=class{name;code;encode;constructor(t,e,n){this.name=t,this.code=e,this.encode=n}digest(t){if(t instanceof Uint8Array){let e=this.encode(t);return e instanceof Uint8Array?Tt(this.code,e):e.then(n=>Tt(this.code,n))}else throw Error("Unknown type, must be binary type")}};function Zi(r){return async t=>new Uint8Array(await crypto.subtle.digest(r,t))}var fr=ro({name:"sha2-256",code:18,encode:Zi("SHA-256")}),lf=ro({name:"sha2-512",code:19,encode:Zi("SHA-512")});var hr={...to,...Js,...Qs,...Zs,...Ws,...hs,...ds,...fs,...Xs,...Ys},r0={...no,...ms};function Ji(r,t,e,n){return{name:r,prefix:t,encoder:{name:r,prefix:t,encode:e},decoder:{decode:n}}}var Wi=Ji("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),so=Ji("ascii","a",r=>{let t="a";for(let e=0;e<r.length;e++)t+=String.fromCharCode(r[e]);return t},r=>{r=r.substring(1);let t=At(r.length);for(let e=0;e<r.length;e++)t[e]=r.charCodeAt(e);return t}),uf={utf8:Wi,"utf-8":Wi,hex:hr.base16,latin1:so,ascii:so,binary:so,...hr},Zr=uf;function J(r,t="utf8"){let e=Zr[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.decoder.decode(`${e.prefix}${r}`)}function oo(r){let t=r??8192,e=t>>>1,n,s=t;return function(i){if(i<1||i>e)return At(i);s+i>t&&(n=At(t),s=0);let a=n.subarray(s,s+=i);return s&7&&(s=(s|7)+1),a}}var Ue=class{fn;len;next;val;constructor(t,e,n){this.fn=t,this.len=e,this.next=void 0,this.val=n}};function io(){}var co=class{head;tail;len;next;constructor(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}},ff=oo();function hf(r){return globalThis.Buffer!=null?At(r):ff(r)}var pr=class{len;head;tail;states;constructor(){this.len=0,this.head=new Ue(io,0,0),this.tail=this.head,this.states=null}_push(t,e,n){return this.tail=this.tail.next=new Ue(t,e,n),this.len+=e,this}uint32(t){return this.len+=(this.tail=this.tail.next=new lo((t=t>>>0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this}int32(t){return t<0?this._push(Wr,10,It.fromNumber(t)):this.uint32(t)}sint32(t){return this.uint32((t<<1^t>>31)>>>0)}uint64(t){let e=It.fromBigInt(t);return this._push(Wr,e.length(),e)}uint64Number(t){return this._push(Ms,St(t),t)}uint64String(t){return this.uint64(BigInt(t))}int64(t){return this.uint64(t)}int64Number(t){return this.uint64Number(t)}int64String(t){return this.uint64String(t)}sint64(t){let e=It.fromBigInt(t).zzEncode();return this._push(Wr,e.length(),e)}sint64Number(t){let e=It.fromNumber(t).zzEncode();return this._push(Wr,e.length(),e)}sint64String(t){return this.sint64(BigInt(t))}bool(t){return this._push(ao,1,t?1:0)}fixed32(t){return this._push(dr,4,t>>>0)}sfixed32(t){return this.fixed32(t)}fixed64(t){let e=It.fromBigInt(t);return this._push(dr,4,e.lo)._push(dr,4,e.hi)}fixed64Number(t){let e=It.fromNumber(t);return this._push(dr,4,e.lo)._push(dr,4,e.hi)}fixed64String(t){return this.fixed64(BigInt(t))}sfixed64(t){return this.fixed64(t)}sfixed64Number(t){return this.fixed64Number(t)}sfixed64String(t){return this.fixed64String(t)}float(t){return this._push(Oi,4,t)}double(t){return this._push(Mi,8,t)}bytes(t){let e=t.length>>>0;return e===0?this._push(ao,1,0):this.uint32(e)._push(pf,e,t)}string(t){let e=qi(t);return e!==0?this.uint32(e)._push($s,e,t):this._push(ao,1,0)}fork(){return this.states=new co(this),this.head=this.tail=new Ue(io,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Ue(io,0,0),this.len=0),this}ldelim(){let t=this.head,e=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=t.next,this.tail=e,this.len+=n),this}finish(){let t=this.head.next,e=hf(this.len),n=0;for(;t!=null;)t.fn(t.val,e,n),n+=t.len,t=t.next;return e}};function ao(r,t,e){t[e]=r&255}function df(r,t,e){for(;r>127;)t[e++]=r&127|128,r>>>=7;t[e]=r}var lo=class extends Ue{next;constructor(t,e){super(df,t,e),this.next=void 0}};function Wr(r,t,e){for(;r.hi!==0;)t[e++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)t[e++]=r.lo&127|128,r.lo=r.lo>>>7;t[e++]=r.lo}function dr(r,t,e){t[e]=r&255,t[e+1]=r>>>8&255,t[e+2]=r>>>16&255,t[e+3]=r>>>24}function pf(r,t,e){t.set(r,e)}globalThis.Buffer!=null&&(pr.prototype.bytes=function(r){let t=r.length>>>0;return this.uint32(t),t>0&&this._push(gf,t,r),this},pr.prototype.string=function(r){let t=globalThis.Buffer.byteLength(r);return this.uint32(t),t>0&&this._push(mf,t,r),this});function gf(r,t,e){t.set(r,e)}function mf(r,t,e){r.length<40?$s(r,t,e):t.utf8Write!=null?t.utf8Write(r,e):t.set(J(r),e)}function uo(){return new pr}function Xt(r,t){let e=uo();return t.encode(r,e,{lengthDelimited:!1}),e.finish()}var Ge;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(Ge||(Ge={}));function Jr(r,t,e,n){return{name:r,type:t,encode:e,decode:n}}function fo(r){function t(s){if(r[s.toString()]==null)throw new Error("Invalid enum value");return r[s]}let e=function(o,i){let a=t(o);i.int32(a)},n=function(o){let i=o.int32();return t(i)};return Jr("enum",Ge.VARINT,e,n)}function Qt(r,t){return Jr("message",Ge.LENGTH_DELIMITED,r,t)}var Yr=class extends Error{code="ERR_MAX_LENGTH";name="MaxLengthError"};var nt;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1"})(nt||(nt={}));var ho;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1"})(ho||(ho={}));(function(r){r.codec=()=>fo(ho)})(nt||(nt={}));var Pt;(function(r){let t;r.codec=()=>(t==null&&(t=Qt((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),nt.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{let o={},i=n==null?e.len:e.pos+n;for(;e.pos<i;){let a=e.uint32();switch(a>>>3){case 1:{o.Type=nt.codec().decode(e);break}case 2:{o.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return o})),t),r.encode=e=>Xt(e,r.codec()),r.decode=(e,n)=>Yt(e,r.codec(),n)})(Pt||(Pt={}));var po;(function(r){let t;r.codec=()=>(t==null&&(t=Qt((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),nt.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{let o={},i=n==null?e.len:e.pos+n;for(;e.pos<i;){let a=e.uint32();switch(a>>>3){case 1:{o.Type=nt.codec().decode(e);break}case 2:{o.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return o})),t),r.encode=e=>Xt(e,r.codec()),r.decode=(e,n)=>Yt(e,r.codec(),n)})(po||(po={}));var Ar={};bt(Ar,{MAX_RSA_KEY_SIZE:()=>qn,generateRSAKeyPair:()=>ja,jwkToJWKKeyPair:()=>Za,jwkToPkcs1:()=>Lf,jwkToPkix:()=>Eo,jwkToRSAPrivateKey:()=>Ga,pkcs1ToJwk:()=>qa,pkcs1ToRSAPrivateKey:()=>$a,pkixToJwk:()=>za,pkixToRSAPublicKey:()=>Ao});var yf=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),ye=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),be=new Uint32Array(64),go=class extends qe{constructor(){super(64,32,8,!1),this.A=ye[0]|0,this.B=ye[1]|0,this.C=ye[2]|0,this.D=ye[3]|0,this.E=ye[4]|0,this.F=ye[5]|0,this.G=ye[6]|0,this.H=ye[7]|0}get(){let{A:t,B:e,C:n,D:s,E:o,F:i,G:a,H:c}=this;return[t,e,n,s,o,i,a,c]}set(t,e,n,s,o,i,a,c){this.A=t|0,this.B=e|0,this.C=n|0,this.D=s|0,this.E=o|0,this.F=i|0,this.G=a|0,this.H=c|0}process(t,e){for(let u=0;u<16;u++,e+=4)be[u]=t.getUint32(e,!1);for(let u=16;u<64;u++){let h=be[u-15],y=be[u-2],b=Ut(h,7)^Ut(h,18)^h>>>3,w=Ut(y,17)^Ut(y,19)^y>>>10;be[u]=w+be[u-7]+b+be[u-16]|0}let{A:n,B:s,C:o,D:i,E:a,F:c,G:f,H:l}=this;for(let u=0;u<64;u++){let h=Ut(a,6)^Ut(a,11)^Ut(a,25),y=l+h+bi(a,c,f)+yf[u]+be[u]|0,w=(Ut(n,2)^Ut(n,13)^Ut(n,22))+wi(n,s,o)|0;l=f,f=c,c=a,a=i+y|0,i=o,o=s,s=n,n=y+w|0}n=n+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,a=a+this.E|0,c=c+this.F|0,f=f+this.G|0,l=l+this.H|0,this.set(n,s,o,i,a,c,f,l)}roundClean(){be.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var je=Vr(()=>new go);var P=$c(Xi());function Le(r,t){let e=0;if(r.length===1)return r[0];for(let n=r.length-1;n>=0;n--)e+=r[r.length-1-n]*Math.pow(2,t*n);return e}function we(r,t,e=-1){let n=e,s=r,o=0,i=Math.pow(2,t);for(let a=1;a<8;a++){if(r<i){let c;if(n<0)c=new ArrayBuffer(a),o=a;else{if(n<a)return new ArrayBuffer(0);c=new ArrayBuffer(n),o=n}let f=new Uint8Array(c);for(let l=a-1;l>=0;l--){let u=Math.pow(2,l*t);f[o-l-1]=Math.floor(s/u),s-=f[o-l-1]*u}return c}i*=Math.pow(2,t)}return new ArrayBuffer(0)}function tn(...r){let t=0,e=0;for(let o of r)t+=o.length;let n=new ArrayBuffer(t),s=new Uint8Array(n);for(let o of r)s.set(o,e),e+=o.length;return s}function yo(){let r=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){let a=r[0]===255&&r[1]&128,c=r[0]===0&&(r[1]&128)===0;(a||c)&&this.warnings.push("Needlessly long format")}let t=new ArrayBuffer(this.valueHex.byteLength),e=new Uint8Array(t);for(let a=0;a<this.valueHex.byteLength;a++)e[a]=0;e[0]=r[0]&128;let n=Le(e,8),s=new ArrayBuffer(this.valueHex.byteLength),o=new Uint8Array(s);for(let a=0;a<this.valueHex.byteLength;a++)o[a]=r[a];return o[0]&=127,Le(o,8)-n}function Qi(r){let t=r<0?r*-1:r,e=128;for(let n=1;n<8;n++){if(t<=e){if(r<0){let i=e-t,a=we(i,8,n),c=new Uint8Array(a);return c[0]|=128,a}let s=we(t,8,n),o=new Uint8Array(s);if(o[0]&128){let i=s.slice(0),a=new Uint8Array(i);s=new ArrayBuffer(s.byteLength+1),o=new Uint8Array(s);for(let c=0;c<i.byteLength;c++)o[c+1]=a[c];o[0]=0}return s}e*=Math.pow(2,8)}return new ArrayBuffer(0)}function ta(r,t){if(r.byteLength!==t.byteLength)return!1;let e=new Uint8Array(r),n=new Uint8Array(t);for(let s=0;s<e.length;s++)if(e[s]!==n[s])return!1;return!0}function kt(r,t){let e=r.toString(10);if(t<e.length)return"";let n=t-e.length,s=new Array(n);for(let i=0;i<n;i++)s[i]="0";return s.join("").concat(e)}var D0=Math.log(2);function en(){if(typeof BigInt>"u")throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function bo(r){let t=0,e=0;for(let s=0;s<r.length;s++){let o=r[s];t+=o.byteLength}let n=new Uint8Array(t);for(let s=0;s<r.length;s++){let o=r[s];n.set(new Uint8Array(o),e),e+=o.byteLength}return n.buffer}function se(r,t,e,n){return t instanceof Uint8Array?t.byteLength?e<0?(r.error="Wrong parameter: inputOffset less than zero",!1):n<0?(r.error="Wrong parameter: inputLength less than zero",!1):t.byteLength-e-n<0?(r.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):!0:(r.error="Wrong parameter: inputBuffer has zero length",!1):(r.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}var mr=class{constructor(){this.items=[]}write(t){this.items.push(t)}final(){return bo(this.items)}},gr=[new Uint8Array([1])],ea="0123456789";var Xe="",Ht=new ArrayBuffer(0),wo=new Uint8Array(0),yr="EndOfContent",na="OCTET STRING",sa="BIT STRING";function oe(r){var t;return t=class extends r{constructor(...n){var s;super(...n);let o=n[0]||{};this.isHexOnly=(s=o.isHexOnly)!==null&&s!==void 0?s:!1,this.valueHexView=o.valueHex?P.BufferSourceConverter.toUint8Array(o.valueHex):wo}get valueHex(){return this.valueHexView.slice().buffer}set valueHex(n){this.valueHexView=new Uint8Array(n)}fromBER(n,s,o){let i=n instanceof ArrayBuffer?new Uint8Array(n):n;if(!se(this,i,s,o))return-1;let a=s+o;return this.valueHexView=i.subarray(s,a),this.valueHexView.length?(this.blockLength=o,a):(this.warnings.push("Zero buffer length"),s)}toBER(n=!1){return this.isHexOnly?n?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",Ht)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:P.Convert.ToHex(this.valueHexView)}}},t.NAME="hexBlock",t}var ee=class{constructor({blockLength:t=0,error:e=Xe,warnings:n=[],valueBeforeDecode:s=wo}={}){this.blockLength=t,this.error=e,this.warnings=n,this.valueBeforeDecodeView=P.BufferSourceConverter.toUint8Array(s)}static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(t){this.valueBeforeDecodeView=new Uint8Array(t)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:P.Convert.ToHex(this.valueBeforeDecodeView)}}};ee.NAME="baseBlock";var mt=class extends ee{fromBER(t,e,n){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(t,e){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}};mt.NAME="valueBlock";var rn=class extends oe(ee){constructor({idBlock:t={}}={}){var e,n,s,o;super(),t?(this.isHexOnly=(e=t.isHexOnly)!==null&&e!==void 0?e:!1,this.valueHexView=t.valueHex?P.BufferSourceConverter.toUint8Array(t.valueHex):wo,this.tagClass=(n=t.tagClass)!==null&&n!==void 0?n:-1,this.tagNumber=(s=t.tagNumber)!==null&&s!==void 0?s:-1,this.isConstructed=(o=t.isConstructed)!==null&&o!==void 0?o:!1):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(t=!1){let e=0;switch(this.tagClass){case 1:e|=0;break;case 2:e|=64;break;case 3:e|=128;break;case 4:e|=192;break;default:return this.error="Unknown tag class",Ht}if(this.isConstructed&&(e|=32),this.tagNumber<31&&!this.isHexOnly){let s=new Uint8Array(1);if(!t){let o=this.tagNumber;o&=31,e|=o,s[0]=e}return s.buffer}if(!this.isHexOnly){let s=we(this.tagNumber,7),o=new Uint8Array(s),i=s.byteLength,a=new Uint8Array(i+1);if(a[0]=e|31,!t){for(let c=0;c<i-1;c++)a[c+1]=o[c]|128;a[i]=o[i-1]}return a.buffer}let n=new Uint8Array(this.valueHexView.byteLength+1);if(n[0]=e|31,!t){let s=this.valueHexView;for(let o=0;o<s.length-1;o++)n[o+1]=s[o]|128;n[this.valueHexView.byteLength]=s[s.length-1]}return n.buffer}fromBER(t,e,n){let s=P.BufferSourceConverter.toUint8Array(t);if(!se(this,s,e,n))return-1;let o=s.subarray(e,e+n);if(o.length===0)return this.error="Zero buffer length",-1;switch(o[0]&192){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=(o[0]&32)===32,this.isHexOnly=!1;let a=o[0]&31;if(a!==31)this.tagNumber=a,this.blockLength=1;else{let c=1,f=this.valueHexView=new Uint8Array(255),l=255;for(;o[c]&128;){if(f[c-1]=o[c]&127,c++,c>=o.length)return this.error="End of input reached before message was fully decoded",-1;if(c===l){l+=255;let h=new Uint8Array(l);for(let y=0;y<f.length;y++)h[y]=f[y];f=this.valueHexView=new Uint8Array(l)}}this.blockLength=c+1,f[c-1]=o[c]&127;let u=new Uint8Array(c);for(let h=0;h<c;h++)u[h]=f[h];f=this.valueHexView=new Uint8Array(c),f.set(u),this.blockLength<=9?this.tagNumber=Le(f,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(this.tagClass===1&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return e+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}};rn.NAME="identificationBlock";var nn=class extends ee{constructor({lenBlock:t={}}={}){var e,n,s;super(),this.isIndefiniteForm=(e=t.isIndefiniteForm)!==null&&e!==void 0?e:!1,this.longFormUsed=(n=t.longFormUsed)!==null&&n!==void 0?n:!1,this.length=(s=t.length)!==null&&s!==void 0?s:0}fromBER(t,e,n){let s=P.BufferSourceConverter.toUint8Array(t);if(!se(this,s,e,n))return-1;let o=s.subarray(e,e+n);if(o.length===0)return this.error="Zero buffer length",-1;if(o[0]===255)return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=o[0]===128,this.isIndefiniteForm)return this.blockLength=1,e+this.blockLength;if(this.longFormUsed=!!(o[0]&128),this.longFormUsed===!1)return this.length=o[0],this.blockLength=1,e+this.blockLength;let i=o[0]&127;if(i>8)return this.error="Too big integer",-1;if(i+1>o.length)return this.error="End of input reached before message was fully decoded",-1;let a=e+1,c=s.subarray(a,a+i);return c[i-1]===0&&this.warnings.push("Needlessly long encoded length"),this.length=Le(c,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=i+1,e+this.blockLength}toBER(t=!1){let e,n;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return e=new ArrayBuffer(1),t===!1&&(n=new Uint8Array(e),n[0]=128),e;if(this.longFormUsed){let s=we(this.length,8);if(s.byteLength>127)return this.error="Too big length",Ht;if(e=new ArrayBuffer(s.byteLength+1),t)return e;let o=new Uint8Array(s);n=new Uint8Array(e),n[0]=s.byteLength|128;for(let i=0;i<s.byteLength;i++)n[i+1]=o[i];return e}return e=new ArrayBuffer(1),t===!1&&(n=new Uint8Array(e),n[0]=this.length),e}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}};nn.NAME="lengthBlock";var E={},ut=class extends ee{constructor({name:t=Xe,optional:e=!1,primitiveSchema:n,...s}={},o){super(s),this.name=t,this.optional=e,n&&(this.primitiveSchema=n),this.idBlock=new rn(s),this.lenBlock=new nn(s),this.valueBlock=o?new o(s):new mt(s)}fromBER(t,e,n){let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}toBER(t,e){let n=e||new mr;e||oa(this);let s=this.idBlock.toBER(t);if(n.write(s),this.lenBlock.isIndefiniteForm)n.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(t,n),n.write(new ArrayBuffer(2));else{let o=this.valueBlock.toBER(t);this.lenBlock.length=o.byteLength;let i=this.lenBlock.toBER(t);n.write(i),n.write(o)}return e?Ht:n.final()}toJSON(){let t={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(t.primitiveSchema=this.primitiveSchema.toJSON()),t}toString(t="ascii"){return t==="ascii"?this.onAsciiEncoding():P.Convert.ToHex(this.toBER())}onAsciiEncoding(){return`${this.constructor.NAME} : ${P.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`}isEqual(t){if(this===t)return!0;if(!(t instanceof this.constructor))return!1;let e=this.toBER(),n=t.toBER();return ta(e,n)}};ut.NAME="BaseBlock";function oa(r){if(r instanceof E.Constructed)for(let t of r.valueBlock.value)oa(t)&&(r.lenBlock.isIndefiniteForm=!0);return!!r.lenBlock.isIndefiniteForm}var sn=class extends ut{constructor({value:t=Xe,...e}={},n){super(e,n),t&&this.fromString(t)}getValue(){return this.valueBlock.value}setValue(t){this.valueBlock.value=t}fromBER(t,e,n){let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}};sn.NAME="BaseStringBlock";var on=class extends oe(mt){constructor({isHexOnly:t=!0,...e}={}){super(e),this.isHexOnly=t}};on.NAME="PrimitiveValueBlock";var ia,an=class extends ut{constructor(t={}){super(t,on),this.idBlock.isConstructed=!1}};ia=an;E.Primitive=ia;an.NAME="PRIMITIVE";function kf(r,t){if(r instanceof t)return r;let e=new t;return e.idBlock=r.idBlock,e.lenBlock=r.lenBlock,e.warnings=r.warnings,e.valueBeforeDecodeView=r.valueBeforeDecodeView,e}function Fn(r,t=0,e=r.length){let n=t,s=new ut({},mt),o=new ee;if(!se(o,r,t,e))return s.error=o.error,{offset:-1,result:s};if(!r.subarray(t,t+e).length)return s.error="Zero buffer length",{offset:-1,result:s};let a=s.idBlock.fromBER(r,t,e);if(s.idBlock.warnings.length&&s.warnings.concat(s.idBlock.warnings),a===-1)return s.error=s.idBlock.error,{offset:-1,result:s};if(t=a,e-=s.idBlock.blockLength,a=s.lenBlock.fromBER(r,t,e),s.lenBlock.warnings.length&&s.warnings.concat(s.lenBlock.warnings),a===-1)return s.error=s.lenBlock.error,{offset:-1,result:s};if(t=a,e-=s.lenBlock.blockLength,!s.idBlock.isConstructed&&s.lenBlock.isIndefiniteForm)return s.error="Indefinite length form used for primitive encoding form",{offset:-1,result:s};let c=ut;switch(s.idBlock.tagClass){case 1:if(s.idBlock.tagNumber>=37&&s.idBlock.isHexOnly===!1)return s.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:s};switch(s.idBlock.tagNumber){case 0:if(s.idBlock.isConstructed&&s.lenBlock.length>0)return s.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:s};c=E.EndOfContent;break;case 1:c=E.Boolean;break;case 2:c=E.Integer;break;case 3:c=E.BitString;break;case 4:c=E.OctetString;break;case 5:c=E.Null;break;case 6:c=E.ObjectIdentifier;break;case 10:c=E.Enumerated;break;case 12:c=E.Utf8String;break;case 13:c=E.RelativeObjectIdentifier;break;case 14:c=E.TIME;break;case 15:return s.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:s};case 16:c=E.Sequence;break;case 17:c=E.Set;break;case 18:c=E.NumericString;break;case 19:c=E.PrintableString;break;case 20:c=E.TeletexString;break;case 21:c=E.VideotexString;break;case 22:c=E.IA5String;break;case 23:c=E.UTCTime;break;case 24:c=E.GeneralizedTime;break;case 25:c=E.GraphicString;break;case 26:c=E.VisibleString;break;case 27:c=E.GeneralString;break;case 28:c=E.UniversalString;break;case 29:c=E.CharacterString;break;case 30:c=E.BmpString;break;case 31:c=E.DATE;break;case 32:c=E.TimeOfDay;break;case 33:c=E.DateTime;break;case 34:c=E.Duration;break;default:{let f=s.idBlock.isConstructed?new E.Constructed:new E.Primitive;f.idBlock=s.idBlock,f.lenBlock=s.lenBlock,f.warnings=s.warnings,s=f}}break;case 2:case 3:case 4:default:c=s.idBlock.isConstructed?E.Constructed:E.Primitive}return s=kf(s,c),a=s.fromBER(r,t,s.lenBlock.isIndefiniteForm?e:s.lenBlock.length),s.valueBeforeDecodeView=r.subarray(n,n+s.blockLength),{offset:a,result:s}}function xo(r){if(!r.byteLength){let t=new ut({},mt);return t.error="Input buffer has zero length",{offset:-1,result:t}}return Fn(P.BufferSourceConverter.toUint8Array(r).slice(),0,r.byteLength)}function If(r,t){return r?1:t}var Mt=class extends mt{constructor({value:t=[],isIndefiniteForm:e=!1,...n}={}){super(n),this.value=t,this.isIndefiniteForm=e}fromBER(t,e,n){let s=P.BufferSourceConverter.toUint8Array(t);if(!se(this,s,e,n))return-1;if(this.valueBeforeDecodeView=s.subarray(e,e+n),this.valueBeforeDecodeView.length===0)return this.warnings.push("Zero buffer length"),e;let o=e;for(;If(this.isIndefiniteForm,n)>0;){let i=Fn(s,o,n);if(i.offset===-1)return this.error=i.result.error,this.warnings.concat(i.result.warnings),-1;if(o=i.offset,this.blockLength+=i.result.blockLength,n-=i.result.blockLength,this.value.push(i.result),this.isIndefiniteForm&&i.result.constructor.NAME===yr)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===yr?this.value.pop():this.warnings.push("No EndOfContent block encoded")),o}toBER(t,e){let n=e||new mr;for(let s=0;s<this.value.length;s++)this.value[s].toBER(t,n);return e?Ht:n.final()}toJSON(){let t={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(let e of this.value)t.value.push(e.toJSON());return t}};Mt.NAME="ConstructedValueBlock";var aa,xe=class extends ut{constructor(t={}){super(t,Mt),this.idBlock.isConstructed=!0}fromBER(t,e,n){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){let t=[];for(let n of this.valueBlock.value)t.push(n.toString("ascii").split(`
./node_modules/@libp2p/mdns/dist/index.min.js:2:"use strict";var Libp2PMdns=(()=>{var Ks=Object.create;var dr=Object.defineProperty;var qs=Object.getOwnPropertyDescriptor;var zs=Object.getOwnPropertyNames;var Vs=Object.getPrototypeOf,Hs=Object.prototype.hasOwnProperty;var ne=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,r)=>(typeof require<"u"?require:e)[r]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')});var ve=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),oe=(t,e)=>{for(var r in e)dr(t,r,{get:e[r],enumerable:!0})},Do=(t,e,r,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of zs(e))!Hs.call(t,o)&&o!==r&&dr(t,o,{get:()=>e[o],enumerable:!(n=qs(e,o))||n.enumerable});return t};var Ut=(t,e,r)=>(r=t!=null?Ks(Vs(t)):{},Do(e||!t||!t.__esModule?dr(r,"default",{value:t,enumerable:!0}):r,t)),js=t=>Do(dr({},"__esModule",{value:!0}),t);var Ko=ve(Zr=>{"use strict";Zr.toString=function(t){switch(t){case 1:return"A";case 10:return"NULL";case 28:return"AAAA";case 18:return"AFSDB";case 42:return"APL";case 257:return"CAA";case 60:return"CDNSKEY";case 59:return"CDS";case 37:return"CERT";case 5:return"CNAME";case 49:return"DHCID";case 32769:return"DLV";case 39:return"DNAME";case 48:return"DNSKEY";case 43:return"DS";case 55:return"HIP";case 13:return"HINFO";case 45:return"IPSECKEY";case 25:return"KEY";case 36:return"KX";case 29:return"LOC";case 15:return"MX";case 35:return"NAPTR";case 2:return"NS";case 47:return"NSEC";case 50:return"NSEC3";case 51:return"NSEC3PARAM";case 12:return"PTR";case 46:return"RRSIG";case 17:return"RP";case 24:return"SIG";case 6:return"SOA";case 99:return"SPF";case 33:return"SRV";case 44:return"SSHFP";case 32768:return"TA";case 249:return"TKEY";case 52:return"TLSA";case 250:return"TSIG";case 16:return"TXT";case 252:return"AXFR";case 251:return"IXFR";case 41:return"OPT";case 255:return"ANY"}return"UNKNOWN_"+t};Zr.toType=function(t){switch(t.toUpperCase()){case"A":return 1;case"NULL":return 10;case"AAAA":return 28;case"AFSDB":return 18;case"APL":return 42;case"CAA":return 257;case"CDNSKEY":return 60;case"CDS":return 59;case"CERT":return 37;case"CNAME":return 5;case"DHCID":return 49;case"DLV":return 32769;case"DNAME":return 39;case"DNSKEY":return 48;case"DS":return 43;case"HIP":return 55;case"HINFO":return 13;case"IPSECKEY":return 45;case"KEY":return 25;case"KX":return 36;case"LOC":return 29;case"MX":return 15;case"NAPTR":return 35;case"NS":return 2;case"NSEC":return 47;case"NSEC3":return 50;case"NSEC3PARAM":return 51;case"PTR":return 12;case"RRSIG":return 46;case"RP":return 17;case"SIG":return 24;case"SOA":return 6;case"SPF":return 99;case"SRV":return 33;case"SSHFP":return 44;case"TA":return 32768;case"TKEY":return 249;case"TLSA":return 52;case"TSIG":return 250;case"TXT":return 16;case"AXFR":return 252;case"IXFR":return 251;case"OPT":return 41;case"ANY":return 255;case"*":return 255}return t.toUpperCase().startsWith("UNKNOWN_")?parseInt(t.slice(8)):0}});var qo=ve(Wr=>{"use strict";Wr.toString=function(t){switch(t){case 0:return"NOERROR";case 1:return"FORMERR";case 2:return"SERVFAIL";case 3:return"NXDOMAIN";case 4:return"NOTIMP";case 5:return"REFUSED";case 6:return"YXDOMAIN";case 7:return"YXRRSET";case 8:return"NXRRSET";case 9:return"NOTAUTH";case 10:return"NOTZONE";case 11:return"RCODE_11";case 12:return"RCODE_12";case 13:return"RCODE_13";case 14:return"RCODE_14";case 15:return"RCODE_15"}return"RCODE_"+t};Wr.toRcode=function(t){switch(t.toUpperCase()){case"NOERROR":return 0;case"FORMERR":return 1;case"SERVFAIL":return 2;case"NXDOMAIN":return 3;case"NOTIMP":return 4;case"REFUSED":return 5;case"YXDOMAIN":return 6;case"YXRRSET":return 7;case"NXRRSET":return 8;case"NOTAUTH":return 9;case"NOTZONE":return 10;case"RCODE_11":return 11;case"RCODE_12":return 12;case"RCODE_13":return 13;case"RCODE_14":return 14;case"RCODE_15":return 15}return 0}});var zo=ve(Qr=>{"use strict";Qr.toString=function(t){switch(t){case 0:return"QUERY";case 1:return"IQUERY";case 2:return"STATUS";case 3:return"OPCODE_3";case 4:return"NOTIFY";case 5:return"UPDATE";case 6:return"OPCODE_6";case 7:return"OPCODE_7";case 8:return"OPCODE_8";case 9:return"OPCODE_9";case 10:return"OPCODE_10";case 11:return"OPCODE_11";case 12:return"OPCODE_12";case 13:return"OPCODE_13";case 14:return"OPCODE_14";case 15:return"OPCODE_15"}return"OPCODE_"+t};Qr.toOpcode=function(t){switch(t.toUpperCase()){case"QUERY":return 0;case"IQUERY":return 1;case"STATUS":return 2;case"OPCODE_3":return 3;case"NOTIFY":return 4;case"UPDATE":return 5;case"OPCODE_6":return 6;case"OPCODE_7":return 7;case"OPCODE_8":return 8;case"OPCODE_9":return 9;case"OPCODE_10":return 10;case"OPCODE_11":return 11;case"OPCODE_12":return 12;case"OPCODE_13":return 13;case"OPCODE_14":return 14;case"OPCODE_15":return 15}return 0}});var Vo=ve(Jr=>{"use strict";Jr.toString=function(t){switch(t){case 1:return"IN";case 2:return"CS";case 3:return"CH";case 4:return"HS";case 255:return"ANY"}return"UNKNOWN_"+t};Jr.toClass=function(t){switch(t.toUpperCase()){case"IN":return 1;case"CS":return 2;case"CH":return 3;case"HS":return 4;case"ANY":return 255}return 0}});var Ho=ve(en=>{"use strict";en.toString=function(t){switch(t){case 1:return"LLQ";case 2:return"UL";case 3:return"NSID";case 5:return"DAU";case 6:return"DHU";case 7:return"N3U";case 8:return"CLIENT_SUBNET";case 9:return"EXPIRE";case 10:return"COOKIE";case 11:return"TCP_KEEPALIVE";case 12:return"PADDING";case 13:return"CHAIN";case 14:return"KEY_TAG";case 26946:return"DEVICEID"}return t<0?null:`OPTION_${t}`};en.toCode=function(t){if(typeof t=="number")return t;if(!t)return-1;switch(t.toUpperCase()){case"OPTION_0":return 0;case"LLQ":return 1;case"UL":return 2;case"NSID":return 3;case"OPTION_4":return 4;case"DAU":return 5;case"DHU":return 6;case"N3U":return 7;case"CLIENT_SUBNET":return 8;case"EXPIRE":return 9;case"COOKIE":return 10;case"TCP_KEEPALIVE":return 11;case"PADDING":return 12;case"CHAIN":return 13;case"KEY_TAG":return 14;case"DEVICEID":return 26946;case"OPTION_65535":return 65535}let e=t.match(/_(\d+)$/);return e?parseInt(e[1],10):-1}});var Go=ve(($o,tn)=>{var jo=function(t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.decode=l,t.encode=g,t.familyOf=d,t.name=void 0,t.sizeOf=c,t.v6=t.v4=void 0;let e=/^(\d{1,3}\.){3,3}\d{1,3}$/,r=4,n=/^(::)?(((\d{1,3}\.){3}(\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i,o=16,i={name:"v4",size:r,isFormat:u=>e.test(u),encode(u,p,h){h=~~h,p=p||new Uint8Array(h+r);let y=u.length,m=0;for(let f=0;f<y;){let x=u.charCodeAt(f++);x===46?(p[h++]=m,m=0):m=m*10+(x-48)}return p[h]=m,p},decode(u,p){return p=~~p,`${u[p++]}.${u[p++]}.${u[p++]}.${u[p]}`}};t.v4=i;let s={name:"v6",size:o,isFormat:u=>u.length>0&&n.test(u),encode(u,p,h){h=~~h;let y=h+o,m=-1,f=0,x=0,b=!0,L=!1;p=p||new Uint8Array(h+o);for(let T=0;T<u.length;T++){let B=u.charCodeAt(T);B===58?(b?m!==-1?(h<y&&(p[h]=0),h<y-1&&(p[h+1]=0),h+=2):h<y&&(m=h):(L===!0?(h<y&&(p[h]=x),h++):(h<y&&(p[h]=f>>8),h<y-1&&(p[h+1]=f&255),h+=2),f=0,x=0),b=!0,L=!1):B===46?(h<y&&(p[h]=x),h++,x=0,f=0,b=!1,L=!0):(b=!1,B>=97?B-=87:B>=65?B-=55:(B-=48,x=x*10+B),f=(f<<4)+B)}if(b===!1)L===!0?(h<y&&(p[h]=x),h++):(h<y&&(p[h]=f>>8),h<y-1&&(p[h+1]=f&255),h+=2);else if(m===0)h<y&&(p[h]=0),h<y-1&&(p[h+1]=0),h+=2;else if(m!==-1){h+=2;for(let T=Math.min(h-1,y-1);T>=m+2;T--)p[T]=p[T-2];p[m]=0,p[m+1]=0,m=h}if(m!==h&&m!==-1)for(h>y-2&&(h=y-2);y>m;)p[--y]=h<y&&h>m?p[--h]:0;else for(;h<y;)p[h++]=0;return p},decode(u,p){p=~~p;let h="";for(let y=0;y<o;y+=2)y!==0&&(h+=":"),h+=(u[p+y]<<8|u[p+y+1]).toString(16);return h.replace(/(^|:)0(:0)*:0(:|$)/,"$1::$3").replace(/:{3,4}/,"::")}};t.v6=s;let a="ip";t.name=a;function c(u){if(i.isFormat(u))return i.size;if(s.isFormat(u))return s.size;throw Error(`Invalid ip address: ${u}`)}function d(u){return c(u)===i.size?1:2}function g(u,p,h){h=~~h;let y=c(u);return typeof p=="function"&&(p=p(h+y)),y===i.size?i.encode(u,p,h):s.encode(u,p,h)}function l(u,p,h){if(p=~~p,h=h||u.length-p,h===i.size)return i.decode(u,p,h);if(h===s.size)return s.decode(u,p,h);throw Error(`Invalid buffer size needs to be ${i.size} for v4 or ${s.size} for v6.`)}return"default"in t?t.default:t}({});typeof define=="function"&&define.amd?define([],function(){return jo}):typeof tn=="object"&&typeof $o=="object"&&(tn.exports=jo)});var Zo=ve(v=>{"use strict";var S=ne("buffer").Buffer,ze=Ko(),$s=qo(),Gs=zo(),mr=Vo(),rn=Ho(),lt=Go(),Ys=0,Yo=32768,nn=32768,Xs=~nn,Xo=32768,Zs=~Xo,w=v.name={};w.encode=function(t,e,r,{mail:n=!1}={}){e||(e=S.alloc(w.encodingLength(t))),r||(r=0);let o=r,i=t.replace(/^\.|\.$/gm,"");if(i.length){let s=[];if(n){let a="";i.split(".").forEach(c=>{c.endsWith("\\")?a+=(a.length?".":"")+c.slice(0,-1):s.length===0&&a.length?s.push(a+"."+c):s.push(c)})}else s=i.split(".");for(let a=0;a<s.length;a++){let c=e.write(s[a],r+1);e[r]=c,r+=c+1}}return e[r++]=0,w.encode.bytes=r-o,e};w.encode.bytes=0;w.decode=function(t,e,{mail:r=!1}={}){e||(e=0);let n=[],o=e,i=0,s=0,a=!1;for(;;){if(e>=t.length)throw new Error("Cannot decode name (buffer overflow)");let c=t[e++];if(s+=a?0:1,c===0)break;if(c&192)if((c&192)===192){if(e+1>t.length)throw new Error("Cannot decode name (buffer overflow)");let d=t.readUInt16BE(e-1)-49152;if(d>=o)throw new Error("Cannot decode name (bad pointer)");e=d,o=d,s+=a?0:1,a=!0}else throw new Error("Cannot decode name (bad label)");else{if(e+c>t.length)throw new Error("Cannot decode name (buffer overflow)");if(i+=c+1,i>254)throw new Error("Cannot decode name (name too long)");let d=t.toString("utf-8",e,e+c);r&&(d=d.replace(/\./g,"\\.")),n.push(d),e+=c,s+=a?0:c}}return w.decode.bytes=s,n.length===0?".":n.join(".")};w.decode.bytes=0;w.encodingLength=function(t){return t==="."||t===".."?1:S.byteLength(t.replace(/^\.|\.$/gm,""))+2};var O={};O.encode=function(t,e,r){e||(e=S.alloc(O.encodingLength(t))),r||(r=0);let n=e.write(t,r+1);return e[r]=n,O.encode.bytes=n+1,e};O.encode.bytes=0;O.decode=function(t,e){e||(e=0);let r=t[e],n=t.toString("utf-8",e+1,e+1+r);return O.decode.bytes=r+1,n};O.decode.bytes=0;O.encodingLength=function(t){return S.byteLength(t)+1};var Ee={};Ee.encode=function(t,e,r){e||(e=Ee.encodingLength(t)),r||(r=0);let n=(t.flags||0)&32767,o=t.type==="response"?Yo:Ys;return e.writeUInt16BE(t.id||0,r),e.writeUInt16BE(n|o,r+2),e.writeUInt16BE(t.questions.length,r+4),e.writeUInt16BE(t.answers.length,r+6),e.writeUInt16BE(t.authorities.length,r+8),e.writeUInt16BE(t.additionals.length,r+10),e};Ee.encode.bytes=12;Ee.decode=function(t,e){if(e||(e=0),t.length<12)throw new Error("Header must be 12 bytes");let r=t.readUInt16BE(e+2);return{id:t.readUInt16BE(e),type:r&Yo?"response":"query",flags:r&32767,flag_qr:(r>>15&1)===1,opcode:Gs.toString(r>>11&15),flag_aa:(r>>10&1)===1,flag_tc:(r>>9&1)===1,flag_rd:(r>>8&1)===1,flag_ra:(r>>7&1)===1,flag_z:(r>>6&1)===1,flag_ad:(r>>5&1)===1,flag_cd:(r>>4&1)===1,rcode:$s.toString(r&15),questions:new Array(t.readUInt16BE(e+4)),answers:new Array(t.readUInt16BE(e+6)),authorities:new Array(t.readUInt16BE(e+8)),additionals:new Array(t.readUInt16BE(e+10))}};Ee.decode.bytes=12;Ee.encodingLength=function(){return 12};var Pe=v.unknown={};Pe.encode=function(t,e,r){return e||(e=S.alloc(Pe.encodingLength(t))),r||(r=0),e.writeUInt16BE(t.length,r),t.copy(e,r+2),Pe.encode.bytes=t.length+2,e};Pe.encode.bytes=0;Pe.decode=function(t,e){e||(e=0);let r=t.readUInt16BE(e),n=t.slice(e+2,e+2+r);return Pe.decode.bytes=r+2,n};Pe.decode.bytes=0;Pe.encodingLength=function(t){return t.length+2};var Re=v.ns={};Re.encode=function(t,e,r){return e||(e=S.alloc(Re.encodingLength(t))),r||(r=0),w.encode(t,e,r+2),e.writeUInt16BE(w.encode.bytes,r),Re.encode.bytes=w.encode.bytes+2,e};Re.encode.bytes=0;Re.decode=function(t,e){e||(e=0);let r=t.readUInt16BE(e),n=w.decode(t,e+2);return Re.decode.bytes=r+2,n};Re.decode.bytes=0;Re.encodingLength=function(t){return w.encodingLength(t)+2};var De=v.soa={};De.encode=function(t,e,r){e||(e=S.alloc(De.encodingLength(t))),r||(r=0);let n=r;return r+=2,w.encode(t.mname,e,r),r+=w.encode.bytes,w.encode(t.rname,e,r,{mail:!0}),r+=w.encode.bytes,e.writeUInt32BE(t.serial||0,r),r+=4,e.writeUInt32BE(t.refresh||0,r),r+=4,e.writeUInt32BE(t.retry||0,r),r+=4,e.writeUInt32BE(t.expire||0,r),r+=4,e.writeUInt32BE(t.minimum||0,r),r+=4,e.writeUInt16BE(r-n-2,n),De.encode.bytes=r-n,e};De.encode.bytes=0;De.decode=function(t,e){e||(e=0);let r=e,n={};return e+=2,n.mname=w.decode(t,e),e+=w.decode.bytes,n.rname=w.decode(t,e,{mail:!0}),e+=w.decode.bytes,n.serial=t.readUInt32BE(e),e+=4,n.refresh=t.readUInt32BE(e),e+=4,n.retry=t.readUInt32BE(e),e+=4,n.expire=t.readUInt32BE(e),e+=4,n.minimum=t.readUInt32BE(e),e+=4,De.decode.bytes=e-r,n};De.decode.bytes=0;De.encodingLength=function(t){return 22+w.encodingLength(t.mname)+w.encodingLength(t.rname)};var ke=v.txt={};ke.encode=function(t,e,r){Array.isArray(t)||(t=[t]);for(let o=0;o<t.length;o++)if(typeof t[o]=="string"&&(t[o]=S.from(t[o])),!S.isBuffer(t[o]))throw new Error("Must be a Buffer");e||(e=S.alloc(ke.encodingLength(t))),r||(r=0);let n=r;return r+=2,t.forEach(function(o){e[r++]=o.length,o.copy(e,r,0,o.length),r+=o.length}),e.writeUInt16BE(r-n-2,n),ke.encode.bytes=r-n,e};ke.encode.bytes=0;ke.decode=function(t,e){e||(e=0);let r=e,n=t.readUInt16BE(e);e+=2;let o=[];for(;n>0;){let i=t[e++];if(--n,n<i)throw new Error("Buffer overflow");o.push(t.slice(e,e+i)),e+=i,n-=i}return ke.decode.bytes=e-r,o};ke.decode.bytes=0;ke.encodingLength=function(t){Array.isArray(t)||(t=[t]);let e=2;return t.forEach(function(r){typeof r=="string"?e+=S.byteLength(r)+1:e+=r.length+1}),e};var _e=v.null={};_e.encode=function(t,e,r){e||(e=S.alloc(_e.encodingLength(t))),r||(r=0),typeof t=="string"&&(t=S.from(t)),t||(t=S.alloc(0));let n=r;r+=2;let o=t.length;return t.copy(e,r,0,o),r+=o,e.writeUInt16BE(r-n-2,n),_e.encode.bytes=r-n,e};_e.encode.bytes=0;_e.decode=function(t,e){e||(e=0);let r=e,n=t.readUInt16BE(e);e+=2;let o=t.slice(e,e+n);return e+=n,_e.decode.bytes=e-r,o};_e.decode.bytes=0;_e.encodingLength=function(t){return t?(S.isBuffer(t)?t.length:S.byteLength(t))+2:2};var Me=v.hinfo={};Me.encode=function(t,e,r){e||(e=S.alloc(Me.encodingLength(t))),r||(r=0);let n=r;return r+=2,O.encode(t.cpu,e,r),r+=O.encode.bytes,O.encode(t.os,e,r),r+=O.encode.bytes,e.writeUInt16BE(r-n-2,n),Me.encode.bytes=r-n,e};Me.encode.bytes=0;Me.decode=function(t,e){e||(e=0);let r=e,n={};return e+=2,n.cpu=O.decode(t,e),e+=O.decode.bytes,n.os=O.decode(t,e),e+=O.decode.bytes,Me.decode.bytes=e-r,n};Me.decode.bytes=0;Me.encodingLength=function(t){return O.encodingLength(t.cpu)+O.encodingLength(t.os)+2};var we=v.ptr={},Ws=v.cname=we,Qs=v.dname=we;we.encode=function(t,e,r){return e||(e=S.alloc(we.encodingLength(t))),r||(r=0),w.encode(t,e,r+2),e.writeUInt16BE(w.encode.bytes,r),we.encode.bytes=w.encode.bytes+2,e};we.encode.bytes=0;we.decode=function(t,e){e||(e=0);let r=w.decode(t,e+2);return we.decode.bytes=w.decode.bytes+2,r};we.decode.bytes=0;we.encodingLength=function(t){return w.encodingLength(t)+2};var Fe=v.srv={};Fe.encode=function(t,e,r){e||(e=S.alloc(Fe.encodingLength(t))),r||(r=0),e.writeUInt16BE(t.priority||0,r+2),e.writeUInt16BE(t.weight||0,r+4),e.writeUInt16BE(t.port||0,r+6),w.encode(t.target,e,r+8);let n=w.encode.bytes+6;return e.writeUInt16BE(n,r),Fe.encode.bytes=n+2,e};Fe.encode.bytes=0;Fe.decode=function(t,e){e||(e=0);let r=t.readUInt16BE(e),n={};return n.priority=t.readUInt16BE(e+2),n.weight=t.readUInt16BE(e+4),n.port=t.readUInt16BE(e+6),n.target=w.decode(t,e+8),Fe.decode.bytes=r+2,n};Fe.decode.bytes=0;Fe.encodingLength=function(t){return 8+w.encodingLength(t.target)};var ae=v.caa={};ae.ISSUER_CRITICAL=128;ae.encode=function(t,e,r){let n=ae.encodingLength(t);return e||(e=S.alloc(ae.encodingLength(t))),r||(r=0),t.issuerCritical&&(t.flags=ae.ISSUER_CRITICAL),e.writeUInt16BE(n-2,r),r+=2,e.writeUInt8(t.flags||0,r),r+=1,O.encode(t.tag,e,r),r+=O.encode.bytes,e.write(t.value,r),r+=S.byteLength(t.value),ae.encode.bytes=n,e};ae.encode.bytes=0;ae.decode=function(t,e){e||(e=0);let r=t.readUInt16BE(e);e+=2;let n=e,o={};return o.flags=t.readUInt8(e),e+=1,o.tag=O.decode(t,e),e+=O.decode.bytes,o.value=t.toString("utf-8",e,n+r),o.issuerCritical=!!(o.flags&ae.ISSUER_CRITICAL),ae.decode.bytes=r+2,o};ae.decode.bytes=0;ae.encodingLength=function(t){return O.encodingLength(t.tag)+O.encodingLength(t.value)+2};var et=v.mx={};et.encode=function(t,e,r){e||(e=S.alloc(et.encodingLength(t))),r||(r=0);let n=r;return r+=2,e.writeUInt16BE(t.preference||0,r),r+=2,w.encode(t.exchange,e,r),r+=w.encode.bytes,e.writeUInt16BE(r-n-2,n),et.encode.bytes=r-n,e};et.encode.bytes=0;et.decode=function(t,e){e||(e=0);let r=e,n={};return e+=2,n.preference=t.readUInt16BE(e),e+=2,n.exchange=w.decode(t,e),e+=w.decode.bytes,et.decode.bytes=e-r,n};et.encodingLength=function(t){return 4+w.encodingLength(t.exchange)};var Ke=v.a={};Ke.encode=function(t,e,r){return e||(e=S.alloc(Ke.encodingLength(t))),r||(r=0),e.writeUInt16BE(4,r),r+=2,lt.v4.encode(t,e,r),Ke.encode.bytes=6,e};Ke.encode.bytes=0;Ke.decode=function(t,e){e||(e=0),e+=2;let r=lt.v4.decode(t,e);return Ke.decode.bytes=6,r};Ke.decode.bytes=0;Ke.encodingLength=function(){return 6};var qe=v.aaaa={};qe.encode=function(t,e,r){return e||(e=S.alloc(qe.encodingLength(t))),r||(r=0),e.writeUInt16BE(16,r),r+=2,lt.v6.encode(t,e,r),qe.encode.bytes=18,e};qe.encode.bytes=0;qe.decode=function(t,e){e||(e=0),e+=2;let r=lt.v6.decode(t,e);return qe.decode.bytes=18,r};qe.decode.bytes=0;qe.encodingLength=function(){return 18};var ie=v.option={};ie.encode=function(t,e,r){e||(e=S.alloc(ie.encodingLength(t))),r||(r=0);let n=r,o=rn.toCode(t.code);if(e.writeUInt16BE(o,r),r+=2,t.data)e.writeUInt16BE(t.data.length,r),r+=2,t.data.copy(e,r),r+=t.data.length;else switch(o){case 8:let i=t.sourcePrefixLength||0,s=t.family||lt.familyOf(t.ip),a=lt.encode(t.ip,S.alloc),c=Math.ceil(i/8);e.writeUInt16BE(c+4,r),r+=2,e.writeUInt16BE(s,r),r+=2,e.writeUInt8(i,r++),e.writeUInt8(t.scopePrefixLength||0,r++),a.copy(e,r,0,c),r+=c;break;case 11:t.timeout?(e.writeUInt16BE(2,r),r+=2,e.writeUInt16BE(t.timeout,r),r+=2):(e.writeUInt16BE(0,r),r+=2);break;case 12:let d=t.length||0;e.writeUInt16BE(d,r),r+=2,e.fill(0,r,r+d),r+=d;break;case 14:let g=t.tags.length*2;e.writeUInt16BE(g,r),r+=2;for(let l of t.tags)e.writeUInt16BE(l,r),r+=2;break;default:throw new Error(`Unknown roption code: ${t.code}`)}return ie.encode.bytes=r-n,e};ie.encode.bytes=0;ie.decode=function(t,e){e||(e=0);let r={};r.code=t.readUInt16BE(e),r.type=rn.toString(r.code),e+=2;let n=t.readUInt16BE(e);switch(e+=2,r.data=t.slice(e,e+n),r.code){case 8:r.family=t.readUInt16BE(e),e+=2,r.sourcePrefixLength=t.readUInt8(e++),r.scopePrefixLength=t.readUInt8(e++);let o=S.alloc(r.family===1?4:16);t.copy(o,0,e,e+n-4),r.ip=lt.decode(o);break;case 11:n>0&&(r.timeout=t.readUInt16BE(e),e+=2);break;case 14:r.tags=[];for(let i=0;i<n;i+=2)r.tags.push(t.readUInt16BE(e)),e+=2}return ie.decode.bytes=n+4,r};ie.decode.bytes=0;ie.encodingLength=function(t){if(t.data)return t.data.length+4;switch(rn.toCode(t.code)){case 8:let r=t.sourcePrefixLength||0;return Math.ceil(r/8)+8;case 11:return typeof t.timeout=="number"?6:4;case 12:return t.length+4;case 14:return 4+t.tags.length*2}throw new Error(`Unknown roption code: ${t.code}`)};var ue=v.opt={};ue.encode=function(t,e,r){e||(e=S.alloc(ue.encodingLength(t))),r||(r=0);let n=r,o=Tt(t,ie);return e.writeUInt16BE(o,r),r=Gt(t,ie,e,r+2),ue.encode.bytes=r-n,e};ue.encode.bytes=0;ue.decode=function(t,e){e||(e=0);let r=e,n=[],o=t.readUInt16BE(e);e+=2;let i=0;for(;o>0;)n[i++]=ie.decode(t,e),e+=ie.decode.bytes,o-=ie.decode.bytes;return ue.decode.bytes=e-r,n};ue.decode.bytes=0;ue.encodingLength=function(t){return 2+Tt(t||[],ie)};var J=v.dnskey={};J.PROTOCOL_DNSSEC=3;J.ZONE_KEY=128;J.SECURE_ENTRYPOINT=32768;J.encode=function(t,e,r){e||(e=S.alloc(J.encodingLength(t))),r||(r=0);let n=r,o=t.key;if(!S.isBuffer(o))throw new Error("Key must be a Buffer");return r+=2,e.writeUInt16BE(t.flags,r),r+=2,e.writeUInt8(J.PROTOCOL_DNSSEC,r),r+=1,e.writeUInt8(t.algorithm,r),r+=1,o.copy(e,r,0,o.length),r+=o.length,J.encode.bytes=r-n,e.writeUInt16BE(J.encode.bytes-2,n),e};J.encode.bytes=0;J.decode=function(t,e){e||(e=0);let r=e;var n={},o=t.readUInt16BE(e);if(e+=2,n.flags=t.readUInt16BE(e),e+=2,t.readUInt8(e)!==J.PROTOCOL_DNSSEC)throw new Error("Protocol must be 3");return e+=1,n.algorithm=t.readUInt8(e),e+=1,n.key=t.slice(e,r+o+2),e+=n.key.length,J.decode.bytes=e-r,n};J.decode.bytes=0;J.encodingLength=function(t){return 6+S.byteLength(t.key)};var Se=v.rrsig={};Se.encode=function(t,e,r){e||(e=S.alloc(Se.encodingLength(t))),r||(r=0);let n=r,o=t.signature;if(!S.isBuffer(o))throw new Error("Signature must be a Buffer");return r+=2,e.writeUInt16BE(ze.toType(t.typeCovered),r),r+=2,e.writeUInt8(t.algorithm,r),r+=1,e.writeUInt8(t.labels,r),r+=1,e.writeUInt32BE(t.originalTTL,r),r+=4,e.writeUInt32BE(t.expiration,r),r+=4,e.writeUInt32BE(t.inception,r),r+=4,e.writeUInt16BE(t.keyTag,r),r+=2,w.encode(t.signersName,e,r),r+=w.encode.bytes,o.copy(e,r,0,o.length),r+=o.length,Se.encode.bytes=r-n,e.writeUInt16BE(Se.encode.bytes-2,n),e};Se.encode.bytes=0;Se.decode=function(t,e){e||(e=0);let r=e;var n={},o=t.readUInt16BE(e);return e+=2,n.typeCovered=ze.toString(t.readUInt16BE(e)),e+=2,n.algorithm=t.readUInt8(e),e+=1,n.labels=t.readUInt8(e),e+=1,n.originalTTL=t.readUInt32BE(e),e+=4,n.expiration=t.readUInt32BE(e),e+=4,n.inception=t.readUInt32BE(e),e+=4,n.keyTag=t.readUInt16BE(e),e+=2,n.signersName=w.decode(t,e),e+=w.decode.bytes,n.signature=t.slice(e,r+o+2),e+=n.signature.length,Se.decode.bytes=e-r,n};Se.decode.bytes=0;Se.encodingLength=function(t){return 20+w.encodingLength(t.signersName)+S.byteLength(t.signature)};var Ae=v.rp={};Ae.encode=function(t,e,r){e||(e=S.alloc(Ae.encodingLength(t))),r||(r=0);let n=r;return r+=2,w.encode(t.mbox||".",e,r,{mail:!0}),r+=w.encode.bytes,w.encode(t.txt||".",e,r),r+=w.encode.bytes,Ae.encode.bytes=r-n,e.writeUInt16BE(Ae.encode.bytes-2,n),e};Ae.encode.bytes=0;Ae.decode=function(t,e){e||(e=0);let r=e,n={};return e+=2,n.mbox=w.decode(t,e,{mail:!0})||".",e+=w.decode.bytes,n.txt=w.decode(t,e)||".",e+=w.decode.bytes,Ae.decode.bytes=e-r,n};Ae.decode.bytes=0;Ae.encodingLength=function(t){return 2+w.encodingLength(t.mbox||".")+w.encodingLength(t.txt||".")};var j={};j.encode=function(t,e,r){e||(e=S.alloc(j.encodingLength(t))),r||(r=0);let n=r;for(var o=[],i=0;i<t.length;i++){var s=ze.toType(t[i]);o[s>>8]===void 0&&(o[s>>8]=[]),o[s>>8][s>>3&31]|=1<<7-(s&7)}for(i=0;i<o.length;i++)if(o[i]!==void 0){var a=S.from(o[i]);e.writeUInt8(i,r),r+=1,e.writeUInt8(a.length,r),r+=1,a.copy(e,r),r+=a.length}return j.encode.bytes=r-n,e};j.encode.bytes=0;j.decode=function(t,e,r){e||(e=0);let n=e;for(var o=[];e-n<r;){var i=t.readUInt8(e);e+=1;var s=t.readUInt8(e);e+=1;for(var a=0;a<s;a++)for(var c=t.readUInt8(e+a),d=0;d<8;d++)if(c&1<<7-d){var g=ze.toString(i<<8|a<<3|d);o.push(g)}e+=s}return j.decode.bytes=e-n,o};j.decode.bytes=0;j.encodingLength=function(t){for(var e=[],r=0;r<t.length;r++){var n=ze.toType(t[r]);e[n>>8]=Math.max(e[n>>8]||0,n&255)}var o=0;for(r=0;r<e.length;r++)e[r]!==void 0&&(o+=2+Math.ceil((e[r]+1)/8));return o};var Be=v.nsec={};Be.encode=function(t,e,r){e||(e=S.alloc(Be.encodingLength(t))),r||(r=0);let n=r;return r+=2,w.encode(t.nextDomain,e,r),r+=w.encode.bytes,j.encode(t.rrtypes,e,r),r+=j.encode.bytes,Be.encode.bytes=r-n,e.writeUInt16BE(Be.encode.bytes-2,n),e};Be.encode.bytes=0;Be.decode=function(t,e){e||(e=0);let r=e;var n={},o=t.readUInt16BE(e);return e+=2,n.nextDomain=w.decode(t,e),e+=w.decode.bytes,n.rrtypes=j.decode(t,e,o-(e-r)),e+=j.decode.bytes,Be.decode.bytes=e-r,n};Be.decode.bytes=0;Be.encodingLength=function(t){return 2+w.encodingLength(t.nextDomain)+j.encodingLength(t.rrtypes)};var Ue=v.nsec3={};Ue.encode=function(t,e,r){e||(e=S.alloc(Ue.encodingLength(t))),r||(r=0);let n=r,o=t.salt;if(!S.isBuffer(o))throw new Error("salt must be a Buffer");let i=t.nextDomain;if(!S.isBuffer(i))throw new Error("nextDomain must be a Buffer");return r+=2,e.writeUInt8(t.algorithm,r),r+=1,e.writeUInt8(t.flags,r),r+=1,e.writeUInt16BE(t.iterations,r),r+=2,e.writeUInt8(o.length,r),r+=1,o.copy(e,r,0,o.length),r+=o.length,e.writeUInt8(i.length,r),r+=1,i.copy(e,r,0,i.length),r+=i.length,j.encode(t.rrtypes,e,r),r+=j.encode.bytes,Ue.encode.bytes=r-n,e.writeUInt16BE(Ue.encode.bytes-2,n),e};Ue.encode.bytes=0;Ue.decode=function(t,e){e||(e=0);let r=e;var n={},o=t.readUInt16BE(e);e+=2,n.algorithm=t.readUInt8(e),e+=1,n.flags=t.readUInt8(e),e+=1,n.iterations=t.readUInt16BE(e),e+=2;let i=t.readUInt8(e);e+=1,n.salt=t.slice(e,e+i),e+=i;let s=t.readUInt8(e);return e+=1,n.nextDomain=t.slice(e,e+s),e+=s,n.rrtypes=j.decode(t,e,o-(e-r)),e+=j.decode.bytes,Ue.decode.bytes=e-r,n};Ue.decode.bytes=0;Ue.encodingLength=function(t){return 8+t.salt.length+t.nextDomain.length+j.encodingLength(t.rrtypes)};var Le=v.ds={};Le.encode=function(t,e,r){e||(e=S.alloc(Le.encodingLength(t))),r||(r=0);let n=r,o=t.digest;if(!S.isBuffer(o))throw new Error("Digest must be a Buffer");return r+=2,e.writeUInt16BE(t.keyTag,r),r+=2,e.writeUInt8(t.algorithm,r),r+=1,e.writeUInt8(t.digestType,r),r+=1,o.copy(e,r,0,o.length),r+=o.length,Le.encode.bytes=r-n,e.writeUInt16BE(Le.encode.bytes-2,n),e};Le.encode.bytes=0;Le.decode=function(t,e){e||(e=0);let r=e;var n={},o=t.readUInt16BE(e);return e+=2,n.keyTag=t.readUInt16BE(e),e+=2,n.algorithm=t.readUInt8(e),e+=1,n.digestType=t.readUInt8(e),e+=1,n.digest=t.slice(e,r+o+2),e+=n.digest.length,Le.decode.bytes=e-r,n};Le.decode.bytes=0;Le.encodingLength=function(t){return 6+S.byteLength(t.digest)};var de=v.sshfp={};de.getFingerprintLengthForHashType=function(e){switch(e){case 1:return 20;case 2:return 32}};de.encode=function(e,r,n){r||(r=S.alloc(de.encodingLength(e))),n||(n=0);let o=n;n+=2,r[n]=e.algorithm,n+=1,r[n]=e.hash,n+=1;let i=S.from(e.fingerprint.toUpperCase(),"hex");if(i.length!==de.getFingerprintLengthForHashType(e.hash))throw new Error("Invalid fingerprint length");return i.copy(r,n),n+=i.byteLength,de.encode.bytes=n-o,r.writeUInt16BE(de.encode.bytes-2,o),r};de.encode.bytes=0;de.decode=function(e,r){r||(r=0);let n=r,o={};r+=2,o.algorithm=e[r],r+=1,o.hash=e[r],r+=1;let i=de.getFingerprintLengthForHashType(o.hash);return o.fingerprint=e.slice(r,r+i).toString("hex").toUpperCase(),r+=i,de.decode.bytes=r-n,o};de.decode.bytes=0;de.encodingLength=function(t){return 4+S.from(t.fingerprint,"hex").byteLength};var Te=v.naptr={};Te.encode=function(t,e,r){e||(e=S.alloc(Te.encodingLength(t))),r||(r=0);let n=r;return r+=2,e.writeUInt16BE(t.order||0,r),r+=2,e.writeUInt16BE(t.preference||0,r),r+=2,O.encode(t.flags,e,r),r+=O.encode.bytes,O.encode(t.services,e,r),r+=O.encode.bytes,O.encode(t.regexp,e,r),r+=O.encode.bytes,w.encode(t.replacement,e,r),r+=w.encode.bytes,Te.encode.bytes=r-n,e.writeUInt16BE(Te.encode.bytes-2,n),e};Te.encode.bytes=0;Te.decode=function(t,e){e||(e=0);let r=e,n={};return e+=2,n.order=t.readUInt16BE(e),e+=2,n.preference=t.readUInt16BE(e),e+=2,n.flags=O.decode(t,e),e+=O.decode.bytes,n.services=O.decode(t,e),e+=O.decode.bytes,n.regexp=O.decode(t,e),e+=O.decode.bytes,n.replacement=w.decode(t,e),e+=w.decode.bytes,Te.decode.bytes=e-r,n};Te.decode.bytes=0;Te.encodingLength=function(t){return O.encodingLength(t.flags)+O.encodingLength(t.services)+O.encodingLength(t.regexp)+w.encodingLength(t.replacement)+6};var Ne=v.tlsa={};Ne.encode=function(t,e,r){e||(e=S.alloc(Ne.encodingLength(t))),r||(r=0);let n=r,o=t.certificate;if(!S.isBuffer(o))throw new Error("Certificate must be a Buffer");return r+=2,e.writeUInt8(t.usage,r),r+=1,e.writeUInt8(t.selector,r),r+=1,e.writeUInt8(t.matchingType,r),r+=1,o.copy(e,r,0,o.length),r+=o.length,Ne.encode.bytes=r-n,e.writeUInt16BE(Ne.encode.bytes-2,n),e};Ne.encode.bytes=0;Ne.decode=function(t,e){e||(e=0);let r=e,n={},o=t.readUInt16BE(e);return e+=2,n.usage=t.readUInt8(e),e+=1,n.selector=t.readUInt8(e),e+=1,n.matchingType=t.readUInt8(e),e+=1,n.certificate=t.slice(e,r+o+2),e+=n.certificate.length,Ne.decode.bytes=e-r,n};Ne.decode.bytes=0;Ne.encodingLength=function(t){return 5+S.byteLength(t.certificate)};var on=v.record=function(t){switch(t.toUpperCase()){case"A":return Ke;case"PTR":return we;case"CNAME":return Ws;case"DNAME":return Qs;case"TXT":return ke;case"NULL":return _e;case"AAAA":return qe;case"SRV":return Fe;case"HINFO":return Me;case"CAA":return ae;case"NS":return Re;case"SOA":return De;case"MX":return et;case"OPT":return ue;case"DNSKEY":return J;case"RRSIG":return Se;case"RP":return Ae;case"NSEC":return Be;case"NSEC3":return Ue;case"SSHFP":return de;case"DS":return Le;case"NAPTR":return Te;case"TLSA":return Ne}return Pe},Y=v.answer={};Y.encode=function(t,e,r){e||(e=S.alloc(Y.encodingLength(t))),r||(r=0);let n=r;if(w.encode(t.name,e,r),r+=w.encode.bytes,e.writeUInt16BE(ze.toType(t.type),r),t.type.toUpperCase()==="OPT"){if(t.name!==".")throw new Error("OPT name must be root.");e.writeUInt16BE(t.udpPayloadSize||4096,r+2),e.writeUInt8(t.extendedRcode||0,r+4),e.writeUInt8(t.ednsVersion||0,r+5),e.writeUInt16BE(t.flags||0,r+6),r+=8,ue.encode(t.options||[],e,r),r+=ue.encode.bytes}else{let o=mr.toClass(t.class===void 0?"IN":t.class);t.flush&&(o|=nn),e.writeUInt16BE(o,r+2),e.writeUInt32BE(t.ttl||0,r+4),r+=8;let i=on(t.type);i.encode(t.data,e,r),r+=i.encode.bytes}return Y.encode.bytes=r-n,e};Y.encode.bytes=0;Y.decode=function(t,e){e||(e=0);let r={},n=e;if(r.name=w.decode(t,e),e+=w.decode.bytes,r.type=ze.toString(t.readUInt16BE(e)),r.type==="OPT")r.udpPayloadSize=t.readUInt16BE(e+2),r.extendedRcode=t.readUInt8(e+4),r.ednsVersion=t.readUInt8(e+5),r.flags=t.readUInt16BE(e+6),r.flag_do=(r.flags>>15&1)===1,r.options=ue.decode(t,e+8),e+=8+ue.decode.bytes;else{let o=t.readUInt16BE(e+2);r.ttl=t.readUInt32BE(e+4),r.class=mr.toString(o&Xs),r.flush=!!(o&nn);let i=on(r.type);r.data=i.decode(t,e+8),e+=8+i.decode.bytes}return Y.decode.bytes=e-n,r};Y.decode.bytes=0;Y.encodingLength=function(t){let e=t.data!==null&&t.data!==void 0?t.data:t.options;return w.encodingLength(t.name)+8+on(t.type).encodingLength(e)};var xe=v.question={};xe.encode=function(t,e,r){e||(e=S.alloc(xe.encodingLength(t))),r||(r=0);let n=r;return w.encode(t.name,e,r),r+=w.encode.bytes,e.writeUInt16BE(ze.toType(t.type),r),r+=2,e.writeUInt16BE(mr.toClass(t.class===void 0?"IN":t.class),r),r+=2,xe.encode.bytes=r-n,t};xe.encode.bytes=0;xe.decode=function(t,e){e||(e=0);let r=e,n={};return n.name=w.decode(t,e),e+=w.decode.bytes,n.type=ze.toString(t.readUInt16BE(e)),e+=2,n.class=mr.toString(t.readUInt16BE(e)),e+=2,!!(n.class&Xo)&&(n.class&=Zs),xe.decode.bytes=e-r,n};xe.decode.bytes=0;xe.encodingLength=function(t){return w.encodingLength(t.name)+4};v.AUTHORITATIVE_ANSWER=1024;v.TRUNCATED_RESPONSE=512;v.RECURSION_DESIRED=256;v.RECURSION_AVAILABLE=128;v.AUTHENTIC_DATA=32;v.CHECKING_DISABLED=16;v.DNSSEC_OK=32768;v.encode=function(t,e,r){let n=!e;n&&(e=S.alloc(v.encodingLength(t))),r||(r=0);let o=r;return t.questions||(t.questions=[]),t.answers||(t.answers=[]),t.authorities||(t.authorities=[]),t.additionals||(t.additionals=[]),Ee.encode(t,e,r),r+=Ee.encode.bytes,r=Gt(t.questions,xe,e,r),r=Gt(t.answers,Y,e,r),r=Gt(t.authorities,Y,e,r),r=Gt(t.additionals,Y,e,r),v.encode.bytes=r-o,n&&v.encode.bytes!==e.length?e.slice(0,v.encode.bytes):e};v.encode.bytes=0;v.decode=function(t,e){e||(e=0);let r=e,n=Ee.decode(t,e);return e+=Ee.decode.bytes,e=pr(n.questions,xe,t,e),e=pr(n.answers,Y,t,e),e=pr(n.authorities,Y,t,e),e=pr(n.additionals,Y,t,e),v.decode.bytes=e-r,n};v.decode.bytes=0;v.encodingLength=function(t){return Ee.encodingLength(t)+Tt(t.questions||[],xe)+Tt(t.answers||[],Y)+Tt(t.authorities||[],Y)+Tt(t.additionals||[],Y)};v.streamEncode=function(t){let e=v.encode(t),r=S.alloc(2);r.writeUInt16BE(e.byteLength);let n=S.concat([r,e]);return v.streamEncode.bytes=n.byteLength,n};v.streamEncode.bytes=0;v.streamDecode=function(t){let e=t.readUInt16BE(0);if(t.byteLength<e+2)return null;let r=v.decode(t.slice(2));return v.streamDecode.bytes=v.decode.bytes,r};v.streamDecode.bytes=0;function Tt(t,e){let r=0;for(let n=0;n<t.length;n++)r+=e.encodingLength(t[n]);return r}function Gt(t,e,r,n){for(let o=0;o<t.length;o++)e.encode(t[o],r,n),n+=e.encode.bytes;return n}function pr(t,e,r,n){for(let o=0;o<t.length;o++)t[o]=e.decode(r,n),n+=e.decode.bytes;return n}});var Jo=ve((Du,Qo)=>{"use strict";var Wo=oc;process.nextTick(nc,42);Qo.exports=Js;function Js(t){var e=n;return r;function r(o){e(o||tc)}function n(o){var i=[o];e=s,t(a);function s(c){i.push(c)}function a(c){var d=arguments;for(e=ec(c)?n:g;i.length;)g(i.shift());function g(l){Wo(rc,l,d)}}}}function ec(t){return Object.prototype.toString.call(t)==="[object Error]"}function tc(){}function rc(t,e){t.apply(null,e)}function nc(t){t===42&&(Wo=process.nextTick)}function oc(t,e,r){process.nextTick(function(){t(e,r)})}});var ri=ve((ku,ti)=>{var sn=Zo(),ic=ne("dgram"),sc=Jo(),cc=ne("events"),an=ne("os"),cn=function(){};ti.exports=function(t){t||(t={});var e=new cc.EventEmitter,r=typeof t.port=="number"?t.port:5353,n=t.type||"udp4",o=t.ip||t.host||(n==="udp4"?"224.0.0.251":null),i={address:o,port:r},s={},a=!1,c=null;if(n==="udp6"&&(!o||!t.interface))throw new Error("For IPv6 multicast you must specify `ip` and `interface`");var d=t.socket||ic.createSocket({type:n,reuseAddr:t.reuseAddr!==!1,toString:function(){return n}});d.on("error",function(l){l.code==="EACCES"||l.code==="EADDRINUSE"?e.emit("error",l):e.emit("warning",l)}),d.on("message",function(l,u){try{l=sn.decode(l)}catch(p){e.emit("warning",p);return}e.emit("packet",l,u),l.type==="query"&&e.emit("query",l,u),l.type==="response"&&e.emit("response",l,u)}),d.on("listening",function(){r||(r=i.port=d.address().port),t.multicast!==!1&&(e.update(),c=setInterval(e.update,5e3),d.setMulticastTTL(t.ttl||255),d.setMulticastLoopback(t.loopback!==!1))});var g=sc(function(l){if(!r||t.bind===!1)return l(null);d.once("error",l),d.bind(r,t.bind||t.interface,function(){d.removeListener("error",l),l(null)})});return g(function(l){if(l)return e.emit("error",l);e.emit("ready")}),e.send=function(l,u,p){if(typeof u=="function")return e.send(l,null,u);p||(p=cn),u?!u.host&&!u.address&&(u.address=i.address):u=i,g(h);function h(y){if(a)return p();if(y)return p(y);var m=sn.encode(l);d.send(m,0,m.length,u.port,u.address||u.host,p)}},e.response=e.respond=function(l,u,p){Array.isArray(l)&&(l={answers:l}),l.type="response",l.flags=(l.flags||0)|sn.AUTHORITATIVE_ANSWER,e.send(l,u,p)},e.query=function(l,u,p,h){if(typeof u=="function")return e.query(l,null,null,u);if(typeof u=="object"&&u&&u.port)return e.query(l,null,u,p);if(typeof p=="function")return e.query(l,u,null,p);h||(h=cn),typeof l=="string"&&(l=[{name:l,type:u||"ANY"}]),Array.isArray(l)&&(l={type:"query",questions:l}),l.type="query",e.send(l,p,h)},e.destroy=function(l){if(l||(l=cn),a)return process.nextTick(l);a=!0,clearInterval(c);for(var u in s)try{d.dropMembership(o,u)}catch{}s={},d.close(l)},e.update=function(){for(var l=t.interface?[].concat(t.interface):dc(),u=!1,p=0;p<l.length;p++){var h=l[p];if(!s[h])try{d.addMembership(o,h),s[h]=!0,u=!0}catch(y){e.emit("warning",y)}}if(u){if(d.setMulticastInterface)try{d.setMulticastInterface(t.interface||ac())}catch(y){e.emit("warning",y)}e.emit("networkInterface")}},e};function ac(){for(var t=an.networkInterfaces(),e=Object.keys(t),r=0;r<e.length;r++)for(var n=t[e[r]],o=0;o<n.length;o++){var i=n[o];if(ei(i.family)&&!i.internal)return an.platform()==="darwin"&&e[r]==="en0"?i.address:"0.0.0.0"}return"127.0.0.1"}function dc(){for(var t=an.networkInterfaces(),e=Object.keys(t),r=[],n=0;n<e.length;n++)for(var o=t[e[n]],i=0;i<o.length;i++){var s=o[i];if(ei(s.family)){r.push(s.address);break}}return r}function ei(t){return t===4||t==="IPv4"}});var xs=ve(cr=>{(function(){var t,e,r,n,o,i,s,a;a=function(c){var d,g,l,u;return d=(c&255<<24)>>>24,g=(c&255<<16)>>>16,l=(c&65280)>>>8,u=c&255,[d,g,l,u].join(".")},s=function(c){var d,g,l,u,p,h;for(d=[],l=u=0;u<=3&&c.length!==0;l=++u){if(l>0){if(c[0]!==".")throw new Error("Invalid IP");c=c.substring(1)}h=e(c),p=h[0],g=h[1],c=c.substring(g),d.push(p)}if(c.length!==0)throw new Error("Invalid IP");switch(d.length){case 1:if(d[0]>4294967295)throw new Error("Invalid IP");return d[0]>>>0;case 2:if(d[0]>255||d[1]>16777215)throw new Error("Invalid IP");return(d[0]<<24|d[1])>>>0;case 3:if(d[0]>255||d[1]>255||d[2]>65535)throw new Error("Invalid IP");return(d[0]<<24|d[1]<<16|d[2])>>>0;case 4:if(d[0]>255||d[1]>255||d[2]>255||d[3]>255)throw new Error("Invalid IP");return(d[0]<<24|d[1]<<16|d[2]<<8|d[3])>>>0;default:throw new Error("Invalid IP")}},r=function(c){return c.charCodeAt(0)},n=r("0"),i=r("a"),o=r("A"),e=function(c){var d,g,l,u,p;for(u=0,d=10,g="9",l=0,c.length>1&&c[l]==="0"&&(c[l+1]==="x"||c[l+1]==="X"?(l+=2,d=16):"0"<=c[l+1]&&c[l+1]<="9"&&(l++,d=8,g="7")),p=l;l<c.length;){if("0"<=c[l]&&c[l]<=g)u=u*d+(r(c[l])-n)>>>0;else if(d===16)if("a"<=c[l]&&c[l]<="f")u=u*d+(10+r(c[l])-i)>>>0;else if("A"<=c[l]&&c[l]<="F")u=u*d+(10+r(c[l])-o)>>>0;else break;else break;if(u>4294967295)throw new Error("too large");l++}if(l===p)throw new Error("empty octet");return[u,l]},t=function(){function c(d,g){var l,u,p,h;if(typeof d!="string")throw new Error("Missing `net' parameter");if(g||(h=d.split("/",2),d=h[0],g=h[1]),g||(g=32),typeof g=="string"&&g.indexOf(".")>-1){try{this.maskLong=s(g)}catch(y){throw l=y,new Error("Invalid mask: "+g)}for(u=p=32;p>=0;u=--p)if(this.maskLong===4294967295<<32-u>>>0){this.bitmask=u;break}}else if(g||g===0)this.bitmask=parseInt(g,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(s(d)&this.maskLong)>>>0}catch(y){throw l=y,new Error("Invalid net address: "+d)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+g);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return c.prototype.contains=function(d){return typeof d=="string"&&(d.indexOf("/")>0||d.split(".").length!==4)&&(d=new c(d)),d instanceof c?this.contains(d.base)&&this.contains(d.broadcast||d.last):(s(d)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},c.prototype.next=function(d){return d==null&&(d=1),new c(a(this.netLong+this.size*d),this.mask)},c.prototype.forEach=function(d){var g,l,u;for(u=s(this.first),l=s(this.last),g=0;u<=l;)d(a(u),u,g),g++,u++},c.prototype.toString=function(){return this.base+"/"+this.bitmask},c}(),cr.ip2long=s,cr.long2ip=a,cr.Netmask=t}).call(cr)});var Wd={};oe(Wd,{mdns:()=>Zd});var ko=Symbol.for("@libp2p/peer-discovery");var Xr=Symbol.for("@libp2p/peer-id");var Lt=class extends Error{static name="InvalidParametersError";constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},ur=class extends Error{static name="InvalidPublicKeyError";constructor(e="Invalid public key"){super(e),this.name="InvalidPublicKeyError"}};var lr=class extends Error{static name="InvalidMultihashError";constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}};var $t=class extends Error{static name="UnsupportedKeyTypeError";constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}};var _o=ne("events"),Mo=(t,...e)=>{try{(0,_o.setMaxListeners)(t,...e)}catch{}};var hr=class extends EventTarget{#e=new Map;constructor(){super(),Mo(1/0,this)}listenerCount(e){let r=this.#e.get(e);return r==null?0:r.length}addEventListener(e,r,n){super.addEventListener(e,r,n);let o=this.#e.get(e);o==null&&(o=[],this.#e.set(e,o)),o.push({callback:r,once:(n!==!0&&n!==!1&&n?.once)??!1})}removeEventListener(e,r,n){super.removeEventListener(e.toString(),r??null,n);let o=this.#e.get(e);o!=null&&(o=o.filter(({callback:i})=>i!==r),this.#e.set(e,o))}dispatchEvent(e){let r=super.dispatchEvent(e),n=this.#e.get(e.type);return n==null||(n=n.filter(({once:o})=>!o),this.#e.set(e.type,n)),r}safeDispatchEvent(e,r={}){return this.dispatchEvent(new CustomEvent(e,r))}};var Fo=Symbol.for("@libp2p/service-capabilities"),iu=Symbol.for("@libp2p/service-dependencies");var Fs=Ut(ri(),1);var pn={};oe(pn,{base58btc:()=>K,base58flickr:()=>gc});var _u=new Uint8Array(0);function ni(t,e){if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0}function me(t){if(t instanceof Uint8Array&&t.constructor.name==="Uint8Array")return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")}function oi(t){return new TextEncoder().encode(t)}function ii(t){return new TextDecoder().decode(t)}function uc(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var o=0;o<t.length;o++){var i=t.charAt(o),s=i.charCodeAt(0);if(r[s]!==255)throw new TypeError(i+" is ambiguous");r[s]=o}var a=t.length,c=t.charAt(0),d=Math.log(a)/Math.log(256),g=Math.log(256)/Math.log(a);function l(h){if(h instanceof Uint8Array||(ArrayBuffer.isView(h)?h=new Uint8Array(h.buffer,h.byteOffset,h.byteLength):Array.isArray(h)&&(h=Uint8Array.from(h))),!(h instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(h.length===0)return"";for(var y=0,m=0,f=0,x=h.length;f!==x&&h[f]===0;)f++,y++;for(var b=(x-f)*g+1>>>0,L=new Uint8Array(b);f!==x;){for(var T=h[f],B=0,U=b-1;(T!==0||B<m)&&U!==-1;U--,B++)T+=256*L[U]>>>0,L[U]=T%a>>>0,T=T/a>>>0;if(T!==0)throw new Error("Non-zero carry");m=B,f++}for(var N=b-m;N!==b&&L[N]===0;)N++;for(var C=c.repeat(y);N<b;++N)C+=t.charAt(L[N]);return C}function u(h){if(typeof h!="string")throw new TypeError("Expected String");if(h.length===0)return new Uint8Array;var y=0;if(h[y]!==" "){for(var m=0,f=0;h[y]===c;)m++,y++;for(var x=(h.length-y)*d+1>>>0,b=new Uint8Array(x);h[y];){var L=r[h.charCodeAt(y)];if(L===255)return;for(var T=0,B=x-1;(L!==0||T<f)&&B!==-1;B--,T++)L+=a*b[B]>>>0,b[B]=L%256>>>0,L=L/256>>>0;if(L!==0)throw new Error("Non-zero carry");f=T,y++}if(h[y]!==" "){for(var U=x-f;U!==x&&b[U]===0;)U++;for(var N=new Uint8Array(m+(x-U)),C=m;U!==x;)N[C++]=b[U++];return N}}}function p(h){var y=u(h);if(y)return y;throw new Error(`Non-${e} character`)}return{encode:l,decodeUnsafe:u,decode:p}}var lc=uc,hc=lc,ci=hc;var dn=class{name;prefix;baseEncode;constructor(e,r,n){this.name=e,this.prefix=r,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},un=class{name;prefix;baseDecode;prefixCodePoint;constructor(e,r,n){this.name=e,this.prefix=r;let o=r.codePointAt(0);if(o===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=o,this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return ai(this,e)}},ln=class{decoders;constructor(e){this.decoders=e}or(e){return ai(this,e)}decode(e){let r=e[0],n=this.decoders[r];if(n!=null)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};function ai(t,e){return new ln({...t.decoders??{[t.prefix]:t},...e.decoders??{[e.prefix]:e}})}var hn=class{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,r,n,o){this.name=e,this.prefix=r,this.baseEncode=n,this.baseDecode=o,this.encoder=new dn(e,r,n),this.decoder=new un(e,r,o)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}};function Nt({name:t,prefix:e,encode:r,decode:n}){return new hn(t,e,r,n)}function tt({name:t,prefix:e,alphabet:r}){let{encode:n,decode:o}=ci(r,t);return Nt({prefix:e,name:t,encode:n,decode:i=>me(o(i))})}function pc(t,e,r,n){let o={};for(let g=0;g<e.length;++g)o[e[g]]=g;let i=t.length;for(;t[i-1]==="=";)--i;let s=new Uint8Array(i*r/8|0),a=0,c=0,d=0;for(let g=0;g<i;++g){let l=o[t[g]];if(l===void 0)throw new SyntaxError(`Non-${n} character`);c=c<<r|l,a+=r,a>=8&&(a-=8,s[d++]=255&c>>a)}if(a>=r||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return s}function mc(t,e,r){let n=e[e.length-1]==="=",o=(1<<r)-1,i="",s=0,a=0;for(let c=0;c<t.length;++c)for(a=a<<8|t[c],s+=8;s>r;)s-=r,i+=e[o&a>>s];if(s!==0&&(i+=e[o&a<<r-s]),n)for(;i.length*r&7;)i+="=";return i}function F({name:t,prefix:e,bitsPerChar:r,alphabet:n}){return Nt({prefix:e,name:t,encode(o){return mc(o,n,r)},decode(o){return pc(o,n,r,t)}})}var K=tt({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),gc=tt({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var mn={};oe(mn,{base32:()=>Ve,base32hex:()=>xc,base32hexpad:()=>bc,base32hexpadupper:()=>Ic,base32hexupper:()=>Ec,base32pad:()=>fc,base32padupper:()=>wc,base32upper:()=>yc,base32z:()=>vc});var Ve=F({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),yc=F({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),fc=F({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),wc=F({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),xc=F({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Ec=F({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),bc=F({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Ic=F({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),vc=F({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var gn={};oe(gn,{base36:()=>Yt,base36upper:()=>Sc});var Yt=tt({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Sc=tt({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var Ac=li,di=128,Bc=127,Uc=~Bc,Lc=Math.pow(2,31);function li(t,e,r){e=e||[],r=r||0;for(var n=r;t>=Lc;)e[r++]=t&255|di,t/=128;for(;t&Uc;)e[r++]=t&255|di,t>>>=7;return e[r]=t|0,li.bytes=r-n+1,e}var Tc=yn,Nc=128,ui=127;function yn(t,n){var r=0,n=n||0,o=0,i=n,s,a=t.length;do{if(i>=a)throw yn.bytes=0,new RangeError("Could not decode varint");s=t[i++],r+=o<28?(s&ui)<<o:(s&ui)*Math.pow(2,o),o+=7}while(s>=Nc);return yn.bytes=i-n,r}var Cc=Math.pow(2,7),Oc=Math.pow(2,14),Pc=Math.pow(2,21),Rc=Math.pow(2,28),Dc=Math.pow(2,35),kc=Math.pow(2,42),_c=Math.pow(2,49),Mc=Math.pow(2,56),Fc=Math.pow(2,63),Kc=function(t){return t<Cc?1:t<Oc?2:t<Pc?3:t<Rc?4:t<Dc?5:t<kc?6:t<_c?7:t<Mc?8:t<Fc?9:10},qc={encode:Ac,decode:Tc,encodingLength:Kc},zc=qc,Xt=zc;function Zt(t,e=0){return[Xt.decode(t,e),Xt.decode.bytes]}function Ct(t,e,r=0){return Xt.encode(t,e,r),e}function Ot(t){return Xt.encodingLength(t)}function ht(t,e){let r=e.byteLength,n=Ot(t),o=n+Ot(r),i=new Uint8Array(o+r);return Ct(t,i,0),Ct(r,i,n),i.set(e,o),new Pt(t,r,e,i)}function pt(t){let e=me(t),[r,n]=Zt(e),[o,i]=Zt(e.subarray(n)),s=e.subarray(n+i);if(s.byteLength!==o)throw new Error("Incorrect length");return new Pt(r,o,s,e)}function hi(t,e){if(t===e)return!0;{let r=e;return t.code===r.code&&t.size===r.size&&r.bytes instanceof Uint8Array&&ni(t.bytes,r.bytes)}}var Pt=class{code;size;digest;bytes;constructor(e,r,n,o){this.code=e,this.size=r,this.digest=n,this.bytes=o}};function pi(t,e){let{bytes:r,version:n}=t;switch(n){case 0:return Hc(r,fn(t),e??K.encoder);default:return jc(r,fn(t),e??Ve.encoder)}}var mi=new WeakMap;function fn(t){let e=mi.get(t);if(e==null){let r=new Map;return mi.set(t,r),r}return e}var ee=class t{code;version;multihash;bytes;"/";constructor(e,r,n,o){this.code=r,this.version=e,this.multihash=n,this.bytes=o,this["/"]=o}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{let{code:e,multihash:r}=this;if(e!==Wt)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(r.code!==$c)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return t.createV0(r)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{let{code:e,digest:r}=this.multihash,n=ht(e,r);return t.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return t.equals(this,e)}static equals(e,r){let n=r;return n!=null&&e.code===n.code&&e.version===n.version&&hi(e.multihash,n.multihash)}toString(e){return pi(this,e)}toJSON(){return{"/":pi(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;let r=e;if(r instanceof t)return r;if(r["/"]!=null&&r["/"]===r.bytes||r.asCID===r){let{version:n,code:o,multihash:i,bytes:s}=r;return new t(n,o,i,s??gi(n,o,i.bytes))}else if(r[Gc]===!0){let{version:n,multihash:o,code:i}=r,s=pt(o);return t.create(n,i,s)}else return null}static create(e,r,n){if(typeof r!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(r!==Wt)throw new Error(`Version 0 CID must use dag-pb (code: ${Wt}) block encoding`);return new t(e,r,n,n.bytes)}case 1:{let o=gi(e,r,n.bytes);return new t(e,r,n,o)}default:throw new Error("Invalid version")}}static createV0(e){return t.create(0,Wt,e)}static createV1(e,r){return t.create(1,e,r)}static decode(e){let[r,n]=t.decodeFirst(e);if(n.length!==0)throw new Error("Incorrect length");return r}static decodeFirst(e){let r=t.inspectBytes(e),n=r.size-r.multihashSize,o=me(e.subarray(n,n+r.multihashSize));if(o.byteLength!==r.multihashSize)throw new Error("Incorrect length");let i=o.subarray(r.multihashSize-r.digestSize),s=new Pt(r.multihashCode,r.digestSize,i,o);return[r.version===0?t.createV0(s):t.createV1(r.codec,s),e.subarray(r.size)]}static inspectBytes(e){let r=0,n=()=>{let[l,u]=Zt(e.subarray(r));return r+=u,l},o=n(),i=Wt;if(o===18?(o=0,r=0):i=n(),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);let s=r,a=n(),c=n(),d=r+c,g=d-s;return{version:o,codec:i,multihashCode:a,digestSize:c,multihashSize:g,size:d}}static parse(e,r){let[n,o]=Vc(e,r),i=t.decode(o);if(i.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return fn(i).set(n,e),i}};function Vc(t,e){switch(t[0]){case"Q":{let r=e??K;return[K.prefix,r.decode(`${K.prefix}${t}`)]}case K.prefix:{let r=e??K;return[K.prefix,r.decode(t)]}case Ve.prefix:{let r=e??Ve;return[Ve.prefix,r.decode(t)]}case Yt.prefix:{let r=e??Yt;return[Yt.prefix,r.decode(t)]}default:{if(e==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[t[0],e.decode(t)]}}}function Hc(t,e,r){let{prefix:n}=r;if(n!==K.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);let o=e.get(n);if(o==null){let i=r.encode(t).slice(1);return e.set(n,i),i}else return o}function jc(t,e,r){let{prefix:n}=r,o=e.get(n);if(o==null){let i=r.encode(t);return e.set(n,i),i}else return o}var Wt=112,$c=18;function gi(t,e,r){let n=Ot(t),o=n+Ot(e),i=new Uint8Array(o+r.byteLength);return Ct(t,i,0),Ct(e,i,n),i.set(r,o),i}var Gc=Symbol.for("@ipld/js-cid/CID");var wn={};oe(wn,{identity:()=>He});var yi=0,Yc="identity",fi=me;function Xc(t){return ht(yi,fi(t))}var He={code:yi,name:Yc,encode:fi,digest:Xc};function je(t,e){if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0}var fr=Ut(ne("crypto"),1);var wi=ne("node:buffer");function Rt(t){return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}function Ce(t,e){return Rt(wi.Buffer.concat(t,e))}var Si=ne("node:buffer");var xn={};oe(xn,{base10:()=>Zc});var Zc=tt({prefix:"9",name:"base10",alphabet:"0123456789"});var En={};oe(En,{base16:()=>Wc,base16upper:()=>Qc});var Wc=F({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Qc=F({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var bn={};oe(bn,{base2:()=>Jc});var Jc=F({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var In={};oe(In,{base256emoji:()=>oa});var xi=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),ea=xi.reduce((t,e,r)=>(t[r]=e,t),[]),ta=xi.reduce((t,e,r)=>{let n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);return t[n]=r,t},[]);function ra(t){return t.reduce((e,r)=>(e+=ea[r],e),"")}function na(t){let e=[];for(let r of t){let n=r.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${r}`);let o=ta[n];if(o==null)throw new Error(`Non-base256emoji character: ${r}`);e.push(o)}return new Uint8Array(e)}var oa=Nt({prefix:"\u{1F680}",name:"base256emoji",encode:ra,decode:na});var vn={};oe(vn,{base64:()=>ia,base64pad:()=>sa,base64url:()=>ca,base64urlpad:()=>aa});var ia=F({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),sa=F({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),ca=F({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),aa=F({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var Sn={};oe(Sn,{base8:()=>da});var da=F({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var An={};oe(An,{identity:()=>ua});var ua=Nt({prefix:"\0",name:"identity",encode:t=>ii(t),decode:t=>oi(t)});var pl=new TextEncoder,ml=new TextDecoder;var Nn={};oe(Nn,{sha256:()=>Tn,sha512:()=>pa});var Ln=Ut(ne("crypto"),1);function Un({name:t,code:e,encode:r}){return new Bn(t,e,r)}var Bn=class{name;code;encode;constructor(e,r,n){this.name=e,this.code=r,this.encode=n}digest(e){if(e instanceof Uint8Array){let r=this.encode(e);return r instanceof Uint8Array?ht(this.code,r):r.then(n=>ht(this.code,n))}else throw Error("Unknown type, must be binary type")}};var Tn=Un({name:"sha2-256",code:18,encode:t=>me(Ln.default.createHash("sha256").update(t).digest())}),pa=Un({name:"sha2-512",code:19,encode:t=>me(Ln.default.createHash("sha512").update(t).digest())});var Qt={...An,...bn,...Sn,...xn,...En,...mn,...gn,...pn,...vn,...In},Ul={...Nn,...wn};var bi=ne("node:buffer");function $e(t=0){return Rt(bi.Buffer.allocUnsafe(t))}function vi(t,e,r,n){return{name:t,prefix:e,encoder:{name:t,prefix:e,encode:r},decoder:{decode:n}}}var Ii=vi("utf8","u",t=>"u"+new TextDecoder("utf8").decode(t),t=>new TextEncoder().encode(t.substring(1))),Cn=vi("ascii","a",t=>{let e="a";for(let r=0;r<t.length;r++)e+=String.fromCharCode(t[r]);return e},t=>{t=t.substring(1);let e=$e(t.length);for(let r=0;r<t.length;r++)e[r]=t.charCodeAt(r);return e}),ma={utf8:Ii,"utf-8":Ii,hex:Qt.base16,latin1:Cn,ascii:Cn,binary:Cn,...Qt},yr=ma;function Ge(t,e="utf8"){let r=yr[e];if(r==null)throw new Error(`Unsupported encoding "${e}"`);return e==="utf8"||e==="utf-8"?Rt(Si.Buffer.from(t,"utf-8")):r.decoder.decode(`${r.prefix}${t}`)}var Ai=ne("node:buffer");function z(t,e="utf8"){let r=yr[e];if(r==null)throw new Error(`Unsupported encoding "${e}"`);return e==="utf8"||e==="utf-8"?Ai.Buffer.from(t.buffer,t.byteOffset,t.byteLength).toString("utf8"):r.encoder.encode(t).substring(1)}var zl=fr.default.generateKeyPairSync,Jt=32;var ga=64;function Bi(t,e,r){if(t.byteLength!==Jt)throw new TypeError('"key" must be 32 bytes in length.');if(!(t instanceof Uint8Array))throw new TypeError('"key" must be a node.js Buffer, or Uint8Array.');if(e.byteLength!==ga)throw new TypeError('"sig" must be 64 bytes in length.');if(!(e instanceof Uint8Array))throw new TypeError('"sig" must be a node.js Buffer, or Uint8Array.');let n=fr.default.createPublicKey({format:"jwk",key:{crv:"Ed25519",x:z(t,"base64url"),kty:"OKP"}});return fr.default.verify(null,r instanceof Uint8Array?r:r.subarray(),n,e)}var wr=class{type="Ed25519";raw;constructor(e){this.raw=On(e,Jt)}toMultihash(){return He.digest(xr(this))}toCID(){return ee.createV1(114,this.toMultihash())}toString(){return K.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:je(this.raw,e.raw)}verify(e,r){return Bi(this.raw,r,e)}};function Li(t){return t=On(t,Jt),new wr(t)}function On(t,e){if(t=Uint8Array.from(t??[]),t.length!==e)throw new Lt(`Key must be a Uint8Array of length ${e}, got ${t.length}`);return t}var fa=Math.pow(2,7),wa=Math.pow(2,14),xa=Math.pow(2,21),Pn=Math.pow(2,28),Rn=Math.pow(2,35),Dn=Math.pow(2,42),kn=Math.pow(2,49),D=128,X=127;function se(t){if(t<fa)return 1;if(t<wa)return 2;if(t<xa)return 3;if(t<Pn)return 4;if(t<Rn)return 5;if(t<Dn)return 6;if(t<kn)return 7;if(Number.MAX_SAFE_INTEGER!=null&&t>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function _n(t,e,r=0){switch(se(t)){case 8:e[r++]=t&255|D,t/=128;case 7:e[r++]=t&255|D,t/=128;case 6:e[r++]=t&255|D,t/=128;case 5:e[r++]=t&255|D,t/=128;case 4:e[r++]=t&255|D,t>>>=7;case 3:e[r++]=t&255|D,t>>>=7;case 2:e[r++]=t&255|D,t>>>=7;case 1:{e[r++]=t&255,t>>>=7;break}default:throw new Error("unreachable")}return e}function Ea(t,e,r=0){switch(se(t)){case 8:e.set(r++,t&255|D),t/=128;case 7:e.set(r++,t&255|D),t/=128;case 6:e.set(r++,t&255|D),t/=128;case 5:e.set(r++,t&255|D),t/=128;case 4:e.set(r++,t&255|D),t>>>=7;case 3:e.set(r++,t&255|D),t>>>=7;case 2:e.set(r++,t&255|D),t>>>=7;case 1:{e.set(r++,t&255),t>>>=7;break}default:throw new Error("unreachable")}return e}function Mn(t,e){let r=t[e],n=0;if(n+=r&X,r<D||(r=t[e+1],n+=(r&X)<<7,r<D)||(r=t[e+2],n+=(r&X)<<14,r<D)||(r=t[e+3],n+=(r&X)<<21,r<D)||(r=t[e+4],n+=(r&X)*Pn,r<D)||(r=t[e+5],n+=(r&X)*Rn,r<D)||(r=t[e+6],n+=(r&X)*Dn,r<D)||(r=t[e+7],n+=(r&X)*kn,r<D))return n;throw new RangeError("Could not decode varint")}function ba(t,e){let r=t.get(e),n=0;if(n+=r&X,r<D||(r=t.get(e+1),n+=(r&X)<<7,r<D)||(r=t.get(e+2),n+=(r&X)<<14,r<D)||(r=t.get(e+3),n+=(r&X)<<21,r<D)||(r=t.get(e+4),n+=(r&X)*Pn,r<D)||(r=t.get(e+5),n+=(r&X)*Rn,r<D)||(r=t.get(e+6),n+=(r&X)*Dn,r<D)||(r=t.get(e+7),n+=(r&X)*kn,r<D))return n;throw new RangeError("Could not decode varint")}function Dt(t,e,r=0){return e==null&&(e=$e(se(t))),e instanceof Uint8Array?_n(t,e,r):Ea(t,e,r)}function gt(t,e=0){return t instanceof Uint8Array?Mn(t,e):ba(t,e)}var Fn=new Float32Array([-0]),rt=new Uint8Array(Fn.buffer);function Ni(t,e,r){Fn[0]=t,e[r]=rt[0],e[r+1]=rt[1],e[r+2]=rt[2],e[r+3]=rt[3]}function Ci(t,e){return rt[0]=t[e],rt[1]=t[e+1],rt[2]=t[e+2],rt[3]=t[e+3],Fn[0]}var Kn=new Float64Array([-0]),Z=new Uint8Array(Kn.buffer);function Oi(t,e,r){Kn[0]=t,e[r]=Z[0],e[r+1]=Z[1],e[r+2]=Z[2],e[r+3]=Z[3],e[r+4]=Z[4],e[r+5]=Z[5],e[r+6]=Z[6],e[r+7]=Z[7]}function Pi(t,e){return Z[0]=t[e],Z[1]=t[e+1],Z[2]=t[e+2],Z[3]=t[e+3],Z[4]=t[e+4],Z[5]=t[e+5],Z[6]=t[e+6],Z[7]=t[e+7],Kn[0]}var Ia=BigInt(Number.MAX_SAFE_INTEGER),va=BigInt(Number.MIN_SAFE_INTEGER),le=class t{lo;hi;constructor(e,r){this.lo=e|0,this.hi=r|0}toNumber(e=!1){if(!e&&this.hi>>>31>0){let r=~this.lo+1>>>0,n=~this.hi>>>0;return r===0&&(n=n+1>>>0),-(r+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(e=!1){if(e)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){let r=~this.lo+1>>>0,n=~this.hi>>>0;return r===0&&(n=n+1>>>0),-(BigInt(r)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(e=!1){return this.toBigInt(e).toString()}zzEncode(){let e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this}zzDecode(){let e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this}length(){let e=this.lo,r=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?r===0?e<16384?e<128?1:2:e<2097152?3:4:r<16384?r<128?5:6:r<2097152?7:8:n<128?9:10}static fromBigInt(e){if(e===0n)return yt;if(e<Ia&&e>va)return this.fromNumber(Number(e));let r=e<0n;r&&(e=-e);let n=e>>32n,o=e-(n<<32n);return r&&(n=~n|0n,o=~o|0n,++o>Ri&&(o=0n,++n>Ri&&(n=0n))),new t(Number(o),Number(n))}static fromNumber(e){if(e===0)return yt;let r=e<0;r&&(e=-e);let n=e>>>0,o=(e-n)/4294967296>>>0;return r&&(o=~o>>>0,n=~n>>>0,++n>4294967295&&(n=0,++o>4294967295&&(o=0))),new t(n,o)}static from(e){return typeof e=="number"?t.fromNumber(e):typeof e=="bigint"?t.fromBigInt(e):typeof e=="string"?t.fromBigInt(BigInt(e)):e.low!=null||e.high!=null?new t(e.low>>>0,e.high>>>0):yt}},yt=new le(0,0);yt.toBigInt=function(){return 0n};yt.zzEncode=yt.zzDecode=function(){return this};yt.length=function(){return 1};var Ri=4294967296n;function Di(t){let e=0,r=0;for(let n=0;n<t.length;++n)r=t.charCodeAt(n),r<128?e+=1:r<2048?e+=2:(r&64512)===55296&&(t.charCodeAt(n+1)&64512)===56320?(++n,e+=4):e+=3;return e}function ki(t,e,r){if(r-e<1)return"";let o,i=[],s=0,a;for(;e<r;)a=t[e++],a<128?i[s++]=a:a>191&&a<224?i[s++]=(a&31)<<6|t[e++]&63:a>239&&a<365?(a=((a&7)<<18|(t[e++]&63)<<12|(t[e++]&63)<<6|t[e++]&63)-65536,i[s++]=55296+(a>>10),i[s++]=56320+(a&1023)):i[s++]=(a&15)<<12|(t[e++]&63)<<6|t[e++]&63,s>8191&&((o??(o=[])).push(String.fromCharCode.apply(String,i)),s=0);return o!=null?(s>0&&o.push(String.fromCharCode.apply(String,i.slice(0,s))),o.join("")):String.fromCharCode.apply(String,i.slice(0,s))}function qn(t,e,r){let n=r,o,i;for(let s=0;s<t.length;++s)o=t.charCodeAt(s),o<128?e[r++]=o:o<2048?(e[r++]=o>>6|192,e[r++]=o&63|128):(o&64512)===55296&&((i=t.charCodeAt(s+1))&64512)===56320?(o=65536+((o&1023)<<10)+(i&1023),++s,e[r++]=o>>18|240,e[r++]=o>>12&63|128,e[r++]=o>>6&63|128,e[r++]=o&63|128):(e[r++]=o>>12|224,e[r++]=o>>6&63|128,e[r++]=o&63|128);return r-n}function be(t,e){return RangeError(`index out of range: ${t.pos} + ${e??1} > ${t.len}`)}function Er(t,e){return(t[e-4]|t[e-3]<<8|t[e-2]<<16|t[e-1]<<24)>>>0}var zn=class{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(e){this.buf=e,this.pos=0,this.len=e.length}uint32(){let e=4294967295;if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,be(this,10);return e}int32(){return this.uint32()|0}sint32(){let e=this.uint32();return e>>>1^-(e&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw be(this,4);return Er(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw be(this,4);return Er(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw be(this,4);let e=Ci(this.buf,this.pos);return this.pos+=4,e}double(){if(this.pos+8>this.len)throw be(this,4);let e=Pi(this.buf,this.pos);return this.pos+=8,e}bytes(){let e=this.uint32(),r=this.pos,n=this.pos+e;if(n>this.len)throw be(this,e);return this.pos+=e,r===n?new Uint8Array(0):this.buf.subarray(r,n)}string(){let e=this.bytes();return ki(e,0,e.length)}skip(e){if(typeof e=="number"){if(this.pos+e>this.len)throw be(this,e);this.pos+=e}else do if(this.pos>=this.len)throw be(this);while(this.buf[this.pos++]&128);return this}skipType(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(e=this.uint32()&7)!==4;)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${e} at offset ${this.pos}`)}return this}readLongVarint(){let e=new le(0,0),r=0;if(this.len-this.pos>4){for(;r<4;++r)if(e.lo=(e.lo|(this.buf[this.pos]&127)<<r*7)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(this.buf[this.pos]&127)<<28)>>>0,e.hi=(e.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return e;r=0}else{for(;r<3;++r){if(this.pos>=this.len)throw be(this);if(e.lo=(e.lo|(this.buf[this.pos]&127)<<r*7)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(this.buf[this.pos++]&127)<<r*7)>>>0,e}if(this.len-this.pos>4){for(;r<5;++r)if(e.hi=(e.hi|(this.buf[this.pos]&127)<<r*7+3)>>>0,this.buf[this.pos++]<128)return e}else for(;r<5;++r){if(this.pos>=this.len)throw be(this);if(e.hi=(e.hi|(this.buf[this.pos]&127)<<r*7+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw be(this,8);let e=Er(this.buf,this.pos+=4),r=Er(this.buf,this.pos+=4);return new le(e,r)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){let e=Mn(this.buf,this.pos);return this.pos+=se(e),e}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}};function Vn(t){return new zn(t instanceof Uint8Array?t:t.subarray())}function br(t,e,r){let n=Vn(t);return e.decode(n,void 0,r)}function Hn(t){let e=t??8192,r=e>>>1,n,o=e;return function(s){if(s<1||s>r)return $e(s);o+s>e&&(n=$e(e),o=0);let a=n.subarray(o,o+=s);return o&7&&(o=(o|7)+1),a}}var ft=class{fn;len;next;val;constructor(e,r,n){this.fn=e,this.len=r,this.next=void 0,this.val=n}};function jn(){}var Gn=class{head;tail;len;next;constructor(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}},Sa=Hn();function Aa(t){return globalThis.Buffer!=null?$e(t):Sa(t)}var tr=class{len;head;tail;states;constructor(){this.len=0,this.head=new ft(jn,0,0),this.tail=this.head,this.states=null}_push(e,r,n){return this.tail=this.tail.next=new ft(e,r,n),this.len+=r,this}uint32(e){return this.len+=(this.tail=this.tail.next=new Yn((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this}int32(e){return e<0?this._push(Ir,10,le.fromNumber(e)):this.uint32(e)}sint32(e){return this.uint32((e<<1^e>>31)>>>0)}uint64(e){let r=le.fromBigInt(e);return this._push(Ir,r.length(),r)}uint64Number(e){return this._push(_n,se(e),e)}uint64String(e){return this.uint64(BigInt(e))}int64(e){return this.uint64(e)}int64Number(e){return this.uint64Number(e)}int64String(e){return this.uint64String(e)}sint64(e){let r=le.fromBigInt(e).zzEncode();return this._push(Ir,r.length(),r)}sint64Number(e){let r=le.fromNumber(e).zzEncode();return this._push(Ir,r.length(),r)}sint64String(e){return this.sint64(BigInt(e))}bool(e){return this._push($n,1,e?1:0)}fixed32(e){return this._push(er,4,e>>>0)}sfixed32(e){return this.fixed32(e)}fixed64(e){let r=le.fromBigInt(e);return this._push(er,4,r.lo)._push(er,4,r.hi)}fixed64Number(e){let r=le.fromNumber(e);return this._push(er,4,r.lo)._push(er,4,r.hi)}fixed64String(e){return this.fixed64(BigInt(e))}sfixed64(e){return this.fixed64(e)}sfixed64Number(e){return this.fixed64Number(e)}sfixed64String(e){return this.fixed64String(e)}float(e){return this._push(Ni,4,e)}double(e){return this._push(Oi,8,e)}bytes(e){let r=e.length>>>0;return r===0?this._push($n,1,0):this.uint32(r)._push(Ua,r,e)}string(e){let r=Di(e);return r!==0?this.uint32(r)._push(qn,r,e):this._push($n,1,0)}fork(){return this.states=new Gn(this),this.head=this.tail=new ft(jn,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new ft(jn,0,0),this.len=0),this}ldelim(){let e=this.head,r=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=e.next,this.tail=r,this.len+=n),this}finish(){let e=this.head.next,r=Aa(this.len),n=0;for(;e!=null;)e.fn(e.val,r,n),n+=e.len,e=e.next;return r}};function $n(t,e,r){e[r]=t&255}function Ba(t,e,r){for(;t>127;)e[r++]=t&127|128,t>>>=7;e[r]=t}var Yn=class extends ft{next;constructor(e,r){super(Ba,e,r),this.next=void 0}};function Ir(t,e,r){for(;t.hi!==0;)e[r++]=t.lo&127|128,t.lo=(t.lo>>>7|t.hi<<25)>>>0,t.hi>>>=7;for(;t.lo>127;)e[r++]=t.lo&127|128,t.lo=t.lo>>>7;e[r++]=t.lo}function er(t,e,r){e[r]=t&255,e[r+1]=t>>>8&255,e[r+2]=t>>>16&255,e[r+3]=t>>>24}function Ua(t,e,r){e.set(t,r)}globalThis.Buffer!=null&&(tr.prototype.bytes=function(t){let e=t.length>>>0;return this.uint32(e),e>0&&this._push(La,e,t),this},tr.prototype.string=function(t){let e=globalThis.Buffer.byteLength(t);return this.uint32(e),e>0&&this._push(Ta,e,t),this});function La(t,e,r){e.set(t,r)}function Ta(t,e,r){t.length<40?qn(t,e,r):e.utf8Write!=null?e.utf8Write(t,r):e.set(Ge(t),r)}function Xn(){return new tr}function vr(t,e){let r=Xn();return e.encode(t,r,{lengthDelimited:!1}),r.finish()}var kt;(function(t){t[t.VARINT=0]="VARINT",t[t.BIT64=1]="BIT64",t[t.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",t[t.START_GROUP=3]="START_GROUP",t[t.END_GROUP=4]="END_GROUP",t[t.BIT32=5]="BIT32"})(kt||(kt={}));function Sr(t,e,r,n){return{name:t,type:e,encode:r,decode:n}}function Zn(t){function e(o){if(t[o.toString()]==null)throw new Error("Invalid enum value");return t[o]}let r=function(i,s){let a=e(i);s.int32(a)},n=function(i){let s=i.int32();return e(s)};return Sr("enum",kt.VARINT,r,n)}function Ar(t,e){return Sr("message",kt.LENGTH_DELIMITED,t,e)}var ge;(function(t){t.RSA="RSA",t.Ed25519="Ed25519",t.secp256k1="secp256k1"})(ge||(ge={}));var Wn;(function(t){t[t.RSA=0]="RSA",t[t.Ed25519=1]="Ed25519",t[t.secp256k1=2]="secp256k1"})(Wn||(Wn={}));(function(t){t.codec=()=>Zn(Wn)})(ge||(ge={}));var rr;(function(t){let e;t.codec=()=>(e==null&&(e=Ar((r,n,o={})=>{o.lengthDelimited!==!1&&n.fork(),r.Type!=null&&(n.uint32(8),ge.codec().encode(r.Type,n)),r.Data!=null&&(n.uint32(18),n.bytes(r.Data)),o.lengthDelimited!==!1&&n.ldelim()},(r,n,o={})=>{let i={},s=n==null?r.len:r.pos+n;for(;r.pos<s;){let a=r.uint32();switch(a>>>3){case 1:{i.Type=ge.codec().decode(r);break}case 2:{i.Data=r.bytes();break}default:{r.skipType(a&7);break}}}return i})),e),t.encode=r=>vr(r,t.codec()),t.decode=(r,n)=>br(r,t.codec(),n)})(rr||(rr={}));var Qn;(function(t){let e;t.codec=()=>(e==null&&(e=Ar((r,n,o={})=>{o.lengthDelimited!==!1&&n.fork(),r.Type!=null&&(n.uint32(8),ge.codec().encode(r.Type,n)),r.Data!=null&&(n.uint32(18),n.bytes(r.Data)),o.lengthDelimited!==!1&&n.ldelim()},(r,n,o={})=>{let i={},s=n==null?r.len:r.pos+n;for(;r.pos<s;){let a=r.uint32();switch(a>>>3){case 1:{i.Type=ge.codec().decode(r);break}case 2:{i.Data=r.bytes();break}default:{r.skipType(a&7);break}}}return i})),e),t.encode=r=>vr(r,t.codec()),t.decode=(r,n)=>br(r,t.codec(),n)})(Qn||(Qn={}));function Mi(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function Ca(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function _t(t,...e){if(!Ca(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function Fi(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Mi(t.outputLen),Mi(t.blockLen)}function Mt(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function Ki(t,e){_t(t);let r=e.outputLen;if(t.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}var Ye=Ut(ne("node:crypto"),1),wt=Ye&&typeof Ye=="object"&&"webcrypto"in Ye?Ye.webcrypto:Ye&&typeof Ye=="object"&&"randomBytes"in Ye?Ye:void 0;var Br=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),Ie=(t,e)=>t<<32-e|t>>>e;function Oa(t){if(typeof t!="string")throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array(new TextEncoder().encode(t))}function nr(t){return typeof t=="string"&&(t=Oa(t)),_t(t),t}function qi(...t){let e=0;for(let n=0;n<t.length;n++){let o=t[n];_t(o),e+=o.length}let r=new Uint8Array(e);for(let n=0,o=0;n<t.length;n++){let i=t[n];r.set(i,o),o+=i.length}return r}var Ft=class{clone(){return this._cloneInto()}};function zi(t){let e=n=>t().update(nr(n)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}function Vi(t=32){if(wt&&typeof wt.getRandomValues=="function")return wt.getRandomValues(new Uint8Array(t));if(wt&&typeof wt.randomBytes=="function")return wt.randomBytes(t);throw new Error("crypto.getRandomValues must be defined")}function Pa(t,e,r,n){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,r,n);let o=BigInt(32),i=BigInt(4294967295),s=Number(r>>o&i),a=Number(r&i),c=n?4:0,d=n?0:4;t.setUint32(e+c,s,n),t.setUint32(e+d,a,n)}var Hi=(t,e,r)=>t&e^~t&r,ji=(t,e,r)=>t&e^t&r^e&r,Ur=class extends Ft{constructor(e,r,n,o){super(),this.blockLen=e,this.outputLen=r,this.padOffset=n,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Br(this.buffer)}update(e){Mt(this);let{view:r,buffer:n,blockLen:o}=this;e=nr(e);let i=e.length;for(let s=0;s<i;){let a=Math.min(o-this.pos,i-s);if(a===o){let c=Br(e);for(;o<=i-s;s+=o)this.process(c,s);continue}n.set(e.subarray(s,s+a),this.pos),this.pos+=a,s+=a,this.pos===o&&(this.process(r,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Mt(this),Ki(e,this),this.finished=!0;let{buffer:r,view:n,blockLen:o,isLE:i}=this,{pos:s}=this;r[s++]=128,this.buffer.subarray(s).fill(0),this.padOffset>o-s&&(this.process(n,0),s=0);for(let l=s;l<o;l++)r[l]=0;Pa(n,o-8,BigInt(this.length*8),i),this.process(n,0);let a=Br(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let d=c/4,g=this.get();if(d>g.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<d;l++)a.setUint32(4*l,g[l],i)}digest(){let{buffer:e,outputLen:r}=this;this.digestInto(e);let n=e.slice(0,r);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:r,buffer:n,length:o,finished:i,destroyed:s,pos:a}=this;return e.length=o,e.pos=a,e.finished=i,e.destroyed=s,o%r&&e.buffer.set(n),e}};var Ra=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),nt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ot=new Uint32Array(64),Jn=class extends Ur{constructor(){super(64,32,8,!1),this.A=nt[0]|0,this.B=nt[1]|0,this.C=nt[2]|0,this.D=nt[3]|0,this.E=nt[4]|0,this.F=nt[5]|0,this.G=nt[6]|0,this.H=nt[7]|0}get(){let{A:e,B:r,C:n,D:o,E:i,F:s,G:a,H:c}=this;return[e,r,n,o,i,s,a,c]}set(e,r,n,o,i,s,a,c){this.A=e|0,this.B=r|0,this.C=n|0,this.D=o|0,this.E=i|0,this.F=s|0,this.G=a|0,this.H=c|0}process(e,r){for(let l=0;l<16;l++,r+=4)ot[l]=e.getUint32(r,!1);for(let l=16;l<64;l++){let u=ot[l-15],p=ot[l-2],h=Ie(u,7)^Ie(u,18)^u>>>3,y=Ie(p,17)^Ie(p,19)^p>>>10;ot[l]=y+ot[l-7]+h+ot[l-16]|0}let{A:n,B:o,C:i,D:s,E:a,F:c,G:d,H:g}=this;for(let l=0;l<64;l++){let u=Ie(a,6)^Ie(a,11)^Ie(a,25),p=g+u+Hi(a,c,d)+Ra[l]+ot[l]|0,y=(Ie(n,2)^Ie(n,13)^Ie(n,22))+ji(n,o,i)|0;g=d,d=c,c=a,a=s+p|0,s=i,i=o,o=n,n=p+y|0}n=n+this.A|0,o=o+this.B|0,i=i+this.C|0,s=s+this.D|0,a=a+this.E|0,c=c+this.F|0,d=d+this.G|0,g=g+this.H|0,this.set(n,o,i,s,a,c,d,g)}roundClean(){ot.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var $i=zi(()=>new Jn);var Lr=class extends Ft{constructor(e,r){super(),this.finished=!1,this.destroyed=!1,Fi(e);let n=nr(r);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let o=this.blockLen,i=new Uint8Array(o);i.set(n.length>o?e.create().update(n).digest():n);for(let s=0;s<i.length;s++)i[s]^=54;this.iHash.update(i),this.oHash=e.create();for(let s=0;s<i.length;s++)i[s]^=106;this.oHash.update(i),i.fill(0)}update(e){return Mt(this),this.iHash.update(e),this}digestInto(e){Mt(this),_t(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){let e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));let{oHash:r,iHash:n,finished:o,destroyed:i,blockLen:s,outputLen:a}=this;return e=e,e.finished=o,e.destroyed=i,e.blockLen=s,e.outputLen=a,e.oHash=r._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},eo=(t,e,r)=>new Lr(t,e).update(r).digest();eo.create=(t,e)=>new Lr(t,e);var so={};oe(so,{aInRange:()=>ct,abool:()=>xt,abytes:()=>Kt,bitGet:()=>Ka,bitLen:()=>oo,bitMask:()=>ir,bitSet:()=>qa,bytesToHex:()=>Et,bytesToNumberBE:()=>Ze,bytesToNumberLE:()=>Cr,concatBytes:()=>qt,createHmacDrbg:()=>io,ensureBytes:()=>he,equalBytes:()=>Ma,hexToBytes:()=>It,hexToNumber:()=>no,inRange:()=>or,isBytes:()=>it,memoized:()=>Pr,notImplemented:()=>Va,numberToBytesBE:()=>st,numberToBytesLE:()=>Or,numberToHexUnpadded:()=>bt,numberToVarBytesBE:()=>_a,utf8ToBytes:()=>Fa,validateObject:()=>at});var Tr=BigInt(0),Nr=BigInt(1),Da=BigInt(2);function it(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function Kt(t){if(!it(t))throw new Error("Uint8Array expected")}function xt(t,e){if(typeof e!="boolean")throw new Error(t+" boolean expected, got "+e)}var ka=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function Et(t){Kt(t);let e="";for(let r=0;r<t.length;r++)e+=ka[t[r]];return e}function bt(t){let e=t.toString(16);return e.length&1?"0"+e:e}function no(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?Tr:BigInt("0x"+t)}var Xe={_0:48,_9:57,A:65,F:70,a:97,f:102};function Gi(t){if(t>=Xe._0&&t<=Xe._9)return t-Xe._0;if(t>=Xe.A&&t<=Xe.F)return t-(Xe.A-10);if(t>=Xe.a&&t<=Xe.f)return t-(Xe.a-10)}function It(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);let e=t.length,r=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);let n=new Uint8Array(r);for(let o=0,i=0;o<r;o++,i+=2){let s=Gi(t.charCodeAt(i)),a=Gi(t.charCodeAt(i+1));if(s===void 0||a===void 0){let c=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+i)}n[o]=s*16+a}return n}function Ze(t){return no(Et(t))}function Cr(t){return Kt(t),no(Et(Uint8Array.from(t).reverse()))}function st(t,e){return It(t.toString(16).padStart(e*2,"0"))}function Or(t,e){return st(t,e).reverse()}function _a(t){return It(bt(t))}function he(t,e,r){let n;if(typeof e=="string")try{n=It(e)}catch(i){throw new Error(t+" must be hex string or Uint8Array, cause: "+i)}else if(it(e))n=Uint8Array.from(e);else throw new Error(t+" must be hex string or Uint8Array");let o=n.length;if(typeof r=="number"&&o!==r)throw new Error(t+" of length "+r+" expected, got "+o);return n}function qt(...t){let e=0;for(let n=0;n<t.length;n++){let o=t[n];Kt(o),e+=o.length}let r=new Uint8Array(e);for(let n=0,o=0;n<t.length;n++){let i=t[n];r.set(i,o),o+=i.length}return r}function Ma(t,e){if(t.length!==e.length)return!1;let r=0;for(let n=0;n<t.length;n++)r|=t[n]^e[n];return r===0}function Fa(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}var to=t=>typeof t=="bigint"&&Tr<=t;function or(t,e,r){return to(t)&&to(e)&&to(r)&&e<=t&&t<r}function ct(t,e,r,n){if(!or(e,r,n))throw new Error("expected valid "+t+": "+r+" <= n < "+n+", got "+e)}function oo(t){let e;for(e=0;t>Tr;t>>=Nr,e+=1);return e}function Ka(t,e){return t>>BigInt(e)&Nr}function qa(t,e,r){return t|(r?Nr:Tr)<<BigInt(e)}var ir=t=>(Da<<BigInt(t-1))-Nr,ro=t=>new Uint8Array(t),Yi=t=>Uint8Array.from(t);function io(t,e,r){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof r!="function")throw new Error("hmacFn must be a function");let n=ro(t),o=ro(t),i=0,s=()=>{n.fill(1),o.fill(0),i=0},a=(...l)=>r(o,n,...l),c=(l=ro())=>{o=a(Yi([0]),l),n=a(),l.length!==0&&(o=a(Yi([1]),l),n=a())},d=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let l=0,u=[];for(;l<e;){n=a();let p=n.slice();u.push(p),l+=n.length}return qt(...u)};return(l,u)=>{s(),c(l);let p;for(;!(p=u(d()));)c();return s(),p}}var za={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||it(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function at(t,e,r={}){let n=(o,i,s)=>{let a=za[i];if(typeof a!="function")throw new Error("invalid validator function");let c=t[o];if(!(s&&c===void 0)&&!a(c,t))throw new Error("param "+String(o)+" is invalid. Expected "+i+", got "+c)};for(let[o,i]of Object.entries(e))n(o,i,!1);for(let[o,i]of Object.entries(r))n(o,i,!0);return t}var Va=()=>{throw new Error("not implemented")};function Pr(t){let e=new WeakMap;return(r,...n)=>{let o=e.get(r);if(o!==void 0)return o;let i=t(r,...n);return e.set(r,i),i}}var H=BigInt(0),q=BigInt(1),vt=BigInt(2),Ha=BigInt(3),co=BigInt(4),Xi=BigInt(5),Zi=BigInt(8),ja=BigInt(9),$a=BigInt(16);function W(t,e){let r=t%e;return r>=H?r:e+r}function Ga(t,e,r){if(e<H)throw new Error("invalid exponent, negatives unsupported");if(r<=H)throw new Error("invalid modulus");if(r===q)return H;let n=q;for(;e>H;)e&q&&(n=n*t%r),t=t*t%r,e>>=q;return n}function pe(t,e,r){let n=t;for(;e-- >H;)n*=n,n%=r;return n}function Rr(t,e){if(t===H)throw new Error("invert: expected non-zero number");if(e<=H)throw new Error("invert: expected positive modulus, got "+e);let r=W(t,e),n=e,o=H,i=q,s=q,a=H;for(;r!==H;){let d=n/r,g=n%r,l=o-s*d,u=i-a*d;n=r,r=g,o=s,i=a,s=l,a=u}if(n!==q)throw new Error("invert: does not exist");return W(o,e)}function Ya(t){let e=(t-q)/vt,r,n,o;for(r=t-q,n=0;r%vt===H;r/=vt,n++);for(o=vt;o<t&&Ga(o,e,t)!==t-q;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(n===1){let s=(t+q)/co;return function(c,d){let g=c.pow(d,s);if(!c.eql(c.sqr(g),d))throw new Error("Cannot find square root");return g}}let i=(r+q)/vt;return function(a,c){if(a.pow(c,e)===a.neg(a.ONE))throw new Error("Cannot find square root");let d=n,g=a.pow(a.mul(a.ONE,o),r),l=a.pow(c,i),u=a.pow(c,r);for(;!a.eql(u,a.ONE);){if(a.eql(u,a.ZERO))return a.ZERO;let p=1;for(let y=a.sqr(u);p<d&&!a.eql(y,a.ONE);p++)y=a.sqr(y);let h=a.pow(g,q<<BigInt(d-p-1));g=a.sqr(h),l=a.mul(l,h),u=a.mul(u,g),d=p}return l}}function Xa(t){if(t%co===Ha){let e=(t+q)/co;return function(n,o){let i=n.pow(o,e);if(!n.eql(n.sqr(i),o))throw new Error("Cannot find square root");return i}}if(t%Zi===Xi){let e=(t-Xi)/Zi;return function(n,o){let i=n.mul(o,vt),s=n.pow(i,e),a=n.mul(o,s),c=n.mul(n.mul(a,vt),s),d=n.mul(a,n.sub(c,n.ONE));if(!n.eql(n.sqr(d),o))throw new Error("Cannot find square root");return d}}return t%$a,Ya(t)}var Za=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ao(t){let e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},r=Za.reduce((n,o)=>(n[o]="function",n),e);return at(t,r)}function Wa(t,e,r){if(r<H)throw new Error("invalid exponent, negatives unsupported");if(r===H)return t.ONE;if(r===q)return e;let n=t.ONE,o=e;for(;r>H;)r&q&&(n=t.mul(n,o)),o=t.sqr(o),r>>=q;return n}function Qa(t,e){let r=new Array(e.length),n=e.reduce((i,s,a)=>t.is0(s)?i:(r[a]=i,t.mul(i,s)),t.ONE),o=t.inv(n);return e.reduceRight((i,s,a)=>t.is0(s)?i:(r[a]=t.mul(i,r[a]),t.mul(i,s)),o),r}function uo(t,e){let r=e!==void 0?e:t.toString(2).length,n=Math.ceil(r/8);return{nBitLength:r,nByteLength:n}}function Dr(t,e,r=!1,n={}){if(t<=H)throw new Error("invalid field: expected ORDER > 0, got "+t);let{nBitLength:o,nByteLength:i}=uo(t,e);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let s,a=Object.freeze({ORDER:t,isLE:r,BITS:o,BYTES:i,MASK:ir(o),ZERO:H,ONE:q,create:c=>W(c,t),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return H<=c&&c<t},is0:c=>c===H,isOdd:c=>(c&q)===q,neg:c=>W(-c,t),eql:(c,d)=>c===d,sqr:c=>W(c*c,t),add:(c,d)=>W(c+d,t),sub:(c,d)=>W(c-d,t),mul:(c,d)=>W(c*d,t),pow:(c,d)=>Wa(a,c,d),div:(c,d)=>W(c*Rr(d,t),t),sqrN:c=>c*c,addN:(c,d)=>c+d,subN:(c,d)=>c-d,mulN:(c,d)=>c*d,inv:c=>Rr(c,t),sqrt:n.sqrt||(c=>(s||(s=Xa(t)),s(a,c))),invertBatch:c=>Qa(a,c),cmov:(c,d,g)=>g?d:c,toBytes:c=>r?Or(c,i):st(c,i),fromBytes:c=>{if(c.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+c.length);return r?Cr(c):Ze(c)}});return Object.freeze(a)}function Wi(t){if(typeof t!="bigint")throw new Error("field order must be bigint");let e=t.toString(2).length;return Math.ceil(e/8)}function lo(t){let e=Wi(t);return e+Math.ceil(e/2)}function Qi(t,e,r=!1){let n=t.length,o=Wi(e),i=lo(e);if(n<16||n<i||n>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+n);let s=r?Cr(t):Ze(t),a=W(s,e-q)+q;return r?Or(a,o):st(a,o)}var Ji=BigInt(0),kr=BigInt(1);function ho(t,e){let r=e.negate();return t?r:e}function es(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function po(t,e){es(t,e);let r=Math.ceil(e/t)+1,n=2**(t-1);return{windows:r,windowSize:n}}function ed(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach((r,n)=>{if(!(r instanceof e))throw new Error("invalid point at index "+n)})}function td(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((r,n)=>{if(!e.isValid(r))throw new Error("invalid scalar at index "+n)})}var mo=new WeakMap,ts=new WeakMap;function go(t){return ts.get(t)||1}function rs(t,e){return{constTimeNegate:ho,hasPrecomputes(r){return go(r)!==1},unsafeLadder(r,n,o=t.ZERO){let i=r;for(;n>Ji;)n&kr&&(o=o.add(i)),i=i.double(),n>>=kr;return o},precomputeWindow(r,n){let{windows:o,windowSize:i}=po(n,e),s=[],a=r,c=a;for(let d=0;d<o;d++){c=a,s.push(c);for(let g=1;g<i;g++)c=c.add(a),s.push(c);a=c.double()}return s},wNAF(r,n,o){let{windows:i,windowSize:s}=po(r,e),a=t.ZERO,c=t.BASE,d=BigInt(2**r-1),g=2**r,l=BigInt(r);for(let u=0;u<i;u++){let p=u*s,h=Number(o&d);o>>=l,h>s&&(h-=g,o+=kr);let y=p,m=p+Math.abs(h)-1,f=u%2!==0,x=h<0;h===0?c=c.add(ho(f,n[y])):a=a.add(ho(x,n[m]))}return{p:a,f:c}},wNAFUnsafe(r,n,o,i=t.ZERO){let{windows:s,windowSize:a}=po(r,e),c=BigInt(2**r-1),d=2**r,g=BigInt(r);for(let l=0;l<s;l++){let u=l*a;if(o===Ji)break;let p=Number(o&c);if(o>>=g,p>a&&(p-=d,o+=kr),p===0)continue;let h=n[u+Math.abs(p)-1];p<0&&(h=h.negate()),i=i.add(h)}return i},getPrecomputes(r,n,o){let i=mo.get(n);return i||(i=this.precomputeWindow(n,r),r!==1&&mo.set(n,o(i))),i},wNAFCached(r,n,o){let i=go(r);return this.wNAF(i,this.getPrecomputes(i,r,o),n)},wNAFCachedUnsafe(r,n,o,i){let s=go(r);return s===1?this.unsafeLadder(r,n,i):this.wNAFUnsafe(s,this.getPrecomputes(s,r,o),n,i)},setWindowSize(r,n){es(n,e),ts.set(r,n),mo.delete(r)}}}function ns(t,e,r,n){if(ed(r,t),td(n,e),r.length!==n.length)throw new Error("arrays of points and scalars must have equal length");let o=t.ZERO,i=oo(BigInt(r.length)),s=i>12?i-3:i>4?i-2:i?2:1,a=(1<<s)-1,c=new Array(a+1).fill(o),d=Math.floor((e.BITS-1)/s)*s,g=o;for(let l=d;l>=0;l-=s){c.fill(o);for(let p=0;p<n.length;p++){let h=n[p],y=Number(h>>BigInt(l)&BigInt(a));c[y]=c[y].add(r[p])}let u=o;for(let p=c.length-1,h=o;p>0;p--)h=h.add(c[p]),u=u.add(h);if(g=g.add(u),l!==0)for(let p=0;p<s;p++)g=g.double()}return g}function yo(t){return ao(t.Fp),at(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...uo(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}function os(t){t.lowS!==void 0&&xt("lowS",t.lowS),t.prehash!==void 0&&xt("prehash",t.prehash)}function rd(t){let e=yo(t);at(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:r,Fp:n,a:o}=e;if(r){if(!n.eql(o,n.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof r!="object"||typeof r.beta!="bigint"||typeof r.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}var{bytesToNumberBE:nd,hexToBytes:od}=so,fo=class extends Error{constructor(e=""){super(e)}},We={Err:fo,_tlv:{encode:(t,e)=>{let{Err:r}=We;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length&1)throw new r("tlv.encode: unpadded data");let n=e.length/2,o=bt(n);if(o.length/2&128)throw new r("tlv.encode: long form length too big");let i=n>127?bt(o.length/2|128):"";return bt(t)+i+o+e},decode(t,e){let{Err:r}=We,n=0;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length<2||e[n++]!==t)throw new r("tlv.decode: wrong tlv");let o=e[n++],i=!!(o&128),s=0;if(!i)s=o;else{let c=o&127;if(!c)throw new r("tlv.decode(long): indefinite length not supported");if(c>4)throw new r("tlv.decode(long): byte length is too big");let d=e.subarray(n,n+c);if(d.length!==c)throw new r("tlv.decode: length bytes not complete");if(d[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(let g of d)s=s<<8|g;if(n+=c,s<128)throw new r("tlv.decode(long): not minimal encoding")}let a=e.subarray(n,n+s);if(a.length!==s)throw new r("tlv.decode: wrong value length");return{v:a,l:e.subarray(n+s)}}},_int:{encode(t){let{Err:e}=We;if(t<Qe)throw new e("integer: negative integers are not allowed");let r=bt(t);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return r},decode(t){let{Err:e}=We;if(t[0]&128)throw new e("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return nd(t)}},toSig(t){let{Err:e,_int:r,_tlv:n}=We,o=typeof t=="string"?od(t):t;Kt(o);let{v:i,l:s}=n.decode(48,o);if(s.length)throw new e("invalid signature: left bytes after parsing");let{v:a,l:c}=n.decode(2,i),{v:d,l:g}=n.decode(2,c);if(g.length)throw new e("invalid signature: left bytes after parsing");return{r:r.decode(a),s:r.decode(d)}},hexFromSig(t){let{_tlv:e,_int:r}=We,n=e.encode(2,r.encode(t.r)),o=e.encode(2,r.encode(t.s)),i=n+o;return e.encode(48,i)}},Qe=BigInt(0),$=BigInt(1),np=BigInt(2),is=BigInt(3),op=BigInt(4);function id(t){let e=rd(t),{Fp:r}=e,n=Dr(e.n,e.nBitLength),o=e.toBytes||((y,m,f)=>{let x=m.toAffine();return qt(Uint8Array.from([4]),r.toBytes(x.x),r.toBytes(x.y))}),i=e.fromBytes||(y=>{let m=y.subarray(1),f=r.fromBytes(m.subarray(0,r.BYTES)),x=r.fromBytes(m.subarray(r.BYTES,2*r.BYTES));return{x:f,y:x}});function s(y){let{a:m,b:f}=e,x=r.sqr(y),b=r.mul(x,y);return r.add(r.add(b,r.mul(y,m)),f)}if(!r.eql(r.sqr(e.Gy),s(e.Gx)))throw new Error("bad generator point: equation left != right");function a(y){return or(y,$,e.n)}function c(y){let{allowedPrivateKeyLengths:m,nByteLength:f,wrapPrivateKey:x,n:b}=e;if(m&&typeof y!="bigint"){if(it(y)&&(y=Et(y)),typeof y!="string"||!m.includes(y.length))throw new Error("invalid private key");y=y.padStart(f*2,"0")}let L;try{L=typeof y=="bigint"?y:Ze(he("private key",y,f))}catch{throw new Error("invalid private key, expected hex or "+f+" bytes, got "+typeof y)}return x&&(L=W(L,b)),ct("private key",L,$,b),L}function d(y){if(!(y instanceof u))throw new Error("ProjectivePoint expected")}let g=Pr((y,m)=>{let{px:f,py:x,pz:b}=y;if(r.eql(b,r.ONE))return{x:f,y:x};let L=y.is0();m==null&&(m=L?r.ONE:r.inv(b));let T=r.mul(f,m),B=r.mul(x,m),U=r.mul(b,m);if(L)return{x:r.ZERO,y:r.ZERO};if(!r.eql(U,r.ONE))throw new Error("invZ was invalid");return{x:T,y:B}}),l=Pr(y=>{if(y.is0()){if(e.allowInfinityPoint&&!r.is0(y.py))return;throw new Error("bad point: ZERO")}let{x:m,y:f}=y.toAffine();if(!r.isValid(m)||!r.isValid(f))throw new Error("bad point: x or y not FE");let x=r.sqr(f),b=s(m);if(!r.eql(x,b))throw new Error("bad point: equation left != right");if(!y.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class u{constructor(m,f,x){if(this.px=m,this.py=f,this.pz=x,m==null||!r.isValid(m))throw new Error("x required");if(f==null||!r.isValid(f))throw new Error("y required");if(x==null||!r.isValid(x))throw new Error("z required");Object.freeze(this)}static fromAffine(m){let{x:f,y:x}=m||{};if(!m||!r.isValid(f)||!r.isValid(x))throw new Error("invalid affine point");if(m instanceof u)throw new Error("projective point not allowed");let b=L=>r.eql(L,r.ZERO);return b(f)&&b(x)?u.ZERO:new u(f,x,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(m){let f=r.invertBatch(m.map(x=>x.pz));return m.map((x,b)=>x.toAffine(f[b])).map(u.fromAffine)}static fromHex(m){let f=u.fromAffine(i(he("pointHex",m)));return f.assertValidity(),f}static fromPrivateKey(m){return u.BASE.multiply(c(m))}static msm(m,f){return ns(u,n,m,f)}_setWindowSize(m){h.setWindowSize(this,m)}assertValidity(){l(this)}hasEvenY(){let{y:m}=this.toAffine();if(r.isOdd)return!r.isOdd(m);throw new Error("Field doesn't support isOdd")}equals(m){d(m);let{px:f,py:x,pz:b}=this,{px:L,py:T,pz:B}=m,U=r.eql(r.mul(f,B),r.mul(L,b)),N=r.eql(r.mul(x,B),r.mul(T,b));return U&&N}negate(){return new u(this.px,r.neg(this.py),this.pz)}double(){let{a:m,b:f}=e,x=r.mul(f,is),{px:b,py:L,pz:T}=this,B=r.ZERO,U=r.ZERO,N=r.ZERO,C=r.mul(b,b),G=r.mul(L,L),M=r.mul(T,T),_=r.mul(b,L);return _=r.add(_,_),N=r.mul(b,T),N=r.add(N,N),B=r.mul(m,N),U=r.mul(x,M),U=r.add(B,U),B=r.sub(G,U),U=r.add(G,U),U=r.mul(B,U),B=r.mul(_,B),N=r.mul(x,N),M=r.mul(m,M),_=r.sub(C,M),_=r.mul(m,_),_=r.add(_,N),N=r.add(C,C),C=r.add(N,C),C=r.add(C,M),C=r.mul(C,_),U=r.add(U,C),M=r.mul(L,T),M=r.add(M,M),C=r.mul(M,_),B=r.sub(B,C),N=r.mul(M,G),N=r.add(N,N),N=r.add(N,N),new u(B,U,N)}add(m){d(m);let{px:f,py:x,pz:b}=this,{px:L,py:T,pz:B}=m,U=r.ZERO,N=r.ZERO,C=r.ZERO,G=e.a,M=r.mul(e.b,is),_=r.mul(f,L),ce=r.mul(x,T),E=r.mul(b,B),I=r.add(f,x),A=r.add(L,T);I=r.mul(I,A),A=r.add(_,ce),I=r.sub(I,A),A=r.add(f,b);let P=r.add(L,B);return A=r.mul(A,P),P=r.add(_,E),A=r.sub(A,P),P=r.add(x,b),U=r.add(T,B),P=r.mul(P,U),U=r.add(ce,E),P=r.sub(P,U),C=r.mul(G,A),U=r.mul(M,E),C=r.add(U,C),U=r.sub(ce,C),C=r.add(ce,C),N=r.mul(U,C),ce=r.add(_,_),ce=r.add(ce,_),E=r.mul(G,E),A=r.mul(M,A),ce=r.add(ce,E),E=r.sub(_,E),E=r.mul(G,E),A=r.add(A,E),_=r.mul(ce,A),N=r.add(N,_),_=r.mul(P,A),U=r.mul(I,U),U=r.sub(U,_),_=r.mul(I,ce),C=r.mul(P,C),C=r.add(C,_),new u(U,N,C)}subtract(m){return this.add(m.negate())}is0(){return this.equals(u.ZERO)}wNAF(m){return h.wNAFCached(this,m,u.normalizeZ)}multiplyUnsafe(m){let{endo:f,n:x}=e;ct("scalar",m,Qe,x);let b=u.ZERO;if(m===Qe)return b;if(this.is0()||m===$)return this;if(!f||h.hasPrecomputes(this))return h.wNAFCachedUnsafe(this,m,u.normalizeZ);let{k1neg:L,k1:T,k2neg:B,k2:U}=f.splitScalar(m),N=b,C=b,G=this;for(;T>Qe||U>Qe;)T&$&&(N=N.add(G)),U&$&&(C=C.add(G)),G=G.double(),T>>=$,U>>=$;return L&&(N=N.negate()),B&&(C=C.negate()),C=new u(r.mul(C.px,f.beta),C.py,C.pz),N.add(C)}multiply(m){let{endo:f,n:x}=e;ct("scalar",m,$,x);let b,L;if(f){let{k1neg:T,k1:B,k2neg:U,k2:N}=f.splitScalar(m),{p:C,f:G}=this.wNAF(B),{p:M,f:_}=this.wNAF(N);C=h.constTimeNegate(T,C),M=h.constTimeNegate(U,M),M=new u(r.mul(M.px,f.beta),M.py,M.pz),b=C.add(M),L=G.add(_)}else{let{p:T,f:B}=this.wNAF(m);b=T,L=B}return u.normalizeZ([b,L])[0]}multiplyAndAddUnsafe(m,f,x){let b=u.BASE,L=(B,U)=>U===Qe||U===$||!B.equals(b)?B.multiplyUnsafe(U):B.multiply(U),T=L(this,f).add(L(m,x));return T.is0()?void 0:T}toAffine(m){return g(this,m)}isTorsionFree(){let{h:m,isTorsionFree:f}=e;if(m===$)return!0;if(f)return f(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:m,clearCofactor:f}=e;return m===$?this:f?f(u,this):this.multiplyUnsafe(e.h)}toRawBytes(m=!0){return xt("isCompressed",m),this.assertValidity(),o(u,this,m)}toHex(m=!0){return xt("isCompressed",m),Et(this.toRawBytes(m))}}u.BASE=new u(e.Gx,e.Gy,r.ONE),u.ZERO=new u(r.ZERO,r.ONE,r.ZERO);let p=e.nBitLength,h=rs(u,e.endo?Math.ceil(p/2):p);return{CURVE:e,ProjectivePoint:u,normPrivateKeyToScalar:c,weierstrassEquation:s,isWithinCurveOrder:a}}function sd(t){let e=yo(t);return at(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function ss(t){let e=sd(t),{Fp:r,n}=e,o=r.BYTES+1,i=2*r.BYTES+1;function s(E){return W(E,n)}function a(E){return Rr(E,n)}let{ProjectivePoint:c,normPrivateKeyToScalar:d,weierstrassEquation:g,isWithinCurveOrder:l}=id({...e,toBytes(E,I,A){let P=I.toAffine(),R=r.toBytes(P.x),V=qt;return xt("isCompressed",A),A?V(Uint8Array.from([I.hasEvenY()?2:3]),R):V(Uint8Array.from([4]),R,r.toBytes(P.y))},fromBytes(E){let I=E.length,A=E[0],P=E.subarray(1);if(I===o&&(A===2||A===3)){let R=Ze(P);if(!or(R,$,r.ORDER))throw new Error("Point is not on curve");let V=g(R),te;try{te=r.sqrt(V)}catch(fe){let re=fe instanceof Error?": "+fe.message:"";throw new Error("Point is not on curve"+re)}let Q=(te&$)===$;return(A&1)===1!==Q&&(te=r.neg(te)),{x:R,y:te}}else if(I===i&&A===4){let R=r.fromBytes(P.subarray(0,r.BYTES)),V=r.fromBytes(P.subarray(r.BYTES,2*r.BYTES));return{x:R,y:V}}else{let R=o,V=i;throw new Error("invalid Point, expected length of "+R+", or uncompressed "+V+", got "+I)}}}),u=E=>Et(st(E,e.nByteLength));function p(E){let I=n>>$;return E>I}function h(E){return p(E)?s(-E):E}let y=(E,I,A)=>Ze(E.slice(I,A));class m{constructor(I,A,P){this.r=I,this.s=A,this.recovery=P,this.assertValidity()}static fromCompact(I){let A=e.nByteLength;return I=he("compactSignature",I,A*2),new m(y(I,0,A),y(I,A,2*A))}static fromDER(I){let{r:A,s:P}=We.toSig(he("DER",I));return new m(A,P)}assertValidity(){ct("r",this.r,$,n),ct("s",this.s,$,n)}addRecoveryBit(I){return new m(this.r,this.s,I)}recoverPublicKey(I){let{r:A,s:P,recovery:R}=this,V=B(he("msgHash",I));if(R==null||![0,1,2,3].includes(R))throw new Error("recovery id invalid");let te=R===2||R===3?A+e.n:A;if(te>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");let Q=R&1?"03":"02",Oe=c.fromHex(Q+u(te)),fe=a(te),re=s(-V*fe),St=s(P*fe),Je=c.BASE.multiplyAndAddUnsafe(Oe,re,St);if(!Je)throw new Error("point at infinify");return Je.assertValidity(),Je}hasHighS(){return p(this.s)}normalizeS(){return this.hasHighS()?new m(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return It(this.toDERHex())}toDERHex(){return We.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return It(this.toCompactHex())}toCompactHex(){return u(this.r)+u(this.s)}}let f={isValidPrivateKey(E){try{return d(E),!0}catch{return!1}},normPrivateKeyToScalar:d,randomPrivateKey:()=>{let E=lo(e.n);return Qi(e.randomBytes(E),e.n)},precompute(E=8,I=c.BASE){return I._setWindowSize(E),I.multiply(BigInt(3)),I}};function x(E,I=!0){return c.fromPrivateKey(E).toRawBytes(I)}function b(E){let I=it(E),A=typeof E=="string",P=(I||A)&&E.length;return I?P===o||P===i:A?P===2*o||P===2*i:E instanceof c}function L(E,I,A=!0){if(b(E))throw new Error("first arg must be private key");if(!b(I))throw new Error("second arg must be public key");return c.fromHex(I).multiply(d(E)).toRawBytes(A)}let T=e.bits2int||function(E){if(E.length>8192)throw new Error("input is too large");let I=Ze(E),A=E.length*8-e.nBitLength;return A>0?I>>BigInt(A):I},B=e.bits2int_modN||function(E){return s(T(E))},U=ir(e.nBitLength);function N(E){return ct("num < 2^"+e.nBitLength,E,Qe,U),st(E,e.nByteLength)}function C(E,I,A=G){if(["recovered","canonical"].some(dt=>dt in A))throw new Error("sign() legacy options not supported");let{hash:P,randomBytes:R}=e,{lowS:V,prehash:te,extraEntropy:Q}=A;V==null&&(V=!0),E=he("msgHash",E),os(A),te&&(E=he("prehashed msgHash",P(E)));let Oe=B(E),fe=d(I),re=[N(fe),N(Oe)];if(Q!=null&&Q!==!1){let dt=Q===!0?R(r.BYTES):Q;re.push(he("extraEntropy",dt))}let St=qt(...re),Je=Oe;function Gr(dt){let At=T(dt);if(!l(At))return;let Yr=a(At),Ht=c.BASE.multiply(At).toAffine(),ut=s(Ht.x);if(ut===Qe)return;let jt=s(Yr*s(Je+ut*fe));if(jt===Qe)return;let Bt=(Ht.x===ut?0:2)|Number(Ht.y&$),Ro=jt;return V&&p(jt)&&(Ro=h(jt),Bt^=1),new m(ut,Ro,Bt)}return{seed:St,k2sig:Gr}}let G={lowS:e.lowS,prehash:!1},M={lowS:e.lowS,prehash:!1};function _(E,I,A=G){let{seed:P,k2sig:R}=C(E,I,A),V=e;return io(V.hash.outputLen,V.nByteLength,V.hmac)(P,R)}c.BASE._setWindowSize(8);function ce(E,I,A,P=M){let R=E;I=he("msgHash",I),A=he("publicKey",A);let{lowS:V,prehash:te,format:Q}=P;if(os(P),"strict"in P)throw new Error("options.strict was renamed to lowS");if(Q!==void 0&&Q!=="compact"&&Q!=="der")throw new Error("format must be compact or der");let Oe=typeof R=="string"||it(R),fe=!Oe&&!Q&&typeof R=="object"&&R!==null&&typeof R.r=="bigint"&&typeof R.s=="bigint";if(!Oe&&!fe)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let re,St;try{if(fe&&(re=new m(R.r,R.s)),Oe){try{Q!=="compact"&&(re=m.fromDER(R))}catch(Bt){if(!(Bt instanceof We.Err))throw Bt}!re&&Q!=="der"&&(re=m.fromCompact(R))}St=c.fromHex(A)}catch{return!1}if(!re||V&&re.hasHighS())return!1;te&&(I=e.hash(I));let{r:Je,s:Gr}=re,dt=B(I),At=a(Gr),Yr=s(dt*At),Ht=s(Je*At),ut=c.BASE.multiplyAndAddUnsafe(St,Yr,Ht)?.toAffine();return ut?s(ut.x)===Je:!1}return{CURVE:e,getPublicKey:x,getSharedSecret:L,sign:_,verify:ce,ProjectivePoint:c,Signature:m,utils:f}}function cd(t){return{hash:t,hmac:(e,...r)=>eo(t,e,qi(...r)),randomBytes:Vi}}function cs(t,e){let r=n=>ss({...t,...cd(n)});return{...r(e),create:r}}var us=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),as=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),ad=BigInt(1),wo=BigInt(2),ds=(t,e)=>(t+e/wo)/e;function dd(t){let e=us,r=BigInt(3),n=BigInt(6),o=BigInt(11),i=BigInt(22),s=BigInt(23),a=BigInt(44),c=BigInt(88),d=t*t*t%e,g=d*d*t%e,l=pe(g,r,e)*g%e,u=pe(l,r,e)*g%e,p=pe(u,wo,e)*d%e,h=pe(p,o,e)*p%e,y=pe(h,i,e)*h%e,m=pe(y,a,e)*y%e,f=pe(m,c,e)*m%e,x=pe(f,a,e)*y%e,b=pe(x,r,e)*g%e,L=pe(b,s,e)*h%e,T=pe(L,n,e)*d%e,B=pe(T,wo,e);if(!xo.eql(xo.sqr(B),t))throw new Error("Cannot find square root");return B}var xo=Dr(us,void 0,void 0,{sqrt:dd}),zt=cs({a:BigInt(0),b:BigInt(7),Fp:xo,n:as,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{let e=as,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-ad*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=r,s=BigInt("0x100000000000000000000000000000000"),a=ds(i*t,e),c=ds(-n*t,e),d=W(t-a*r-c*o,e),g=W(-a*n-c*i,e),l=d>s,u=g>s;if(l&&(d=e-d),u&&(g=e-g),d>s||g>s)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:l,k1:d,k2neg:u,k2:g}}}},$i),pp=BigInt(0);var mp=zt.ProjectivePoint;var ls=Ut(ne("node:crypto"),1);var _r=class extends Error{constructor(e="An error occurred while verifying a message"){super(e),this.name="VerificationError"}};function hs(t,e,r){let n=ls.default.createHash("sha256");if(r instanceof Uint8Array)n.update(r);else for(let i of r)n.update(i);let o=n.digest();try{return zt.verify(e,o,t)}catch(i){throw new _r(String(i))}}var Mr=class{type="secp256k1";raw;_key;constructor(e){this._key=ms(e),this.raw=ps(this._key)}toMultihash(){return He.digest(xr(this))}toCID(){return ee.createV1(114,this.toMultihash())}toString(){return K.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:je(this.raw,e.raw)}verify(e,r){return hs(this._key,r,e)}};function gs(t){return new Mr(t)}function ps(t){return zt.ProjectivePoint.fromHex(t).toRawBytes(!0)}function ms(t){try{return zt.ProjectivePoint.fromHex(t),t}catch(e){throw new ur(String(e))}}function ys(t){let{Type:e,Data:r}=rr.decode(t.digest),n=r??new Uint8Array;switch(e){case ge.Ed25519:return Li(n);case ge.secp256k1:return gs(n);default:throw new $t}}function xr(t){return rr.encode({Type:ge[t.type],Data:t.raw})}var fs=Symbol.for("nodejs.util.inspect.custom"),ud=114,sr=class{type;multihash;publicKey;string;constructor(e){this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}[Xr]=!0;toString(){return this.string==null&&(this.string=K.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return ee.createV1(ud,this.multihash)}toJSON(){return this.toString()}equals(e){if(e==null)return!1;if(e instanceof Uint8Array)return je(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(e?.toMultihash()?.bytes!=null)return je(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[fs](){return`PeerId(${this.toString()})`}},Fr=class extends sr{type="RSA";publicKey;constructor(e){super({...e,type:"RSA"}),this.publicKey=e.publicKey}},Kr=class extends sr{type="Ed25519";publicKey;constructor(e){super({...e,type:"Ed25519"}),this.publicKey=e.publicKey}},qr=class extends sr{type="secp256k1";publicKey;constructor(e){super({...e,type:"secp256k1"}),this.publicKey=e.publicKey}},ld=2336,zr=class{type="url";multihash;publicKey;url;constructor(e){this.url=e.toString(),this.multihash=He.digest(Ge(this.url))}[fs](){return`PeerId(${this.url})`}[Xr]=!0;toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return ee.createV1(ld,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=z(e)),e.toString()===this.toString())}};function ws(t,e){let r;if(t.charAt(0)==="1"||t.charAt(0)==="Q")r=pt(K.decode(`z${t}`));else{if(e==null)throw new Lt('Please pass a multibase decoder for strings that do not start with "1" or "Q"');r=pt(e.decode(t))}return hd(r)}function hd(t){if(md(t))return new Fr({multihash:t});if(pd(t))try{let e=ys(t);if(e.type==="Ed25519")return new Kr({multihash:t,publicKey:e});if(e.type==="secp256k1")return new qr({multihash:t,publicKey:e})}catch{let r=z(t.digest);return new zr(new URL(r))}throw new lr("Supplied PeerID Multihash is invalid")}function pd(t){return t.code===He.code}function md(t){return t.code===Tn.code}var ye=ne("node:net");function Vr(t){return!!(0,ye.isIP)(t)}var Es=Ut(xs(),1),gd=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"],yd=gd.map(t=>new Es.Netmask(t));function Eo(t){for(let e of yd)if(e.contains(t))return!0;return!1}function fd(t){return/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(t)}function wd(t){let e=t.split(":");if(e.length<2)return!1;let r=e[e.length-1].padStart(4,"0"),n=e[e.length-2].padStart(4,"0"),o=`${parseInt(n.substring(0,2),16)}.${parseInt(n.substring(2),16)}.${parseInt(r.substring(0,2),16)}.${parseInt(r.substring(2),16)}`;return Eo(o)}function xd(t){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(t)}function Ed(t){let e=t.split(":"),r=e[e.length-1];return Eo(r)}function bd(t){return/^::$/.test(t)||/^::1$/.test(t)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(t)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(t)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(t)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(t)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(t)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(t)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(t)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(t)||/^ff([0-9a-fA-F]{2,2}):/i.test(t)}function bs(t){return(0,ye.isIPv4)(t)?Eo(t):fd(t)?wd(t):xd(t)?Ed(t):(0,ye.isIPv6)(t)?bd(t):void 0}var Id=4,vd=41,Sd=53,Ad=54,Bd=55,Ud=56;function Is(t){try{let[[e,r]]=t.stringTuples();if(r==null)return!0;if(e===Sd||e===Ad||e===Bd||e===Ud)return!1;if(e===Id||e===vd)return bs(r)??!1}catch{}return!0}var Hr=class{index=0;input="";new(e){return this.index=0,this.input=e,this}readAtomically(e){let r=this.index,n=e();return n===void 0&&(this.index=r),n}parseWith(e){let r=e();if(this.index===this.input.length)return r}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(e){return this.readAtomically(()=>{let r=this.readChar();if(r===e)return r})}readSeparator(e,r,n){return this.readAtomically(()=>{if(!(r>0&&this.readGivenChar(e)===void 0))return n()})}readNumber(e,r,n,o){return this.readAtomically(()=>{let i=0,s=0,a=this.peekChar();if(a===void 0)return;let c=a==="0",d=2**(8*o)-1;for(;;){let g=this.readAtomically(()=>{let l=this.readChar();if(l===void 0)return;let u=Number.parseInt(l,e);if(!Number.isNaN(u))return u});if(g===void 0)break;if(i*=e,i+=g,i>d||(s+=1,r!==void 0&&s>r))return}if(s!==0)return!n&&c&&s>1?void 0:i})}readIPv4Addr(){return this.readAtomically(()=>{let e=new Uint8Array(4);for(let r=0;r<e.length;r++){let n=this.readSeparator(".",r,()=>this.readNumber(10,3,!1,1));if(n===void 0)return;e[r]=n}return e})}readIPv6Addr(){let e=r=>{for(let n=0;n<r.length/2;n++){let o=n*2;if(n<r.length-3){let s=this.readSeparator(":",n,()=>this.readIPv4Addr());if(s!==void 0)return r[o]=s[0],r[o+1]=s[1],r[o+2]=s[2],r[o+3]=s[3],[o+4,!0]}let i=this.readSeparator(":",n,()=>this.readNumber(16,4,!0,2));if(i===void 0)return[o,!1];r[o]=i>>8,r[o+1]=i&255}return[r.length,!1]};return this.readAtomically(()=>{let r=new Uint8Array(16),[n,o]=e(r);if(n===16)return r;if(o||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;let i=new Uint8Array(14),s=16-(n+2),[a]=e(i.subarray(0,s));return r.set(i.subarray(0,a),16-a),r})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}};var x0=new Hr;var U0=parseInt("0xFFFF",16),L0=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);var As=ye.isIPv4,Pd=ye.isIPv6,bo=function(t){let e=0;if(t=t.toString().trim(),As(t)){let r=new Uint8Array(e+4);return t.split(/\./g).forEach(n=>{r[e++]=parseInt(n,10)&255}),r}if(Pd(t)){let r=t.split(":",8),n;for(n=0;n<r.length;n++){let i=As(r[n]),s;i&&(s=bo(r[n]),r[n]=z(s.slice(0,2),"base16")),s!=null&&++n<8&&r.splice(n,0,z(s.slice(2,4),"base16"))}if(r[0]==="")for(;r.length<8;)r.unshift("0");else if(r[r.length-1]==="")for(;r.length<8;)r.push("0");else if(r.length<8){for(n=0;n<r.length&&r[n]!=="";n++);let i=[n,1];for(n=9-r.length;n>0;n--)i.push("0");r.splice.apply(r,i)}let o=new Uint8Array(e+16);for(n=0;n<r.length;n++){let i=parseInt(r[n],16);o[e++]=i>>8&255,o[e++]=i&255}return o}throw new Error("invalid ip address")},Bs=function(t,e=0,r){e=~~e,r=r??t.length-e;let n=new DataView(t.buffer);if(r===4){let o=[];for(let i=0;i<r;i++)o.push(t[e+i]);return o.join(".")}if(r===16){let o=[];for(let i=0;i<r;i+=2)o.push(n.getUint16(e+i).toString(16));return o.join(":").replace(/(^|:)0(:0)*:0(:|$)/,"$1::$3").replace(/:{3,4}/,"::")}return""};var Vt={},Io={},Dd=[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,-1,"ip6zone"],[43,8,"ipcidr"],[53,-1,"dns",!0],[54,-1,"dns4",!0],[55,-1,"dns6",!0],[56,-1,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc-direct"],[281,0,"webrtc"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,-1,"unix",!1,!0],[421,-1,"ipfs"],[421,-1,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,-1,"garlic64"],[448,0,"tls"],[449,-1,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,-1,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[481,-1,"http-path"],[777,-1,"memory"]];Dd.forEach(t=>{let e=kd(...t);Io[e.code]=e,Vt[e.name]=e});function kd(t,e,r,n,o){return{code:t,size:e,name:r,resolvable:!!n,path:!!o}}function k(t){if(typeof t=="number"){if(Io[t]!=null)return Io[t];throw new Error(`no protocol with code: ${t}`)}else if(typeof t=="string"){if(Vt[t]!=null)return Vt[t];throw new Error(`no protocol with name: ${t}`)}throw new Error(`invalid protocol id type: ${typeof t}`)}var lm=k("ip4"),hm=k("ip6"),pm=k("ipcidr");function Bo(t,e){switch(k(t).code){case 4:case 41:return Md(e);case 42:return Ao(e);case 43:return z(e,"base10");case 6:case 273:case 33:case 132:return Ts(e).toString();case 53:case 54:case 55:case 56:case 400:case 449:case 777:return Ao(e);case 421:return zd(e);case 444:return Ls(e);case 445:return Ls(e);case 466:return qd(e);case 481:return globalThis.encodeURIComponent(Ao(e));default:return z(e,"base16")}}function Uo(t,e){switch(k(t).code){case 4:return Us(e);case 41:return Us(e);case 42:return So(e);case 43:return Ge(e,"base10");case 6:case 273:case 33:case 132:return Lo(parseInt(e,10));case 53:case 54:case 55:case 56:case 400:case 449:case 777:return So(e);case 421:return Fd(e);case 444:return Vd(e);case 445:return Hd(e);case 466:return Kd(e);case 481:return So(globalThis.decodeURIComponent(e));default:return Ge(e,"base16")}}var vo=Object.values(Qt).map(t=>t.decoder),_d=function(){let t=vo[0].or(vo[1]);return vo.slice(2).forEach(e=>t=t.or(e)),t}();function Us(t){if(!Vr(t))throw new Error("invalid ip address");return bo(t)}function Md(t){let e=Bs(t,0,t.length);if(e==null)throw new Error("ipBuff is required");if(!Vr(e))throw new Error("invalid ip address");return e}function Lo(t){let e=new ArrayBuffer(2);return new DataView(e).setUint16(0,t),new Uint8Array(e)}function Ts(t){return new DataView(t.buffer).getUint16(t.byteOffset)}function So(t){let e=Ge(t),r=Uint8Array.from(Dt(e.length));return Ce([r,e],r.length+e.length)}function Ao(t){let e=gt(t);if(t=t.slice(se(e)),t.length!==e)throw new Error("inconsistent lengths");return z(t)}function Fd(t){let e;t[0]==="Q"||t[0]==="1"?e=pt(K.decode(`z${t}`)).bytes:e=ee.parse(t).multihash.bytes;let r=Uint8Array.from(Dt(e.length));return Ce([r,e],r.length+e.length)}function Kd(t){let e=_d.decode(t),r=Uint8Array.from(Dt(e.length));return Ce([r,e],r.length+e.length)}function qd(t){let e=gt(t),r=t.slice(se(e));if(r.length!==e)throw new Error("inconsistent lengths");return"u"+z(r,"base64url")}function zd(t){let e=gt(t),r=t.slice(se(e));if(r.length!==e)throw new Error("inconsistent lengths");return z(r,"base58btc")}function Vd(t){let e=t.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);let r=Ve.decode("b"+e[0]),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");let o=Lo(n);return Ce([r,o],r.length+o.length)}function Hd(t){let e=t.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);let r=Ve.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");let o=Lo(n);return Ce([r,o],r.length+o.length)}function Ls(t){let e=t.slice(0,t.length-2),r=t.slice(t.length-2),n=z(e,"base32"),o=Ts(r);return`${n}:${o}`}function Ns(t){t=To(t);let e=[],r=[],n=null,o=t.split("/").slice(1);if(o.length===1&&o[0]==="")return{bytes:new Uint8Array,string:"/",tuples:[],stringTuples:[],path:null};for(let i=0;i<o.length;i++){let s=o[i],a=k(s);if(a.size===0){e.push([a.code]),r.push([a.code]);continue}if(i++,i>=o.length)throw Os("invalid address: "+t);if(a.path===!0){n=To(o.slice(i).join("/")),e.push([a.code,Uo(a.code,n)]),r.push([a.code,n]);break}let c=Uo(a.code,o[i]);e.push([a.code,c]),r.push([a.code,Bo(a.code,c)])}return{string:Cs(r),bytes:Co(e),tuples:e,stringTuples:r,path:n}}function No(t){let e=[],r=[],n=null,o=0;for(;o<t.length;){let i=gt(t,o),s=se(i),a=k(i),c=jd(a,t.slice(o+s));if(c===0){e.push([i]),r.push([i]),o+=s;continue}let d=t.slice(o+s,o+s+c);if(o+=c+s,o>t.length)throw Os("Invalid address Uint8Array: "+z(t,"base16"));e.push([i,d]);let g=Bo(i,d);if(r.push([i,g]),a.path===!0){n=g;break}}return{bytes:Uint8Array.from(t),string:Cs(r),tuples:e,stringTuples:r,path:n}}function Cs(t){let e=[];return t.map(r=>{let n=k(r[0]);return e.push(n.name),r.length>1&&r[1]!=null&&e.push(r[1]),null}),To(e.join("/"))}function Co(t){return Ce(t.map(e=>{let r=k(e[0]),n=Uint8Array.from(Dt(r.code));return e.length>1&&e[1]!=null&&(n=Ce([n,e[1]])),n}))}function jd(t,e){if(t.size>0)return t.size/8;if(t.size===0)return 0;{let r=gt(e instanceof Uint8Array?e:Uint8Array.from(e));return r+se(r)}}function To(t){return"/"+t.trim().split("/").filter(e=>e).join("/")}function Os(t){return new Error("Error parsing address: "+t)}var $d=Symbol.for("nodejs.util.inspect.custom"),Po=Symbol.for("@multiformats/js-multiaddr/multiaddr"),Gd=[k("dns").code,k("dns4").code,k("dns6").code,k("dnsaddr").code],Oo=class extends Error{constructor(e="No available resolver"){super(e),this.name="NoAvailableResolverError"}},jr=class t{bytes;#e;#t;#r;#n;[Po]=!0;constructor(e){e==null&&(e="");let r;if(e instanceof Uint8Array)r=No(e);else if(typeof e=="string"){if(e.length>0&&e.charAt(0)!=="/")throw new Error(`multiaddr "${e}" must start with a "/"`);r=Ns(e)}else if(Rs(e))r=No(e.bytes);else throw new Error("addr must be a string, Buffer, or another Multiaddr");this.bytes=r.bytes,this.#e=r.string,this.#t=r.tuples,this.#r=r.stringTuples,this.#n=r.path}toString(){return this.#e}toJSON(){return this.toString()}toOptions(){let e,r,n,o,i="",s=k("tcp"),a=k("udp"),c=k("ip4"),d=k("ip6"),g=k("dns6"),l=k("ip6zone");for(let[p,h]of this.stringTuples())p===l.code&&(i=`%${h??""}`),Gd.includes(p)&&(r=s.name,o=443,n=`${h??""}${i}`,e=p===g.code?6:4),(p===s.code||p===a.code)&&(r=k(p).name,o=parseInt(h??"")),(p===c.code||p===d.code)&&(r=k(p).name,n=`${h??""}${i}`,e=p===d.code?6:4);if(e==null||r==null||n==null||o==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:e,host:n,transport:r,port:o}}protos(){return this.#t.map(([e])=>Object.assign({},k(e)))}protoCodes(){return this.#t.map(([e])=>e)}protoNames(){return this.#t.map(([e])=>k(e).name)}tuples(){return this.#t.map(([e,r])=>r==null?[e]:[e,r])}stringTuples(){return this.#r.map(([e,r])=>r==null?[e]:[e,r])}encapsulate(e){return e=new t(e),new t(this.toString()+e.toString())}decapsulate(e){let r=e.toString(),n=this.toString(),o=n.lastIndexOf(r);if(o<0)throw new Error(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);return new t(n.slice(0,o))}decapsulateCode(e){let r=this.tuples();for(let n=r.length-1;n>=0;n--)if(r[n][0]===e)return new t(Co(r.slice(0,n)));return this}getPeerId(){try{let e=[];this.stringTuples().forEach(([n,o])=>{n===Vt.p2p.code&&e.push([n,o]),n===Vt["p2p-circuit"].code&&(e=[])});let r=e.pop();if(r?.[1]!=null){let n=r[1];return n[0]==="Q"||n[0]==="1"?z(K.decode(`z${n}`),"base58btc"):z(ee.parse(n).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){return this.#n}equals(e){return je(this.bytes,e.bytes)}async resolve(e){let r=this.protos().find(i=>i.resolvable);if(r==null)return[this];let n=Ps.get(r.name);if(n==null)throw new Oo(`no available resolver for ${r.name}`);return(await n(this,e)).map(i=>ar(i))}nodeAddress(){let e=this.toOptions();if(e.transport!=="tcp"&&e.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:e.family,address:e.host,port:e.port}}isThinWaistAddress(e){let r=(e??this).protos();return!(r.length!==2||r[0].code!==4&&r[0].code!==41||r[1].code!==6&&r[1].code!==273)}[$d](){return`Multiaddr(${this.#e})`}};var Ps=new Map;function Rs(t){return!!t?.[Po]}function ar(t){return new jr(t)}function Ds(t,e,r,n){let o=()=>{n?.log.trace("query",e),t.query({questions:[{name:e,type:"PTR"}]})};return o(),setInterval(o,r)}function ks(t,e,r,n){if(t.answers==null)return;let o,i=[];if(t.answers.forEach(s=>{switch(s.type){case"PTR":o=s;break;case"TXT":i.push(s);break;default:break}}),t.additionals.forEach(s=>{switch(s.type){case"TXT":i.push(s);break;default:break}}),!(o==null||o?.name!==r||i.length===0||o.data.startsWith(e)))try{let s=i.flatMap(c=>c.data).filter(c=>c.toString().startsWith("dnsaddr=")).map(c=>ar(c.toString().substring(8))),a=s[0].getPeerId();if(a==null)throw new Error("Multiaddr doesn't contain PeerId");return n?.log("peer found %p",a),{id:ws(a),multiaddrs:s.map(c=>c.decapsulateCode(k("p2p").code))}}catch(s){n?.log.error("failed to parse mdns response",s)}}function _s(t,e,r,n,o,i,s){if(!i){s?.log("not responding to mDNS query as broadcast mode is false");return}if(n.length!==0&&t.questions[0]!=null&&t.questions[0].name===o){let a=[];a.push({name:o,type:"PTR",class:"IN",ttl:120,data:r+"."+o}),n.filter(Yd).forEach(c=>{let d="dnsaddr="+c.toString();if(d.length>255){s?.log("multiaddr %a is too long to use in mDNS query response",c);return}if(c.getPeerId()==null){s?.log("multiaddr %a did not have a peer ID so cannot be used in mDNS query response",c);return}a.push({name:r+"."+o,type:"TXT",class:"IN",ttl:120,data:d})}),s?.log.trace("responding to query"),e.respond(a)}}function Yd(t){return!!Is(t)}function Ms(t){let e="",r="abcdefghijklmnopqrstuvwxyz0123456789";for(let n=0;n<t;n++)e+=r.charAt(Math.floor(Math.random()*r.length));return e}var $r=class extends hr{mdns;log;broadcast;interval;serviceTag;peerName;port;ip;_queryInterval;components;constructor(e,r={}){if(super(),this.log=e.logger.forComponent("libp2p:mdns"),this.broadcast=r.broadcast!==!1,this.interval=r.interval??1e3*10,this.serviceTag=r.serviceTag??"_p2p._udp.local",this.ip=r.ip??"224.0.0.251",this.peerName=r.peerName??Ms(63),this.peerName.length>=64)throw new Error("Peer name should be less than 64 chars long");this.port=r.port??5353,this.components=e,this._queryInterval=null,this._onMdnsQuery=this._onMdnsQuery.bind(this),this._onMdnsResponse=this._onMdnsResponse.bind(this),this._onMdnsWarning=this._onMdnsWarning.bind(this),this._onMdnsError=this._onMdnsError.bind(this)}[ko]=this;[Symbol.toStringTag]="@libp2p/mdns";[Fo]=["@libp2p/peer-discovery"];isStarted(){return!!this.mdns}async start(){this.mdns==null&&(this.mdns=(0,Fs.default)({port:this.port,ip:this.ip}),this.mdns.on("query",this._onMdnsQuery),this.mdns.on("response",this._onMdnsResponse),this.mdns.on("warning",this._onMdnsWarning),this.mdns.on("error",this._onMdnsError),this._queryInterval=Ds(this.mdns,this.serviceTag,this.interval,{log:this.log}))}_onMdnsQuery(e){this.mdns!=null&&(this.log.trace("received incoming mDNS query"),_s(e,this.mdns,this.peerName,this.components.addressManager.getAddresses(),this.serviceTag,this.broadcast,{log:this.log}))}_onMdnsResponse(e){this.log.trace("received mDNS query response");try{let r=ks(e,this.peerName,this.serviceTag,{log:this.log});r!=null&&(this.log("discovered peer in mDNS query response %p",r.id),this.dispatchEvent(new CustomEvent("peer",{detail:r})))}catch(r){this.log.error("Error processing peer response",r)}}_onMdnsWarning(e){this.log.error("mdns warning",e)}_onMdnsError(e){this.log.error("mdns error",e)}async stop(){this.mdns!=null&&(this.mdns.removeListener("query",this._onMdnsQuery),this.mdns.removeListener("response",this._onMdnsResponse),this.mdns.removeListener("warning",this._onMdnsWarning),this.mdns.removeListener("error",this._onMdnsError),this._queryInterval!=null&&(clearInterval(this._queryInterval),this._queryInterval=null),await new Promise(e=>{this.mdns!=null?this.mdns.destroy(e):e()}),this.mdns=void 0)}};function Zd(t={}){return e=>new $r(e,t)}return js(Wd);})();
./node_modules/@libp2p/keychain/dist/index.min.js:2:"use strict";var Libp2PKeychain=(()=>{var Yc=Object.create;var Gr=Object.defineProperty;var Xc=Object.getOwnPropertyDescriptor;var Qc=Object.getOwnPropertyNames;var tl=Object.getPrototypeOf,el=Object.prototype.hasOwnProperty;var Ee=(r,t)=>()=>(t||r((t={exports:{}}).exports,t),t.exports),ft=(r,t)=>{for(var e in t)Gr(r,e,{get:t[e],enumerable:!0})},Yo=(r,t,e,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of Qc(t))!el.call(r,s)&&s!==e&&Gr(r,s,{get:()=>t[s],enumerable:!(n=Xc(t,s))||n.enumerable});return r};var xs=(r,t,e)=>(e=r!=null?Yc(tl(r)):{},Yo(t||!r||!r.__esModule?Gr(e,"default",{value:r,enumerable:!0}):e,r)),rl=r=>Yo(Gr({},"__esModule",{value:!0}),r);var na=Ee(er=>{"use strict";var Sf="[object ArrayBuffer]",Zt=class r{static isArrayBuffer(t){return Object.prototype.toString.call(t)===Sf}static toArrayBuffer(t){return this.isArrayBuffer(t)?t:t.byteLength===t.buffer.byteLength||t.byteOffset===0&&t.byteLength===t.buffer.byteLength?t.buffer:this.toUint8Array(t.buffer).slice(t.byteOffset,t.byteOffset+t.byteLength).buffer}static toUint8Array(t){return this.toView(t,Uint8Array)}static toView(t,e){if(t.constructor===e)return t;if(this.isArrayBuffer(t))return new e(t);if(this.isArrayBufferView(t))return new e(t.buffer,t.byteOffset,t.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(t){return this.isArrayBufferView(t)||this.isArrayBuffer(t)}static isArrayBufferView(t){return ArrayBuffer.isView(t)||t&&this.isArrayBuffer(t.buffer)}static isEqual(t,e){let n=r.toUint8Array(t),s=r.toUint8Array(e);if(n.length!==s.byteLength)return!1;for(let o=0;o<n.length;o++)if(n[o]!==s[o])return!1;return!0}static concat(...t){let e;Array.isArray(t[0])&&!(t[1]instanceof Function)||Array.isArray(t[0])&&t[1]instanceof Function?e=t[0]:t[t.length-1]instanceof Function?e=t.slice(0,t.length-1):e=t;let n=0;for(let i of e)n+=i.byteLength;let s=new Uint8Array(n),o=0;for(let i of e){let a=this.toUint8Array(i);s.set(a,o),o+=a.length}return t[t.length-1]instanceof Function?this.toView(s,t[t.length-1]):s.buffer}},Eo="string",If=/^[0-9a-f\s]+$/i,Nf=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,Cf=/^[a-zA-Z0-9-_]+$/,xn=class{static fromString(t){let e=unescape(encodeURIComponent(t)),n=new Uint8Array(e.length);for(let s=0;s<e.length;s++)n[s]=e.charCodeAt(s);return n.buffer}static toString(t){let e=Zt.toUint8Array(t),n="";for(let o=0;o<e.length;o++)n+=String.fromCharCode(e[o]);return decodeURIComponent(escape(n))}},At=class{static toString(t,e=!1){let n=Zt.toArrayBuffer(t),s=new DataView(n),o="";for(let i=0;i<n.byteLength;i+=2){let a=s.getUint16(i,e);o+=String.fromCharCode(a)}return o}static fromString(t,e=!1){let n=new ArrayBuffer(t.length*2),s=new DataView(n);for(let o=0;o<t.length;o++)s.setUint16(o*2,t.charCodeAt(o),e);return n}},vn=class r{static isHex(t){return typeof t===Eo&&If.test(t)}static isBase64(t){return typeof t===Eo&&Nf.test(t)}static isBase64Url(t){return typeof t===Eo&&Cf.test(t)}static ToString(t,e="utf8"){let n=Zt.toUint8Array(t);switch(e.toLowerCase()){case"utf8":return this.ToUtf8String(n);case"binary":return this.ToBinary(n);case"hex":return this.ToHex(n);case"base64":return this.ToBase64(n);case"base64url":return this.ToBase64Url(n);case"utf16le":return At.toString(n,!0);case"utf16":case"utf16be":return At.toString(n);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromString(t,e="utf8"){if(!t)return new ArrayBuffer(0);switch(e.toLowerCase()){case"utf8":return this.FromUtf8String(t);case"binary":return this.FromBinary(t);case"hex":return this.FromHex(t);case"base64":return this.FromBase64(t);case"base64url":return this.FromBase64Url(t);case"utf16le":return At.fromString(t,!0);case"utf16":case"utf16be":return At.fromString(t);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToBase64(t){let e=Zt.toUint8Array(t);if(typeof btoa<"u"){let n=this.ToString(e,"binary");return btoa(n)}else return Buffer.from(e).toString("base64")}static FromBase64(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isBase64(e))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return typeof atob<"u"?this.FromBinary(atob(e)):new Uint8Array(Buffer.from(e,"base64")).buffer}static FromBase64Url(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isBase64Url(e))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(e.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(t){return this.ToBase64(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(t,e=r.DEFAULT_UTF8_ENCODING){switch(e){case"ascii":return this.FromBinary(t);case"utf8":return xn.fromString(t);case"utf16":case"utf16be":return At.fromString(t);case"utf16le":case"usc2":return At.fromString(t,!0);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToUtf8String(t,e=r.DEFAULT_UTF8_ENCODING){switch(e){case"ascii":return this.ToBinary(t);case"utf8":return xn.toString(t);case"utf16":case"utf16be":return At.toString(t);case"utf16le":case"usc2":return At.toString(t,!0);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromBinary(t){let e=t.length,n=new Uint8Array(e);for(let s=0;s<e;s++)n[s]=t.charCodeAt(s);return n.buffer}static ToBinary(t){let e=Zt.toUint8Array(t),n="";for(let s=0;s<e.length;s++)n+=String.fromCharCode(e[s]);return n}static ToHex(t){let e=Zt.toUint8Array(t),n="",s=e.length;for(let o=0;o<s;o++){let i=e[o];i<16&&(n+="0"),n+=i.toString(16)}return n}static FromHex(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isHex(e))throw new TypeError("Argument 'hexString' is not HEX encoded");e.length%2&&(e=`0${e}`);let n=new Uint8Array(e.length/2);for(let s=0;s<e.length;s=s+2){let o=e.slice(s,s+2);n[s/2]=parseInt(o,16)}return n.buffer}static ToUtf16String(t,e=!1){return At.toString(t,e)}static FromUtf16String(t,e=!1){return At.fromString(t,e)}static Base64Padding(t){let e=4-t.length%4;if(e<4)for(let n=0;n<e;n++)t+="=";return t}static formatString(t){return t?.replace(/[\n\r\t ]/g,"")||""}};vn.DEFAULT_UTF8_ENCODING="utf8";function Tf(r,...t){let e=arguments[0];for(let n=1;n<arguments.length;n++){let s=arguments[n];for(let o in s)e[o]=s[o]}return e}function Uf(...r){let t=r.map(s=>s.byteLength).reduce((s,o)=>s+o),e=new Uint8Array(t),n=0;return r.map(s=>new Uint8Array(s)).forEach(s=>{for(let o of s)e[n++]=o}),e.buffer}function Rf(r,t){if(!(r&&t)||r.byteLength!==t.byteLength)return!1;let e=new Uint8Array(r),n=new Uint8Array(t);for(let s=0;s<r.byteLength;s++)if(e[s]!==n[s])return!1;return!0}er.BufferSourceConverter=Zt;er.Convert=vn;er.assign=Tf;er.combine=Uf;er.isEqual=Rf});var vc=Ee((dm,xc)=>{"use strict";xc.exports=r=>{if(Object.prototype.toString.call(r)!=="[object Object]")return!1;let t=Object.getPrototypeOf(r);return t===null||t===Object.prototype}});var Ic=Ee((kc,Sc)=>{"use strict";var gs=vc(),{hasOwnProperty:Ec}=Object.prototype,{propertyIsEnumerable:Yf}=Object,ir=(r,t,e)=>Object.defineProperty(r,t,{value:e,writable:!0,enumerable:!0,configurable:!0}),Xf=kc,Bc={concatArrays:!1,ignoreUndefined:!1},ms=r=>{let t=[];for(let e in r)Ec.call(r,e)&&t.push(e);if(Object.getOwnPropertySymbols){let e=Object.getOwnPropertySymbols(r);for(let n of e)Yf.call(r,n)&&t.push(n)}return t};function ar(r){return Array.isArray(r)?Qf(r):gs(r)?th(r):r}function Qf(r){let t=r.slice(0,0);return ms(r).forEach(e=>{ir(t,e,ar(r[e]))}),t}function th(r){let t=Object.getPrototypeOf(r)===null?Object.create(null):{};return ms(r).forEach(e=>{ir(t,e,ar(r[e]))}),t}var Ac=(r,t,e,n)=>(e.forEach(s=>{typeof t[s]>"u"&&n.ignoreUndefined||(s in r&&r[s]!==Object.getPrototypeOf(r)?ir(r,s,Do(r[s],t[s],n)):ir(r,s,ar(t[s])))}),r),eh=(r,t,e)=>{let n=r.slice(0,0),s=0;return[r,t].forEach(o=>{let i=[];for(let a=0;a<o.length;a++)Ec.call(o,a)&&(i.push(String(a)),o===r?ir(n,s++,o[a]):ir(n,s++,ar(o[a])));n=Ac(n,o,ms(o).filter(a=>!i.includes(a)),e)}),n};function Do(r,t,e){return e.concatArrays&&Array.isArray(r)&&Array.isArray(t)?eh(r,t,e):!gs(t)||!gs(r)?ar(t):Ac(r,t,ms(t),e)}Sc.exports=function(...r){let t=Do(ar(Bc),this!==Xf&&this||{},Bc),e={_:{}};for(let n of r)if(n!==void 0){if(!gs(n))throw new TypeError("`"+n+"` is not an Option Object");e=Do(e,{_:n},t)}return e._}});var Uc=Ee((gm,Tc)=>{"use strict";function rh(r){return r>=55296&&r<=56319}function nh(r){return r>=56320&&r<=57343}Tc.exports=function(t,e,n){if(typeof e!="string")throw new Error("Input must be string");for(var s=e.length,o=0,i,a,c=0;c<s;c+=1){if(i=e.charCodeAt(c),a=e[c],rh(i)&&nh(e.charCodeAt(c+1))&&(c+=1,a+=e[c]),o+=t(a),o===n)return e.slice(0,c+1);if(o>n)return e.slice(0,c-a.length+1)}return e}});var Lc=Ee((mm,Rc)=>{"use strict";function sh(r){return r>=55296&&r<=56319}function oh(r){return r>=56320&&r<=57343}Rc.exports=function(t){if(typeof t!="string")throw new Error("Input must be string");for(var e=t.length,n=0,s=null,o=null,i=0;i<e;i++)s=t.charCodeAt(i),oh(s)?o!=null&&sh(o)?n+=1:n+=3:s<=127?n+=1:s>=128&&s<=2047?n+=2:s>=2048&&s<=65535&&(n+=3),o=s;return n}});var Vc=Ee((ym,Hc)=>{"use strict";var ih=Uc(),ah=Lc();Hc.exports=ih.bind(null,ah)});var Dc=Ee((wm,_c)=>{"use strict";var ch=Vc(),lh=/[\/\?<>\\:\*\|"]/g,uh=/[\x00-\x1f\x80-\x9f]/g,fh=/^\.+$/,hh=/^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i,dh=/[\. ]+$/;function Oc(r,t){if(typeof r!="string")throw new Error("Input must be string");var e=r.replace(lh,t).replace(uh,t).replace(fh,t).replace(hh,t).replace(dh,t);return ch(e,255)}_c.exports=function(r,t){var e=t&&t.replacement||"",n=Oc(r,e);return e===""?n:Oc(n,"")}});var kh={};ft(kh,{keychain:()=>Ah});var hr=class extends Error{constructor(t="An error occurred while signing a message"){super(t),this.name="SigningError"}},dr=class extends Error{constructor(t="An error occurred while verifying a message"){super(t),this.name="VerificationError"}},Zr=class extends Error{constructor(t="Missing Web Crypto API"){super(t),this.name="WebCryptoMissingError"}};var Xo={get(r=globalThis){let t=r.crypto;if(t?.subtle==null)throw new Zr("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return t}};var wt=Xo;var V=class extends Error{static name="InvalidParametersError";constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}},Ke=class extends Error{static name="InvalidPublicKeyError";constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}},pr=class extends Error{static name="InvalidPrivateKeyError";constructor(t="Invalid private key"){super(t),this.name="InvalidPrivateKeyError"}};var Wr=class extends Error{static name="NotFoundError";constructor(t="Not found"){super(t),this.name="NotFoundError"}};var Me=class extends Error{static name="UnsupportedKeyTypeError";constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}};var Qo=Symbol.for("@libp2p/service-capabilities"),Lh=Symbol.for("@libp2p/service-dependencies");var ks={};ft(ks,{base58btc:()=>st,base58flickr:()=>cl});var nd=new Uint8Array(0);function ti(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function Pt(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function ei(r){return new TextEncoder().encode(r)}function ri(r){return new TextDecoder().decode(r)}function nl(r,t){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),n=0;n<e.length;n++)e[n]=255;for(var s=0;s<r.length;s++){var o=r.charAt(s),i=o.charCodeAt(0);if(e[i]!==255)throw new TypeError(o+" is ambiguous");e[i]=s}var a=r.length,c=r.charAt(0),u=Math.log(a)/Math.log(256),l=Math.log(256)/Math.log(a);function f(w){if(w instanceof Uint8Array||(ArrayBuffer.isView(w)?w=new Uint8Array(w.buffer,w.byteOffset,w.byteLength):Array.isArray(w)&&(w=Uint8Array.from(w))),!(w instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(w.length===0)return"";for(var m=0,d=0,b=0,B=w.length;b!==B&&w[b]===0;)b++,m++;for(var p=(B-b)*l+1>>>0,k=new Uint8Array(p);b!==B;){for(var R=w[b],U=0,I=p-1;(R!==0||U<d)&&I!==-1;I--,U++)R+=256*k[I]>>>0,k[I]=R%a>>>0,R=R/a>>>0;if(R!==0)throw new Error("Non-zero carry");d=U,b++}for(var T=p-d;T!==p&&k[T]===0;)T++;for(var N=c.repeat(m);T<p;++T)N+=r.charAt(k[T]);return N}function h(w){if(typeof w!="string")throw new TypeError("Expected String");if(w.length===0)return new Uint8Array;var m=0;if(w[m]!==" "){for(var d=0,b=0;w[m]===c;)d++,m++;for(var B=(w.length-m)*u+1>>>0,p=new Uint8Array(B);w[m];){var k=e[w.charCodeAt(m)];if(k===255)return;for(var R=0,U=B-1;(k!==0||R<b)&&U!==-1;U--,R++)k+=a*p[U]>>>0,p[U]=k%256>>>0,k=k/256>>>0;if(k!==0)throw new Error("Non-zero carry");b=R,m++}if(w[m]!==" "){for(var I=B-b;I!==B&&p[I]===0;)I++;for(var T=new Uint8Array(d+(B-I)),N=d;I!==B;)T[N++]=p[I++];return T}}}function y(w){var m=h(w);if(m)return m;throw new Error(`Non-${t} character`)}return{encode:f,decodeUnsafe:h,decode:y}}var sl=nl,ol=sl,si=ol;var vs=class{name;prefix;baseEncode;constructor(t,e,n){this.name=t,this.prefix=e,this.baseEncode=n}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}},Bs=class{name;prefix;baseDecode;prefixCodePoint;constructor(t,e,n){this.name=t,this.prefix=e;let s=e.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=n}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return oi(this,t)}},Es=class{decoders;constructor(t){this.decoders=t}or(t){return oi(this,t)}decode(t){let e=t[0],n=this.decoders[e];if(n!=null)return n.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};function oi(r,t){return new Es({...r.decoders??{[r.prefix]:r},...t.decoders??{[t.prefix]:t}})}var As=class{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(t,e,n,s){this.name=t,this.prefix=e,this.baseEncode=n,this.baseDecode=s,this.encoder=new vs(t,e,n),this.decoder=new Bs(t,e,s)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}};function Pe({name:r,prefix:t,encode:e,decode:n}){return new As(r,t,e,n)}function se({name:r,prefix:t,alphabet:e}){let{encode:n,decode:s}=si(e,r);return Pe({prefix:t,name:r,encode:n,decode:o=>Pt(s(o))})}function il(r,t,e,n){let s={};for(let l=0;l<t.length;++l)s[t[l]]=l;let o=r.length;for(;r[o-1]==="=";)--o;let i=new Uint8Array(o*e/8|0),a=0,c=0,u=0;for(let l=0;l<o;++l){let f=s[r[l]];if(f===void 0)throw new SyntaxError(`Non-${n} character`);c=c<<e|f,a+=e,a>=8&&(a-=8,i[u++]=255&c>>a)}if(a>=e||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return i}function al(r,t,e){let n=t[t.length-1]==="=",s=(1<<e)-1,o="",i=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],i+=8;i>e;)i-=e,o+=t[s&a>>i];if(i!==0&&(o+=t[s&a<<e-i]),n)for(;o.length*e&7;)o+="=";return o}function Y({name:r,prefix:t,bitsPerChar:e,alphabet:n}){return Pe({prefix:t,name:r,encode(s){return al(s,n,e)},decode(s){return il(s,n,e,r)}})}var st=se({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),cl=se({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var Ss={};ft(Ss,{base32:()=>Fe,base32hex:()=>hl,base32hexpad:()=>pl,base32hexpadupper:()=>gl,base32hexupper:()=>dl,base32pad:()=>ul,base32padupper:()=>fl,base32upper:()=>ll,base32z:()=>ml});var Fe=Y({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),ll=Y({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),ul=Y({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),fl=Y({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),hl=Y({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),dl=Y({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),pl=Y({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),gl=Y({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),ml=Y({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var Is={};ft(Is,{base36:()=>gr,base36upper:()=>yl});var gr=se({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),yl=se({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var wl=ci,ii=128,bl=127,xl=~bl,vl=Math.pow(2,31);function ci(r,t,e){t=t||[],e=e||0;for(var n=e;r>=vl;)t[e++]=r&255|ii,r/=128;for(;r&xl;)t[e++]=r&255|ii,r>>>=7;return t[e]=r|0,ci.bytes=e-n+1,t}var Bl=Ns,El=128,ai=127;function Ns(r,n){var e=0,n=n||0,s=0,o=n,i,a=r.length;do{if(o>=a)throw Ns.bytes=0,new RangeError("Could not decode varint");i=r[o++],e+=s<28?(i&ai)<<s:(i&ai)*Math.pow(2,s),s+=7}while(i>=El);return Ns.bytes=o-n,e}var Al=Math.pow(2,7),kl=Math.pow(2,14),Sl=Math.pow(2,21),Il=Math.pow(2,28),Nl=Math.pow(2,35),Cl=Math.pow(2,42),Tl=Math.pow(2,49),Ul=Math.pow(2,56),Rl=Math.pow(2,63),Ll=function(r){return r<Al?1:r<kl?2:r<Sl?3:r<Il?4:r<Nl?5:r<Cl?6:r<Tl?7:r<Ul?8:r<Rl?9:10},Hl={encode:wl,decode:Bl,encodingLength:Ll},Vl=Hl,mr=Vl;function yr(r,t=0){return[mr.decode(r,t),mr.decode.bytes]}function qe(r,t,e=0){return mr.encode(r,t,e),t}function je(r){return mr.encodingLength(r)}function St(r,t){let e=t.byteLength,n=je(r),s=n+je(e),o=new Uint8Array(s+e);return qe(r,o,0),qe(e,o,n),o.set(t,s),new $e(r,e,t,o)}function li(r){let t=Pt(r),[e,n]=yr(t),[s,o]=yr(t.subarray(n)),i=t.subarray(n+o);if(i.byteLength!==s)throw new Error("Incorrect length");return new $e(e,s,i,t)}function ui(r,t){if(r===t)return!0;{let e=t;return r.code===e.code&&r.size===e.size&&e.bytes instanceof Uint8Array&&ti(r.bytes,e.bytes)}}var $e=class{code;size;digest;bytes;constructor(t,e,n,s){this.code=t,this.size=e,this.digest=n,this.bytes=s}};function fi(r,t){let{bytes:e,version:n}=r;switch(n){case 0:return _l(e,Cs(r),t??st.encoder);default:return Dl(e,Cs(r),t??Fe.encoder)}}var hi=new WeakMap;function Cs(r){let t=hi.get(r);if(t==null){let e=new Map;return hi.set(r,e),e}return t}var Ht=class r{code;version;multihash;bytes;"/";constructor(t,e,n,s){this.code=e,this.version=t,this.multihash=n,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{let{code:t,multihash:e}=this;if(t!==br)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==Kl)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return r.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{let{code:t,digest:e}=this.multihash,n=St(t,e);return r.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return r.equals(this,t)}static equals(t,e){let n=e;return n!=null&&t.code===n.code&&t.version===n.version&&ui(t.multihash,n.multihash)}toString(t){return fi(this,t)}toJSON(){return{"/":fi(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;let e=t;if(e instanceof r)return e;if(e["/"]!=null&&e["/"]===e.bytes||e.asCID===e){let{version:n,code:s,multihash:o,bytes:i}=e;return new r(n,s,o,i??di(n,s,o.bytes))}else if(e[Ml]===!0){let{version:n,multihash:s,code:o}=e,i=li(s);return r.create(n,o,i)}else return null}static create(t,e,n){if(typeof e!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(e!==br)throw new Error(`Version 0 CID must use dag-pb (code: ${br}) block encoding`);return new r(t,e,n,n.bytes)}case 1:{let s=di(t,e,n.bytes);return new r(t,e,n,s)}default:throw new Error("Invalid version")}}static createV0(t){return r.create(0,br,t)}static createV1(t,e){return r.create(1,t,e)}static decode(t){let[e,n]=r.decodeFirst(t);if(n.length!==0)throw new Error("Incorrect length");return e}static decodeFirst(t){let e=r.inspectBytes(t),n=e.size-e.multihashSize,s=Pt(t.subarray(n,n+e.multihashSize));if(s.byteLength!==e.multihashSize)throw new Error("Incorrect length");let o=s.subarray(e.multihashSize-e.digestSize),i=new $e(e.multihashCode,e.digestSize,o,s);return[e.version===0?r.createV0(i):r.createV1(e.codec,i),t.subarray(e.size)]}static inspectBytes(t){let e=0,n=()=>{let[f,h]=yr(t.subarray(e));return e+=h,f},s=n(),o=br;if(s===18?(s=0,e=0):o=n(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);let i=e,a=n(),c=n(),u=e+c,l=u-i;return{version:s,codec:o,multihashCode:a,digestSize:c,multihashSize:l,size:u}}static parse(t,e){let[n,s]=Ol(t,e),o=r.decode(s);if(o.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Cs(o).set(n,t),o}};function Ol(r,t){switch(r[0]){case"Q":{let e=t??st;return[st.prefix,e.decode(`${st.prefix}${r}`)]}case st.prefix:{let e=t??st;return[st.prefix,e.decode(r)]}case Fe.prefix:{let e=t??Fe;return[Fe.prefix,e.decode(r)]}case gr.prefix:{let e=t??gr;return[gr.prefix,e.decode(r)]}default:{if(t==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],t.decode(r)]}}}function _l(r,t,e){let{prefix:n}=e;if(n!==st.prefix)throw Error(`Cannot string encode V0 in ${e.name} encoding`);let s=t.get(n);if(s==null){let o=e.encode(r).slice(1);return t.set(n,o),o}else return s}function Dl(r,t,e){let{prefix:n}=e,s=t.get(n);if(s==null){let o=e.encode(r);return t.set(n,o),o}else return s}var br=112,Kl=18;function di(r,t,e){let n=je(r),s=n+je(t),o=new Uint8Array(s+e.byteLength);return qe(r,o,0),qe(t,o,n),o.set(e,s),o}var Ml=Symbol.for("@ipld/js-cid/CID");var Ts={};ft(Ts,{identity:()=>xr});var pi=0,Pl="identity",gi=Pt;function Fl(r){return St(pi,gi(r))}var xr={code:pi,name:Pl,encode:gi,digest:Fl};function Ft(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function ze(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function ql(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Ge(r,...t){if(!ql(r))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(r.length))throw new Error("Uint8Array expected of length "+t+", got length="+r.length)}function Yr(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");ze(r.outputLen),ze(r.blockLen)}function Ze(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function mi(r,t){Ge(r);let e=t.outputLen;if(r.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}var Ae=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var ke=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),It=(r,t)=>r<<32-t|r>>>t,Xr=(r,t)=>r<<t|r>>>32-t>>>0;var jl=async()=>{};async function yi(r,t,e){let n=Date.now();for(let s=0;s<r;s++){e(s);let o=Date.now()-n;o>=0&&o<t||(await jl(),n+=o)}}function wi(r){if(typeof r!="string")throw new Error("utf8ToBytes expected string, got "+typeof r);return new Uint8Array(new TextEncoder().encode(r))}function oe(r){return typeof r=="string"&&(r=wi(r)),Ge(r),r}function Us(...r){let t=0;for(let n=0;n<r.length;n++){let s=r[n];Ge(s),t+=s.length}let e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){let o=r[n];e.set(o,s),s+=o.length}return e}var We=class{clone(){return this._cloneInto()}};function bi(r,t){if(t!==void 0&&{}.toString.call(t)!=="[object Object]")throw new Error("Options should be object or undefined");return Object.assign(r,t)}function Je(r){let t=n=>r().update(oe(n)).digest(),e=r();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>r(),t}function Ye(r=32){if(Ae&&typeof Ae.getRandomValues=="function")return Ae.getRandomValues(new Uint8Array(r));if(Ae&&typeof Ae.randomBytes=="function")return Ae.randomBytes(r);throw new Error("crypto.getRandomValues must be defined")}function $l(r,t,e,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(t,e,n);let s=BigInt(32),o=BigInt(4294967295),i=Number(e>>s&o),a=Number(e&o),c=n?4:0,u=n?0:4;r.setUint32(t+c,i,n),r.setUint32(t+u,a,n)}var Qr=(r,t,e)=>r&t^~r&e,tn=(r,t,e)=>r&t^r&e^t&e,ie=class extends We{constructor(t,e,n,s){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=ke(this.buffer)}update(t){Ze(this);let{view:e,buffer:n,blockLen:s}=this;t=oe(t);let o=t.length;for(let i=0;i<o;){let a=Math.min(s-this.pos,o-i);if(a===s){let c=ke(t);for(;s<=o-i;i+=s)this.process(c,i);continue}n.set(t.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Ze(this),mi(t,this),this.finished=!0;let{buffer:e,view:n,blockLen:s,isLE:o}=this,{pos:i}=this;e[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>s-i&&(this.process(n,0),i=0);for(let f=i;f<s;f++)e[f]=0;$l(n,s-8,BigInt(this.length*8),o),this.process(n,0);let a=ke(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let u=c/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<u;f++)a.setUint32(4*f,l[f],o)}digest(){let{buffer:t,outputLen:e}=this;this.digestInto(t);let n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:e,buffer:n,length:s,finished:o,destroyed:i,pos:a}=this;return t.length=s,t.pos=a,t.finished=o,t.destroyed=i,s%e&&t.buffer.set(n),t}};var en=BigInt(4294967295),Rs=BigInt(32);function xi(r,t=!1){return t?{h:Number(r&en),l:Number(r>>Rs&en)}:{h:Number(r>>Rs&en)|0,l:Number(r&en)|0}}function zl(r,t=!1){let e=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let s=0;s<r.length;s++){let{h:o,l:i}=xi(r[s],t);[e[s],n[s]]=[o,i]}return[e,n]}var Gl=(r,t)=>BigInt(r>>>0)<<Rs|BigInt(t>>>0),Zl=(r,t,e)=>r>>>e,Wl=(r,t,e)=>r<<32-e|t>>>e,Jl=(r,t,e)=>r>>>e|t<<32-e,Yl=(r,t,e)=>r<<32-e|t>>>e,Xl=(r,t,e)=>r<<64-e|t>>>e-32,Ql=(r,t,e)=>r>>>e-32|t<<64-e,tu=(r,t)=>t,eu=(r,t)=>r,ru=(r,t,e)=>r<<e|t>>>32-e,nu=(r,t,e)=>t<<e|r>>>32-e,su=(r,t,e)=>t<<e-32|r>>>64-e,ou=(r,t,e)=>r<<e-32|t>>>64-e;function iu(r,t,e,n){let s=(t>>>0)+(n>>>0);return{h:r+e+(s/2**32|0)|0,l:s|0}}var au=(r,t,e)=>(r>>>0)+(t>>>0)+(e>>>0),cu=(r,t,e,n)=>t+e+n+(r/2**32|0)|0,lu=(r,t,e,n)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0),uu=(r,t,e,n,s)=>t+e+n+s+(r/2**32|0)|0,fu=(r,t,e,n,s)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(s>>>0),hu=(r,t,e,n,s,o)=>t+e+n+s+o+(r/2**32|0)|0;var du={fromBig:xi,split:zl,toBig:Gl,shrSH:Zl,shrSL:Wl,rotrSH:Jl,rotrSL:Yl,rotrBH:Xl,rotrBL:Ql,rotr32H:tu,rotr32L:eu,rotlSH:ru,rotlSL:nu,rotlBH:su,rotlBL:ou,add:iu,add3L:au,add3H:cu,add4L:lu,add4H:uu,add5H:hu,add5L:fu},_=du;var[pu,gu]=_.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),ae=new Uint32Array(80),ce=new Uint32Array(80),Ls=class extends ie{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){let{Ah:t,Al:e,Bh:n,Bl:s,Ch:o,Cl:i,Dh:a,Dl:c,Eh:u,El:l,Fh:f,Fl:h,Gh:y,Gl:w,Hh:m,Hl:d}=this;return[t,e,n,s,o,i,a,c,u,l,f,h,y,w,m,d]}set(t,e,n,s,o,i,a,c,u,l,f,h,y,w,m,d){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=a|0,this.Dl=c|0,this.Eh=u|0,this.El=l|0,this.Fh=f|0,this.Fl=h|0,this.Gh=y|0,this.Gl=w|0,this.Hh=m|0,this.Hl=d|0}process(t,e){for(let p=0;p<16;p++,e+=4)ae[p]=t.getUint32(e),ce[p]=t.getUint32(e+=4);for(let p=16;p<80;p++){let k=ae[p-15]|0,R=ce[p-15]|0,U=_.rotrSH(k,R,1)^_.rotrSH(k,R,8)^_.shrSH(k,R,7),I=_.rotrSL(k,R,1)^_.rotrSL(k,R,8)^_.shrSL(k,R,7),T=ae[p-2]|0,N=ce[p-2]|0,G=_.rotrSH(T,N,19)^_.rotrBH(T,N,61)^_.shrSH(T,N,6),F=_.rotrSL(T,N,19)^_.rotrBL(T,N,61)^_.shrSL(T,N,6),K=_.add4L(I,F,ce[p-7],ce[p-16]),Q=_.add4H(K,U,G,ae[p-7],ae[p-16]);ae[p]=Q|0,ce[p]=K|0}let{Ah:n,Al:s,Bh:o,Bl:i,Ch:a,Cl:c,Dh:u,Dl:l,Eh:f,El:h,Fh:y,Fl:w,Gh:m,Gl:d,Hh:b,Hl:B}=this;for(let p=0;p<80;p++){let k=_.rotrSH(f,h,14)^_.rotrSH(f,h,18)^_.rotrBH(f,h,41),R=_.rotrSL(f,h,14)^_.rotrSL(f,h,18)^_.rotrBL(f,h,41),U=f&y^~f&m,I=h&w^~h&d,T=_.add5L(B,R,I,gu[p],ce[p]),N=_.add5H(T,b,k,U,pu[p],ae[p]),G=T|0,F=_.rotrSH(n,s,28)^_.rotrBH(n,s,34)^_.rotrBH(n,s,39),K=_.rotrSL(n,s,28)^_.rotrBL(n,s,34)^_.rotrBL(n,s,39),Q=n&o^n&a^o&a,E=s&i^s&c^i&c;b=m|0,B=d|0,m=y|0,d=w|0,y=f|0,w=h|0,{h:f,l:h}=_.add(u|0,l|0,N|0,G|0),u=a|0,l=c|0,a=o|0,c=i|0,o=n|0,i=s|0;let C=_.add3L(G,K,E);n=_.add3H(C,N,F,Q),s=C|0}({h:n,l:s}=_.add(this.Ah|0,this.Al|0,n|0,s|0)),{h:o,l:i}=_.add(this.Bh|0,this.Bl|0,o|0,i|0),{h:a,l:c}=_.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:u,l}=_.add(this.Dh|0,this.Dl|0,u|0,l|0),{h:f,l:h}=_.add(this.Eh|0,this.El|0,f|0,h|0),{h:y,l:w}=_.add(this.Fh|0,this.Fl|0,y|0,w|0),{h:m,l:d}=_.add(this.Gh|0,this.Gl|0,m|0,d|0),{h:b,l:B}=_.add(this.Hh|0,this.Hl|0,b|0,B|0),this.set(n,s,o,i,a,c,u,l,f,h,y,w,m,d,b,B)}roundClean(){ae.fill(0),ce.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}};var le=Je(()=>new Ls);var sn={};ft(sn,{aInRange:()=>bt,abool:()=>Nt,abytes:()=>Xe,bitGet:()=>vu,bitLen:()=>_s,bitMask:()=>Br,bitSet:()=>Bu,bytesToHex:()=>jt,bytesToNumberBE:()=>$t,bytesToNumberLE:()=>fe,concatBytes:()=>zt,createHmacDrbg:()=>Ds,ensureBytes:()=>J,equalBytes:()=>bu,hexToBytes:()=>Ie,hexToNumber:()=>Os,inRange:()=>vr,isBytes:()=>ue,memoized:()=>Ce,notImplemented:()=>Au,numberToBytesBE:()=>he,numberToBytesLE:()=>Ne,numberToHexUnpadded:()=>Se,numberToVarBytesBE:()=>wu,utf8ToBytes:()=>xu,validateObject:()=>Vt});var rn=BigInt(0),nn=BigInt(1),mu=BigInt(2);function ue(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Xe(r){if(!ue(r))throw new Error("Uint8Array expected")}function Nt(r,t){if(typeof t!="boolean")throw new Error(r+" boolean expected, got "+t)}var yu=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function jt(r){Xe(r);let t="";for(let e=0;e<r.length;e++)t+=yu[r[e]];return t}function Se(r){let t=r.toString(16);return t.length&1?"0"+t:t}function Os(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?rn:BigInt("0x"+r)}var qt={_0:48,_9:57,A:65,F:70,a:97,f:102};function vi(r){if(r>=qt._0&&r<=qt._9)return r-qt._0;if(r>=qt.A&&r<=qt.F)return r-(qt.A-10);if(r>=qt.a&&r<=qt.f)return r-(qt.a-10)}function Ie(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);let t=r.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);let n=new Uint8Array(e);for(let s=0,o=0;s<e;s++,o+=2){let i=vi(r.charCodeAt(o)),a=vi(r.charCodeAt(o+1));if(i===void 0||a===void 0){let c=r[o]+r[o+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+o)}n[s]=i*16+a}return n}function $t(r){return Os(jt(r))}function fe(r){return Xe(r),Os(jt(Uint8Array.from(r).reverse()))}function he(r,t){return Ie(r.toString(16).padStart(t*2,"0"))}function Ne(r,t){return he(r,t).reverse()}function wu(r){return Ie(Se(r))}function J(r,t,e){let n;if(typeof t=="string")try{n=Ie(t)}catch(o){throw new Error(r+" must be hex string or Uint8Array, cause: "+o)}else if(ue(t))n=Uint8Array.from(t);else throw new Error(r+" must be hex string or Uint8Array");let s=n.length;if(typeof e=="number"&&s!==e)throw new Error(r+" of length "+e+" expected, got "+s);return n}function zt(...r){let t=0;for(let n=0;n<r.length;n++){let s=r[n];Xe(s),t+=s.length}let e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){let o=r[n];e.set(o,s),s+=o.length}return e}function bu(r,t){if(r.length!==t.length)return!1;let e=0;for(let n=0;n<r.length;n++)e|=r[n]^t[n];return e===0}function xu(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}var Hs=r=>typeof r=="bigint"&&rn<=r;function vr(r,t,e){return Hs(r)&&Hs(t)&&Hs(e)&&t<=r&&r<e}function bt(r,t,e,n){if(!vr(t,e,n))throw new Error("expected valid "+r+": "+e+" <= n < "+n+", got "+t)}function _s(r){let t;for(t=0;r>rn;r>>=nn,t+=1);return t}function vu(r,t){return r>>BigInt(t)&nn}function Bu(r,t,e){return r|(e?nn:rn)<<BigInt(t)}var Br=r=>(mu<<BigInt(r-1))-nn,Vs=r=>new Uint8Array(r),Bi=r=>Uint8Array.from(r);function Ds(r,t,e){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let n=Vs(r),s=Vs(r),o=0,i=()=>{n.fill(1),s.fill(0),o=0},a=(...f)=>e(s,n,...f),c=(f=Vs())=>{s=a(Bi([0]),f),n=a(),f.length!==0&&(s=a(Bi([1]),f),n=a())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let f=0,h=[];for(;f<t;){n=a();let y=n.slice();h.push(y),f+=n.length}return zt(...h)};return(f,h)=>{i(),c(f);let y;for(;!(y=h(u()));)c();return i(),y}}var Eu={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||ue(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,t)=>t.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function Vt(r,t,e={}){let n=(s,o,i)=>{let a=Eu[o];if(typeof a!="function")throw new Error("invalid validator function");let c=r[s];if(!(i&&c===void 0)&&!a(c,r))throw new Error("param "+String(s)+" is invalid. Expected "+o+", got "+c)};for(let[s,o]of Object.entries(t))n(s,o,!1);for(let[s,o]of Object.entries(e))n(s,o,!0);return r}var Au=()=>{throw new Error("not implemented")};function Ce(r){let t=new WeakMap;return(e,...n)=>{let s=t.get(e);if(s!==void 0)return s;let o=r(e,...n);return t.set(e,o),o}}var tt=BigInt(0),Z=BigInt(1),Te=BigInt(2),ku=BigInt(3),Ks=BigInt(4),Ei=BigInt(5),Ai=BigInt(8),Su=BigInt(9),Iu=BigInt(16);function $(r,t){let e=r%t;return e>=tt?e:t+e}function Nu(r,t,e){if(t<tt)throw new Error("invalid exponent, negatives unsupported");if(e<=tt)throw new Error("invalid modulus");if(e===Z)return tt;let n=Z;for(;t>tt;)t&Z&&(n=n*r%e),r=r*r%e,t>>=Z;return n}function W(r,t,e){let n=r;for(;t-- >tt;)n*=n,n%=e;return n}function on(r,t){if(r===tt)throw new Error("invert: expected non-zero number");if(t<=tt)throw new Error("invert: expected positive modulus, got "+t);let e=$(r,t),n=t,s=tt,o=Z,i=Z,a=tt;for(;e!==tt;){let u=n/e,l=n%e,f=s-i*u,h=o-a*u;n=e,e=l,s=i,o=a,i=f,a=h}if(n!==Z)throw new Error("invert: does not exist");return $(s,t)}function Cu(r){let t=(r-Z)/Te,e,n,s;for(e=r-Z,n=0;e%Te===tt;e/=Te,n++);for(s=Te;s<r&&Nu(s,t,r)!==r-Z;s++)if(s>1e3)throw new Error("Cannot find square root: likely non-prime P");if(n===1){let i=(r+Z)/Ks;return function(c,u){let l=c.pow(u,i);if(!c.eql(c.sqr(l),u))throw new Error("Cannot find square root");return l}}let o=(e+Z)/Te;return function(a,c){if(a.pow(c,t)===a.neg(a.ONE))throw new Error("Cannot find square root");let u=n,l=a.pow(a.mul(a.ONE,s),e),f=a.pow(c,o),h=a.pow(c,e);for(;!a.eql(h,a.ONE);){if(a.eql(h,a.ZERO))return a.ZERO;let y=1;for(let m=a.sqr(h);y<u&&!a.eql(m,a.ONE);y++)m=a.sqr(m);let w=a.pow(l,Z<<BigInt(u-y-1));l=a.sqr(w),f=a.mul(f,w),h=a.mul(h,l),u=y}return f}}function Tu(r){if(r%Ks===ku){let t=(r+Z)/Ks;return function(n,s){let o=n.pow(s,t);if(!n.eql(n.sqr(o),s))throw new Error("Cannot find square root");return o}}if(r%Ai===Ei){let t=(r-Ei)/Ai;return function(n,s){let o=n.mul(s,Te),i=n.pow(o,t),a=n.mul(s,i),c=n.mul(n.mul(a,Te),i),u=n.mul(a,n.sub(c,n.ONE));if(!n.eql(n.sqr(u),s))throw new Error("Cannot find square root");return u}}return r%Iu,Cu(r)}var ki=(r,t)=>($(r,t)&Z)===Z,Uu=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ms(r){let t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Uu.reduce((n,s)=>(n[s]="function",n),t);return Vt(r,e)}function Ru(r,t,e){if(e<tt)throw new Error("invalid exponent, negatives unsupported");if(e===tt)return r.ONE;if(e===Z)return t;let n=r.ONE,s=t;for(;e>tt;)e&Z&&(n=r.mul(n,s)),s=r.sqr(s),e>>=Z;return n}function Lu(r,t){let e=new Array(t.length),n=t.reduce((o,i,a)=>r.is0(i)?o:(e[a]=o,r.mul(o,i)),r.ONE),s=r.inv(n);return t.reduceRight((o,i,a)=>r.is0(i)?o:(e[a]=r.mul(o,e[a]),r.mul(o,i)),s),e}function Ps(r,t){let e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}function de(r,t,e=!1,n={}){if(r<=tt)throw new Error("invalid field: expected ORDER > 0, got "+r);let{nBitLength:s,nByteLength:o}=Ps(r,t);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let i,a=Object.freeze({ORDER:r,isLE:e,BITS:s,BYTES:o,MASK:Br(s),ZERO:tt,ONE:Z,create:c=>$(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return tt<=c&&c<r},is0:c=>c===tt,isOdd:c=>(c&Z)===Z,neg:c=>$(-c,r),eql:(c,u)=>c===u,sqr:c=>$(c*c,r),add:(c,u)=>$(c+u,r),sub:(c,u)=>$(c-u,r),mul:(c,u)=>$(c*u,r),pow:(c,u)=>Ru(a,c,u),div:(c,u)=>$(c*on(u,r),r),sqrN:c=>c*c,addN:(c,u)=>c+u,subN:(c,u)=>c-u,mulN:(c,u)=>c*u,inv:c=>on(c,r),sqrt:n.sqrt||(c=>(i||(i=Tu(r)),i(a,c))),invertBatch:c=>Lu(a,c),cmov:(c,u,l)=>l?u:c,toBytes:c=>e?Ne(c,o):he(c,o),fromBytes:c=>{if(c.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+c.length);return e?fe(c):$t(c)}});return Object.freeze(a)}function Si(r){if(typeof r!="bigint")throw new Error("field order must be bigint");let t=r.toString(2).length;return Math.ceil(t/8)}function Fs(r){let t=Si(r);return t+Math.ceil(t/2)}function Ii(r,t,e=!1){let n=r.length,s=Si(t),o=Fs(t);if(n<16||n<o||n>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+n);let i=e?fe(r):$t(r),a=$(i,t-Z)+Z;return e?Ne(a,s):he(a,s)}var Ni=BigInt(0),an=BigInt(1);function qs(r,t){let e=t.negate();return r?e:t}function Ci(r,t){if(!Number.isSafeInteger(r)||r<=0||r>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+r)}function js(r,t){Ci(r,t);let e=Math.ceil(t/r)+1,n=2**(r-1);return{windows:e,windowSize:n}}function Vu(r,t){if(!Array.isArray(r))throw new Error("array expected");r.forEach((e,n)=>{if(!(e instanceof t))throw new Error("invalid point at index "+n)})}function Ou(r,t){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((e,n)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+n)})}var $s=new WeakMap,Ti=new WeakMap;function zs(r){return Ti.get(r)||1}function cn(r,t){return{constTimeNegate:qs,hasPrecomputes(e){return zs(e)!==1},unsafeLadder(e,n,s=r.ZERO){let o=e;for(;n>Ni;)n&an&&(s=s.add(o)),o=o.double(),n>>=an;return s},precomputeWindow(e,n){let{windows:s,windowSize:o}=js(n,t),i=[],a=e,c=a;for(let u=0;u<s;u++){c=a,i.push(c);for(let l=1;l<o;l++)c=c.add(a),i.push(c);a=c.double()}return i},wNAF(e,n,s){let{windows:o,windowSize:i}=js(e,t),a=r.ZERO,c=r.BASE,u=BigInt(2**e-1),l=2**e,f=BigInt(e);for(let h=0;h<o;h++){let y=h*i,w=Number(s&u);s>>=f,w>i&&(w-=l,s+=an);let m=y,d=y+Math.abs(w)-1,b=h%2!==0,B=w<0;w===0?c=c.add(qs(b,n[m])):a=a.add(qs(B,n[d]))}return{p:a,f:c}},wNAFUnsafe(e,n,s,o=r.ZERO){let{windows:i,windowSize:a}=js(e,t),c=BigInt(2**e-1),u=2**e,l=BigInt(e);for(let f=0;f<i;f++){let h=f*a;if(s===Ni)break;let y=Number(s&c);if(s>>=l,y>a&&(y-=u,s+=an),y===0)continue;let w=n[h+Math.abs(y)-1];y<0&&(w=w.negate()),o=o.add(w)}return o},getPrecomputes(e,n,s){let o=$s.get(n);return o||(o=this.precomputeWindow(n,e),e!==1&&$s.set(n,s(o))),o},wNAFCached(e,n,s){let o=zs(e);return this.wNAF(o,this.getPrecomputes(o,e,s),n)},wNAFCachedUnsafe(e,n,s,o){let i=zs(e);return i===1?this.unsafeLadder(e,n,o):this.wNAFUnsafe(i,this.getPrecomputes(i,e,s),n,o)},setWindowSize(e,n){Ci(n,t),Ti.set(e,n),$s.delete(e)}}}function ln(r,t,e,n){if(Vu(e,r),Ou(n,t),e.length!==n.length)throw new Error("arrays of points and scalars must have equal length");let s=r.ZERO,o=_s(BigInt(e.length)),i=o>12?o-3:o>4?o-2:o?2:1,a=(1<<i)-1,c=new Array(a+1).fill(s),u=Math.floor((t.BITS-1)/i)*i,l=s;for(let f=u;f>=0;f-=i){c.fill(s);for(let y=0;y<n.length;y++){let w=n[y],m=Number(w>>BigInt(f)&BigInt(a));c[m]=c[m].add(e[y])}let h=s;for(let y=c.length-1,w=s;y>0;y--)w=w.add(c[y]),h=h.add(w);if(l=l.add(h),f!==0)for(let y=0;y<i;y++)l=l.double()}return l}function Er(r){return Ms(r.Fp),Vt(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Ps(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}var Ct=BigInt(0),xt=BigInt(1),un=BigInt(2),_u=BigInt(8),Du={zip215:!0};function Ku(r){let t=Er(r);return Vt(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}function Ui(r){let t=Ku(r),{Fp:e,n,prehash:s,hash:o,randomBytes:i,nByteLength:a,h:c}=t,u=un<<BigInt(a*8)-xt,l=e.create,f=de(t.n,t.nBitLength),h=t.uvRatio||((x,g)=>{try{return{isValid:!0,value:e.sqrt(x*e.inv(g))}}catch{return{isValid:!1,value:Ct}}}),y=t.adjustScalarBytes||(x=>x),w=t.domain||((x,g,v)=>{if(Nt("phflag",v),g.length||v)throw new Error("Contexts/pre-hash are not supported");return x});function m(x,g){bt("coordinate "+x,g,Ct,u)}function d(x){if(!(x instanceof p))throw new Error("ExtendedPoint expected")}let b=Ce((x,g)=>{let{ex:v,ey:S,ez:L}=x,H=x.is0();g==null&&(g=H?_u:e.inv(L));let D=l(v*g),P=l(S*g),O=l(L*g);if(H)return{x:Ct,y:xt};if(O!==xt)throw new Error("invZ was invalid");return{x:D,y:P}}),B=Ce(x=>{let{a:g,d:v}=t;if(x.is0())throw new Error("bad point: ZERO");let{ex:S,ey:L,ez:H,et:D}=x,P=l(S*S),O=l(L*L),j=l(H*H),z=l(j*j),rt=l(P*g),nt=l(j*l(rt+O)),at=l(z+l(v*l(P*O)));if(nt!==at)throw new Error("bad point: equation left != right (1)");let ut=l(S*L),yt=l(H*D);if(ut!==yt)throw new Error("bad point: equation left != right (2)");return!0});class p{constructor(g,v,S,L){this.ex=g,this.ey=v,this.ez=S,this.et=L,m("x",g),m("y",v),m("z",S),m("t",L),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(g){if(g instanceof p)throw new Error("extended point not allowed");let{x:v,y:S}=g||{};return m("x",v),m("y",S),new p(v,S,xt,l(v*S))}static normalizeZ(g){let v=e.invertBatch(g.map(S=>S.ez));return g.map((S,L)=>S.toAffine(v[L])).map(p.fromAffine)}static msm(g,v){return ln(p,f,g,v)}_setWindowSize(g){U.setWindowSize(this,g)}assertValidity(){B(this)}equals(g){d(g);let{ex:v,ey:S,ez:L}=this,{ex:H,ey:D,ez:P}=g,O=l(v*P),j=l(H*L),z=l(S*P),rt=l(D*L);return O===j&&z===rt}is0(){return this.equals(p.ZERO)}negate(){return new p(l(-this.ex),this.ey,this.ez,l(-this.et))}double(){let{a:g}=t,{ex:v,ey:S,ez:L}=this,H=l(v*v),D=l(S*S),P=l(un*l(L*L)),O=l(g*H),j=v+S,z=l(l(j*j)-H-D),rt=O+D,nt=rt-P,at=O-D,ut=l(z*nt),yt=l(rt*at),pt=l(z*at),Lt=l(nt*rt);return new p(ut,yt,Lt,pt)}add(g){d(g);let{a:v,d:S}=t,{ex:L,ey:H,ez:D,et:P}=this,{ex:O,ey:j,ez:z,et:rt}=g;if(v===BigInt(-1)){let jo=l((H-L)*(j+O)),$o=l((H+L)*(j-O)),bs=l($o-jo);if(bs===Ct)return this.double();let zo=l(D*un*rt),Go=l(P*un*z),Zo=Go+zo,Wo=$o+jo,Jo=Go-zo,Gc=l(Zo*bs),Zc=l(Wo*Jo),Wc=l(Zo*Jo),Jc=l(bs*Wo);return new p(Gc,Zc,Jc,Wc)}let nt=l(L*O),at=l(H*j),ut=l(P*S*rt),yt=l(D*z),pt=l((L+H)*(O+j)-nt-at),Lt=yt-ut,Mt=yt+ut,fr=l(at-v*nt),qc=l(pt*Lt),jc=l(Mt*fr),$c=l(pt*fr),zc=l(Lt*Mt);return new p(qc,jc,zc,$c)}subtract(g){return this.add(g.negate())}wNAF(g){return U.wNAFCached(this,g,p.normalizeZ)}multiply(g){let v=g;bt("scalar",v,xt,n);let{p:S,f:L}=this.wNAF(v);return p.normalizeZ([S,L])[0]}multiplyUnsafe(g,v=p.ZERO){let S=g;return bt("scalar",S,Ct,n),S===Ct?R:this.is0()||S===xt?this:U.wNAFCachedUnsafe(this,S,p.normalizeZ,v)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return U.unsafeLadder(this,n).is0()}toAffine(g){return b(this,g)}clearCofactor(){let{h:g}=t;return g===xt?this:this.multiplyUnsafe(g)}static fromHex(g,v=!1){let{d:S,a:L}=t,H=e.BYTES;g=J("pointHex",g,H),Nt("zip215",v);let D=g.slice(),P=g[H-1];D[H-1]=P&-129;let O=fe(D),j=v?u:e.ORDER;bt("pointHex.y",O,Ct,j);let z=l(O*O),rt=l(z-xt),nt=l(S*z-L),{isValid:at,value:ut}=h(rt,nt);if(!at)throw new Error("Point.fromHex: invalid y coordinate");let yt=(ut&xt)===xt,pt=(P&128)!==0;if(!v&&ut===Ct&&pt)throw new Error("Point.fromHex: x=0 and x_0=1");return pt!==yt&&(ut=l(-ut)),p.fromAffine({x:ut,y:O})}static fromPrivateKey(g){return N(g).point}toRawBytes(){let{x:g,y:v}=this.toAffine(),S=Ne(v,e.BYTES);return S[S.length-1]|=g&xt?128:0,S}toHex(){return jt(this.toRawBytes())}}p.BASE=new p(t.Gx,t.Gy,xt,l(t.Gx*t.Gy)),p.ZERO=new p(Ct,xt,xt,Ct);let{BASE:k,ZERO:R}=p,U=cn(p,a*8);function I(x){return $(x,n)}function T(x){return I(fe(x))}function N(x){let g=e.BYTES;x=J("private key",x,g);let v=J("hashed private key",o(x),2*g),S=y(v.slice(0,g)),L=v.slice(g,2*g),H=T(S),D=k.multiply(H),P=D.toRawBytes();return{head:S,prefix:L,scalar:H,point:D,pointBytes:P}}function G(x){return N(x).pointBytes}function F(x=new Uint8Array,...g){let v=zt(...g);return T(o(w(v,J("context",x),!!s)))}function K(x,g,v={}){x=J("message",x),s&&(x=s(x));let{prefix:S,scalar:L,pointBytes:H}=N(g),D=F(v.context,S,x),P=k.multiply(D).toRawBytes(),O=F(v.context,P,H,x),j=I(D+O*L);bt("signature.s",j,Ct,n);let z=zt(P,Ne(j,e.BYTES));return J("result",z,e.BYTES*2)}let Q=Du;function E(x,g,v,S=Q){let{context:L,zip215:H}=S,D=e.BYTES;x=J("signature",x,2*D),g=J("message",g),v=J("publicKey",v,D),H!==void 0&&Nt("zip215",H),s&&(g=s(g));let P=fe(x.slice(D,2*D)),O,j,z;try{O=p.fromHex(v,H),j=p.fromHex(x.slice(0,D),H),z=k.multiplyUnsafe(P)}catch{return!1}if(!H&&O.isSmallOrder())return!1;let rt=F(L,j.toRawBytes(),O.toRawBytes(),g);return j.add(O.multiplyUnsafe(rt)).subtract(z).clearCofactor().equals(p.ZERO)}return k._setWindowSize(8),{CURVE:t,getPublicKey:G,sign:K,verify:E,ExtendedPoint:p,utils:{getExtendedPublicKey:N,randomPrivateKey:()=>i(e.BYTES),precompute(x=8,g=p.BASE){return g._setWindowSize(x),g.multiply(BigInt(3)),g}}}}var Gs=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Ri=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),Zd=BigInt(0),Mu=BigInt(1),Li=BigInt(2),Wd=BigInt(3),Pu=BigInt(5),Fu=BigInt(8);function qu(r){let t=BigInt(10),e=BigInt(20),n=BigInt(40),s=BigInt(80),o=Gs,a=r*r%o*r%o,c=W(a,Li,o)*a%o,u=W(c,Mu,o)*r%o,l=W(u,Pu,o)*u%o,f=W(l,t,o)*l%o,h=W(f,e,o)*f%o,y=W(h,n,o)*h%o,w=W(y,s,o)*y%o,m=W(w,s,o)*y%o,d=W(m,t,o)*l%o;return{pow_p_5_8:W(d,Li,o)*r%o,b2:a}}function ju(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function $u(r,t){let e=Gs,n=$(t*t*t,e),s=$(n*n*t,e),o=qu(r*s).pow_p_5_8,i=$(r*n*o,e),a=$(t*i*i,e),c=i,u=$(i*Ri,e),l=a===r,f=a===$(-r,e),h=a===$(-r*Ri,e);return l&&(i=c),(f||h)&&(i=u),ki(i,e)&&(i=$(-i,e)),{isValid:l||f,value:i}}var zu=de(Gs,void 0,!0),Gu={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:zu,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:Fu,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:le,randomBytes:Ye,adjustScalarBytes:ju,uvRatio:$u},Zs=Ui(Gu);var Ar=32,Gt=64,Zu=32;function Hi(r,t){let e=r.subarray(0,Zu);return Zs.sign(t instanceof Uint8Array?t:t.subarray(),e)}function Vi(r,t,e){return Zs.verify(t,e instanceof Uint8Array?e:e.subarray(),r)}var fn=class{type="Ed25519";raw;constructor(t){this.raw=Sr(t,Ar)}toMultihash(){return xr.digest(hn(this))}toCID(){return Ht.createV1(114,this.toMultihash())}toString(){return st.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:Ft(this.raw,t.raw)}verify(t,e){return Vi(this.raw,e,t)}},kr=class{type="Ed25519";raw;publicKey;constructor(t,e){this.raw=Sr(t,Gt),this.publicKey=new fn(e)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:Ft(this.raw,t.raw)}sign(t){return Hi(this.raw,t)}};function Ws(r){if(r.length>Gt){r=Sr(r,Gt+Ar);let n=r.subarray(0,Gt),s=r.subarray(Gt,r.length);return new kr(n,s)}r=Sr(r,Gt);let t=r.subarray(0,Gt),e=r.subarray(Ar);return new kr(t,e)}function Sr(r,t){if(r=Uint8Array.from(r??[]),r.length!==t)throw new V(`Key must be a Uint8Array of length ${t}, got ${r.length}`);return r}function Ot(r=0){return new Uint8Array(r)}var Wu=Math.pow(2,7),Ju=Math.pow(2,14),Yu=Math.pow(2,21),_i=Math.pow(2,28),Di=Math.pow(2,35),Ki=Math.pow(2,42),Mi=Math.pow(2,49),gt=128,pe=127;function Ir(r){if(r<Wu)return 1;if(r<Ju)return 2;if(r<Yu)return 3;if(r<_i)return 4;if(r<Di)return 5;if(r<Ki)return 6;if(r<Mi)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function Pi(r,t,e=0){switch(Ir(r)){case 8:t[e++]=r&255|gt,r/=128;case 7:t[e++]=r&255|gt,r/=128;case 6:t[e++]=r&255|gt,r/=128;case 5:t[e++]=r&255|gt,r/=128;case 4:t[e++]=r&255|gt,r>>>=7;case 3:t[e++]=r&255|gt,r>>>=7;case 2:t[e++]=r&255|gt,r>>>=7;case 1:{t[e++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return t}function Fi(r,t){let e=r[t],n=0;if(n+=e&pe,e<gt||(e=r[t+1],n+=(e&pe)<<7,e<gt)||(e=r[t+2],n+=(e&pe)<<14,e<gt)||(e=r[t+3],n+=(e&pe)<<21,e<gt)||(e=r[t+4],n+=(e&pe)*_i,e<gt)||(e=r[t+5],n+=(e&pe)*Di,e<gt)||(e=r[t+6],n+=(e&pe)*Ki,e<gt)||(e=r[t+7],n+=(e&pe)*Mi,e<gt))return n;throw new RangeError("Could not decode varint")}var Js=new Float32Array([-0]),ge=new Uint8Array(Js.buffer);function qi(r,t,e){Js[0]=r,t[e]=ge[0],t[e+1]=ge[1],t[e+2]=ge[2],t[e+3]=ge[3]}function ji(r,t){return ge[0]=r[t],ge[1]=r[t+1],ge[2]=r[t+2],ge[3]=r[t+3],Js[0]}var Ys=new Float64Array([-0]),ht=new Uint8Array(Ys.buffer);function $i(r,t,e){Ys[0]=r,t[e]=ht[0],t[e+1]=ht[1],t[e+2]=ht[2],t[e+3]=ht[3],t[e+4]=ht[4],t[e+5]=ht[5],t[e+6]=ht[6],t[e+7]=ht[7]}function zi(r,t){return ht[0]=r[t],ht[1]=r[t+1],ht[2]=r[t+2],ht[3]=r[t+3],ht[4]=r[t+4],ht[5]=r[t+5],ht[6]=r[t+6],ht[7]=r[t+7],Ys[0]}var Xu=BigInt(Number.MAX_SAFE_INTEGER),Qu=BigInt(Number.MIN_SAFE_INTEGER),Et=class r{lo;hi;constructor(t,e){this.lo=t|0,this.hi=e|0}toNumber(t=!1){if(!t&&this.hi>>>31>0){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(e+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(t=!1){if(t)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(BigInt(e)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(t=!1){return this.toBigInt(t).toString()}zzEncode(){let t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this}zzDecode(){let t=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this}length(){let t=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?e===0?t<16384?t<128?1:2:t<2097152?3:4:e<16384?e<128?5:6:e<2097152?7:8:n<128?9:10}static fromBigInt(t){if(t===0n)return Ue;if(t<Xu&&t>Qu)return this.fromNumber(Number(t));let e=t<0n;e&&(t=-t);let n=t>>32n,s=t-(n<<32n);return e&&(n=~n|0n,s=~s|0n,++s>Gi&&(s=0n,++n>Gi&&(n=0n))),new r(Number(s),Number(n))}static fromNumber(t){if(t===0)return Ue;let e=t<0;e&&(t=-t);let n=t>>>0,s=(t-n)/4294967296>>>0;return e&&(s=~s>>>0,n=~n>>>0,++n>4294967295&&(n=0,++s>4294967295&&(s=0))),new r(n,s)}static from(t){return typeof t=="number"?r.fromNumber(t):typeof t=="bigint"?r.fromBigInt(t):typeof t=="string"?r.fromBigInt(BigInt(t)):t.low!=null||t.high!=null?new r(t.low>>>0,t.high>>>0):Ue}},Ue=new Et(0,0);Ue.toBigInt=function(){return 0n};Ue.zzEncode=Ue.zzDecode=function(){return this};Ue.length=function(){return 1};var Gi=4294967296n;function Zi(r){let t=0,e=0;for(let n=0;n<r.length;++n)e=r.charCodeAt(n),e<128?t+=1:e<2048?t+=2:(e&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,t+=4):t+=3;return t}function Wi(r,t,e){if(e-t<1)return"";let s,o=[],i=0,a;for(;t<e;)a=r[t++],a<128?o[i++]=a:a>191&&a<224?o[i++]=(a&31)<<6|r[t++]&63:a>239&&a<365?(a=((a&7)<<18|(r[t++]&63)<<12|(r[t++]&63)<<6|r[t++]&63)-65536,o[i++]=55296+(a>>10),o[i++]=56320+(a&1023)):o[i++]=(a&15)<<12|(r[t++]&63)<<6|r[t++]&63,i>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,o)),i=0);return s!=null?(i>0&&s.push(String.fromCharCode.apply(String,o.slice(0,i))),s.join("")):String.fromCharCode.apply(String,o.slice(0,i))}function Xs(r,t,e){let n=e,s,o;for(let i=0;i<r.length;++i)s=r.charCodeAt(i),s<128?t[e++]=s:s<2048?(t[e++]=s>>6|192,t[e++]=s&63|128):(s&64512)===55296&&((o=r.charCodeAt(i+1))&64512)===56320?(s=65536+((s&1023)<<10)+(o&1023),++i,t[e++]=s>>18|240,t[e++]=s>>12&63|128,t[e++]=s>>6&63|128,t[e++]=s&63|128):(t[e++]=s>>12|224,t[e++]=s>>6&63|128,t[e++]=s&63|128);return e-n}function Tt(r,t){return RangeError(`index out of range: ${r.pos} + ${t??1} > ${r.len}`)}function dn(r,t){return(r[t-4]|r[t-3]<<8|r[t-2]<<16|r[t-1]<<24)>>>0}var Qs=class{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(t){this.buf=t,this.pos=0,this.len=t.length}uint32(){let t=4294967295;if(t=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(t=(t|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return t;if((this.pos+=5)>this.len)throw this.pos=this.len,Tt(this,10);return t}int32(){return this.uint32()|0}sint32(){let t=this.uint32();return t>>>1^-(t&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw Tt(this,4);return dn(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw Tt(this,4);return dn(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw Tt(this,4);let t=ji(this.buf,this.pos);return this.pos+=4,t}double(){if(this.pos+8>this.len)throw Tt(this,4);let t=zi(this.buf,this.pos);return this.pos+=8,t}bytes(){let t=this.uint32(),e=this.pos,n=this.pos+t;if(n>this.len)throw Tt(this,t);return this.pos+=t,e===n?new Uint8Array(0):this.buf.subarray(e,n)}string(){let t=this.bytes();return Wi(t,0,t.length)}skip(t){if(typeof t=="number"){if(this.pos+t>this.len)throw Tt(this,t);this.pos+=t}else do if(this.pos>=this.len)throw Tt(this);while(this.buf[this.pos++]&128);return this}skipType(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${t} at offset ${this.pos}`)}return this}readLongVarint(){let t=new Et(0,0),e=0;if(this.len-this.pos>4){for(;e<4;++e)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw Tt(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,t}if(this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw Tt(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw Tt(this,8);let t=dn(this.buf,this.pos+=4),e=dn(this.buf,this.pos+=4);return new Et(t,e)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){let t=Fi(this.buf,this.pos);return this.pos+=Ir(t),t}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}};function to(r){return new Qs(r instanceof Uint8Array?r:r.subarray())}function pn(r,t,e){let n=to(r);return t.decode(n,void 0,e)}var eo={};ft(eo,{base10:()=>tf});var tf=se({prefix:"9",name:"base10",alphabet:"0123456789"});var ro={};ft(ro,{base16:()=>ef,base16upper:()=>rf});var ef=Y({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),rf=Y({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var no={};ft(no,{base2:()=>nf});var nf=Y({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var so={};ft(so,{base256emoji:()=>lf});var Yi=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),sf=Yi.reduce((r,t,e)=>(r[e]=t,r),[]),of=Yi.reduce((r,t,e)=>{let n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);return r[n]=e,r},[]);function af(r){return r.reduce((t,e)=>(t+=sf[e],t),"")}function cf(r){let t=[];for(let e of r){let n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);let s=of[n];if(s==null)throw new Error(`Non-base256emoji character: ${e}`);t.push(s)}return new Uint8Array(t)}var lf=Pe({prefix:"\u{1F680}",name:"base256emoji",encode:af,decode:cf});var oo={};ft(oo,{base64:()=>Re,base64pad:()=>uf,base64url:()=>ff,base64urlpad:()=>hf});var Re=Y({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),uf=Y({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),ff=Y({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),hf=Y({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var io={};ft(io,{base8:()=>df});var df=Y({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var ao={};ft(ao,{identity:()=>pf});var pf=Pe({prefix:"\0",name:"identity",encode:r=>ri(r),decode:r=>ei(r)});var T0=new TextEncoder,U0=new TextDecoder;var uo={};ft(uo,{sha256:()=>Qe,sha512:()=>yf});function lo({name:r,code:t,encode:e}){return new co(r,t,e)}var co=class{name;code;encode;constructor(t,e,n){this.name=t,this.code=e,this.encode=n}digest(t){if(t instanceof Uint8Array){let e=this.encode(t);return e instanceof Uint8Array?St(this.code,e):e.then(n=>St(this.code,n))}else throw Error("Unknown type, must be binary type")}};function Qi(r){return async t=>new Uint8Array(await crypto.subtle.digest(r,t))}var Qe=lo({name:"sha2-256",code:18,encode:Qi("SHA-256")}),yf=lo({name:"sha2-512",code:19,encode:Qi("SHA-512")});var fo={...ao,...no,...io,...eo,...ro,...Ss,...Is,...ks,...oo,...so},q0={...uo,...Ts};function ea(r,t,e,n){return{name:r,prefix:t,encoder:{name:r,prefix:t,encode:e},decoder:{decode:n}}}var ta=ea("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),ho=ea("ascii","a",r=>{let t="a";for(let e=0;e<r.length;e++)t+=String.fromCharCode(r[e]);return t},r=>{r=r.substring(1);let t=Ot(r.length);for(let e=0;e<r.length;e++)t[e]=r.charCodeAt(e);return t}),wf={utf8:ta,"utf-8":ta,hex:fo.base16,latin1:ho,ascii:ho,binary:ho,...fo},gn=wf;function q(r,t="utf8"){let e=gn[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.decoder.decode(`${e.prefix}${r}`)}function po(r){let t=r??8192,e=t>>>1,n,s=t;return function(i){if(i<1||i>e)return Ot(i);s+i>t&&(n=Ot(t),s=0);let a=n.subarray(s,s+=i);return s&7&&(s=(s|7)+1),a}}var Le=class{fn;len;next;val;constructor(t,e,n){this.fn=t,this.len=e,this.next=void 0,this.val=n}};function go(){}var yo=class{head;tail;len;next;constructor(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}},bf=po();function xf(r){return globalThis.Buffer!=null?Ot(r):bf(r)}var Cr=class{len;head;tail;states;constructor(){this.len=0,this.head=new Le(go,0,0),this.tail=this.head,this.states=null}_push(t,e,n){return this.tail=this.tail.next=new Le(t,e,n),this.len+=e,this}uint32(t){return this.len+=(this.tail=this.tail.next=new wo((t=t>>>0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this}int32(t){return t<0?this._push(mn,10,Et.fromNumber(t)):this.uint32(t)}sint32(t){return this.uint32((t<<1^t>>31)>>>0)}uint64(t){let e=Et.fromBigInt(t);return this._push(mn,e.length(),e)}uint64Number(t){return this._push(Pi,Ir(t),t)}uint64String(t){return this.uint64(BigInt(t))}int64(t){return this.uint64(t)}int64Number(t){return this.uint64Number(t)}int64String(t){return this.uint64String(t)}sint64(t){let e=Et.fromBigInt(t).zzEncode();return this._push(mn,e.length(),e)}sint64Number(t){let e=Et.fromNumber(t).zzEncode();return this._push(mn,e.length(),e)}sint64String(t){return this.sint64(BigInt(t))}bool(t){return this._push(mo,1,t?1:0)}fixed32(t){return this._push(Nr,4,t>>>0)}sfixed32(t){return this.fixed32(t)}fixed64(t){let e=Et.fromBigInt(t);return this._push(Nr,4,e.lo)._push(Nr,4,e.hi)}fixed64Number(t){let e=Et.fromNumber(t);return this._push(Nr,4,e.lo)._push(Nr,4,e.hi)}fixed64String(t){return this.fixed64(BigInt(t))}sfixed64(t){return this.fixed64(t)}sfixed64Number(t){return this.fixed64Number(t)}sfixed64String(t){return this.fixed64String(t)}float(t){return this._push(qi,4,t)}double(t){return this._push($i,8,t)}bytes(t){let e=t.length>>>0;return e===0?this._push(mo,1,0):this.uint32(e)._push(Bf,e,t)}string(t){let e=Zi(t);return e!==0?this.uint32(e)._push(Xs,e,t):this._push(mo,1,0)}fork(){return this.states=new yo(this),this.head=this.tail=new Le(go,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Le(go,0,0),this.len=0),this}ldelim(){let t=this.head,e=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=t.next,this.tail=e,this.len+=n),this}finish(){let t=this.head.next,e=xf(this.len),n=0;for(;t!=null;)t.fn(t.val,e,n),n+=t.len,t=t.next;return e}};function mo(r,t,e){t[e]=r&255}function vf(r,t,e){for(;r>127;)t[e++]=r&127|128,r>>>=7;t[e]=r}var wo=class extends Le{next;constructor(t,e){super(vf,t,e),this.next=void 0}};function mn(r,t,e){for(;r.hi!==0;)t[e++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)t[e++]=r.lo&127|128,r.lo=r.lo>>>7;t[e++]=r.lo}function Nr(r,t,e){t[e]=r&255,t[e+1]=r>>>8&255,t[e+2]=r>>>16&255,t[e+3]=r>>>24}function Bf(r,t,e){t.set(r,e)}globalThis.Buffer!=null&&(Cr.prototype.bytes=function(r){let t=r.length>>>0;return this.uint32(t),t>0&&this._push(Ef,t,r),this},Cr.prototype.string=function(r){let t=globalThis.Buffer.byteLength(r);return this.uint32(t),t>0&&this._push(Af,t,r),this});function Ef(r,t,e){t.set(r,e)}function Af(r,t,e){r.length<40?Xs(r,t,e):t.utf8Write!=null?t.utf8Write(r,e):t.set(q(r),e)}function bo(){return new Cr}function yn(r,t){let e=bo();return t.encode(r,e,{lengthDelimited:!1}),e.finish()}var tr;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(tr||(tr={}));function wn(r,t,e,n){return{name:r,type:t,encode:e,decode:n}}function xo(r){function t(s){if(r[s.toString()]==null)throw new Error("Invalid enum value");return r[s]}let e=function(o,i){let a=t(o);i.int32(a)},n=function(o){let i=o.int32();return t(i)};return wn("enum",tr.VARINT,e,n)}function bn(r,t){return wn("message",tr.LENGTH_DELIMITED,r,t)}var ot;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1"})(ot||(ot={}));var vo;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1"})(vo||(vo={}));(function(r){r.codec=()=>xo(vo)})(ot||(ot={}));var me;(function(r){let t;r.codec=()=>(t==null&&(t=bn((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),ot.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{let o={},i=n==null?e.len:e.pos+n;for(;e.pos<i;){let a=e.uint32();switch(a>>>3){case 1:{o.Type=ot.codec().decode(e);break}case 2:{o.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return o})),t),r.encode=e=>yn(e,r.codec()),r.decode=(e,n)=>pn(e,r.codec(),n)})(me||(me={}));var Tr;(function(r){let t;r.codec=()=>(t==null&&(t=bn((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),ot.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{let o={},i=n==null?e.len:e.pos+n;for(;e.pos<i;){let a=e.uint32();switch(a>>>3){case 1:{o.Type=ot.codec().decode(e);break}case 2:{o.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return o})),t),r.encode=e=>yn(e,r.codec()),r.decode=(e,n)=>pn(e,r.codec(),n)})(Tr||(Tr={}));var Kr={};ft(Kr,{MAX_RSA_KEY_SIZE:()=>cs,generateRSAKeyPair:()=>Ya,jwkToJWKKeyPair:()=>Xa,jwkToPkcs1:()=>Kf,jwkToPkix:()=>To,jwkToRSAPrivateKey:()=>Ja,pkcs1ToJwk:()=>Ga,pkcs1ToRSAPrivateKey:()=>ls,pkixToJwk:()=>Za,pkixToRSAPublicKey:()=>Wa});var kf=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),ye=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),we=new Uint32Array(64),Bo=class extends ie{constructor(){super(64,32,8,!1),this.A=ye[0]|0,this.B=ye[1]|0,this.C=ye[2]|0,this.D=ye[3]|0,this.E=ye[4]|0,this.F=ye[5]|0,this.G=ye[6]|0,this.H=ye[7]|0}get(){let{A:t,B:e,C:n,D:s,E:o,F:i,G:a,H:c}=this;return[t,e,n,s,o,i,a,c]}set(t,e,n,s,o,i,a,c){this.A=t|0,this.B=e|0,this.C=n|0,this.D=s|0,this.E=o|0,this.F=i|0,this.G=a|0,this.H=c|0}process(t,e){for(let f=0;f<16;f++,e+=4)we[f]=t.getUint32(e,!1);for(let f=16;f<64;f++){let h=we[f-15],y=we[f-2],w=It(h,7)^It(h,18)^h>>>3,m=It(y,17)^It(y,19)^y>>>10;we[f]=m+we[f-7]+w+we[f-16]|0}let{A:n,B:s,C:o,D:i,E:a,F:c,G:u,H:l}=this;for(let f=0;f<64;f++){let h=It(a,6)^It(a,11)^It(a,25),y=l+h+Qr(a,c,u)+kf[f]+we[f]|0,m=(It(n,2)^It(n,13)^It(n,22))+tn(n,s,o)|0;l=u,u=c,c=a,a=i+y|0,i=o,o=s,s=n,n=y+m|0}n=n+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(n,s,o,i,a,c,u,l)}roundClean(){we.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var be=Je(()=>new Bo);var M=xs(na());function He(r,t){let e=0;if(r.length===1)return r[0];for(let n=r.length-1;n>=0;n--)e+=r[r.length-1-n]*Math.pow(2,t*n);return e}function xe(r,t,e=-1){let n=e,s=r,o=0,i=Math.pow(2,t);for(let a=1;a<8;a++){if(r<i){let c;if(n<0)c=new ArrayBuffer(a),o=a;else{if(n<a)return new ArrayBuffer(0);c=new ArrayBuffer(n),o=n}let u=new Uint8Array(c);for(let l=a-1;l>=0;l--){let f=Math.pow(2,l*t);u[o-l-1]=Math.floor(s/f),s-=u[o-l-1]*f}return c}i*=Math.pow(2,t)}return new ArrayBuffer(0)}function Bn(...r){let t=0,e=0;for(let o of r)t+=o.length;let n=new ArrayBuffer(t),s=new Uint8Array(n);for(let o of r)s.set(o,e),e+=o.length;return s}function Ao(){let r=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){let a=r[0]===255&&r[1]&128,c=r[0]===0&&(r[1]&128)===0;(a||c)&&this.warnings.push("Needlessly long format")}let t=new ArrayBuffer(this.valueHex.byteLength),e=new Uint8Array(t);for(let a=0;a<this.valueHex.byteLength;a++)e[a]=0;e[0]=r[0]&128;let n=He(e,8),s=new ArrayBuffer(this.valueHex.byteLength),o=new Uint8Array(s);for(let a=0;a<this.valueHex.byteLength;a++)o[a]=r[a];return o[0]&=127,He(o,8)-n}function sa(r){let t=r<0?r*-1:r,e=128;for(let n=1;n<8;n++){if(t<=e){if(r<0){let i=e-t,a=xe(i,8,n),c=new Uint8Array(a);return c[0]|=128,a}let s=xe(t,8,n),o=new Uint8Array(s);if(o[0]&128){let i=s.slice(0),a=new Uint8Array(i);s=new ArrayBuffer(s.byteLength+1),o=new Uint8Array(s);for(let c=0;c<i.byteLength;c++)o[c+1]=a[c];o[0]=0}return s}e*=Math.pow(2,8)}return new ArrayBuffer(0)}function oa(r,t){if(r.byteLength!==t.byteLength)return!1;let e=new Uint8Array(r),n=new Uint8Array(t);for(let s=0;s<e.length;s++)if(e[s]!==n[s])return!1;return!0}function vt(r,t){let e=r.toString(10);if(t<e.length)return"";let n=t-e.length,s=new Array(n);for(let i=0;i<n;i++)s[i]="0";return s.join("").concat(e)}var Ap=Math.log(2);function En(){if(typeof BigInt>"u")throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function ko(r){let t=0,e=0;for(let s=0;s<r.length;s++){let o=r[s];t+=o.byteLength}let n=new Uint8Array(t);for(let s=0;s<r.length;s++){let o=r[s];n.set(new Uint8Array(o),e),e+=o.byteLength}return n.buffer}function Qt(r,t,e,n){return t instanceof Uint8Array?t.byteLength?e<0?(r.error="Wrong parameter: inputOffset less than zero",!1):n<0?(r.error="Wrong parameter: inputLength less than zero",!1):t.byteLength-e-n<0?(r.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):!0:(r.error="Wrong parameter: inputBuffer has zero length",!1):(r.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}var Rr=class{constructor(){this.items=[]}write(t){this.items.push(t)}final(){return ko(this.items)}},Ur=[new Uint8Array([1])],ia="0123456789";var nr="",Ut=new ArrayBuffer(0),So=new Uint8Array(0),Lr="EndOfContent",ca="OCTET STRING",la="BIT STRING";function te(r){var t;return t=class extends r{constructor(...n){var s;super(...n);let o=n[0]||{};this.isHexOnly=(s=o.isHexOnly)!==null&&s!==void 0?s:!1,this.valueHexView=o.valueHex?M.BufferSourceConverter.toUint8Array(o.valueHex):So}get valueHex(){return this.valueHexView.slice().buffer}set valueHex(n){this.valueHexView=new Uint8Array(n)}fromBER(n,s,o){let i=n instanceof ArrayBuffer?new Uint8Array(n):n;if(!Qt(this,i,s,o))return-1;let a=s+o;return this.valueHexView=i.subarray(s,a),this.valueHexView.length?(this.blockLength=o,a):(this.warnings.push("Zero buffer length"),s)}toBER(n=!1){return this.isHexOnly?n?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",Ut)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:M.Convert.ToHex(this.valueHexView)}}},t.NAME="hexBlock",t}var Wt=class{constructor({blockLength:t=0,error:e=nr,warnings:n=[],valueBeforeDecode:s=So}={}){this.blockLength=t,this.error=e,this.warnings=n,this.valueBeforeDecodeView=M.BufferSourceConverter.toUint8Array(s)}static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(t){this.valueBeforeDecodeView=new Uint8Array(t)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:M.Convert.ToHex(this.valueBeforeDecodeView)}}};Wt.NAME="baseBlock";var dt=class extends Wt{fromBER(t,e,n){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(t,e){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}};dt.NAME="valueBlock";var An=class extends te(Wt){constructor({idBlock:t={}}={}){var e,n,s,o;super(),t?(this.isHexOnly=(e=t.isHexOnly)!==null&&e!==void 0?e:!1,this.valueHexView=t.valueHex?M.BufferSourceConverter.toUint8Array(t.valueHex):So,this.tagClass=(n=t.tagClass)!==null&&n!==void 0?n:-1,this.tagNumber=(s=t.tagNumber)!==null&&s!==void 0?s:-1,this.isConstructed=(o=t.isConstructed)!==null&&o!==void 0?o:!1):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(t=!1){let e=0;switch(this.tagClass){case 1:e|=0;break;case 2:e|=64;break;case 3:e|=128;break;case 4:e|=192;break;default:return this.error="Unknown tag class",Ut}if(this.isConstructed&&(e|=32),this.tagNumber<31&&!this.isHexOnly){let s=new Uint8Array(1);if(!t){let o=this.tagNumber;o&=31,e|=o,s[0]=e}return s.buffer}if(!this.isHexOnly){let s=xe(this.tagNumber,7),o=new Uint8Array(s),i=s.byteLength,a=new Uint8Array(i+1);if(a[0]=e|31,!t){for(let c=0;c<i-1;c++)a[c+1]=o[c]|128;a[i]=o[i-1]}return a.buffer}let n=new Uint8Array(this.valueHexView.byteLength+1);if(n[0]=e|31,!t){let s=this.valueHexView;for(let o=0;o<s.length-1;o++)n[o+1]=s[o]|128;n[this.valueHexView.byteLength]=s[s.length-1]}return n.buffer}fromBER(t,e,n){let s=M.BufferSourceConverter.toUint8Array(t);if(!Qt(this,s,e,n))return-1;let o=s.subarray(e,e+n);if(o.length===0)return this.error="Zero buffer length",-1;switch(o[0]&192){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=(o[0]&32)===32,this.isHexOnly=!1;let a=o[0]&31;if(a!==31)this.tagNumber=a,this.blockLength=1;else{let c=1,u=this.valueHexView=new Uint8Array(255),l=255;for(;o[c]&128;){if(u[c-1]=o[c]&127,c++,c>=o.length)return this.error="End of input reached before message was fully decoded",-1;if(c===l){l+=255;let h=new Uint8Array(l);for(let y=0;y<u.length;y++)h[y]=u[y];u=this.valueHexView=new Uint8Array(l)}}this.blockLength=c+1,u[c-1]=o[c]&127;let f=new Uint8Array(c);for(let h=0;h<c;h++)f[h]=u[h];u=this.valueHexView=new Uint8Array(c),u.set(f),this.blockLength<=9?this.tagNumber=He(u,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(this.tagClass===1&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return e+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}};An.NAME="identificationBlock";var kn=class extends Wt{constructor({lenBlock:t={}}={}){var e,n,s;super(),this.isIndefiniteForm=(e=t.isIndefiniteForm)!==null&&e!==void 0?e:!1,this.longFormUsed=(n=t.longFormUsed)!==null&&n!==void 0?n:!1,this.length=(s=t.length)!==null&&s!==void 0?s:0}fromBER(t,e,n){let s=M.BufferSourceConverter.toUint8Array(t);if(!Qt(this,s,e,n))return-1;let o=s.subarray(e,e+n);if(o.length===0)return this.error="Zero buffer length",-1;if(o[0]===255)return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=o[0]===128,this.isIndefiniteForm)return this.blockLength=1,e+this.blockLength;if(this.longFormUsed=!!(o[0]&128),this.longFormUsed===!1)return this.length=o[0],this.blockLength=1,e+this.blockLength;let i=o[0]&127;if(i>8)return this.error="Too big integer",-1;if(i+1>o.length)return this.error="End of input reached before message was fully decoded",-1;let a=e+1,c=s.subarray(a,a+i);return c[i-1]===0&&this.warnings.push("Needlessly long encoded length"),this.length=He(c,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=i+1,e+this.blockLength}toBER(t=!1){let e,n;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return e=new ArrayBuffer(1),t===!1&&(n=new Uint8Array(e),n[0]=128),e;if(this.longFormUsed){let s=xe(this.length,8);if(s.byteLength>127)return this.error="Too big length",Ut;if(e=new ArrayBuffer(s.byteLength+1),t)return e;let o=new Uint8Array(s);n=new Uint8Array(e),n[0]=s.byteLength|128;for(let i=0;i<s.byteLength;i++)n[i+1]=o[i];return e}return e=new ArrayBuffer(1),t===!1&&(n=new Uint8Array(e),n[0]=this.length),e}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}};kn.NAME="lengthBlock";var A={},ct=class extends Wt{constructor({name:t=nr,optional:e=!1,primitiveSchema:n,...s}={},o){super(s),this.name=t,this.optional=e,n&&(this.primitiveSchema=n),this.idBlock=new An(s),this.lenBlock=new kn(s),this.valueBlock=o?new o(s):new dt(s)}fromBER(t,e,n){let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}toBER(t,e){let n=e||new Rr;e||ua(this);let s=this.idBlock.toBER(t);if(n.write(s),this.lenBlock.isIndefiniteForm)n.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(t,n),n.write(new ArrayBuffer(2));else{let o=this.valueBlock.toBER(t);this.lenBlock.length=o.byteLength;let i=this.lenBlock.toBER(t);n.write(i),n.write(o)}return e?Ut:n.final()}toJSON(){let t={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(t.primitiveSchema=this.primitiveSchema.toJSON()),t}toString(t="ascii"){return t==="ascii"?this.onAsciiEncoding():M.Convert.ToHex(this.toBER())}onAsciiEncoding(){return`${this.constructor.NAME} : ${M.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`}isEqual(t){if(this===t)return!0;if(!(t instanceof this.constructor))return!1;let e=this.toBER(),n=t.toBER();return oa(e,n)}};ct.NAME="BaseBlock";function ua(r){if(r instanceof A.Constructed)for(let t of r.valueBlock.value)ua(t)&&(r.lenBlock.isIndefiniteForm=!0);return!!r.lenBlock.isIndefiniteForm}var Sn=class extends ct{constructor({value:t=nr,...e}={},n){super(e,n),t&&this.fromString(t)}getValue(){return this.valueBlock.value}setValue(t){this.valueBlock.value=t}fromBER(t,e,n){let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}};Sn.NAME="BaseStringBlock";var In=class extends te(dt){constructor({isHexOnly:t=!0,...e}={}){super(e),this.isHexOnly=t}};In.NAME="PrimitiveValueBlock";var fa,Nn=class extends ct{constructor(t={}){super(t,In),this.idBlock.isConstructed=!1}};fa=Nn;A.Primitive=fa;Nn.NAME="PRIMITIVE";function Hf(r,t){if(r instanceof t)return r;let e=new t;return e.idBlock=r.idBlock,e.lenBlock=r.lenBlock,e.warnings=r.warnings,e.valueBeforeDecodeView=r.valueBeforeDecodeView,e}function as(r,t=0,e=r.length){let n=t,s=new ct({},dt),o=new Wt;if(!Qt(o,r,t,e))return s.error=o.error,{offset:-1,result:s};if(!r.subarray(t,t+e).length)return s.error="Zero buffer length",{offset:-1,result:s};let a=s.idBlock.fromBER(r,t,e);if(s.idBlock.warnings.length&&s.warnings.concat(s.idBlock.warnings),a===-1)return s.error=s.idBlock.error,{offset:-1,result:s};if(t=a,e-=s.idBlock.blockLength,a=s.lenBlock.fromBER(r,t,e),s.lenBlock.warnings.length&&s.warnings.concat(s.lenBlock.warnings),a===-1)return s.error=s.lenBlock.error,{offset:-1,result:s};if(t=a,e-=s.lenBlock.blockLength,!s.idBlock.isConstructed&&s.lenBlock.isIndefiniteForm)return s.error="Indefinite length form used for primitive encoding form",{offset:-1,result:s};let c=ct;switch(s.idBlock.tagClass){case 1:if(s.idBlock.tagNumber>=37&&s.idBlock.isHexOnly===!1)return s.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:s};switch(s.idBlock.tagNumber){case 0:if(s.idBlock.isConstructed&&s.lenBlock.length>0)return s.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:s};c=A.EndOfContent;break;case 1:c=A.Boolean;break;case 2:c=A.Integer;break;case 3:c=A.BitString;break;case 4:c=A.OctetString;break;case 5:c=A.Null;break;case 6:c=A.ObjectIdentifier;break;case 10:c=A.Enumerated;break;case 12:c=A.Utf8String;break;case 13:c=A.RelativeObjectIdentifier;break;case 14:c=A.TIME;break;case 15:return s.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:s};case 16:c=A.Sequence;break;case 17:c=A.Set;break;case 18:c=A.NumericString;break;case 19:c=A.PrintableString;break;case 20:c=A.TeletexString;break;case 21:c=A.VideotexString;break;case 22:c=A.IA5String;break;case 23:c=A.UTCTime;break;case 24:c=A.GeneralizedTime;break;case 25:c=A.GraphicString;break;case 26:c=A.VisibleString;break;case 27:c=A.GeneralString;break;case 28:c=A.UniversalString;break;case 29:c=A.CharacterString;break;case 30:c=A.BmpString;break;case 31:c=A.DATE;break;case 32:c=A.TimeOfDay;break;case 33:c=A.DateTime;break;case 34:c=A.Duration;break;default:{let u=s.idBlock.isConstructed?new A.Constructed:new A.Primitive;u.idBlock=s.idBlock,u.lenBlock=s.lenBlock,u.warnings=s.warnings,s=u}}break;case 2:case 3:case 4:default:c=s.idBlock.isConstructed?A.Constructed:A.Primitive}return s=Hf(s,c),a=s.fromBER(r,t,s.lenBlock.isIndefiniteForm?e:s.lenBlock.length),s.valueBeforeDecodeView=r.subarray(n,n+s.blockLength),{offset:a,result:s}}function Ve(r){if(!r.byteLength){let t=new ct({},dt);return t.error="Input buffer has zero length",{offset:-1,result:t}}return as(M.BufferSourceConverter.toUint8Array(r).slice(),0,r.byteLength)}function Vf(r,t){return r?1:t}var _t=class extends dt{constructor({value:t=[],isIndefiniteForm:e=!1,...n}={}){super(n),this.value=t,this.isIndefiniteForm=e}fromBER(t,e,n){let s=M.BufferSourceConverter.toUint8Array(t);if(!Qt(this,s,e,n))return-1;if(this.valueBeforeDecodeView=s.subarray(e,e+n),this.valueBeforeDecodeView.length===0)return this.warnings.push("Zero buffer length"),e;let o=e;for(;Vf(this.isIndefiniteForm,n)>0;){let i=as(s,o,n);if(i.offset===-1)return this.error=i.result.error,this.warnings.concat(i.result.warnings),-1;if(o=i.offset,this.blockLength+=i.result.blockLength,n-=i.result.blockLength,this.value.push(i.result),this.isIndefiniteForm&&i.result.constructor.NAME===Lr)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===Lr?this.value.pop():this.warnings.push("No EndOfContent block encoded")),o}toBER(t,e){let n=e||new Rr;for(let s=0;s<this.value.length;s++)this.value[s].toBER(t,n);return e?Ut:n.final()}toJSON(){let t={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(let e of this.value)t.value.push(e.toJSON());return t}};_t.NAME="ConstructedValueBlock";var ha,ve=class extends ct{constructor(t={}){super(t,_t),this.idBlock.isConstructed=!0}fromBER(t,e,n){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){let t=[];for(let n of this.valueBlock.value)t.push(n.toString("ascii").split(`
./node_modules/@libp2p/kad-dht/dist/index.min.js:2:"use strict";var Libp2PKadDht=(()=>{var L4=Object.create;var Gn=Object.defineProperty;var C4=Object.getOwnPropertyDescriptor;var _4=Object.getOwnPropertyNames;var U4=Object.getPrototypeOf,D4=Object.prototype.hasOwnProperty;var xs=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),Te=(r,e)=>{for(var t in e)Gn(r,t,{get:e[t],enumerable:!0})},z2=(r,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of _4(e))!D4.call(r,i)&&i!==t&&Gn(r,i,{get:()=>e[i],enumerable:!(n=C4(e,i))||n.enumerable});return r};var vs=(r,e,t)=>(t=r!=null?L4(U4(r)):{},z2(e||!r||!r.__esModule?Gn(t,"default",{value:r,enumerable:!0}):t,r)),O4=r=>z2(Gn({},"__esModule",{value:!0}),r);var J2=xs((Zc,As)=>{"use strict";var F4=Object.prototype.hasOwnProperty,Re="~";function on(){}Object.create&&(on.prototype=Object.create(null),new on().__proto__||(Re=!1));function H4(r,e,t){this.fn=r,this.context=e,this.once=t||!1}function X2(r,e,t,n,i){if(typeof t!="function")throw new TypeError("The listener must be a function");var s=new H4(t,n||r,i),o=Re?Re+e:e;return r._events[o]?r._events[o].fn?r._events[o]=[r._events[o],s]:r._events[o].push(s):(r._events[o]=s,r._eventsCount++),r}function Qn(r,e){--r._eventsCount===0?r._events=new on:delete r._events[e]}function Ee(){this._events=new on,this._eventsCount=0}Ee.prototype.eventNames=function(){var e=[],t,n;if(this._eventsCount===0)return e;for(n in t=this._events)F4.call(t,n)&&e.push(Re?n.slice(1):n);return Object.getOwnPropertySymbols?e.concat(Object.getOwnPropertySymbols(t)):e};Ee.prototype.listeners=function(e){var t=Re?Re+e:e,n=this._events[t];if(!n)return[];if(n.fn)return[n.fn];for(var i=0,s=n.length,o=new Array(s);i<s;i++)o[i]=n[i].fn;return o};Ee.prototype.listenerCount=function(e){var t=Re?Re+e:e,n=this._events[t];return n?n.fn?1:n.length:0};Ee.prototype.emit=function(e,t,n,i,s,o){var a=Re?Re+e:e;if(!this._events[a])return!1;var c=this._events[a],l=arguments.length,u,f;if(c.fn){switch(c.once&&this.removeListener(e,c.fn,void 0,!0),l){case 1:return c.fn.call(c.context),!0;case 2:return c.fn.call(c.context,t),!0;case 3:return c.fn.call(c.context,t,n),!0;case 4:return c.fn.call(c.context,t,n,i),!0;case 5:return c.fn.call(c.context,t,n,i,s),!0;case 6:return c.fn.call(c.context,t,n,i,s,o),!0}for(f=1,u=new Array(l-1);f<l;f++)u[f-1]=arguments[f];c.fn.apply(c.context,u)}else{var h=c.length,p;for(f=0;f<h;f++)switch(c[f].once&&this.removeListener(e,c[f].fn,void 0,!0),l){case 1:c[f].fn.call(c[f].context);break;case 2:c[f].fn.call(c[f].context,t);break;case 3:c[f].fn.call(c[f].context,t,n);break;case 4:c[f].fn.call(c[f].context,t,n,i);break;default:if(!u)for(p=1,u=new Array(l-1);p<l;p++)u[p-1]=arguments[p];c[f].fn.apply(c[f].context,u)}}return!0};Ee.prototype.on=function(e,t,n){return X2(this,e,t,n,!1)};Ee.prototype.once=function(e,t,n){return X2(this,e,t,n,!0)};Ee.prototype.removeListener=function(e,t,n,i){var s=Re?Re+e:e;if(!this._events[s])return this;if(!t)return Qn(this,s),this;var o=this._events[s];if(o.fn)o.fn===t&&(!i||o.once)&&(!n||o.context===n)&&Qn(this,s);else{for(var a=0,c=[],l=o.length;a<l;a++)(o[a].fn!==t||i&&!o[a].once||n&&o[a].context!==n)&&c.push(o[a]);c.length?this._events[s]=c.length===1?c[0]:c:Qn(this,s)}return this};Ee.prototype.removeAllListeners=function(e){var t;return e?(t=Re?Re+e:e,this._events[t]&&Qn(this,t)):(this._events=new on,this._eventsCount=0),this};Ee.prototype.off=Ee.prototype.removeListener;Ee.prototype.addListener=Ee.prototype.on;Ee.prefixed=Re;Ee.EventEmitter=Ee;typeof As<"u"&&(As.exports=Ee)});var T3=xs($r=>{"use strict";var S8="[object ArrayBuffer]",At=class r{static isArrayBuffer(e){return Object.prototype.toString.call(e)===S8}static toArrayBuffer(e){return this.isArrayBuffer(e)?e:e.byteLength===e.buffer.byteLength||e.byteOffset===0&&e.byteLength===e.buffer.byteLength?e.buffer:this.toUint8Array(e.buffer).slice(e.byteOffset,e.byteOffset+e.byteLength).buffer}static toUint8Array(e){return this.toView(e,Uint8Array)}static toView(e,t){if(e.constructor===t)return e;if(this.isArrayBuffer(e))return new t(e);if(this.isArrayBufferView(e))return new t(e.buffer,e.byteOffset,e.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(e){return this.isArrayBufferView(e)||this.isArrayBuffer(e)}static isArrayBufferView(e){return ArrayBuffer.isView(e)||e&&this.isArrayBuffer(e.buffer)}static isEqual(e,t){let n=r.toUint8Array(e),i=r.toUint8Array(t);if(n.length!==i.byteLength)return!1;for(let s=0;s<n.length;s++)if(n[s]!==i[s])return!1;return!0}static concat(...e){let t;Array.isArray(e[0])&&!(e[1]instanceof Function)||Array.isArray(e[0])&&e[1]instanceof Function?t=e[0]:e[e.length-1]instanceof Function?t=e.slice(0,e.length-1):t=e;let n=0;for(let o of t)n+=o.byteLength;let i=new Uint8Array(n),s=0;for(let o of t){let a=this.toUint8Array(o);i.set(a,s),s+=a.length}return e[e.length-1]instanceof Function?this.toView(i,e[e.length-1]):i.buffer}},Yo="string",I8=/^[0-9a-f\s]+$/i,B8=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,k8=/^[a-zA-Z0-9-_]+$/,S1=class{static fromString(e){let t=unescape(encodeURIComponent(e)),n=new Uint8Array(t.length);for(let i=0;i<t.length;i++)n[i]=t.charCodeAt(i);return n.buffer}static toString(e){let t=At.toUint8Array(e),n="";for(let s=0;s<t.length;s++)n+=String.fromCharCode(t[s]);return decodeURIComponent(escape(n))}},Ge=class{static toString(e,t=!1){let n=At.toArrayBuffer(e),i=new DataView(n),s="";for(let o=0;o<n.byteLength;o+=2){let a=i.getUint16(o,t);s+=String.fromCharCode(a)}return s}static fromString(e,t=!1){let n=new ArrayBuffer(e.length*2),i=new DataView(n);for(let s=0;s<e.length;s++)i.setUint16(s*2,e.charCodeAt(s),t);return n}},I1=class r{static isHex(e){return typeof e===Yo&&I8.test(e)}static isBase64(e){return typeof e===Yo&&B8.test(e)}static isBase64Url(e){return typeof e===Yo&&k8.test(e)}static ToString(e,t="utf8"){let n=At.toUint8Array(e);switch(t.toLowerCase()){case"utf8":return this.ToUtf8String(n);case"binary":return this.ToBinary(n);case"hex":return this.ToHex(n);case"base64":return this.ToBase64(n);case"base64url":return this.ToBase64Url(n);case"utf16le":return Ge.toString(n,!0);case"utf16":case"utf16be":return Ge.toString(n);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromString(e,t="utf8"){if(!e)return new ArrayBuffer(0);switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(e);case"binary":return this.FromBinary(e);case"hex":return this.FromHex(e);case"base64":return this.FromBase64(e);case"base64url":return this.FromBase64Url(e);case"utf16le":return Ge.fromString(e,!0);case"utf16":case"utf16be":return Ge.fromString(e);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(e){let t=At.toUint8Array(e);if(typeof btoa<"u"){let n=this.ToString(t,"binary");return btoa(n)}else return Buffer.from(t).toString("base64")}static FromBase64(e){let t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!r.isBase64(t))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return typeof atob<"u"?this.FromBinary(atob(t)):new Uint8Array(Buffer.from(t,"base64")).buffer}static FromBase64Url(e){let t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!r.isBase64Url(t))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(t.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(e){return this.ToBase64(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(e,t=r.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.FromBinary(e);case"utf8":return S1.fromString(e);case"utf16":case"utf16be":return Ge.fromString(e);case"utf16le":case"usc2":return Ge.fromString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToUtf8String(e,t=r.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.ToBinary(e);case"utf8":return S1.toString(e);case"utf16":case"utf16be":return Ge.toString(e);case"utf16le":case"usc2":return Ge.toString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromBinary(e){let t=e.length,n=new Uint8Array(t);for(let i=0;i<t;i++)n[i]=e.charCodeAt(i);return n.buffer}static ToBinary(e){let t=At.toUint8Array(e),n="";for(let i=0;i<t.length;i++)n+=String.fromCharCode(t[i]);return n}static ToHex(e){let t=At.toUint8Array(e),n="",i=t.length;for(let s=0;s<i;s++){let o=t[s];o<16&&(n+="0"),n+=o.toString(16)}return n}static FromHex(e){let t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!r.isHex(t))throw new TypeError("Argument 'hexString' is not HEX encoded");t.length%2&&(t=`0${t}`);let n=new Uint8Array(t.length/2);for(let i=0;i<t.length;i=i+2){let s=t.slice(i,i+2);n[i/2]=parseInt(s,16)}return n.buffer}static ToUtf16String(e,t=!1){return Ge.toString(e,t)}static FromUtf16String(e,t=!1){return Ge.fromString(e,t)}static Base64Padding(e){let t=4-e.length%4;if(t<4)for(let n=0;n<t;n++)e+="=";return e}static formatString(e){return e?.replace(/[\n\r\t ]/g,"")||""}};I1.DEFAULT_UTF8_ENCODING="utf8";function T8(r,...e){let t=arguments[0];for(let n=1;n<arguments.length;n++){let i=arguments[n];for(let s in i)t[s]=i[s]}return t}function R8(...r){let e=r.map(i=>i.byteLength).reduce((i,s)=>i+s),t=new Uint8Array(e),n=0;return r.map(i=>new Uint8Array(i)).forEach(i=>{for(let s of i)t[n++]=s}),t.buffer}function P8(r,e){if(!(r&&e)||r.byteLength!==e.byteLength)return!1;let t=new Uint8Array(r),n=new Uint8Array(e);for(let i=0;i<r.byteLength;i++)if(t[i]!==n[i])return!1;return!0}$r.BufferSourceConverter=At;$r.Convert=I1;$r.assign=T8;$r.combine=R8;$r.isEqual=P8});var qa=xs(Mn=>{(function(){var r,e,t,n,i,s,o,a;a=function(c){var l,u,f,h;return l=(c&255<<24)>>>24,u=(c&255<<16)>>>16,f=(c&65280)>>>8,h=c&255,[l,u,f,h].join(".")},o=function(c){var l,u,f,h,p,m;for(l=[],f=h=0;h<=3&&c.length!==0;f=++h){if(f>0){if(c[0]!==".")throw new Error("Invalid IP");c=c.substring(1)}m=e(c),p=m[0],u=m[1],c=c.substring(u),l.push(p)}if(c.length!==0)throw new Error("Invalid IP");switch(l.length){case 1:if(l[0]>4294967295)throw new Error("Invalid IP");return l[0]>>>0;case 2:if(l[0]>255||l[1]>16777215)throw new Error("Invalid IP");return(l[0]<<24|l[1])>>>0;case 3:if(l[0]>255||l[1]>255||l[2]>65535)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2])>>>0;case 4:if(l[0]>255||l[1]>255||l[2]>255||l[3]>255)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2]<<8|l[3])>>>0;default:throw new Error("Invalid IP")}},t=function(c){return c.charCodeAt(0)},n=t("0"),s=t("a"),i=t("A"),e=function(c){var l,u,f,h,p;for(h=0,l=10,u="9",f=0,c.length>1&&c[f]==="0"&&(c[f+1]==="x"||c[f+1]==="X"?(f+=2,l=16):"0"<=c[f+1]&&c[f+1]<="9"&&(f++,l=8,u="7")),p=f;f<c.length;){if("0"<=c[f]&&c[f]<=u)h=h*l+(t(c[f])-n)>>>0;else if(l===16)if("a"<=c[f]&&c[f]<="f")h=h*l+(10+t(c[f])-s)>>>0;else if("A"<=c[f]&&c[f]<="F")h=h*l+(10+t(c[f])-i)>>>0;else break;else break;if(h>4294967295)throw new Error("too large");f++}if(f===p)throw new Error("empty octet");return[h,f]},r=function(){function c(l,u){var f,h,p,m;if(typeof l!="string")throw new Error("Missing `net' parameter");if(u||(m=l.split("/",2),l=m[0],u=m[1]),u||(u=32),typeof u=="string"&&u.indexOf(".")>-1){try{this.maskLong=o(u)}catch(w){throw f=w,new Error("Invalid mask: "+u)}for(h=p=32;p>=0;h=--p)if(this.maskLong===4294967295<<32-h>>>0){this.bitmask=h;break}}else if(u||u===0)this.bitmask=parseInt(u,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(o(l)&this.maskLong)>>>0}catch(w){throw f=w,new Error("Invalid net address: "+l)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+u);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return c.prototype.contains=function(l){return typeof l=="string"&&(l.indexOf("/")>0||l.split(".").length!==4)&&(l=new c(l)),l instanceof c?this.contains(l.base)&&this.contains(l.broadcast||l.last):(o(l)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},c.prototype.next=function(l){return l==null&&(l=1),new c(a(this.netLong+this.size*l),this.mask)},c.prototype.forEach=function(l){var u,f,h;for(h=o(this.first),f=o(this.last),u=0;h<=f;)l(a(h),h,u),u++,h++},c.prototype.toString=function(){return this.base+"/"+this.bitmask},c}(),Mn.ip2long=o,Mn.long2ip=a,Mn.Netmask=r}).call(Mn)});var pc={};Te(pc,{EventTypes:()=>Kn,MessageType:()=>V,Record:()=>ue,kadDHT:()=>dc,passthroughMapper:()=>Ga,removePrivateAddressesMapper:()=>ki,removePublicAddressesMapper:()=>$a});var $2=Symbol.for("@libp2p/content-routing");var G2=Symbol.for("@libp2p/peer-discovery");var Es=Symbol.for("@libp2p/peer-id");var j2=Symbol.for("@libp2p/peer-routing");var W2="keep-alive";var ht=class extends Error{static name="AbortError";constructor(e="The operation was aborted"){super(e),this.name="AbortError"}};var z=class extends Error{static name="InvalidParametersError";constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},dt=class extends Error{static name="InvalidPublicKeyError";constructor(e="Invalid public key"){super(e),this.name="InvalidPublicKeyError"}};var je=class extends Error{static name="NotFoundError";constructor(e="Not found"){super(e),this.name="NotFoundError"}};var jn=class extends Error{static name="InvalidMultihashError";constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}};var Le=class extends Error{static name="InvalidMessageError";constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}};var rr=class extends Error{static name="UnsupportedKeyTypeError";constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}};var re=(r,...e)=>{try{[...e]}catch{}};var Ce=class extends EventTarget{#e=new Map;constructor(){super(),re(1/0,this)}listenerCount(e){let t=this.#e.get(e);return t==null?0:t.length}addEventListener(e,t,n){super.addEventListener(e,t,n);let i=this.#e.get(e);i==null&&(i=[],this.#e.set(e,i)),i.push({callback:t,once:(n!==!0&&n!==!1&&n?.once)??!1})}removeEventListener(e,t,n){super.removeEventListener(e.toString(),t??null,n);let i=this.#e.get(e);i!=null&&(i=i.filter(({callback:s})=>s!==t),this.#e.set(e,i))}dispatchEvent(e){let t=super.dispatchEvent(e),n=this.#e.get(e.type);return n==null||(n=n.filter(({once:i})=>!i),this.#e.set(e.type,n)),t}safeDispatchEvent(e,t={}){return this.dispatchEvent(new CustomEvent(e,t))}};function Q2(r){return r!=null&&typeof r.start=="function"&&typeof r.stop=="function"}async function nn(...r){let e=[];for(let t of r)Q2(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStart!=null&&await t.beforeStart()})),await Promise.all(e.map(async t=>{await t.start()})),await Promise.all(e.map(async t=>{t.afterStart!=null&&await t.afterStart()}))}async function Wn(...r){let e=[];for(let t of r)Q2(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStop!=null&&await t.beforeStop()})),await Promise.all(e.map(async t=>{await t.stop()})),await Promise.all(e.map(async t=>{t.afterStop!=null&&await t.afterStop()}))}var Z2=Symbol.for("@libp2p/service-capabilities"),Y2=Symbol.for("@libp2p/service-dependencies");function M4(r){return r[Symbol.asyncIterator]!=null}function V4(r){if(M4(r))return(async()=>{for await(let e of r);})();for(let e of r);}var sn=V4;var Ss=vs(J2(),1);var an=class extends Error{constructor(e){super(e),this.name="TimeoutError"}},Is=class extends Error{constructor(e){super(),this.name="AbortError",this.message=e}},e0=r=>globalThis.DOMException===void 0?new Is(r):new DOMException(r),t0=r=>{let e=r.reason===void 0?e0("This operation was aborted."):r.reason;return e instanceof Error?e:e0(e)};function nr(r,e){let{milliseconds:t,fallback:n,message:i,customTimers:s={setTimeout,clearTimeout}}=e,o,a,l=new Promise((u,f)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(e.signal){let{signal:p}=e;p.aborted&&f(t0(p)),a=()=>{f(t0(p))},p.addEventListener("abort",a,{once:!0})}if(t===Number.POSITIVE_INFINITY){r.then(u,f);return}let h=new an;o=s.setTimeout.call(void 0,()=>{if(n){try{u(n())}catch(p){f(p)}return}typeof r.cancel=="function"&&r.cancel(),i===!1?u():i instanceof Error?f(i):(h.message=i??`Promise timed out after ${t} milliseconds`,f(h))},t),(async()=>{try{u(await r)}catch(p){f(p)}})()}).finally(()=>{l.clear(),a&&e.signal&&e.signal.removeEventListener("abort",a)});return l.clear=()=>{s.clearTimeout.call(void 0,o),o=void 0},l}function Bs(r,e,t){let n=0,i=r.length;for(;i>0;){let s=Math.trunc(i/2),o=n+s;t(r[o],e)<=0?(n=++o,i-=s+1):i=s}return n}var cn=class{#e=[];enqueue(e,t){t={priority:0,...t};let n={priority:t.priority,run:e};if(this.size&&this.#e[this.size-1].priority>=t.priority){this.#e.push(n);return}let i=Bs(this.#e,n,(s,o)=>o.priority-s.priority);this.#e.splice(i,0,n)}dequeue(){return this.#e.shift()?.run}filter(e){return this.#e.filter(t=>t.priority===e.priority).map(t=>t.run)}get size(){return this.#e.length}};var Er=class extends Ss.default{#e;#r;#s=0;#a;#c;#p=0;#n;#l;#t;#m;#i=0;#u;#o;#g;timeout;constructor(e){if(super(),e={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:cn,...e},!(typeof e.intervalCap=="number"&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${e.intervalCap?.toString()??""}\` (${typeof e.intervalCap})`);if(e.interval===void 0||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${e.interval?.toString()??""}\` (${typeof e.interval})`);this.#e=e.carryoverConcurrencyCount,this.#r=e.intervalCap===Number.POSITIVE_INFINITY||e.interval===0,this.#a=e.intervalCap,this.#c=e.interval,this.#t=new e.queueClass,this.#m=e.queueClass,this.concurrency=e.concurrency,this.timeout=e.timeout,this.#g=e.throwOnTimeout===!0,this.#o=e.autoStart===!1}get#b(){return this.#r||this.#s<this.#a}get#x(){return this.#i<this.#u}#v(){this.#i--,this.#f(),this.emit("next")}#E(){this.#w(),this.#y(),this.#l=void 0}get#A(){let e=Date.now();if(this.#n===void 0){let t=this.#p-e;if(t<0)this.#s=this.#e?this.#i:0;else return this.#l===void 0&&(this.#l=setTimeout(()=>{this.#E()},t)),!0}return!1}#f(){if(this.#t.size===0)return this.#n&&clearInterval(this.#n),this.#n=void 0,this.emit("empty"),this.#i===0&&this.emit("idle"),!1;if(!this.#o){let e=!this.#A;if(this.#b&&this.#x){let t=this.#t.dequeue();return t?(this.emit("active"),t(),e&&this.#y(),!0):!1}}return!1}#y(){this.#r||this.#n!==void 0||(this.#n=setInterval(()=>{this.#w()},this.#c),this.#p=Date.now()+this.#c)}#w(){this.#s===0&&this.#i===0&&this.#n&&(clearInterval(this.#n),this.#n=void 0),this.#s=this.#e?this.#i:0,this.#h()}#h(){for(;this.#f(););}get concurrency(){return this.#u}set concurrency(e){if(!(typeof e=="number"&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);this.#u=e,this.#h()}async#S(e){return new Promise((t,n)=>{e.addEventListener("abort",()=>{n(e.reason)},{once:!0})})}async add(e,t={}){return t={timeout:this.timeout,throwOnTimeout:this.#g,...t},new Promise((n,i)=>{this.#t.enqueue(async()=>{this.#i++,this.#s++;try{t.signal?.throwIfAborted();let s=e({signal:t.signal});t.timeout&&(s=nr(Promise.resolve(s),{milliseconds:t.timeout})),t.signal&&(s=Promise.race([s,this.#S(t.signal)]));let o=await s;n(o),this.emit("completed",o)}catch(s){if(s instanceof an&&!t.throwOnTimeout){n();return}i(s),this.emit("error",s)}finally{this.#v()}},t),this.emit("add"),this.#f()})}async addAll(e,t){return Promise.all(e.map(async n=>this.add(n,t)))}start(){return this.#o?(this.#o=!1,this.#h(),this):this}pause(){this.#o=!0}clear(){this.#t=new this.#m}async onEmpty(){this.#t.size!==0&&await this.#d("empty")}async onSizeLessThan(e){this.#t.size<e||await this.#d("next",()=>this.#t.size<e)}async onIdle(){this.#i===0&&this.#t.size===0||await this.#d("idle")}async#d(e,t){return new Promise(n=>{let i=()=>{t&&!t()||(this.off(e,i),n())};this.on(e,i)})}get size(){return this.#t.size}sizeBy(e){return this.#t.filter(e).length}get pending(){return this.#i}get isPaused(){return this.#o}};var Ct={},Ar=r=>{r.addEventListener("message",e=>{Ar.dispatchEvent("message",r,e)}),r.port!=null&&r.port.addEventListener("message",e=>{Ar.dispatchEvent("message",r,e)})};Ar.addEventListener=(r,e)=>{Ct[r]==null&&(Ct[r]=[]),Ct[r].push(e)};Ar.removeEventListener=(r,e)=>{Ct[r]!=null&&(Ct[r]=Ct[r].filter(t=>t===e))};Ar.dispatchEvent=function(r,e,t){Ct[r]!=null&&Ct[r].forEach(n=>n(e,t))};var ks=Ar;var Ts="lock:worker:request-read",Rs="lock:worker:release-read",Ps="lock:master:grant-read",Ns="lock:worker:request-write",Ls="lock:worker:release-write",Cs="lock:master:grant-write";var r0=(r=21)=>Math.random().toString().substring(2);var n0=(r,e,t,n,i)=>(s,o)=>{if(o.data.type!==t)return;let a={type:o.data.type,name:o.data.name,identifier:o.data.identifier};r.dispatchEvent(new MessageEvent(e,{data:{name:a.name,handler:async()=>{s.postMessage({type:i,name:a.name,identifier:a.identifier}),await new Promise(c=>{let l=u=>{if(u?.data==null)return;let f={type:u.data.type,name:u.data.name,identifier:u.data.identifier};f.type===n&&f.identifier===a.identifier&&(s.removeEventListener("message",l),c())};s.addEventListener("message",l)})}}}))},i0=(r,e,t,n)=>async()=>{let i=r0();return globalThis.postMessage({type:e,identifier:i,name:r}),new Promise(s=>{let o=a=>{if(a?.data==null)return;let c={type:a.data.type,identifier:a.data.identifier};c.type===t&&c.identifier===i&&(globalThis.removeEventListener("message",o),s(()=>{globalThis.postMessage({type:n,identifier:i,name:r})}))};globalThis.addEventListener("message",o)})},q4={singleProcess:!1},s0=r=>{if(r=Object.assign({},q4,r),!!globalThis.document||r.singleProcess){let t=new EventTarget;return ks.addEventListener("message",n0(t,"requestReadLock",Ts,Rs,Ps)),ks.addEventListener("message",n0(t,"requestWriteLock",Ns,Ls,Cs)),t}return{isWorker:!0,readLock:t=>i0(t,Ts,Ps,Rs),writeLock:t=>i0(t,Ns,Cs,Ls)}};var ir={},_t;async function _s(r,e){let t,n=new Promise(i=>{t=i});return r.add(async()=>nr((async()=>{await new Promise(i=>{t(()=>{i()})})})(),{milliseconds:e.timeout})),n}var K4=(r,e)=>{if(_t.isWorker===!0)return{readLock:_t.readLock(r,e),writeLock:_t.writeLock(r,e)};let t=new Er({concurrency:1}),n;return{async readLock(){if(n!=null)return _s(n,e);n=new Er({concurrency:e.concurrency,autoStart:!1});let i=n,s=_s(n,e);return t.add(async()=>{i.start(),await i.onIdle().then(()=>{n===i&&(n=null)})}),s},async writeLock(){return n=null,_s(t,e)}}},z4={name:"lock",concurrency:1/0,timeout:846e5,singleProcess:!1};function Us(r){let e=Object.assign({},z4,r);return _t==null&&(_t=s0(e),_t.isWorker!==!0&&(_t.addEventListener("requestReadLock",t=>{ir[t.data.name]!=null&&ir[t.data.name].readLock().then(async n=>t.data.handler().finally(()=>{n()}))}),_t.addEventListener("requestWriteLock",async t=>{ir[t.data.name]!=null&&ir[t.data.name].writeLock().then(async n=>t.data.handler().finally(()=>{n()}))}))),ir[e.name]==null&&(ir[e.name]=K4(e.name,e)),ir[e.name]}function oe(){let r={};return r.promise=new Promise((e,t)=>{r.resolve=e,r.reject=t}),r}var Sr=1e3,Ds=60*Sr,Zn=60*Ds,o0=36*Zn,a0="/ipfs/kad/1.0.0",c0=48*Zn;var l0=24*Zn,u0=10,f0=16384,h0=Zn,bl=10*Sr;var Yn=20,Ir=3,d0=5*Ds,p0=Sr,m0=5*Sr,g0=5*Ds,y0=30*Sr,w0=180*Sr,Os=`${W2}-kad-dht`;function _e(r=0){return new Uint8Array(r)}function me(r=0){return new Uint8Array(r)}var $4=Math.pow(2,7),G4=Math.pow(2,14),j4=Math.pow(2,21),Ms=Math.pow(2,28),Vs=Math.pow(2,35),Fs=Math.pow(2,42),Hs=Math.pow(2,49),$=128,Ae=127;function ae(r){if(r<$4)return 1;if(r<G4)return 2;if(r<j4)return 3;if(r<Ms)return 4;if(r<Vs)return 5;if(r<Fs)return 6;if(r<Hs)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function qs(r,e,t=0){switch(ae(r)){case 8:e[t++]=r&255|$,r/=128;case 7:e[t++]=r&255|$,r/=128;case 6:e[t++]=r&255|$,r/=128;case 5:e[t++]=r&255|$,r/=128;case 4:e[t++]=r&255|$,r>>>=7;case 3:e[t++]=r&255|$,r>>>=7;case 2:e[t++]=r&255|$,r>>>=7;case 1:{e[t++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return e}function W4(r,e,t=0){switch(ae(r)){case 8:e.set(t++,r&255|$),r/=128;case 7:e.set(t++,r&255|$),r/=128;case 6:e.set(t++,r&255|$),r/=128;case 5:e.set(t++,r&255|$),r/=128;case 4:e.set(t++,r&255|$),r>>>=7;case 3:e.set(t++,r&255|$),r>>>=7;case 2:e.set(t++,r&255|$),r>>>=7;case 1:{e.set(t++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return e}function Ks(r,e){let t=r[e],n=0;if(n+=t&Ae,t<$||(t=r[e+1],n+=(t&Ae)<<7,t<$)||(t=r[e+2],n+=(t&Ae)<<14,t<$)||(t=r[e+3],n+=(t&Ae)<<21,t<$)||(t=r[e+4],n+=(t&Ae)*Ms,t<$)||(t=r[e+5],n+=(t&Ae)*Vs,t<$)||(t=r[e+6],n+=(t&Ae)*Fs,t<$)||(t=r[e+7],n+=(t&Ae)*Hs,t<$))return n;throw new RangeError("Could not decode varint")}function Q4(r,e){let t=r.get(e),n=0;if(n+=t&Ae,t<$||(t=r.get(e+1),n+=(t&Ae)<<7,t<$)||(t=r.get(e+2),n+=(t&Ae)<<14,t<$)||(t=r.get(e+3),n+=(t&Ae)<<21,t<$)||(t=r.get(e+4),n+=(t&Ae)*Ms,t<$)||(t=r.get(e+5),n+=(t&Ae)*Vs,t<$)||(t=r.get(e+6),n+=(t&Ae)*Fs,t<$)||(t=r.get(e+7),n+=(t&Ae)*Hs,t<$))return n;throw new RangeError("Could not decode varint")}function $e(r,e,t=0){return e==null&&(e=me(ae(r))),e instanceof Uint8Array?qs(r,e,t):W4(r,e,t)}function Ve(r,e=0){return r instanceof Uint8Array?Ks(r,e):Q4(r,e)}var zs=new Float32Array([-0]),Ut=new Uint8Array(zs.buffer);function b0(r,e,t){zs[0]=r,e[t]=Ut[0],e[t+1]=Ut[1],e[t+2]=Ut[2],e[t+3]=Ut[3]}function x0(r,e){return Ut[0]=r[e],Ut[1]=r[e+1],Ut[2]=r[e+2],Ut[3]=r[e+3],zs[0]}var $s=new Float64Array([-0]),Se=new Uint8Array($s.buffer);function v0(r,e,t){$s[0]=r,e[t]=Se[0],e[t+1]=Se[1],e[t+2]=Se[2],e[t+3]=Se[3],e[t+4]=Se[4],e[t+5]=Se[5],e[t+6]=Se[6],e[t+7]=Se[7]}function E0(r,e){return Se[0]=r[e],Se[1]=r[e+1],Se[2]=r[e+2],Se[3]=r[e+3],Se[4]=r[e+4],Se[5]=r[e+5],Se[6]=r[e+6],Se[7]=r[e+7],$s[0]}var Z4=BigInt(Number.MAX_SAFE_INTEGER),Y4=BigInt(Number.MIN_SAFE_INTEGER),Fe=class r{lo;hi;constructor(e,t){this.lo=e|0,this.hi=t|0}toNumber(e=!1){if(!e&&this.hi>>>31>0){let t=~this.lo+1>>>0,n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(t+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(e=!1){if(e)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){let t=~this.lo+1>>>0,n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(BigInt(t)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(e=!1){return this.toBigInt(e).toString()}zzEncode(){let e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this}zzDecode(){let e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this}length(){let e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?t===0?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:n<128?9:10}static fromBigInt(e){if(e===0n)return or;if(e<Z4&&e>Y4)return this.fromNumber(Number(e));let t=e<0n;t&&(e=-e);let n=e>>32n,i=e-(n<<32n);return t&&(n=~n|0n,i=~i|0n,++i>A0&&(i=0n,++n>A0&&(n=0n))),new r(Number(i),Number(n))}static fromNumber(e){if(e===0)return or;let t=e<0;t&&(e=-e);let n=e>>>0,i=(e-n)/4294967296>>>0;return t&&(i=~i>>>0,n=~n>>>0,++n>4294967295&&(n=0,++i>4294967295&&(i=0))),new r(n,i)}static from(e){return typeof e=="number"?r.fromNumber(e):typeof e=="bigint"?r.fromBigInt(e):typeof e=="string"?r.fromBigInt(BigInt(e)):e.low!=null||e.high!=null?new r(e.low>>>0,e.high>>>0):or}},or=new Fe(0,0);or.toBigInt=function(){return 0n};or.zzEncode=or.zzDecode=function(){return this};or.length=function(){return 1};var A0=4294967296n;function S0(r){let e=0,t=0;for(let n=0;n<r.length;++n)t=r.charCodeAt(n),t<128?e+=1:t<2048?e+=2:(t&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,e+=4):e+=3;return e}function I0(r,e,t){if(t-e<1)return"";let i,s=[],o=0,a;for(;e<t;)a=r[e++],a<128?s[o++]=a:a>191&&a<224?s[o++]=(a&31)<<6|r[e++]&63:a>239&&a<365?(a=((a&7)<<18|(r[e++]&63)<<12|(r[e++]&63)<<6|r[e++]&63)-65536,s[o++]=55296+(a>>10),s[o++]=56320+(a&1023)):s[o++]=(a&15)<<12|(r[e++]&63)<<6|r[e++]&63,o>8191&&((i??(i=[])).push(String.fromCharCode.apply(String,s)),o=0);return i!=null?(o>0&&i.push(String.fromCharCode.apply(String,s.slice(0,o))),i.join("")):String.fromCharCode.apply(String,s.slice(0,o))}function Gs(r,e,t){let n=t,i,s;for(let o=0;o<r.length;++o)i=r.charCodeAt(o),i<128?e[t++]=i:i<2048?(e[t++]=i>>6|192,e[t++]=i&63|128):(i&64512)===55296&&((s=r.charCodeAt(o+1))&64512)===56320?(i=65536+((i&1023)<<10)+(s&1023),++o,e[t++]=i>>18|240,e[t++]=i>>12&63|128,e[t++]=i>>6&63|128,e[t++]=i&63|128):(e[t++]=i>>12|224,e[t++]=i>>6&63|128,e[t++]=i&63|128);return t-n}function We(r,e){return RangeError(`index out of range: ${r.pos} + ${e??1} > ${r.len}`)}function Xn(r,e){return(r[e-4]|r[e-3]<<8|r[e-2]<<16|r[e-1]<<24)>>>0}var js=class{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(e){this.buf=e,this.pos=0,this.len=e.length}uint32(){let e=4294967295;if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,We(this,10);return e}int32(){return this.uint32()|0}sint32(){let e=this.uint32();return e>>>1^-(e&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw We(this,4);return Xn(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw We(this,4);return Xn(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw We(this,4);let e=x0(this.buf,this.pos);return this.pos+=4,e}double(){if(this.pos+8>this.len)throw We(this,4);let e=E0(this.buf,this.pos);return this.pos+=8,e}bytes(){let e=this.uint32(),t=this.pos,n=this.pos+e;if(n>this.len)throw We(this,e);return this.pos+=e,t===n?new Uint8Array(0):this.buf.subarray(t,n)}string(){let e=this.bytes();return I0(e,0,e.length)}skip(e){if(typeof e=="number"){if(this.pos+e>this.len)throw We(this,e);this.pos+=e}else do if(this.pos>=this.len)throw We(this);while(this.buf[this.pos++]&128);return this}skipType(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(e=this.uint32()&7)!==4;)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${e} at offset ${this.pos}`)}return this}readLongVarint(){let e=new Fe(0,0),t=0;if(this.len-this.pos>4){for(;t<4;++t)if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(this.buf[this.pos]&127)<<28)>>>0,e.hi=(e.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return e;t=0}else{for(;t<3;++t){if(this.pos>=this.len)throw We(this);if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(this.buf[this.pos++]&127)<<t*7)>>>0,e}if(this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw We(this);if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw We(this,8);let e=Xn(this.buf,this.pos+=4),t=Xn(this.buf,this.pos+=4);return new Fe(e,t)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){let e=Ks(this.buf,this.pos);return this.pos+=ae(e),e}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}};function Ws(r){return new js(r instanceof Uint8Array?r:r.subarray())}function rt(r,e,t){let n=Ws(r);return e.decode(n,void 0,t)}var Js={};Te(Js,{base10:()=>n5});var Nl=new Uint8Array(0);function k0(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function pt(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function T0(r){return new TextEncoder().encode(r)}function R0(r){return new TextDecoder().decode(r)}function X4(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),n=0;n<t.length;n++)t[n]=255;for(var i=0;i<r.length;i++){var s=r.charAt(i),o=s.charCodeAt(0);if(t[o]!==255)throw new TypeError(s+" is ambiguous");t[o]=i}var a=r.length,c=r.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function f(m){if(m instanceof Uint8Array||(ArrayBuffer.isView(m)?m=new Uint8Array(m.buffer,m.byteOffset,m.byteLength):Array.isArray(m)&&(m=Uint8Array.from(m))),!(m instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(m.length===0)return"";for(var w=0,d=0,x=0,E=m.length;x!==E&&m[x]===0;)x++,w++;for(var g=(E-x)*u+1>>>0,S=new Uint8Array(g);x!==E;){for(var L=m[x],T=0,k=g-1;(L!==0||T<d)&&k!==-1;k--,T++)L+=256*S[k]>>>0,S[k]=L%a>>>0,L=L/a>>>0;if(L!==0)throw new Error("Non-zero carry");d=T,x++}for(var R=g-d;R!==g&&S[R]===0;)R++;for(var P=c.repeat(w);R<g;++R)P+=r.charAt(S[R]);return P}function h(m){if(typeof m!="string")throw new TypeError("Expected String");if(m.length===0)return new Uint8Array;var w=0;if(m[w]!==" "){for(var d=0,x=0;m[w]===c;)d++,w++;for(var E=(m.length-w)*l+1>>>0,g=new Uint8Array(E);m[w];){var S=t[m.charCodeAt(w)];if(S===255)return;for(var L=0,T=E-1;(S!==0||L<x)&&T!==-1;T--,L++)S+=a*g[T]>>>0,g[T]=S%256>>>0,S=S/256>>>0;if(S!==0)throw new Error("Non-zero carry");x=L,w++}if(m[w]!==" "){for(var k=E-x;k!==E&&g[k]===0;)k++;for(var R=new Uint8Array(d+(E-k)),P=d;k!==E;)R[P++]=g[k++];return R}}}function p(m){var w=h(m);if(w)return w;throw new Error(`Non-${e} character`)}return{encode:f,decodeUnsafe:h,decode:p}}var J4=X4,e5=J4,N0=e5;var Qs=class{name;prefix;baseEncode;constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},Zs=class{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,n){this.name=e,this.prefix=t;let i=t.codePointAt(0);if(i===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=i,this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return L0(this,e)}},Ys=class{decoders;constructor(e){this.decoders=e}or(e){return L0(this,e)}decode(e){let t=e[0],n=this.decoders[t];if(n!=null)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};function L0(r,e){return new Ys({...r.decoders??{[r.prefix]:r},...e.decoders??{[e.prefix]:e}})}var Xs=class{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,n,i){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=i,this.encoder=new Qs(e,t,n),this.decoder=new Zs(e,t,i)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}};function Br({name:r,prefix:e,encode:t,decode:n}){return new Xs(r,e,t,n)}function Dt({name:r,prefix:e,alphabet:t}){let{encode:n,decode:i}=N0(t,r);return Br({prefix:e,name:r,encode:n,decode:s=>pt(i(s))})}function t5(r,e,t,n){let i={};for(let u=0;u<e.length;++u)i[e[u]]=u;let s=r.length;for(;r[s-1]==="=";)--s;let o=new Uint8Array(s*t/8|0),a=0,c=0,l=0;for(let u=0;u<s;++u){let f=i[r[u]];if(f===void 0)throw new SyntaxError(`Non-${n} character`);c=c<<t|f,a+=t,a>=8&&(a-=8,o[l++]=255&c>>a)}if(a>=t||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return o}function r5(r,e,t){let n=e[e.length-1]==="=",i=(1<<t)-1,s="",o=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],o+=8;o>t;)o-=t,s+=e[i&a>>o];if(o!==0&&(s+=e[i&a<<t-o]),n)for(;s.length*t&7;)s+="=";return s}function se({name:r,prefix:e,bitsPerChar:t,alphabet:n}){return Br({prefix:e,name:r,encode(i){return r5(i,n,t)},decode(i){return t5(i,n,t,r)}})}var n5=Dt({prefix:"9",name:"base10",alphabet:"0123456789"});var eo={};Te(eo,{base16:()=>i5,base16upper:()=>s5});var i5=se({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),s5=se({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var to={};Te(to,{base2:()=>o5});var o5=se({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var ro={};Te(ro,{base256emoji:()=>f5});var C0=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),a5=C0.reduce((r,e,t)=>(r[t]=e,r),[]),c5=C0.reduce((r,e,t)=>{let n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);return r[n]=t,r},[]);function l5(r){return r.reduce((e,t)=>(e+=a5[t],e),"")}function u5(r){let e=[];for(let t of r){let n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);let i=c5[n];if(i==null)throw new Error(`Non-base256emoji character: ${t}`);e.push(i)}return new Uint8Array(e)}var f5=Br({prefix:"\u{1F680}",name:"base256emoji",encode:l5,decode:u5});var no={};Te(no,{base32:()=>mt,base32hex:()=>m5,base32hexpad:()=>y5,base32hexpadupper:()=>w5,base32hexupper:()=>g5,base32pad:()=>d5,base32padupper:()=>p5,base32upper:()=>h5,base32z:()=>b5});var mt=se({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),h5=se({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),d5=se({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),p5=se({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),m5=se({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),g5=se({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),y5=se({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),w5=se({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),b5=se({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var io={};Te(io,{base36:()=>ln,base36upper:()=>x5});var ln=Dt({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),x5=Dt({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var so={};Te(so,{base58btc:()=>Y,base58flickr:()=>v5});var Y=Dt({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),v5=Dt({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var oo={};Te(oo,{base64:()=>E5,base64pad:()=>A5,base64url:()=>S5,base64urlpad:()=>I5});var E5=se({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),A5=se({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),S5=se({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),I5=se({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var ao={};Te(ao,{base8:()=>B5});var B5=se({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var co={};Te(co,{identity:()=>k5});var k5=Br({prefix:"\0",name:"identity",encode:r=>R0(r),decode:r=>T0(r)});var jl=new TextEncoder,Wl=new TextDecoder;var _0=85;var uo={};Te(uo,{identity:()=>gt});var R5=M0,D0=128,P5=127,N5=~P5,L5=Math.pow(2,31);function M0(r,e,t){e=e||[],t=t||0;for(var n=t;r>=L5;)e[t++]=r&255|D0,r/=128;for(;r&N5;)e[t++]=r&255|D0,r>>>=7;return e[t]=r|0,M0.bytes=t-n+1,e}var C5=lo,_5=128,O0=127;function lo(r,n){var t=0,n=n||0,i=0,s=n,o,a=r.length;do{if(s>=a)throw lo.bytes=0,new RangeError("Could not decode varint");o=r[s++],t+=i<28?(o&O0)<<i:(o&O0)*Math.pow(2,i),i+=7}while(o>=_5);return lo.bytes=s-n,t}var U5=Math.pow(2,7),D5=Math.pow(2,14),O5=Math.pow(2,21),M5=Math.pow(2,28),V5=Math.pow(2,35),F5=Math.pow(2,42),H5=Math.pow(2,49),q5=Math.pow(2,56),K5=Math.pow(2,63),z5=function(r){return r<U5?1:r<D5?2:r<O5?3:r<M5?4:r<V5?5:r<F5?6:r<H5?7:r<q5?8:r<K5?9:10},$5={encode:R5,decode:C5,encodingLength:z5},G5=$5,un=G5;function fn(r,e=0){return[un.decode(r,e),un.decode.bytes]}function kr(r,e,t=0){return un.encode(r,e,t),e}function Tr(r){return un.encodingLength(r)}function Qe(r,e){let t=e.byteLength,n=Tr(r),i=n+Tr(t),s=new Uint8Array(i+t);return kr(r,s,0),kr(t,s,n),s.set(e,i),new Rr(r,t,e,s)}function ce(r){let e=pt(r),[t,n]=fn(e),[i,s]=fn(e.subarray(n)),o=e.subarray(n+s);if(o.byteLength!==i)throw new Error("Incorrect length");return new Rr(t,i,o,e)}function V0(r,e){if(r===e)return!0;{let t=e;return r.code===t.code&&r.size===t.size&&t.bytes instanceof Uint8Array&&k0(r.bytes,t.bytes)}}var Rr=class{code;size;digest;bytes;constructor(e,t,n,i){this.code=e,this.size=t,this.digest=n,this.bytes=i}};var F0=0,j5="identity",H0=pt;function W5(r){return Qe(F0,H0(r))}var gt={code:F0,name:j5,encode:H0,digest:W5};var po={};Te(po,{sha256:()=>yt,sha512:()=>Q5});function ho({name:r,code:e,encode:t}){return new fo(r,e,t)}var fo=class{name;code;encode;constructor(e,t,n){this.name=e,this.code=t,this.encode=n}digest(e){if(e instanceof Uint8Array){let t=this.encode(e);return t instanceof Uint8Array?Qe(this.code,t):t.then(n=>Qe(this.code,n))}else throw Error("Unknown type, must be binary type")}};function K0(r){return async e=>new Uint8Array(await crypto.subtle.digest(r,e))}var yt=ho({name:"sha2-256",code:18,encode:K0("SHA-256")}),Q5=ho({name:"sha2-512",code:19,encode:K0("SHA-512")});function z0(r,e){let{bytes:t,version:n}=r;switch(n){case 0:return Y5(t,mo(r),e??Y.encoder);default:return X5(t,mo(r),e??mt.encoder)}}var $0=new WeakMap;function mo(r){let e=$0.get(r);if(e==null){let t=new Map;return $0.set(r,t),t}return e}var ne=class r{code;version;multihash;bytes;"/";constructor(e,t,n,i){this.code=t,this.version=e,this.multihash=n,this.bytes=i,this["/"]=i}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{let{code:e,multihash:t}=this;if(e!==hn)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==J5)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return r.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{let{code:e,digest:t}=this.multihash,n=Qe(e,t);return r.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return r.equals(this,e)}static equals(e,t){let n=t;return n!=null&&e.code===n.code&&e.version===n.version&&V0(e.multihash,n.multihash)}toString(e){return z0(this,e)}toJSON(){return{"/":z0(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;let t=e;if(t instanceof r)return t;if(t["/"]!=null&&t["/"]===t.bytes||t.asCID===t){let{version:n,code:i,multihash:s,bytes:o}=t;return new r(n,i,s,o??G0(n,i,s.bytes))}else if(t[e6]===!0){let{version:n,multihash:i,code:s}=t,o=ce(i);return r.create(n,s,o)}else return null}static create(e,t,n){if(typeof t!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(t!==hn)throw new Error(`Version 0 CID must use dag-pb (code: ${hn}) block encoding`);return new r(e,t,n,n.bytes)}case 1:{let i=G0(e,t,n.bytes);return new r(e,t,n,i)}default:throw new Error("Invalid version")}}static createV0(e){return r.create(0,hn,e)}static createV1(e,t){return r.create(1,e,t)}static decode(e){let[t,n]=r.decodeFirst(e);if(n.length!==0)throw new Error("Incorrect length");return t}static decodeFirst(e){let t=r.inspectBytes(e),n=t.size-t.multihashSize,i=pt(e.subarray(n,n+t.multihashSize));if(i.byteLength!==t.multihashSize)throw new Error("Incorrect length");let s=i.subarray(t.multihashSize-t.digestSize),o=new Rr(t.multihashCode,t.digestSize,s,i);return[t.version===0?r.createV0(o):r.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0,n=()=>{let[f,h]=fn(e.subarray(t));return t+=h,f},i=n(),s=hn;if(i===18?(i=0,t=0):s=n(),i!==0&&i!==1)throw new RangeError(`Invalid CID version ${i}`);let o=t,a=n(),c=n(),l=t+c,u=l-o;return{version:i,codec:s,multihashCode:a,digestSize:c,multihashSize:u,size:l}}static parse(e,t){let[n,i]=Z5(e,t),s=r.decode(i);if(s.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return mo(s).set(n,e),s}};function Z5(r,e){switch(r[0]){case"Q":{let t=e??Y;return[Y.prefix,t.decode(`${Y.prefix}${r}`)]}case Y.prefix:{let t=e??Y;return[Y.prefix,t.decode(r)]}case mt.prefix:{let t=e??mt;return[mt.prefix,t.decode(r)]}case ln.prefix:{let t=e??ln;return[ln.prefix,t.decode(r)]}default:{if(e==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],e.decode(r)]}}}function Y5(r,e,t){let{prefix:n}=t;if(n!==Y.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);let i=e.get(n);if(i==null){let s=t.encode(r).slice(1);return e.set(n,s),s}else return i}function X5(r,e,t){let{prefix:n}=t,i=e.get(n);if(i==null){let s=t.encode(r);return e.set(n,s),s}else return i}var hn=112,J5=18;function G0(r,e,t){let n=Tr(r),i=n+Tr(e),s=new Uint8Array(i+t.byteLength);return kr(r,s,0),kr(e,s,n),s.set(t,i),s}var e6=Symbol.for("@ipld/js-cid/CID");var dn={...co,...to,...ao,...Js,...eo,...no,...io,...so,...oo,...ro},g9={...po,...uo};function W0(r,e,t,n){return{name:r,prefix:e,encoder:{name:r,prefix:e,encode:t},decoder:{decode:n}}}var j0=W0("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),go=W0("ascii","a",r=>{let e="a";for(let t=0;t<r.length;t++)e+=String.fromCharCode(r[t]);return e},r=>{r=r.substring(1);let e=me(r.length);for(let t=0;t<r.length;t++)e[t]=r.charCodeAt(t);return e}),t6={utf8:j0,"utf-8":j0,hex:dn.base16,latin1:go,ascii:go,binary:go,...dn},e1=t6;function W(r,e="utf8"){let t=e1[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.decoder.decode(`${t.prefix}${r}`)}function yo(r){let e=r??8192,t=e>>>1,n,i=e;return function(o){if(o<1||o>t)return me(o);i+o>e&&(n=me(e),i=0);let a=n.subarray(i,i+=o);return i&7&&(i=(i|7)+1),a}}var ar=class{fn;len;next;val;constructor(e,t,n){this.fn=e,this.len=t,this.next=void 0,this.val=n}};function wo(){}var xo=class{head;tail;len;next;constructor(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}},r6=yo();function n6(r){return globalThis.Buffer!=null?me(r):r6(r)}var mn=class{len;head;tail;states;constructor(){this.len=0,this.head=new ar(wo,0,0),this.tail=this.head,this.states=null}_push(e,t,n){return this.tail=this.tail.next=new ar(e,t,n),this.len+=t,this}uint32(e){return this.len+=(this.tail=this.tail.next=new vo((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this}int32(e){return e<0?this._push(t1,10,Fe.fromNumber(e)):this.uint32(e)}sint32(e){return this.uint32((e<<1^e>>31)>>>0)}uint64(e){let t=Fe.fromBigInt(e);return this._push(t1,t.length(),t)}uint64Number(e){return this._push(qs,ae(e),e)}uint64String(e){return this.uint64(BigInt(e))}int64(e){return this.uint64(e)}int64Number(e){return this.uint64Number(e)}int64String(e){return this.uint64String(e)}sint64(e){let t=Fe.fromBigInt(e).zzEncode();return this._push(t1,t.length(),t)}sint64Number(e){let t=Fe.fromNumber(e).zzEncode();return this._push(t1,t.length(),t)}sint64String(e){return this.sint64(BigInt(e))}bool(e){return this._push(bo,1,e?1:0)}fixed32(e){return this._push(pn,4,e>>>0)}sfixed32(e){return this.fixed32(e)}fixed64(e){let t=Fe.fromBigInt(e);return this._push(pn,4,t.lo)._push(pn,4,t.hi)}fixed64Number(e){let t=Fe.fromNumber(e);return this._push(pn,4,t.lo)._push(pn,4,t.hi)}fixed64String(e){return this.fixed64(BigInt(e))}sfixed64(e){return this.fixed64(e)}sfixed64Number(e){return this.fixed64Number(e)}sfixed64String(e){return this.fixed64String(e)}float(e){return this._push(b0,4,e)}double(e){return this._push(v0,8,e)}bytes(e){let t=e.length>>>0;return t===0?this._push(bo,1,0):this.uint32(t)._push(s6,t,e)}string(e){let t=S0(e);return t!==0?this.uint32(t)._push(Gs,t,e):this._push(bo,1,0)}fork(){return this.states=new xo(this),this.head=this.tail=new ar(wo,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new ar(wo,0,0),this.len=0),this}ldelim(){let e=this.head,t=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=e.next,this.tail=t,this.len+=n),this}finish(){let e=this.head.next,t=n6(this.len),n=0;for(;e!=null;)e.fn(e.val,t,n),n+=e.len,e=e.next;return t}};function bo(r,e,t){e[t]=r&255}function i6(r,e,t){for(;r>127;)e[t++]=r&127|128,r>>>=7;e[t]=r}var vo=class extends ar{next;constructor(e,t){super(i6,e,t),this.next=void 0}};function t1(r,e,t){for(;r.hi!==0;)e[t++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)e[t++]=r.lo&127|128,r.lo=r.lo>>>7;e[t++]=r.lo}function pn(r,e,t){e[t]=r&255,e[t+1]=r>>>8&255,e[t+2]=r>>>16&255,e[t+3]=r>>>24}function s6(r,e,t){e.set(r,t)}globalThis.Buffer!=null&&(mn.prototype.bytes=function(r){let e=r.length>>>0;return this.uint32(e),e>0&&this._push(o6,e,r),this},mn.prototype.string=function(r){let e=globalThis.Buffer.byteLength(r);return this.uint32(e),e>0&&this._push(a6,e,r),this});function o6(r,e,t){e.set(r,t)}function a6(r,e,t){r.length<40?Gs(r,e,t):e.utf8Write!=null?e.utf8Write(r,t):e.set(W(r),t)}function Eo(){return new mn}function nt(r,e){let t=Eo();return e.encode(r,t,{lengthDelimited:!1}),t.finish()}var Pr;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(Pr||(Pr={}));function r1(r,e,t,n){return{name:r,type:e,encode:t,decode:n}}function Nr(r){function e(i){if(r[i.toString()]==null)throw new Error("Invalid enum value");return r[i]}let t=function(s,o){let a=e(s);o.int32(a)},n=function(s){let o=s.int32();return e(o)};return r1("enum",Pr.VARINT,t,n)}function it(r,e){return r1("message",Pr.LENGTH_DELIMITED,r,e)}var Lr=class extends Error{code="ERR_MAX_LENGTH";name="MaxLengthError"};var gn;(function(r){let e;r.codec=()=>(e==null&&(e=it((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.key!=null&&t.key.byteLength>0&&(n.uint32(10),n.bytes(t.key)),t.value!=null&&t.value.byteLength>0&&(n.uint32(18),n.bytes(t.value)),t.timeReceived!=null&&t.timeReceived!==""&&(n.uint32(42),n.string(t.timeReceived)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{let s={key:_e(0),value:_e(0),timeReceived:""},o=n==null?t.len:t.pos+n;for(;t.pos<o;){let a=t.uint32();switch(a>>>3){case 1:{s.key=t.bytes();break}case 2:{s.value=t.bytes();break}case 5:{s.timeReceived=t.string();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>nt(t,r.codec()),r.decode=(t,n)=>rt(t,r.codec(),n)})(gn||(gn={}));function Q0(r){let e=r.getUTCFullYear(),t=String(r.getUTCMonth()+1).padStart(2,"0"),n=String(r.getUTCDate()).padStart(2,"0"),i=String(r.getUTCHours()).padStart(2,"0"),s=String(r.getUTCMinutes()).padStart(2,"0"),o=String(r.getUTCSeconds()).padStart(2,"0"),a=r.getUTCMilliseconds(),c=String(a*1e3*1e3).padStart(9,"0");return`${e}-${t}-${n}T${i}:${s}:${o}.${c}Z`}function Z0(r){let e=new RegExp("(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"),t=String(r).trim().match(e);if(t==null)throw new Error("Invalid format");let n=parseInt(t[1],10),i=parseInt(t[2],10)-1,s=parseInt(t[3],10),o=parseInt(t[4],10),a=parseInt(t[5],10),c=parseInt(t[6],10),l=parseInt(t[7].slice(0,-6),10);return new Date(Date.UTC(n,i,s,o,a,c,l))}var ue=class r{key;value;timeReceived;constructor(e,t,n){if(!(e instanceof Uint8Array))throw new Error("key must be a Uint8Array");if(!(t instanceof Uint8Array))throw new Error("value must be a Uint8Array");this.key=e,this.value=t,this.timeReceived=n}serialize(){return gn.encode(this.prepareSerialize())}prepareSerialize(){return{key:this.key,value:this.value,timeReceived:Q0(this.timeReceived)}}static deserialize(e){let t=gn.decode(e);return new r(t.key,t.value,new Date(t.timeReceived))}static fromDeserialized(e){let t=Z0(e.timeReceived);if(e.key==null)throw new Error("key missing from deserialized object");if(e.value==null)throw new Error("value missing from deserialized object");return new r(e.key,e.value,t)}};function l6(r){let[e,t]=r[Symbol.asyncIterator]!=null?[r[Symbol.asyncIterator](),Symbol.asyncIterator]:[r[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>e.next(),push:i=>{n.push(i)},next:()=>n.length>0?{done:!1,value:n.shift()}:e.next(),[t](){return this}}}var Y0=l6;function u6(r){return r[Symbol.asyncIterator]!=null}function f6(r,e){let t=0;if(u6(r))return async function*(){for await(let c of r)yield e(c,t++)}();let n=Y0(r),{value:i,done:s}=n.next();if(s===!0)return function*(){}();let o=e(i,t++);if(typeof o.then=="function")return async function*(){yield await o;for await(let c of n)yield e(c,t++)}();let a=e;return function*(){yield o;for(let c of n)yield a(c,t++)}()}var Ot=f6;var n1=globalThis.CustomEvent??Event;async function*cr(r,e={}){let t=e.concurrency??1/0;t<1&&(t=1/0);let n=e.ordered==null?!1:e.ordered,i=new EventTarget,s=[],o=oe(),a=oe(),c=!1,l,u=!1;i.addEventListener("task-complete",()=>{a.resolve()}),Promise.resolve().then(async()=>{try{for await(let m of r){if(s.length===t&&(o=oe(),await o.promise),u)break;let w={done:!1};s.push(w),m().then(d=>{w.done=!0,w.ok=!0,w.value=d,i.dispatchEvent(new n1("task-complete"))},d=>{w.done=!0,w.err=d,i.dispatchEvent(new n1("task-complete"))})}c=!0,i.dispatchEvent(new n1("task-complete"))}catch(m){l=m,i.dispatchEvent(new n1("task-complete"))}});function f(){return n?s[0]?.done:!!s.find(m=>m.done)}function*h(){for(;s.length>0&&s[0].done;){let m=s[0];if(s.shift(),m.ok)yield m.value;else throw u=!0,o.resolve(),m.err;o.resolve()}}function*p(){for(;f();)for(let m=0;m<s.length;m++)if(s[m].done){let w=s[m];if(s.splice(m,1),m--,w.ok)yield w.value;else throw u=!0,o.resolve(),w.err;o.resolve()}}for(;;){if(f()||(a=oe(),await a.promise),l!=null)throw l;if(n?yield*h():yield*p(),c&&s.length===0)break}}var i1=class{buffer;mask;top;btm;next;constructor(e){if(!(e>0)||e-1&e)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){let e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}},Cr=class{size;hwm;head;tail;constructor(e={}){this.hwm=e.splitLimit??16,this.head=new i1(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return e?.byteLength!=null?e.byteLength:1}push(e){if(e?.value!=null&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){let t=this.head;this.head=t.next=new i1(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next!=null){let t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return e?.value!=null&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}};var Ao=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}};function _r(r={}){return h6(t=>{let n=t.shift();if(n==null)return{done:!0};if(n.error!=null)throw n.error;return{done:n.done===!0,value:n.value}},r)}function h6(r,e){e=e??{};let t=e.onEnd,n=new Cr,i,s,o,a=oe(),c=async()=>{try{return n.isEmpty()?o?{done:!0}:await new Promise((d,x)=>{s=E=>{s=null,n.push(E);try{d(r(n))}catch(g){x(g)}return i}}):r(n)}finally{n.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=oe()})}},l=d=>s!=null?s(d):(n.push(d),i),u=d=>(n=new Cr,s!=null?s({error:d}):(n.push({error:d}),i)),f=d=>{if(o)return i;if(e?.objectMode!==!0&&d?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return l({done:!1,value:d})},h=d=>o?i:(o=!0,d!=null?u(d):l({done:!0})),p=()=>(n=new Cr,h(),{done:!0}),m=d=>(h(d),{done:!0});if(i={[Symbol.asyncIterator](){return this},next:c,return:p,throw:m,push:f,end:h,get readableLength(){return n.size},onEmpty:async d=>{let x=d?.signal;if(x?.throwIfAborted(),n.isEmpty())return;let E,g;x!=null&&(E=new Promise((S,L)=>{g=()=>{L(new Ao)},x.addEventListener("abort",g)}));try{await Promise.race([a.promise,E])}finally{g!=null&&x!=null&&x?.removeEventListener("abort",g)}}},t==null)return i;let w=i;return i={[Symbol.asyncIterator](){return this},next(){return w.next()},throw(d){return w.throw(d),t!=null&&(t(d),t=void 0),{done:!0}},return(){return w.return(),t!=null&&(t(),t=void 0),{done:!0}},push:f,end(d){return w.end(d),t!=null&&(t(d),t=void 0),i},get readableLength(){return w.readableLength},onEmpty:d=>w.onEmpty(d)},i}function d6(r){return r[Symbol.asyncIterator]!=null}function p6(...r){let e=[];for(let t of r)d6(t)||e.push(t);return e.length===r.length?function*(){for(let t of e)yield*t}():async function*(){let t=_r({objectMode:!0});Promise.resolve().then(async()=>{try{await Promise.all(r.map(async n=>{for await(let i of n)t.push(i)})),t.end()}catch(n){t.end(n)}}),yield*t}()}var s1=p6;function Mt(r,...e){if(r==null)throw new Error("Empty pipeline");if(So(r)){let n=r;r=()=>n.source}else if(J0(r)||X0(r)){let n=r;r=()=>n}let t=[r,...e];if(t.length>1&&So(t[t.length-1])&&(t[t.length-1]=t[t.length-1].sink),t.length>2)for(let n=1;n<t.length-1;n++)So(t[n])&&(t[n]=g6(t[n]));return m6(...t)}var m6=(...r)=>{let e;for(;r.length>0;)e=r.shift()(e);return e},X0=r=>r?.[Symbol.asyncIterator]!=null,J0=r=>r?.[Symbol.iterator]!=null,So=r=>r==null?!1:r.sink!=null&&r.source!=null,g6=r=>e=>{let t=r.sink(e);if(t?.then!=null){let n=_r({objectMode:!0});t.then(()=>{n.end()},o=>{n.end(o)});let i,s=r.source;if(X0(s))i=async function*(){yield*s,n.end()};else if(J0(s))i=function*(){yield*s,n.end()};else throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");return s1(n,i())}return r.source};function X(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}var Vt=class extends Error{constructor(e="Query error"){super(e),this.name="QueryError"}},o1=class extends Error{constructor(e="Query aborted"){super(e),this.name="QueryAbortedError"}},a1=class extends Error{constructor(e="Invalid record"){super(e),this.name="InvalidRecordError"}},c1=class extends Error{constructor(e="No selector function configured for prefix"){super(e),this.name="MissingSelectorError"}};var e3;(function(r){let e;r.codec=()=>(e==null&&(e=it((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.key!=null&&(n.uint32(10),n.bytes(t.key)),t.value!=null&&(n.uint32(18),n.bytes(t.value)),t.author!=null&&(n.uint32(26),n.bytes(t.author)),t.signature!=null&&(n.uint32(34),n.bytes(t.signature)),t.timeReceived!=null&&(n.uint32(42),n.string(t.timeReceived)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{let s={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){let a=t.uint32();switch(a>>>3){case 1:{s.key=t.bytes();break}case 2:{s.value=t.bytes();break}case 3:{s.author=t.bytes();break}case 4:{s.signature=t.bytes();break}case 5:{s.timeReceived=t.string();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>nt(t,r.codec()),r.decode=(t,n)=>rt(t,r.codec(),n)})(e3||(e3={}));var V;(function(r){r.PUT_VALUE="PUT_VALUE",r.GET_VALUE="GET_VALUE",r.ADD_PROVIDER="ADD_PROVIDER",r.GET_PROVIDERS="GET_PROVIDERS",r.FIND_NODE="FIND_NODE",r.PING="PING"})(V||(V={}));var l1;(function(r){r[r.PUT_VALUE=0]="PUT_VALUE",r[r.GET_VALUE=1]="GET_VALUE",r[r.ADD_PROVIDER=2]="ADD_PROVIDER",r[r.GET_PROVIDERS=3]="GET_PROVIDERS",r[r.FIND_NODE=4]="FIND_NODE",r[r.PING=5]="PING"})(l1||(l1={}));(function(r){r.codec=()=>Nr(l1)})(V||(V={}));var Dr;(function(r){r.NOT_CONNECTED="NOT_CONNECTED",r.CONNECTED="CONNECTED",r.CAN_CONNECT="CAN_CONNECT",r.CANNOT_CONNECT="CANNOT_CONNECT"})(Dr||(Dr={}));var Io;(function(r){r[r.NOT_CONNECTED=0]="NOT_CONNECTED",r[r.CONNECTED=1]="CONNECTED",r[r.CAN_CONNECT=2]="CAN_CONNECT",r[r.CANNOT_CONNECT=3]="CANNOT_CONNECT"})(Io||(Io={}));(function(r){r.codec=()=>Nr(Io)})(Dr||(Dr={}));var Ur;(function(r){let e;r.codec=()=>(e==null&&(e=it((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.id!=null&&t.id.byteLength>0&&(n.uint32(10),n.bytes(t.id)),t.multiaddrs!=null)for(let s of t.multiaddrs)n.uint32(18),n.bytes(s);t.connection!=null&&(n.uint32(24),Dr.codec().encode(t.connection,n)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{let s={id:_e(0),multiaddrs:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){let a=t.uint32();switch(a>>>3){case 1:{s.id=t.bytes();break}case 2:{if(i.limits?.multiaddrs!=null&&s.multiaddrs.length===i.limits.multiaddrs)throw new Lr('Decode error - map field "multiaddrs" had too many elements');s.multiaddrs.push(t.bytes());break}case 3:{s.connection=Dr.codec().decode(t);break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>nt(t,r.codec()),r.decode=(t,n)=>rt(t,r.codec(),n)})(Ur||(Ur={}));var wt;(function(r){let e;r.codec=()=>(e==null&&(e=it((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.type!=null&&l1[t.type]!==0&&(n.uint32(8),V.codec().encode(t.type,n)),t.clusterLevel!=null&&(n.uint32(80),n.int32(t.clusterLevel)),t.key!=null&&(n.uint32(18),n.bytes(t.key)),t.record!=null&&(n.uint32(26),n.bytes(t.record)),t.closer!=null)for(let s of t.closer)n.uint32(66),Ur.codec().encode(s,n);if(t.providers!=null)for(let s of t.providers)n.uint32(74),Ur.codec().encode(s,n);i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{let s={type:V.PUT_VALUE,closer:[],providers:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){let a=t.uint32();switch(a>>>3){case 1:{s.type=V.codec().decode(t);break}case 10:{s.clusterLevel=t.int32();break}case 2:{s.key=t.bytes();break}case 3:{s.record=t.bytes();break}case 8:{if(i.limits?.closer!=null&&s.closer.length===i.limits.closer)throw new Lr('Decode error - map field "closer" had too many elements');s.closer.push(Ur.codec().decode(t,t.uint32(),{limits:i.limits?.closer$}));break}case 9:{if(i.limits?.providers!=null&&s.providers.length===i.limits.providers)throw new Lr('Decode error - map field "providers" had too many elements');s.providers.push(Ur.codec().decode(t,t.uint32(),{limits:i.limits?.providers$}));break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>nt(t,r.codec()),r.decode=(t,n)=>rt(t,r.codec(),n)})(wt||(wt={}));function Bo(r,e={}){let t={...r,name:"SEND_QUERY",type:0,messageName:r.type,messageType:r.type};return e.onProgress?.(new CustomEvent("kad-dht:query:send-query",{detail:t})),t}function yn(r,e={}){let t={...r,name:"PEER_RESPONSE",type:1,messageName:r.messageType,closer:r.closer??[],providers:r.providers??[]};return e.onProgress?.(new CustomEvent("kad-dht:query:peer-response",{detail:t})),t}function u1(r,e={}){let t={...r,name:"FINAL_PEER",type:2};return e.onProgress?.(new CustomEvent("kad-dht:query:final-peer",{detail:t})),t}function qe(r,e={}){let t={...r,name:"QUERY_ERROR",type:3};return e.onProgress?.(new CustomEvent("kad-dht:query:query-error",{detail:t})),t}function ko(r,e={}){let t={...r,name:"PROVIDER",type:4};return e.onProgress?.(new CustomEvent("kad-dht:query:provider",{detail:t})),t}function wn(r,e={}){let t={...r,name:"VALUE",type:5};return e.onProgress?.(new CustomEvent("kad-dht:query:value",{detail:t})),t}function To(r,e={}){let t={...r,name:"DIAL_PEER",type:7};return e.onProgress?.(new CustomEvent("kad-dht:query:dial-peer",{detail:t})),t}function D(r,e="utf8"){let t=e1[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.encoder.encode(r).substring(1)}function t3(r,e,t){if(t.length===0)throw new z("No records given");let i=D(e).split("/");if(i.length<3)throw new z("Record key does not have a selector function");let s=r[i[1].toString()];if(s==null)throw new c1(`No selector function configured for key type "${i[1]}"`);return t.length===1?0:s(e,t)}function y6(r,e){return 0}var r3={pk:y6};function n3(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function w6(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Or(r,...e){if(!w6(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error("Uint8Array expected of length "+e+", got length="+r.length)}function i3(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");n3(r.outputLen),n3(r.blockLen)}function Mr(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function s3(r,e){Or(r);let t=e.outputLen;if(r.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}var lr=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var f1=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),Ze=(r,e)=>r<<32-e|r>>>e;function o3(r){if(typeof r!="string")throw new Error("utf8ToBytes expected string, got "+typeof r);return new Uint8Array(new TextEncoder().encode(r))}function bn(r){return typeof r=="string"&&(r=o3(r)),Or(r),r}function Ro(...r){let e=0;for(let n=0;n<r.length;n++){let i=r[n];Or(i),e+=i.length}let t=new Uint8Array(e);for(let n=0,i=0;n<r.length;n++){let s=r[n];t.set(s,i),i+=s.length}return t}var Vr=class{clone(){return this._cloneInto()}};function h1(r){let e=n=>r().update(bn(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function Fr(r=32){if(lr&&typeof lr.getRandomValues=="function")return lr.getRandomValues(new Uint8Array(r));if(lr&&typeof lr.randomBytes=="function")return lr.randomBytes(r);throw new Error("crypto.getRandomValues must be defined")}function b6(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);let i=BigInt(32),s=BigInt(4294967295),o=Number(t>>i&s),a=Number(t&s),c=n?4:0,l=n?0:4;r.setUint32(e+c,o,n),r.setUint32(e+l,a,n)}var a3=(r,e,t)=>r&e^~r&t,c3=(r,e,t)=>r&e^r&t^e&t,Hr=class extends Vr{constructor(e,t,n,i){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=i,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=f1(this.buffer)}update(e){Mr(this);let{view:t,buffer:n,blockLen:i}=this;e=bn(e);let s=e.length;for(let o=0;o<s;){let a=Math.min(i-this.pos,s-o);if(a===i){let c=f1(e);for(;i<=s-o;o+=i)this.process(c,o);continue}n.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===i&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Mr(this),s3(e,this),this.finished=!0;let{buffer:t,view:n,blockLen:i,isLE:s}=this,{pos:o}=this;t[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>i-o&&(this.process(n,0),o=0);for(let f=o;f<i;f++)t[f]=0;b6(n,i-8,BigInt(this.length*8),s),this.process(n,0);let a=f1(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let l=c/4,u=this.get();if(l>u.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<l;f++)a.setUint32(4*f,u[f],s)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:n,length:i,finished:s,destroyed:o,pos:a}=this;return e.length=i,e.pos=a,e.finished=s,e.destroyed=o,i%t&&e.buffer.set(n),e}};var d1=BigInt(4294967295),Po=BigInt(32);function l3(r,e=!1){return e?{h:Number(r&d1),l:Number(r>>Po&d1)}:{h:Number(r>>Po&d1)|0,l:Number(r&d1)|0}}function x6(r,e=!1){let t=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let i=0;i<r.length;i++){let{h:s,l:o}=l3(r[i],e);[t[i],n[i]]=[s,o]}return[t,n]}var v6=(r,e)=>BigInt(r>>>0)<<Po|BigInt(e>>>0),E6=(r,e,t)=>r>>>t,A6=(r,e,t)=>r<<32-t|e>>>t,S6=(r,e,t)=>r>>>t|e<<32-t,I6=(r,e,t)=>r<<32-t|e>>>t,B6=(r,e,t)=>r<<64-t|e>>>t-32,k6=(r,e,t)=>r>>>t-32|e<<64-t,T6=(r,e)=>e,R6=(r,e)=>r,P6=(r,e,t)=>r<<t|e>>>32-t,N6=(r,e,t)=>e<<t|r>>>32-t,L6=(r,e,t)=>e<<t-32|r>>>64-t,C6=(r,e,t)=>r<<t-32|e>>>64-t;function _6(r,e,t,n){let i=(e>>>0)+(n>>>0);return{h:r+t+(i/2**32|0)|0,l:i|0}}var U6=(r,e,t)=>(r>>>0)+(e>>>0)+(t>>>0),D6=(r,e,t,n)=>e+t+n+(r/2**32|0)|0,O6=(r,e,t,n)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0),M6=(r,e,t,n,i)=>e+t+n+i+(r/2**32|0)|0,V6=(r,e,t,n,i)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0)+(i>>>0),F6=(r,e,t,n,i,s)=>e+t+n+i+s+(r/2**32|0)|0;var H6={fromBig:l3,split:x6,toBig:v6,shrSH:E6,shrSL:A6,rotrSH:S6,rotrSL:I6,rotrBH:B6,rotrBL:k6,rotr32H:T6,rotr32L:R6,rotlSH:P6,rotlSL:N6,rotlBH:L6,rotlBL:C6,add:_6,add3L:U6,add3H:D6,add4L:O6,add4H:M6,add5H:F6,add5L:V6},O=H6;var[q6,K6]=O.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),Ft=new Uint32Array(80),Ht=new Uint32Array(80),No=class extends Hr{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){let{Ah:e,Al:t,Bh:n,Bl:i,Ch:s,Cl:o,Dh:a,Dl:c,Eh:l,El:u,Fh:f,Fl:h,Gh:p,Gl:m,Hh:w,Hl:d}=this;return[e,t,n,i,s,o,a,c,l,u,f,h,p,m,w,d]}set(e,t,n,i,s,o,a,c,l,u,f,h,p,m,w,d){this.Ah=e|0,this.Al=t|0,this.Bh=n|0,this.Bl=i|0,this.Ch=s|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=l|0,this.El=u|0,this.Fh=f|0,this.Fl=h|0,this.Gh=p|0,this.Gl=m|0,this.Hh=w|0,this.Hl=d|0}process(e,t){for(let g=0;g<16;g++,t+=4)Ft[g]=e.getUint32(t),Ht[g]=e.getUint32(t+=4);for(let g=16;g<80;g++){let S=Ft[g-15]|0,L=Ht[g-15]|0,T=O.rotrSH(S,L,1)^O.rotrSH(S,L,8)^O.shrSH(S,L,7),k=O.rotrSL(S,L,1)^O.rotrSL(S,L,8)^O.shrSL(S,L,7),R=Ft[g-2]|0,P=Ht[g-2]|0,J=O.rotrSH(R,P,19)^O.rotrBH(R,P,61)^O.shrSH(R,P,6),K=O.rotrSL(R,P,19)^O.rotrBL(R,P,61)^O.shrSL(R,P,6),F=O.add4L(k,K,Ht[g-7],Ht[g-16]),le=O.add4H(F,T,J,Ft[g-7],Ft[g-16]);Ft[g]=le|0,Ht[g]=F|0}let{Ah:n,Al:i,Bh:s,Bl:o,Ch:a,Cl:c,Dh:l,Dl:u,Eh:f,El:h,Fh:p,Fl:m,Gh:w,Gl:d,Hh:x,Hl:E}=this;for(let g=0;g<80;g++){let S=O.rotrSH(f,h,14)^O.rotrSH(f,h,18)^O.rotrBH(f,h,41),L=O.rotrSL(f,h,14)^O.rotrSL(f,h,18)^O.rotrBL(f,h,41),T=f&p^~f&w,k=h&m^~h&d,R=O.add5L(E,L,k,K6[g],Ht[g]),P=O.add5H(R,x,S,T,q6[g],Ft[g]),J=R|0,K=O.rotrSH(n,i,28)^O.rotrBH(n,i,34)^O.rotrBH(n,i,39),F=O.rotrSL(n,i,28)^O.rotrBL(n,i,34)^O.rotrBL(n,i,39),le=n&s^n&a^s&a,A=i&o^i&c^o&c;x=w|0,E=d|0,w=p|0,d=m|0,p=f|0,m=h|0,{h:f,l:h}=O.add(l|0,u|0,P|0,J|0),l=a|0,u=c|0,a=s|0,c=o|0,s=n|0,o=i|0;let N=O.add3L(J,F,A);n=O.add3H(N,P,K,le),i=N|0}({h:n,l:i}=O.add(this.Ah|0,this.Al|0,n|0,i|0)),{h:s,l:o}=O.add(this.Bh|0,this.Bl|0,s|0,o|0),{h:a,l:c}=O.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:l,l:u}=O.add(this.Dh|0,this.Dl|0,l|0,u|0),{h:f,l:h}=O.add(this.Eh|0,this.El|0,f|0,h|0),{h:p,l:m}=O.add(this.Fh|0,this.Fl|0,p|0,m|0),{h:w,l:d}=O.add(this.Gh|0,this.Gl|0,w|0,d|0),{h:x,l:E}=O.add(this.Hh|0,this.Hl|0,x|0,E|0),this.set(n,i,s,o,a,c,l,u,f,h,p,m,w,d,x,E)}roundClean(){Ft.fill(0),Ht.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}};var u3=h1(()=>new No);var g1={};Te(g1,{aInRange:()=>Ue,abool:()=>Ye,abytes:()=>qr,bitGet:()=>Q6,bitLen:()=>Uo,bitMask:()=>vn,bitSet:()=>Z6,bytesToHex:()=>xt,bytesToNumberBE:()=>vt,bytesToNumberLE:()=>Kt,concatBytes:()=>Et,createHmacDrbg:()=>Do,ensureBytes:()=>ie,equalBytes:()=>j6,hexToBytes:()=>fr,hexToNumber:()=>_o,inRange:()=>xn,isBytes:()=>qt,memoized:()=>dr,notImplemented:()=>X6,numberToBytesBE:()=>zt,numberToBytesLE:()=>hr,numberToHexUnpadded:()=>ur,numberToVarBytesBE:()=>G6,utf8ToBytes:()=>W6,validateObject:()=>st});var p1=BigInt(0),m1=BigInt(1),z6=BigInt(2);function qt(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function qr(r){if(!qt(r))throw new Error("Uint8Array expected")}function Ye(r,e){if(typeof e!="boolean")throw new Error(r+" boolean expected, got "+e)}var $6=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function xt(r){qr(r);let e="";for(let t=0;t<r.length;t++)e+=$6[r[t]];return e}function ur(r){let e=r.toString(16);return e.length&1?"0"+e:e}function _o(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?p1:BigInt("0x"+r)}var bt={_0:48,_9:57,A:65,F:70,a:97,f:102};function f3(r){if(r>=bt._0&&r<=bt._9)return r-bt._0;if(r>=bt.A&&r<=bt.F)return r-(bt.A-10);if(r>=bt.a&&r<=bt.f)return r-(bt.a-10)}function fr(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);let e=r.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);let n=new Uint8Array(t);for(let i=0,s=0;i<t;i++,s+=2){let o=f3(r.charCodeAt(s)),a=f3(r.charCodeAt(s+1));if(o===void 0||a===void 0){let c=r[s]+r[s+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+s)}n[i]=o*16+a}return n}function vt(r){return _o(xt(r))}function Kt(r){return qr(r),_o(xt(Uint8Array.from(r).reverse()))}function zt(r,e){return fr(r.toString(16).padStart(e*2,"0"))}function hr(r,e){return zt(r,e).reverse()}function G6(r){return fr(ur(r))}function ie(r,e,t){let n;if(typeof e=="string")try{n=fr(e)}catch(s){throw new Error(r+" must be hex string or Uint8Array, cause: "+s)}else if(qt(e))n=Uint8Array.from(e);else throw new Error(r+" must be hex string or Uint8Array");let i=n.length;if(typeof t=="number"&&i!==t)throw new Error(r+" of length "+t+" expected, got "+i);return n}function Et(...r){let e=0;for(let n=0;n<r.length;n++){let i=r[n];qr(i),e+=i.length}let t=new Uint8Array(e);for(let n=0,i=0;n<r.length;n++){let s=r[n];t.set(s,i),i+=s.length}return t}function j6(r,e){if(r.length!==e.length)return!1;let t=0;for(let n=0;n<r.length;n++)t|=r[n]^e[n];return t===0}function W6(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}var Lo=r=>typeof r=="bigint"&&p1<=r;function xn(r,e,t){return Lo(r)&&Lo(e)&&Lo(t)&&e<=r&&r<t}function Ue(r,e,t,n){if(!xn(e,t,n))throw new Error("expected valid "+r+": "+t+" <= n < "+n+", got "+e)}function Uo(r){let e;for(e=0;r>p1;r>>=m1,e+=1);return e}function Q6(r,e){return r>>BigInt(e)&m1}function Z6(r,e,t){return r|(t?m1:p1)<<BigInt(e)}var vn=r=>(z6<<BigInt(r-1))-m1,Co=r=>new Uint8Array(r),h3=r=>Uint8Array.from(r);function Do(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=Co(r),i=Co(r),s=0,o=()=>{n.fill(1),i.fill(0),s=0},a=(...f)=>t(i,n,...f),c=(f=Co())=>{i=a(h3([0]),f),n=a(),f.length!==0&&(i=a(h3([1]),f),n=a())},l=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let f=0,h=[];for(;f<e;){n=a();let p=n.slice();h.push(p),f+=n.length}return Et(...h)};return(f,h)=>{o(),c(f);let p;for(;!(p=h(l()));)c();return o(),p}}var Y6={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||qt(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,e)=>e.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function st(r,e,t={}){let n=(i,s,o)=>{let a=Y6[s];if(typeof a!="function")throw new Error("invalid validator function");let c=r[i];if(!(o&&c===void 0)&&!a(c,r))throw new Error("param "+String(i)+" is invalid. Expected "+s+", got "+c)};for(let[i,s]of Object.entries(e))n(i,s,!1);for(let[i,s]of Object.entries(t))n(i,s,!0);return r}var X6=()=>{throw new Error("not implemented")};function dr(r){let e=new WeakMap;return(t,...n)=>{let i=e.get(t);if(i!==void 0)return i;let s=r(t,...n);return e.set(t,s),s}}var fe=BigInt(0),ee=BigInt(1),pr=BigInt(2),J6=BigInt(3),Oo=BigInt(4),d3=BigInt(5),p3=BigInt(8),e8=BigInt(9),t8=BigInt(16);function Q(r,e){let t=r%e;return t>=fe?t:e+t}function r8(r,e,t){if(e<fe)throw new Error("invalid exponent, negatives unsupported");if(t<=fe)throw new Error("invalid modulus");if(t===ee)return fe;let n=ee;for(;e>fe;)e&ee&&(n=n*r%t),r=r*r%t,e>>=ee;return n}function te(r,e,t){let n=r;for(;e-- >fe;)n*=n,n%=t;return n}function y1(r,e){if(r===fe)throw new Error("invert: expected non-zero number");if(e<=fe)throw new Error("invert: expected positive modulus, got "+e);let t=Q(r,e),n=e,i=fe,s=ee,o=ee,a=fe;for(;t!==fe;){let l=n/t,u=n%t,f=i-o*l,h=s-a*l;n=t,t=u,i=o,s=a,o=f,a=h}if(n!==ee)throw new Error("invert: does not exist");return Q(i,e)}function n8(r){let e=(r-ee)/pr,t,n,i;for(t=r-ee,n=0;t%pr===fe;t/=pr,n++);for(i=pr;i<r&&r8(i,e,r)!==r-ee;i++)if(i>1e3)throw new Error("Cannot find square root: likely non-prime P");if(n===1){let o=(r+ee)/Oo;return function(c,l){let u=c.pow(l,o);if(!c.eql(c.sqr(u),l))throw new Error("Cannot find square root");return u}}let s=(t+ee)/pr;return function(a,c){if(a.pow(c,e)===a.neg(a.ONE))throw new Error("Cannot find square root");let l=n,u=a.pow(a.mul(a.ONE,i),t),f=a.pow(c,s),h=a.pow(c,t);for(;!a.eql(h,a.ONE);){if(a.eql(h,a.ZERO))return a.ZERO;let p=1;for(let w=a.sqr(h);p<l&&!a.eql(w,a.ONE);p++)w=a.sqr(w);let m=a.pow(u,ee<<BigInt(l-p-1));u=a.sqr(m),f=a.mul(f,m),h=a.mul(h,u),l=p}return f}}function i8(r){if(r%Oo===J6){let e=(r+ee)/Oo;return function(n,i){let s=n.pow(i,e);if(!n.eql(n.sqr(s),i))throw new Error("Cannot find square root");return s}}if(r%p3===d3){let e=(r-d3)/p3;return function(n,i){let s=n.mul(i,pr),o=n.pow(s,e),a=n.mul(i,o),c=n.mul(n.mul(a,pr),o),l=n.mul(a,n.sub(c,n.ONE));if(!n.eql(n.sqr(l),i))throw new Error("Cannot find square root");return l}}return r%t8,n8(r)}var m3=(r,e)=>(Q(r,e)&ee)===ee,s8=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Mo(r){let e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=s8.reduce((n,i)=>(n[i]="function",n),e);return st(r,t)}function o8(r,e,t){if(t<fe)throw new Error("invalid exponent, negatives unsupported");if(t===fe)return r.ONE;if(t===ee)return e;let n=r.ONE,i=e;for(;t>fe;)t&ee&&(n=r.mul(n,i)),i=r.sqr(i),t>>=ee;return n}function a8(r,e){let t=new Array(e.length),n=e.reduce((s,o,a)=>r.is0(o)?s:(t[a]=s,r.mul(s,o)),r.ONE),i=r.inv(n);return e.reduceRight((s,o,a)=>r.is0(o)?s:(t[a]=r.mul(s,t[a]),r.mul(s,o)),i),t}function Vo(r,e){let t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function $t(r,e,t=!1,n={}){if(r<=fe)throw new Error("invalid field: expected ORDER > 0, got "+r);let{nBitLength:i,nByteLength:s}=Vo(r,e);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o,a=Object.freeze({ORDER:r,isLE:t,BITS:i,BYTES:s,MASK:vn(i),ZERO:fe,ONE:ee,create:c=>Q(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return fe<=c&&c<r},is0:c=>c===fe,isOdd:c=>(c&ee)===ee,neg:c=>Q(-c,r),eql:(c,l)=>c===l,sqr:c=>Q(c*c,r),add:(c,l)=>Q(c+l,r),sub:(c,l)=>Q(c-l,r),mul:(c,l)=>Q(c*l,r),pow:(c,l)=>o8(a,c,l),div:(c,l)=>Q(c*y1(l,r),r),sqrN:c=>c*c,addN:(c,l)=>c+l,subN:(c,l)=>c-l,mulN:(c,l)=>c*l,inv:c=>y1(c,r),sqrt:n.sqrt||(c=>(o||(o=i8(r)),o(a,c))),invertBatch:c=>a8(a,c),cmov:(c,l,u)=>u?l:c,toBytes:c=>t?hr(c,s):zt(c,s),fromBytes:c=>{if(c.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+c.length);return t?Kt(c):vt(c)}});return Object.freeze(a)}function g3(r){if(typeof r!="bigint")throw new Error("field order must be bigint");let e=r.toString(2).length;return Math.ceil(e/8)}function Fo(r){let e=g3(r);return e+Math.ceil(e/2)}function y3(r,e,t=!1){let n=r.length,i=g3(e),s=Fo(e);if(n<16||n<s||n>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+n);let o=t?Kt(r):vt(r),a=Q(o,e-ee)+ee;return t?hr(a,i):zt(a,i)}var w3=BigInt(0),w1=BigInt(1);function Ho(r,e){let t=e.negate();return r?t:e}function b3(r,e){if(!Number.isSafeInteger(r)||r<=0||r>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+r)}function qo(r,e){b3(r,e);let t=Math.ceil(e/r)+1,n=2**(r-1);return{windows:t,windowSize:n}}function l8(r,e){if(!Array.isArray(r))throw new Error("array expected");r.forEach((t,n)=>{if(!(t instanceof e))throw new Error("invalid point at index "+n)})}function u8(r,e){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((t,n)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+n)})}var Ko=new WeakMap,x3=new WeakMap;function zo(r){return x3.get(r)||1}function b1(r,e){return{constTimeNegate:Ho,hasPrecomputes(t){return zo(t)!==1},unsafeLadder(t,n,i=r.ZERO){let s=t;for(;n>w3;)n&w1&&(i=i.add(s)),s=s.double(),n>>=w1;return i},precomputeWindow(t,n){let{windows:i,windowSize:s}=qo(n,e),o=[],a=t,c=a;for(let l=0;l<i;l++){c=a,o.push(c);for(let u=1;u<s;u++)c=c.add(a),o.push(c);a=c.double()}return o},wNAF(t,n,i){let{windows:s,windowSize:o}=qo(t,e),a=r.ZERO,c=r.BASE,l=BigInt(2**t-1),u=2**t,f=BigInt(t);for(let h=0;h<s;h++){let p=h*o,m=Number(i&l);i>>=f,m>o&&(m-=u,i+=w1);let w=p,d=p+Math.abs(m)-1,x=h%2!==0,E=m<0;m===0?c=c.add(Ho(x,n[w])):a=a.add(Ho(E,n[d]))}return{p:a,f:c}},wNAFUnsafe(t,n,i,s=r.ZERO){let{windows:o,windowSize:a}=qo(t,e),c=BigInt(2**t-1),l=2**t,u=BigInt(t);for(let f=0;f<o;f++){let h=f*a;if(i===w3)break;let p=Number(i&c);if(i>>=u,p>a&&(p-=l,i+=w1),p===0)continue;let m=n[h+Math.abs(p)-1];p<0&&(m=m.negate()),s=s.add(m)}return s},getPrecomputes(t,n,i){let s=Ko.get(n);return s||(s=this.precomputeWindow(n,t),t!==1&&Ko.set(n,i(s))),s},wNAFCached(t,n,i){let s=zo(t);return this.wNAF(s,this.getPrecomputes(s,t,i),n)},wNAFCachedUnsafe(t,n,i,s){let o=zo(t);return o===1?this.unsafeLadder(t,n,s):this.wNAFUnsafe(o,this.getPrecomputes(o,t,i),n,s)},setWindowSize(t,n){b3(n,e),x3.set(t,n),Ko.delete(t)}}}function x1(r,e,t,n){if(l8(t,r),u8(n,e),t.length!==n.length)throw new Error("arrays of points and scalars must have equal length");let i=r.ZERO,s=Uo(BigInt(t.length)),o=s>12?s-3:s>4?s-2:s?2:1,a=(1<<o)-1,c=new Array(a+1).fill(i),l=Math.floor((e.BITS-1)/o)*o,u=i;for(let f=l;f>=0;f-=o){c.fill(i);for(let p=0;p<n.length;p++){let m=n[p],w=Number(m>>BigInt(f)&BigInt(a));c[w]=c[w].add(t[p])}let h=i;for(let p=c.length-1,m=i;p>0;p--)m=m.add(c[p]),h=h.add(m);if(u=u.add(h),f!==0)for(let p=0;p<o;p++)u=u.double()}return u}function En(r){return Mo(r.Fp),st(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Vo(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}var Xe=BigInt(0),De=BigInt(1),v1=BigInt(2),f8=BigInt(8),h8={zip215:!0};function d8(r){let e=En(r);return st(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function v3(r){let e=d8(r),{Fp:t,n,prehash:i,hash:s,randomBytes:o,nByteLength:a,h:c}=e,l=v1<<BigInt(a*8)-De,u=t.create,f=$t(e.n,e.nBitLength),h=e.uvRatio||((b,y)=>{try{return{isValid:!0,value:t.sqrt(b*t.inv(y))}}catch{return{isValid:!1,value:Xe}}}),p=e.adjustScalarBytes||(b=>b),m=e.domain||((b,y,v)=>{if(Ye("phflag",v),y.length||v)throw new Error("Contexts/pre-hash are not supported");return b});function w(b,y){Ue("coordinate "+b,y,Xe,l)}function d(b){if(!(b instanceof g))throw new Error("ExtendedPoint expected")}let x=dr((b,y)=>{let{ex:v,ey:B,ez:C}=b,_=b.is0();y==null&&(y=_?f8:t.inv(C));let M=u(v*y),q=u(B*y),U=u(C*y);if(_)return{x:Xe,y:De};if(U!==De)throw new Error("invZ was invalid");return{x:M,y:q}}),E=dr(b=>{let{a:y,d:v}=e;if(b.is0())throw new Error("bad point: ZERO");let{ex:B,ey:C,ez:_,et:M}=b,q=u(B*B),U=u(C*C),G=u(_*_),Z=u(G*G),de=u(q*y),pe=u(G*u(de+U)),ye=u(Z+u(v*u(q*U)));if(pe!==ye)throw new Error("bad point: equation left != right (1)");let ve=u(B*C),Ne=u(_*M);if(ve!==Ne)throw new Error("bad point: equation left != right (2)");return!0});class g{constructor(y,v,B,C){this.ex=y,this.ey=v,this.ez=B,this.et=C,w("x",y),w("y",v),w("z",B),w("t",C),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(y){if(y instanceof g)throw new Error("extended point not allowed");let{x:v,y:B}=y||{};return w("x",v),w("y",B),new g(v,B,De,u(v*B))}static normalizeZ(y){let v=t.invertBatch(y.map(B=>B.ez));return y.map((B,C)=>B.toAffine(v[C])).map(g.fromAffine)}static msm(y,v){return x1(g,f,y,v)}_setWindowSize(y){T.setWindowSize(this,y)}assertValidity(){E(this)}equals(y){d(y);let{ex:v,ey:B,ez:C}=this,{ex:_,ey:M,ez:q}=y,U=u(v*q),G=u(_*C),Z=u(B*q),de=u(M*C);return U===G&&Z===de}is0(){return this.equals(g.ZERO)}negate(){return new g(u(-this.ex),this.ey,this.ez,u(-this.et))}double(){let{a:y}=e,{ex:v,ey:B,ez:C}=this,_=u(v*v),M=u(B*B),q=u(v1*u(C*C)),U=u(y*_),G=v+B,Z=u(u(G*G)-_-M),de=U+M,pe=de-q,ye=U-M,ve=u(Z*pe),Ne=u(de*ye),ke=u(Z*ye),tt=u(pe*de);return new g(ve,Ne,tt,ke)}add(y){d(y);let{a:v,d:B}=e,{ex:C,ey:_,ez:M,et:q}=this,{ex:U,ey:G,ez:Z,et:de}=y;if(v===BigInt(-1)){let O2=u((_-C)*(G+U)),M2=u((_+C)*(G-U)),bs=u(M2-O2);if(bs===Xe)return this.double();let V2=u(M*v1*de),F2=u(q*v1*Z),H2=F2+V2,q2=M2+O2,K2=F2-V2,T4=u(H2*bs),R4=u(q2*K2),P4=u(H2*K2),N4=u(bs*q2);return new g(T4,R4,N4,P4)}let pe=u(C*U),ye=u(_*G),ve=u(q*B*de),Ne=u(M*Z),ke=u((C+_)*(U+G)-pe-ye),tt=Ne-ve,ft=Ne+ve,rn=u(ye-v*pe),S4=u(ke*tt),I4=u(ft*rn),B4=u(ke*rn),k4=u(tt*ft);return new g(S4,I4,k4,B4)}subtract(y){return this.add(y.negate())}wNAF(y){return T.wNAFCached(this,y,g.normalizeZ)}multiply(y){let v=y;Ue("scalar",v,De,n);let{p:B,f:C}=this.wNAF(v);return g.normalizeZ([B,C])[0]}multiplyUnsafe(y,v=g.ZERO){let B=y;return Ue("scalar",B,Xe,n),B===Xe?L:this.is0()||B===De?this:T.wNAFCachedUnsafe(this,B,g.normalizeZ,v)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return T.unsafeLadder(this,n).is0()}toAffine(y){return x(this,y)}clearCofactor(){let{h:y}=e;return y===De?this:this.multiplyUnsafe(y)}static fromHex(y,v=!1){let{d:B,a:C}=e,_=t.BYTES;y=ie("pointHex",y,_),Ye("zip215",v);let M=y.slice(),q=y[_-1];M[_-1]=q&-129;let U=Kt(M),G=v?l:t.ORDER;Ue("pointHex.y",U,Xe,G);let Z=u(U*U),de=u(Z-De),pe=u(B*Z-C),{isValid:ye,value:ve}=h(de,pe);if(!ye)throw new Error("Point.fromHex: invalid y coordinate");let Ne=(ve&De)===De,ke=(q&128)!==0;if(!v&&ve===Xe&&ke)throw new Error("Point.fromHex: x=0 and x_0=1");return ke!==Ne&&(ve=u(-ve)),g.fromAffine({x:ve,y:U})}static fromPrivateKey(y){return P(y).point}toRawBytes(){let{x:y,y:v}=this.toAffine(),B=hr(v,t.BYTES);return B[B.length-1]|=y&De?128:0,B}toHex(){return xt(this.toRawBytes())}}g.BASE=new g(e.Gx,e.Gy,De,u(e.Gx*e.Gy)),g.ZERO=new g(Xe,De,De,Xe);let{BASE:S,ZERO:L}=g,T=b1(g,a*8);function k(b){return Q(b,n)}function R(b){return k(Kt(b))}function P(b){let y=t.BYTES;b=ie("private key",b,y);let v=ie("hashed private key",s(b),2*y),B=p(v.slice(0,y)),C=v.slice(y,2*y),_=R(B),M=S.multiply(_),q=M.toRawBytes();return{head:B,prefix:C,scalar:_,point:M,pointBytes:q}}function J(b){return P(b).pointBytes}function K(b=new Uint8Array,...y){let v=Et(...y);return R(s(m(v,ie("context",b),!!i)))}function F(b,y,v={}){b=ie("message",b),i&&(b=i(b));let{prefix:B,scalar:C,pointBytes:_}=P(y),M=K(v.context,B,b),q=S.multiply(M).toRawBytes(),U=K(v.context,q,_,b),G=k(M+U*C);Ue("signature.s",G,Xe,n);let Z=Et(q,hr(G,t.BYTES));return ie("result",Z,t.BYTES*2)}let le=h8;function A(b,y,v,B=le){let{context:C,zip215:_}=B,M=t.BYTES;b=ie("signature",b,2*M),y=ie("message",y),v=ie("publicKey",v,M),_!==void 0&&Ye("zip215",_),i&&(y=i(y));let q=Kt(b.slice(M,2*M)),U,G,Z;try{U=g.fromHex(v,_),G=g.fromHex(b.slice(0,M),_),Z=S.multiplyUnsafe(q)}catch{return!1}if(!_&&U.isSmallOrder())return!1;let de=K(C,G.toRawBytes(),U.toRawBytes(),y);return G.add(U.multiplyUnsafe(de)).subtract(Z).clearCofactor().equals(g.ZERO)}return S._setWindowSize(8),{CURVE:e,getPublicKey:J,sign:F,verify:A,ExtendedPoint:g,utils:{getExtendedPublicKey:P,randomPrivateKey:()=>o(t.BYTES),precompute(b=8,y=g.BASE){return y._setWindowSize(b),y.multiply(BigInt(3)),y}}}}var $o=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),E3=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),Qu=BigInt(0),p8=BigInt(1),A3=BigInt(2),Zu=BigInt(3),m8=BigInt(5),g8=BigInt(8);function y8(r){let e=BigInt(10),t=BigInt(20),n=BigInt(40),i=BigInt(80),s=$o,a=r*r%s*r%s,c=te(a,A3,s)*a%s,l=te(c,p8,s)*r%s,u=te(l,m8,s)*l%s,f=te(u,e,s)*u%s,h=te(f,t,s)*f%s,p=te(h,n,s)*h%s,m=te(p,i,s)*p%s,w=te(m,i,s)*p%s,d=te(w,e,s)*u%s;return{pow_p_5_8:te(d,A3,s)*r%s,b2:a}}function w8(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function b8(r,e){let t=$o,n=Q(e*e*e,t),i=Q(n*n*e,t),s=y8(r*i).pow_p_5_8,o=Q(r*n*s,t),a=Q(e*o*o,t),c=o,l=Q(o*E3,t),u=a===r,f=a===Q(-r,t),h=a===Q(-r*E3,t);return u&&(o=c),(f||h)&&(o=l),m3(o,t)&&(o=Q(-o,t)),{isValid:u||f,value:o}}var x8=$t($o,void 0,!0),v8={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:x8,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:g8,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:u3,randomBytes:Fr,adjustScalarBytes:w8,uvRatio:b8},S3=v3(v8);var E1=32;function I3(r,e,t){return S3.verify(e,t instanceof Uint8Array?t:t.subarray(),r)}var A1=class{type="Ed25519";raw;constructor(e){this.raw=Go(e,E1)}toMultihash(){return gt.digest(Kr(this))}toCID(){return ne.createV1(114,this.toMultihash())}toString(){return Y.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:X(this.raw,e.raw)}verify(e,t){return I3(this.raw,t,e)}};function jo(r){return r=Go(r,E1),new A1(r)}function Go(r,e){if(r=Uint8Array.from(r??[]),r.length!==e)throw new z(`Key must be a Uint8Array of length ${e}, got ${r.length}`);return r}var he;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1"})(he||(he={}));var Wo;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1"})(Wo||(Wo={}));(function(r){r.codec=()=>Nr(Wo)})(he||(he={}));var ot;(function(r){let e;r.codec=()=>(e==null&&(e=it((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),he.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{let s={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){let a=t.uint32();switch(a>>>3){case 1:{s.Type=he.codec().decode(t);break}case 2:{s.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>nt(t,r.codec()),r.decode=(t,n)=>rt(t,r.codec(),n)})(ot||(ot={}));var Qo;(function(r){let e;r.codec=()=>(e==null&&(e=it((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),he.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{let s={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){let a=t.uint32();switch(a>>>3){case 1:{s.Type=he.codec().decode(t);break}case 2:{s.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>nt(t,r.codec()),r.decode=(t,n)=>rt(t,r.codec(),n)})(Qo||(Qo={}));var Ln={};Te(Ln,{MAX_RSA_KEY_SIZE:()=>mi,generateRSAKeyPair:()=>Aa,jwkToJWKKeyPair:()=>Sa,jwkToPkcs1:()=>M8,jwkToPkix:()=>i2,jwkToRSAPrivateKey:()=>Ea,pkcs1ToJwk:()=>ba,pkcs1ToRSAPrivateKey:()=>va,pkixToJwk:()=>xa,pkixToRSAPublicKey:()=>s2});var A8=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Gt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),jt=new Uint32Array(64),Zo=class extends Hr{constructor(){super(64,32,8,!1),this.A=Gt[0]|0,this.B=Gt[1]|0,this.C=Gt[2]|0,this.D=Gt[3]|0,this.E=Gt[4]|0,this.F=Gt[5]|0,this.G=Gt[6]|0,this.H=Gt[7]|0}get(){let{A:e,B:t,C:n,D:i,E:s,F:o,G:a,H:c}=this;return[e,t,n,i,s,o,a,c]}set(e,t,n,i,s,o,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=i|0,this.E=s|0,this.F=o|0,this.G=a|0,this.H=c|0}process(e,t){for(let f=0;f<16;f++,t+=4)jt[f]=e.getUint32(t,!1);for(let f=16;f<64;f++){let h=jt[f-15],p=jt[f-2],m=Ze(h,7)^Ze(h,18)^h>>>3,w=Ze(p,17)^Ze(p,19)^p>>>10;jt[f]=w+jt[f-7]+m+jt[f-16]|0}let{A:n,B:i,C:s,D:o,E:a,F:c,G:l,H:u}=this;for(let f=0;f<64;f++){let h=Ze(a,6)^Ze(a,11)^Ze(a,25),p=u+h+a3(a,c,l)+A8[f]+jt[f]|0,w=(Ze(n,2)^Ze(n,13)^Ze(n,22))+c3(n,i,s)|0;u=l,l=c,c=a,a=o+p|0,o=s,s=i,i=n,n=p+w|0}n=n+this.A|0,i=i+this.B|0,s=s+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,l=l+this.G|0,u=u+this.H|0,this.set(n,i,s,o,a,c,l,u)}roundClean(){jt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var zr=h1(()=>new Zo);var H=vs(T3());function mr(r,e){let t=0;if(r.length===1)return r[0];for(let n=r.length-1;n>=0;n--)t+=r[r.length-1-n]*Math.pow(2,e*n);return t}function Wt(r,e,t=-1){let n=t,i=r,s=0,o=Math.pow(2,e);for(let a=1;a<8;a++){if(r<o){let c;if(n<0)c=new ArrayBuffer(a),s=a;else{if(n<a)return new ArrayBuffer(0);c=new ArrayBuffer(n),s=n}let l=new Uint8Array(c);for(let u=a-1;u>=0;u--){let f=Math.pow(2,u*e);l[s-u-1]=Math.floor(i/f),i-=l[s-u-1]*f}return c}o*=Math.pow(2,e)}return new ArrayBuffer(0)}function B1(...r){let e=0,t=0;for(let s of r)e+=s.length;let n=new ArrayBuffer(e),i=new Uint8Array(n);for(let s of r)i.set(s,t),t+=s.length;return i}function Xo(){let r=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){let a=r[0]===255&&r[1]&128,c=r[0]===0&&(r[1]&128)===0;(a||c)&&this.warnings.push("Needlessly long format")}let e=new ArrayBuffer(this.valueHex.byteLength),t=new Uint8Array(e);for(let a=0;a<this.valueHex.byteLength;a++)t[a]=0;t[0]=r[0]&128;let n=mr(t,8),i=new ArrayBuffer(this.valueHex.byteLength),s=new Uint8Array(i);for(let a=0;a<this.valueHex.byteLength;a++)s[a]=r[a];return s[0]&=127,mr(s,8)-n}function R3(r){let e=r<0?r*-1:r,t=128;for(let n=1;n<8;n++){if(e<=t){if(r<0){let o=t-e,a=Wt(o,8,n),c=new Uint8Array(a);return c[0]|=128,a}let i=Wt(e,8,n),s=new Uint8Array(i);if(s[0]&128){let o=i.slice(0),a=new Uint8Array(o);i=new ArrayBuffer(i.byteLength+1),s=new Uint8Array(i);for(let c=0;c<o.byteLength;c++)s[c+1]=a[c];s[0]=0}return i}t*=Math.pow(2,8)}return new ArrayBuffer(0)}function P3(r,e){if(r.byteLength!==e.byteLength)return!1;let t=new Uint8Array(r),n=new Uint8Array(e);for(let i=0;i<t.length;i++)if(t[i]!==n[i])return!1;return!0}function Oe(r,e){let t=r.toString(10);if(e<t.length)return"";let n=e-t.length,i=new Array(n);for(let o=0;o<n;o++)i[o]="0";return i.join("").concat(t)}var xf=Math.log(2);function k1(){if(typeof BigInt>"u")throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function Jo(r){let e=0,t=0;for(let i=0;i<r.length;i++){let s=r[i];e+=s.byteLength}let n=new Uint8Array(e);for(let i=0;i<r.length;i++){let s=r[i];n.set(new Uint8Array(s),t),t+=s.byteLength}return n.buffer}function kt(r,e,t,n){return e instanceof Uint8Array?e.byteLength?t<0?(r.error="Wrong parameter: inputOffset less than zero",!1):n<0?(r.error="Wrong parameter: inputLength less than zero",!1):e.byteLength-t-n<0?(r.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):!0:(r.error="Wrong parameter: inputBuffer has zero length",!1):(r.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}var Sn=class{constructor(){this.items=[]}write(e){this.items.push(e)}final(){return Jo(this.items)}},An=[new Uint8Array([1])],N3="0123456789";var Qr="",Je=new ArrayBuffer(0),e2=new Uint8Array(0),In="EndOfContent",C3="OCTET STRING",_3="BIT STRING";function Tt(r){var e;return e=class extends r{constructor(...n){var i;super(...n);let s=n[0]||{};this.isHexOnly=(i=s.isHexOnly)!==null&&i!==void 0?i:!1,this.valueHexView=s.valueHex?H.BufferSourceConverter.toUint8Array(s.valueHex):e2}get valueHex(){return this.valueHexView.slice().buffer}set valueHex(n){this.valueHexView=new Uint8Array(n)}fromBER(n,i,s){let o=n instanceof ArrayBuffer?new Uint8Array(n):n;if(!kt(this,o,i,s))return-1;let a=i+s;return this.valueHexView=o.subarray(i,a),this.valueHexView.length?(this.blockLength=s,a):(this.warnings.push("Zero buffer length"),i)}toBER(n=!1){return this.isHexOnly?n?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",Je)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:H.Convert.ToHex(this.valueHexView)}}},e.NAME="hexBlock",e}var St=class{constructor({blockLength:e=0,error:t=Qr,warnings:n=[],valueBeforeDecode:i=e2}={}){this.blockLength=e,this.error=t,this.warnings=n,this.valueBeforeDecodeView=H.BufferSourceConverter.toUint8Array(i)}static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(e){this.valueBeforeDecodeView=new Uint8Array(e)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:H.Convert.ToHex(this.valueBeforeDecodeView)}}};St.NAME="baseBlock";var Ie=class extends St{fromBER(e,t,n){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(e,t){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}};Ie.NAME="valueBlock";var T1=class extends Tt(St){constructor({idBlock:e={}}={}){var t,n,i,s;super(),e?(this.isHexOnly=(t=e.isHexOnly)!==null&&t!==void 0?t:!1,this.valueHexView=e.valueHex?H.BufferSourceConverter.toUint8Array(e.valueHex):e2,this.tagClass=(n=e.tagClass)!==null&&n!==void 0?n:-1,this.tagNumber=(i=e.tagNumber)!==null&&i!==void 0?i:-1,this.isConstructed=(s=e.isConstructed)!==null&&s!==void 0?s:!1):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(e=!1){let t=0;switch(this.tagClass){case 1:t|=0;break;case 2:t|=64;break;case 3:t|=128;break;case 4:t|=192;break;default:return this.error="Unknown tag class",Je}if(this.isConstructed&&(t|=32),this.tagNumber<31&&!this.isHexOnly){let i=new Uint8Array(1);if(!e){let s=this.tagNumber;s&=31,t|=s,i[0]=t}return i.buffer}if(!this.isHexOnly){let i=Wt(this.tagNumber,7),s=new Uint8Array(i),o=i.byteLength,a=new Uint8Array(o+1);if(a[0]=t|31,!e){for(let c=0;c<o-1;c++)a[c+1]=s[c]|128;a[o]=s[o-1]}return a.buffer}let n=new Uint8Array(this.valueHexView.byteLength+1);if(n[0]=t|31,!e){let i=this.valueHexView;for(let s=0;s<i.length-1;s++)n[s+1]=i[s]|128;n[this.valueHexView.byteLength]=i[i.length-1]}return n.buffer}fromBER(e,t,n){let i=H.BufferSourceConverter.toUint8Array(e);if(!kt(this,i,t,n))return-1;let s=i.subarray(t,t+n);if(s.length===0)return this.error="Zero buffer length",-1;switch(s[0]&192){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=(s[0]&32)===32,this.isHexOnly=!1;let a=s[0]&31;if(a!==31)this.tagNumber=a,this.blockLength=1;else{let c=1,l=this.valueHexView=new Uint8Array(255),u=255;for(;s[c]&128;){if(l[c-1]=s[c]&127,c++,c>=s.length)return this.error="End of input reached before message was fully decoded",-1;if(c===u){u+=255;let h=new Uint8Array(u);for(let p=0;p<l.length;p++)h[p]=l[p];l=this.valueHexView=new Uint8Array(u)}}this.blockLength=c+1,l[c-1]=s[c]&127;let f=new Uint8Array(c);for(let h=0;h<c;h++)f[h]=l[h];l=this.valueHexView=new Uint8Array(c),l.set(f),this.blockLength<=9?this.tagNumber=mr(l,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(this.tagClass===1&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}};T1.NAME="identificationBlock";var R1=class extends St{constructor({lenBlock:e={}}={}){var t,n,i;super(),this.isIndefiniteForm=(t=e.isIndefiniteForm)!==null&&t!==void 0?t:!1,this.longFormUsed=(n=e.longFormUsed)!==null&&n!==void 0?n:!1,this.length=(i=e.length)!==null&&i!==void 0?i:0}fromBER(e,t,n){let i=H.BufferSourceConverter.toUint8Array(e);if(!kt(this,i,t,n))return-1;let s=i.subarray(t,t+n);if(s.length===0)return this.error="Zero buffer length",-1;if(s[0]===255)return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=s[0]===128,this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(s[0]&128),this.longFormUsed===!1)return this.length=s[0],this.blockLength=1,t+this.blockLength;let o=s[0]&127;if(o>8)return this.error="Too big integer",-1;if(o+1>s.length)return this.error="End of input reached before message was fully decoded",-1;let a=t+1,c=i.subarray(a,a+o);return c[o-1]===0&&this.warnings.push("Needlessly long encoded length"),this.length=mr(c,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=o+1,t+this.blockLength}toBER(e=!1){let t,n;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),e===!1&&(n=new Uint8Array(t),n[0]=128),t;if(this.longFormUsed){let i=Wt(this.length,8);if(i.byteLength>127)return this.error="Too big length",Je;if(t=new ArrayBuffer(i.byteLength+1),e)return t;let s=new Uint8Array(i);n=new Uint8Array(t),n[0]=i.byteLength|128;for(let o=0;o<i.byteLength;o++)n[o+1]=s[o];return t}return t=new ArrayBuffer(1),e===!1&&(n=new Uint8Array(t),n[0]=this.length),t}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}};R1.NAME="lengthBlock";var I={},we=class extends St{constructor({name:e=Qr,optional:t=!1,primitiveSchema:n,...i}={},s){super(i),this.name=e,this.optional=t,n&&(this.primitiveSchema=n),this.idBlock=new T1(i),this.lenBlock=new R1(i),this.valueBlock=s?new s(i):new Ie(i)}fromBER(e,t,n){let i=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return i===-1?(this.error=this.valueBlock.error,i):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),i)}toBER(e,t){let n=t||new Sn;t||U3(this);let i=this.idBlock.toBER(e);if(n.write(i),this.lenBlock.isIndefiniteForm)n.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(e,n),n.write(new ArrayBuffer(2));else{let s=this.valueBlock.toBER(e);this.lenBlock.length=s.byteLength;let o=this.lenBlock.toBER(e);n.write(o),n.write(s)}return t?Je:n.final()}toJSON(){let e={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}toString(e="ascii"){return e==="ascii"?this.onAsciiEncoding():H.Convert.ToHex(this.toBER())}onAsciiEncoding(){return`${this.constructor.NAME} : ${H.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`}isEqual(e){if(this===e)return!0;if(!(e instanceof this.constructor))return!1;let t=this.toBER(),n=e.toBER();return P3(t,n)}};we.NAME="BaseBlock";function U3(r){if(r instanceof I.Constructed)for(let e of r.valueBlock.value)U3(e)&&(r.lenBlock.isIndefiniteForm=!0);return!!r.lenBlock.isIndefiniteForm}var P1=class extends we{constructor({value:e=Qr,...t}={},n){super(t,n),e&&this.fromString(e)}getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}fromBER(e,t,n){let i=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return i===-1?(this.error=this.valueBlock.error,i):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),i)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}};P1.NAME="BaseStringBlock";var N1=class extends Tt(Ie){constructor({isHexOnly:e=!0,...t}={}){super(t),this.isHexOnly=e}};N1.NAME="PrimitiveValueBlock";var D3,L1=class extends we{constructor(e={}){super(e,N1),this.idBlock.isConstructed=!1}};D3=L1;I.Primitive=D3;L1.NAME="PRIMITIVE";function L8(r,e){if(r instanceof e)return r;let t=new e;return t.idBlock=r.idBlock,t.lenBlock=r.lenBlock,t.warnings=r.warnings,t.valueBeforeDecodeView=r.valueBeforeDecodeView,t}function hi(r,e=0,t=r.length){let n=e,i=new we({},Ie),s=new St;if(!kt(s,r,e,t))return i.error=s.error,{offset:-1,result:i};if(!r.subarray(e,e+t).length)return i.error="Zero buffer length",{offset:-1,result:i};let a=i.idBlock.fromBER(r,e,t);if(i.idBlock.warnings.length&&i.warnings.concat(i.idBlock.warnings),a===-1)return i.error=i.idBlock.error,{offset:-1,result:i};if(e=a,t-=i.idBlock.blockLength,a=i.lenBlock.fromBER(r,e,t),i.lenBlock.warnings.length&&i.warnings.concat(i.lenBlock.warnings),a===-1)return i.error=i.lenBlock.error,{offset:-1,result:i};if(e=a,t-=i.lenBlock.blockLength,!i.idBlock.isConstructed&&i.lenBlock.isIndefiniteForm)return i.error="Indefinite length form used for primitive encoding form",{offset:-1,result:i};let c=we;switch(i.idBlock.tagClass){case 1:if(i.idBlock.tagNumber>=37&&i.idBlock.isHexOnly===!1)return i.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:i};switch(i.idBlock.tagNumber){case 0:if(i.idBlock.isConstructed&&i.lenBlock.length>0)return i.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:i};c=I.EndOfContent;break;case 1:c=I.Boolean;break;case 2:c=I.Integer;break;case 3:c=I.BitString;break;case 4:c=I.OctetString;break;case 5:c=I.Null;break;case 6:c=I.ObjectIdentifier;break;case 10:c=I.Enumerated;break;case 12:c=I.Utf8String;break;case 13:c=I.RelativeObjectIdentifier;break;case 14:c=I.TIME;break;case 15:return i.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:i};case 16:c=I.Sequence;break;case 17:c=I.Set;break;case 18:c=I.NumericString;break;case 19:c=I.PrintableString;break;case 20:c=I.TeletexString;break;case 21:c=I.VideotexString;break;case 22:c=I.IA5String;break;case 23:c=I.UTCTime;break;case 24:c=I.GeneralizedTime;break;case 25:c=I.GraphicString;break;case 26:c=I.VisibleString;break;case 27:c=I.GeneralString;break;case 28:c=I.UniversalString;break;case 29:c=I.CharacterString;break;case 30:c=I.BmpString;break;case 31:c=I.DATE;break;case 32:c=I.TimeOfDay;break;case 33:c=I.DateTime;break;case 34:c=I.Duration;break;default:{let l=i.idBlock.isConstructed?new I.Constructed:new I.Primitive;l.idBlock=i.idBlock,l.lenBlock=i.lenBlock,l.warnings=i.warnings,i=l}}break;case 2:case 3:case 4:default:c=i.idBlock.isConstructed?I.Constructed:I.Primitive}return i=L8(i,c),a=i.fromBER(r,e,i.lenBlock.isIndefiniteForm?t:i.lenBlock.length),i.valueBeforeDecodeView=r.subarray(n,n+i.blockLength),{offset:a,result:i}}function t2(r){if(!r.byteLength){let e=new we({},Ie);return e.error="Input buffer has zero length",{offset:-1,result:e}}return hi(H.BufferSourceConverter.toUint8Array(r).slice(),0,r.byteLength)}function C8(r,e){return r?1:e}var at=class extends Ie{constructor({value:e=[],isIndefiniteForm:t=!1,...n}={}){super(n),this.value=e,this.isIndefiniteForm=t}fromBER(e,t,n){let i=H.BufferSourceConverter.toUint8Array(e);if(!kt(this,i,t,n))return-1;if(this.valueBeforeDecodeView=i.subarray(t,t+n),this.valueBeforeDecodeView.length===0)return this.warnings.push("Zero buffer length"),t;let s=t;for(;C8(this.isIndefiniteForm,n)>0;){let o=hi(i,s,n);if(o.offset===-1)return this.error=o.result.error,this.warnings.concat(o.result.warnings),-1;if(s=o.offset,this.blockLength+=o.result.blockLength,n-=o.result.blockLength,this.value.push(o.result),this.isIndefiniteForm&&o.result.constructor.NAME===In)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===In?this.value.pop():this.warnings.push("No EndOfContent block encoded")),s}toBER(e,t){let n=t||new Sn;for(let i=0;i<this.value.length;i++)this.value[i].toBER(e,n);return t?Je:n.final()}toJSON(){let e={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(let t of this.value)e.value.push(t.toJSON());return e}};at.NAME="ConstructedValueBlock";var O3,Qt=class extends we{constructor(e={}){super(e,at),this.idBlock.isConstructed=!0}fromBER(e,t,n){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;let i=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return i===-1?(this.error=this.valueBlock.error,i):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),i)}onAsciiEncoding(){let e=[];for(let n of this.valueBlock.value)e.push(n.toString("ascii").split(`
./node_modules/@libp2p/pnet/dist/index.min.js:2:"use strict";var Libp2PPnet=(()=>{var er=Object.create;var le=Object.defineProperty;var tr=Object.getOwnPropertyDescriptor;var rr=Object.getOwnPropertyNames;var nr=Object.getPrototypeOf,or=Object.prototype.hasOwnProperty;var at=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),q=(r,e)=>{for(var t in e)le(r,t,{get:e[t],enumerable:!0})},ft=(r,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of rr(e))!or.call(r,o)&&o!==t&&le(r,o,{get:()=>e[o],enumerable:!(n=tr(e,o))||n.enumerable});return r};var sr=(r,e,t)=>(t=r!=null?er(nr(r)):{},ft(e||!r||!r.__esModule?le(t,"default",{value:r,enumerable:!0}):t,r)),ir=r=>ft(le({},"__esModule",{value:!0}),r);var Kt=at((bs,Gt)=>{var In=(r,e)=>function(){return e||(0,r[Object.keys(r)[0]])((e={exports:{}}).exports,e),e.exports},Bn=(()=>{for(var r=new Uint8Array(128),e=0;e<64;e++)r[e<26?e+65:e<52?e+71:e<62?e-4:e*4-205]=e;return t=>{for(var n=t.length,o=new Uint8Array((n-(t[n-1]=="=")-(t[n-2]=="="))*3/4|0),i=0,a=0;i<n;){var f=r[t.charCodeAt(i++)],c=r[t.charCodeAt(i++)],y=r[t.charCodeAt(i++)],p=r[t.charCodeAt(i++)];o[a++]=f<<2|c>>4,o[a++]=c<<4|y>>2,o[a++]=y<<6|p}return o}})(),vn=In({"wasm-binary:./xsalsa20.wat"(r,e){e.exports=Bn("AGFzbQEAAAABGgNgBn9/f39/fwBgBn9/f39+fwF+YAN/f38AAwcGAAEBAgICBQUBAQroBwcoAwZtZW1vcnkCAAx4c2Fsc2EyMF94b3IAAAxjb3JlX3NhbHNhMjAABArqEQYYACAAIAEgAiADIAQgACkDACAFEAE3AwALPQBB8AAgAyAFEAMgACABIAIgA0EQaiAEQfAAEAJB8ABCADcDAEH4AEIANwMAQYABQgA3AwBBiAFCADcDAAuHBQEBfyACQQBGBEBCAA8LQdAAIAUpAwA3AwBB2AAgBUEIaikDADcDAEHgACAFQRBqKQMANwMAQegAIAVBGGopAwA3AwBBACADKQMANwMAQQggBDcDAAJAA0AgAkHAAEkNAUEQQQBB0AAQBSAAIAEpAwBBECkDAIU3AwAgAEEIaiABQQhqKQMAQRgpAwCFNwMAIABBEGogAUEQaikDAEEgKQMAhTcDACAAQRhqIAFBGGopAwBBKCkDAIU3AwAgAEEgaiABQSBqKQMAQTApAwCFNwMAIABBKGogAUEoaikDAEE4KQMAhTcDACAAQTBqIAFBMGopAwBBwAApAwCFNwMAIABBOGogAUE4aikDAEHIACkDAIU3AwBBCEEIKQMAQgF8NwMAIABBwABqIQAgAUHAAGohASACQcAAayECDAALC0EIKQMAIQQgAkEASwRAQRBBAEHQABAFAkACQAJAAkACQAJAAkACQCACQQhuDgcHBgUEAwIBAAsgAEE4aiABQThqKQMAQcgAKQMAhTcDAAsgAEEwaiABQTBqKQMAQcAAKQMAhTcDAAsgAEEoaiABQShqKQMAQTgpAwCFNwMACyAAQSBqIAFBIGopAwBBMCkDAIU3AwALIABBGGogAUEYaikDAEEoKQMAhTcDAAsgAEEQaiABQRBqKQMAQSApAwCFNwMACyAAQQhqIAFBCGopAwBBGCkDAIU3AwALIAAgASkDAEEQKQMAhTcDAAtBEEIANwMAQRhCADcDAEEgQgA3AwBBKEIANwMAQTBCADcDAEE4QgA3AwBBwABCADcDAEHIAEIANwMAQdAAQgA3AwBB2ABCADcDAEHgAEIANwMAQegAQgA3AwAgBA8LnQUBEX9B5fDBiwYhA0HuyIGZAyEIQbLaiMsHIQ1B9MqB2QYhEiACKAIAIQQgAkEEaigCACEFIAJBCGooAgAhBiACQQxqKAIAIQcgAkEQaigCACEOIAJBFGooAgAhDyACQRhqKAIAIRAgAkEcaigCACERIAEoAgAhCSABQQRqKAIAIQogAUEIaigCACELIAFBDGooAgAhDEEUIRMCQANAIBNBAEYNASAHIAMgD2pBB3dzIQcgCyAHIANqQQl3cyELIA8gCyAHakENd3MhDyADIA8gC2pBEndzIQMgDCAIIARqQQd3cyEMIBAgDCAIakEJd3MhECAEIBAgDGpBDXdzIQQgCCAEIBBqQRJ3cyEIIBEgDSAJakEHd3MhESAFIBEgDWpBCXdzIQUgCSAFIBFqQQ13cyEJIA0gCSAFakESd3MhDSAGIBIgDmpBB3dzIQYgCiAGIBJqQQl3cyEKIA4gCiAGakENd3MhDiASIA4gCmpBEndzIRIgBCADIAZqQQd3cyEEIAUgBCADakEJd3MhBSAGIAUgBGpBDXdzIQYgAyAGIAVqQRJ3cyEDIAkgCCAHakEHd3MhCSAKIAkgCGpBCXdzIQogByAKIAlqQQ13cyEHIAggByAKakESd3MhCCAOIA0gDGpBB3dzIQ4gCyAOIA1qQQl3cyELIAwgCyAOakENd3MhDCANIAwgC2pBEndzIQ0gDyASIBFqQQd3cyEPIBAgDyASakEJd3MhECARIBAgD2pBDXdzIREgEiARIBBqQRJ3cyESIBNBAmshEwwACwsgACADNgIAIABBBGogCDYCACAAQQhqIA02AgAgAEEMaiASNgIAIABBEGogCTYCACAAQRRqIAo2AgAgAEEYaiALNgIAIABBHGogDDYCAAsKACAAIAEgAhAFC90GASF/QeXwwYsGIQNB7siBmQMhCEGy2ojLByENQfTKgdkGIRIgAigCACEEIAJBBGooAgAhBSACQQhqKAIAIQYgAkEMaigCACEHIAJBEGooAgAhDiACQRRqKAIAIQ8gAkEYaigCACEQIAJBHGooAgAhESABKAIAIQkgAUEEaigCACEKIAFBCGooAgAhCyABQQxqKAIAIQwgAyETIAQhFCAFIRUgBiEWIAchFyAIIRggCSEZIAohGiALIRsgDCEcIA0hHSAOIR4gDyEfIBAhICARISEgEiEiQRQhIwJAA0AgI0EARg0BIAcgAyAPakEHd3MhByALIAcgA2pBCXdzIQsgDyALIAdqQQ13cyEPIAMgDyALakESd3MhAyAMIAggBGpBB3dzIQwgECAMIAhqQQl3cyEQIAQgECAMakENd3MhBCAIIAQgEGpBEndzIQggESANIAlqQQd3cyERIAUgESANakEJd3MhBSAJIAUgEWpBDXdzIQkgDSAJIAVqQRJ3cyENIAYgEiAOakEHd3MhBiAKIAYgEmpBCXdzIQogDiAKIAZqQQ13cyEOIBIgDiAKakESd3MhEiAEIAMgBmpBB3dzIQQgBSAEIANqQQl3cyEFIAYgBSAEakENd3MhBiADIAYgBWpBEndzIQMgCSAIIAdqQQd3cyEJIAogCSAIakEJd3MhCiAHIAogCWpBDXdzIQcgCCAHIApqQRJ3cyEIIA4gDSAMakEHd3MhDiALIA4gDWpBCXdzIQsgDCALIA5qQQ13cyEMIA0gDCALakESd3MhDSAPIBIgEWpBB3dzIQ8gECAPIBJqQQl3cyEQIBEgECAPakENd3MhESASIBEgEGpBEndzIRIgI0ECayEjDAALCyAAIAMgE2o2AgAgAEEEaiAEIBRqNgIAIABBCGogBSAVajYCACAAQQxqIAYgFmo2AgAgAEEQaiAHIBdqNgIAIABBFGogCCAYajYCACAAQRhqIAkgGWo2AgAgAEEcaiAKIBpqNgIAIABBIGogCyAbajYCACAAQSRqIAwgHGo2AgAgAEEoaiANIB1qNgIAIABBLGogDiAeajYCACAAQTBqIA8gH2o2AgAgAEE0aiAQICBqNgIAIABBOGogESAhajYCACAAQTxqIBIgImo2AgAL")}}),Cn=vn(),Qn=new WebAssembly.Module(Cn);Gt.exports=r=>new WebAssembly.Instance(Qn,r).exports});var Yt=at((ys,Jt)=>{var he=typeof WebAssembly<"u"&&Kt()(),Be=new Uint8Array([101,120,112,97,110,100,32,51,50,45,98,121,116,101,32,107]),P=144,ne=P,Ie=[];Jt.exports=k;k.NONCEBYTES=24;k.KEYBYTES=32;k.core_hsalsa20=Ht;k.SIGMA=Be;function k(r,e){if(!(this instanceof k))return new k(r,e);if(!r||r.length<24)throw new Error("nonce must be at least 24 bytes");if(!e||e.length<32)throw new Error("key must be at least 32 bytes");this._xor=he?new ve(r,e):new tt(r,e)}k.prototype.update=function(r,e){if(!r)throw new Error("input must be Uint8Array or Buffer");return e||(e=new Uint8Array(r.length)),r.length&&this._xor.update(r,e),e};k.prototype.final=k.prototype.finalize=function(){this._xor.finalize(),this._xor=null};function ve(r,e){Ie.length||(Ie.push(P),P+=64),this._pointer=Ie.pop(),this._nonce=this._pointer+8,this._key=this._nonce+24,this._overflow=0,this._memory=new Uint8Array(he.memory.buffer),this._memory.fill(0,this._pointer,this._pointer+8),this._memory.set(r,this._nonce),this._memory.set(e,this._key)}ve.prototype.realloc=function(r){he.memory.grow(Math.ceil(Math.abs(r-this._memory.length)/65536)),this._memory=new Uint8Array(he.memory.buffer)};ve.prototype.update=function(r,e){var t=this._overflow+r.length,n=P+this._overflow;ne=P+t,ne>=this._memory.length&&this.realloc(ne),this._memory.set(r,n),he.xsalsa20_xor(this._pointer,P,P,t,this._nonce,this._key),e.set(this._memory.subarray(n,P+t)),this._overflow=t&63};ve.prototype.finalize=function(){this._memory.fill(0,this._pointer,this._key+32),ne>P&&(this._memory.fill(0,P,ne),ne=0),Ie.push(this._pointer)};function tt(r,e){this._s=new Uint8Array(32),this._z=new Uint8Array(16),this._overflow=0,Ht(this._s,r,e,Be);for(var t=0;t<8;t++)this._z[t]=r[t+16]}tt.prototype.update=function(r,e){for(var t=new Uint8Array(64),n=0,o=this._overflow,i=r.length+this._overflow,a=this._z,f=-this._overflow,c=-this._overflow;i>=64;){for(Vt(t,a,this._s,Be);o<64;o++)e[c+o]=r[f+o]^t[o];for(n=1,o=8;o<16;o++)n+=a[o]&255|0,a[o]=n&255,n>>>=8;i-=64,c+=64,f+=64,o=0}if(i>0)for(Vt(t,a,this._s,Be);o<i;o++)e[c+o]=r[f+o]^t[o];this._overflow=i&63};tt.prototype.finalize=function(){this._s.fill(0),this._z.fill(0)};function Vt(r,e,t,n){for(var o=n[0]&255|(n[1]&255)<<8|(n[2]&255)<<16|(n[3]&255)<<24,i=t[0]&255|(t[1]&255)<<8|(t[2]&255)<<16|(t[3]&255)<<24,a=t[4]&255|(t[5]&255)<<8|(t[6]&255)<<16|(t[7]&255)<<24,f=t[8]&255|(t[9]&255)<<8|(t[10]&255)<<16|(t[11]&255)<<24,c=t[12]&255|(t[13]&255)<<8|(t[14]&255)<<16|(t[15]&255)<<24,y=n[4]&255|(n[5]&255)<<8|(n[6]&255)<<16|(n[7]&255)<<24,p=e[0]&255|(e[1]&255)<<8|(e[2]&255)<<16|(e[3]&255)<<24,h=e[4]&255|(e[5]&255)<<8|(e[6]&255)<<16|(e[7]&255)<<24,I=e[8]&255|(e[9]&255)<<8|(e[10]&255)<<16|(e[11]&255)<<24,z=e[12]&255|(e[13]&255)<<8|(e[14]&255)<<16|(e[15]&255)<<24,d=n[8]&255|(n[9]&255)<<8|(n[10]&255)<<16|(n[11]&255)<<24,w=t[16]&255|(t[17]&255)<<8|(t[18]&255)<<16|(t[19]&255)<<24,u=t[20]&255|(t[21]&255)<<8|(t[22]&255)<<16|(t[23]&255)<<24,E=t[24]&255|(t[25]&255)<<8|(t[26]&255)<<16|(t[27]&255)<<24,N=t[28]&255|(t[29]&255)<<8|(t[30]&255)<<16|(t[31]&255)<<24,U=n[12]&255|(n[13]&255)<<8|(n[14]&255)<<16|(n[15]&255)<<24,l=o,A=i,g=a,x=f,m=c,b=y,B=p,v=h,C=I,Q=z,S=d,M=w,T=u,_=E,R=N,D=U,s,oe=0;oe<20;oe+=2)s=l+T|0,m^=s<<7|s>>>25,s=m+l|0,C^=s<<9|s>>>23,s=C+m|0,T^=s<<13|s>>>19,s=T+C|0,l^=s<<18|s>>>14,s=b+A|0,Q^=s<<7|s>>>25,s=Q+b|0,_^=s<<9|s>>>23,s=_+Q|0,A^=s<<13|s>>>19,s=A+_|0,b^=s<<18|s>>>14,s=S+B|0,R^=s<<7|s>>>25,s=R+S|0,g^=s<<9|s>>>23,s=g+R|0,B^=s<<13|s>>>19,s=B+g|0,S^=s<<18|s>>>14,s=D+M|0,x^=s<<7|s>>>25,s=x+D|0,v^=s<<9|s>>>23,s=v+x|0,M^=s<<13|s>>>19,s=M+v|0,D^=s<<18|s>>>14,s=l+x|0,A^=s<<7|s>>>25,s=A+l|0,g^=s<<9|s>>>23,s=g+A|0,x^=s<<13|s>>>19,s=x+g|0,l^=s<<18|s>>>14,s=b+m|0,B^=s<<7|s>>>25,s=B+b|0,v^=s<<9|s>>>23,s=v+B|0,m^=s<<13|s>>>19,s=m+v|0,b^=s<<18|s>>>14,s=S+Q|0,M^=s<<7|s>>>25,s=M+S|0,C^=s<<9|s>>>23,s=C+M|0,Q^=s<<13|s>>>19,s=Q+C|0,S^=s<<18|s>>>14,s=D+R|0,T^=s<<7|s>>>25,s=T+D|0,_^=s<<9|s>>>23,s=_+T|0,R^=s<<13|s>>>19,s=R+_|0,D^=s<<18|s>>>14;l=l+o|0,A=A+i|0,g=g+a|0,x=x+f|0,m=m+c|0,b=b+y|0,B=B+p|0,v=v+h|0,C=C+I|0,Q=Q+z|0,S=S+d|0,M=M+w|0,T=T+u|0,_=_+E|0,R=R+N|0,D=D+U|0,r[0]=l>>>0&255,r[1]=l>>>8&255,r[2]=l>>>16&255,r[3]=l>>>24&255,r[4]=A>>>0&255,r[5]=A>>>8&255,r[6]=A>>>16&255,r[7]=A>>>24&255,r[8]=g>>>0&255,r[9]=g>>>8&255,r[10]=g>>>16&255,r[11]=g>>>24&255,r[12]=x>>>0&255,r[13]=x>>>8&255,r[14]=x>>>16&255,r[15]=x>>>24&255,r[16]=m>>>0&255,r[17]=m>>>8&255,r[18]=m>>>16&255,r[19]=m>>>24&255,r[20]=b>>>0&255,r[21]=b>>>8&255,r[22]=b>>>16&255,r[23]=b>>>24&255,r[24]=B>>>0&255,r[25]=B>>>8&255,r[26]=B>>>16&255,r[27]=B>>>24&255,r[28]=v>>>0&255,r[29]=v>>>8&255,r[30]=v>>>16&255,r[31]=v>>>24&255,r[32]=C>>>0&255,r[33]=C>>>8&255,r[34]=C>>>16&255,r[35]=C>>>24&255,r[36]=Q>>>0&255,r[37]=Q>>>8&255,r[38]=Q>>>16&255,r[39]=Q>>>24&255,r[40]=S>>>0&255,r[41]=S>>>8&255,r[42]=S>>>16&255,r[43]=S>>>24&255,r[44]=M>>>0&255,r[45]=M>>>8&255,r[46]=M>>>16&255,r[47]=M>>>24&255,r[48]=T>>>0&255,r[49]=T>>>8&255,r[50]=T>>>16&255,r[51]=T>>>24&255,r[52]=_>>>0&255,r[53]=_>>>8&255,r[54]=_>>>16&255,r[55]=_>>>24&255,r[56]=R>>>0&255,r[57]=R>>>8&255,r[58]=R>>>16&255,r[59]=R>>>24&255,r[60]=D>>>0&255,r[61]=D>>>8&255,r[62]=D>>>16&255,r[63]=D>>>24&255}function Ht(r,e,t,n){for(var o=n[0]&255|(n[1]&255)<<8|(n[2]&255)<<16|(n[3]&255)<<24,i=t[0]&255|(t[1]&255)<<8|(t[2]&255)<<16|(t[3]&255)<<24,a=t[4]&255|(t[5]&255)<<8|(t[6]&255)<<16|(t[7]&255)<<24,f=t[8]&255|(t[9]&255)<<8|(t[10]&255)<<16|(t[11]&255)<<24,c=t[12]&255|(t[13]&255)<<8|(t[14]&255)<<16|(t[15]&255)<<24,y=n[4]&255|(n[5]&255)<<8|(n[6]&255)<<16|(n[7]&255)<<24,p=e[0]&255|(e[1]&255)<<8|(e[2]&255)<<16|(e[3]&255)<<24,h=e[4]&255|(e[5]&255)<<8|(e[6]&255)<<16|(e[7]&255)<<24,I=e[8]&255|(e[9]&255)<<8|(e[10]&255)<<16|(e[11]&255)<<24,z=e[12]&255|(e[13]&255)<<8|(e[14]&255)<<16|(e[15]&255)<<24,d=n[8]&255|(n[9]&255)<<8|(n[10]&255)<<16|(n[11]&255)<<24,w=t[16]&255|(t[17]&255)<<8|(t[18]&255)<<16|(t[19]&255)<<24,u=t[20]&255|(t[21]&255)<<8|(t[22]&255)<<16|(t[23]&255)<<24,E=t[24]&255|(t[25]&255)<<8|(t[26]&255)<<16|(t[27]&255)<<24,N=t[28]&255|(t[29]&255)<<8|(t[30]&255)<<16|(t[31]&255)<<24,U=n[12]&255|(n[13]&255)<<8|(n[14]&255)<<16|(n[15]&255)<<24,l=o,A=i,g=a,x=f,m=c,b=y,B=p,v=h,C=I,Q=z,S=d,M=w,T=u,_=E,R=N,D=U,s,oe=0;oe<20;oe+=2)s=l+T|0,m^=s<<7|s>>>25,s=m+l|0,C^=s<<9|s>>>23,s=C+m|0,T^=s<<13|s>>>19,s=T+C|0,l^=s<<18|s>>>14,s=b+A|0,Q^=s<<7|s>>>25,s=Q+b|0,_^=s<<9|s>>>23,s=_+Q|0,A^=s<<13|s>>>19,s=A+_|0,b^=s<<18|s>>>14,s=S+B|0,R^=s<<7|s>>>25,s=R+S|0,g^=s<<9|s>>>23,s=g+R|0,B^=s<<13|s>>>19,s=B+g|0,S^=s<<18|s>>>14,s=D+M|0,x^=s<<7|s>>>25,s=x+D|0,v^=s<<9|s>>>23,s=v+x|0,M^=s<<13|s>>>19,s=M+v|0,D^=s<<18|s>>>14,s=l+x|0,A^=s<<7|s>>>25,s=A+l|0,g^=s<<9|s>>>23,s=g+A|0,x^=s<<13|s>>>19,s=x+g|0,l^=s<<18|s>>>14,s=b+m|0,B^=s<<7|s>>>25,s=B+b|0,v^=s<<9|s>>>23,s=v+B|0,m^=s<<13|s>>>19,s=m+v|0,b^=s<<18|s>>>14,s=S+Q|0,M^=s<<7|s>>>25,s=M+S|0,C^=s<<9|s>>>23,s=C+M|0,Q^=s<<13|s>>>19,s=Q+C|0,S^=s<<18|s>>>14,s=D+R|0,T^=s<<7|s>>>25,s=T+D|0,_^=s<<9|s>>>23,s=_+T|0,R^=s<<13|s>>>19,s=R+_|0,D^=s<<18|s>>>14;r[0]=l>>>0&255,r[1]=l>>>8&255,r[2]=l>>>16&255,r[3]=l>>>24&255,r[4]=b>>>0&255,r[5]=b>>>8&255,r[6]=b>>>16&255,r[7]=b>>>24&255,r[8]=S>>>0&255,r[9]=S>>>8&255,r[10]=S>>>16&255,r[11]=S>>>24&255,r[12]=D>>>0&255,r[13]=D>>>8&255,r[14]=D>>>16&255,r[15]=D>>>24&255,r[16]=B>>>0&255,r[17]=B>>>8&255,r[18]=B>>>16&255,r[19]=B>>>24&255,r[20]=v>>>0&255,r[21]=v>>>8&255,r[22]=v>>>16&255,r[23]=v>>>24&255,r[24]=C>>>0&255,r[25]=C>>>8&255,r[26]=C>>>16&255,r[27]=C>>>24&255,r[28]=Q>>>0&255,r[29]=Q>>>8&255,r[30]=Q>>>16&255,r[31]=Q>>>24&255}});var Un={};q(Un,{generateKey:()=>Xt,preSharedKey:()=>Dn});var Y=class extends Error{static name="InvalidParametersError";constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}};var Ue={};q(Ue,{base58btc:()=>F,base58flickr:()=>lr});var Mn=new Uint8Array(0);function ct(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function j(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function ut(r){return new TextEncoder().encode(r)}function ht(r){return new TextDecoder().decode(r)}function ar(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),n=0;n<t.length;n++)t[n]=255;for(var o=0;o<r.length;o++){var i=r.charAt(o),a=i.charCodeAt(0);if(t[a]!==255)throw new TypeError(i+" is ambiguous");t[a]=o}var f=r.length,c=r.charAt(0),y=Math.log(f)/Math.log(256),p=Math.log(256)/Math.log(f);function h(d){if(d instanceof Uint8Array||(ArrayBuffer.isView(d)?d=new Uint8Array(d.buffer,d.byteOffset,d.byteLength):Array.isArray(d)&&(d=Uint8Array.from(d))),!(d instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(d.length===0)return"";for(var w=0,u=0,E=0,N=d.length;E!==N&&d[E]===0;)E++,w++;for(var U=(N-E)*p+1>>>0,l=new Uint8Array(U);E!==N;){for(var A=d[E],g=0,x=U-1;(A!==0||g<u)&&x!==-1;x--,g++)A+=256*l[x]>>>0,l[x]=A%f>>>0,A=A/f>>>0;if(A!==0)throw new Error("Non-zero carry");u=g,E++}for(var m=U-u;m!==U&&l[m]===0;)m++;for(var b=c.repeat(w);m<U;++m)b+=r.charAt(l[m]);return b}function I(d){if(typeof d!="string")throw new TypeError("Expected String");if(d.length===0)return new Uint8Array;var w=0;if(d[w]!==" "){for(var u=0,E=0;d[w]===c;)u++,w++;for(var N=(d.length-w)*y+1>>>0,U=new Uint8Array(N);d[w];){var l=t[d.charCodeAt(w)];if(l===255)return;for(var A=0,g=N-1;(l!==0||A<E)&&g!==-1;g--,A++)l+=f*U[g]>>>0,U[g]=l%256>>>0,l=l/256>>>0;if(l!==0)throw new Error("Non-zero carry");E=A,w++}if(d[w]!==" "){for(var x=N-E;x!==N&&U[x]===0;)x++;for(var m=new Uint8Array(u+(N-x)),b=u;x!==N;)m[b++]=U[x++];return m}}}function z(d){var w=I(d);if(w)return w;throw new Error(`Non-${e} character`)}return{encode:h,decodeUnsafe:I,decode:z}}var fr=ar,cr=fr,pt=cr;var Ce=class{name;prefix;baseEncode;constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},Qe=class{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,n){this.name=e,this.prefix=t;let o=t.codePointAt(0);if(o===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=o,this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return dt(this,e)}},Se=class{decoders;constructor(e){this.decoders=e}or(e){return dt(this,e)}decode(e){let t=e[0],n=this.decoders[t];if(n!=null)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};function dt(r,e){return new Se({...r.decoders??{[r.prefix]:r},...e.decoders??{[e.prefix]:e}})}var De=class{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,n,o){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=o,this.encoder=new Ce(e,t,n),this.decoder=new Qe(e,t,o)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}};function X({name:r,prefix:e,encode:t,decode:n}){return new De(r,e,t,n)}function K({name:r,prefix:e,alphabet:t}){let{encode:n,decode:o}=pt(t,r);return X({prefix:e,name:r,encode:n,decode:i=>j(o(i))})}function ur(r,e,t,n){let o={};for(let p=0;p<e.length;++p)o[e[p]]=p;let i=r.length;for(;r[i-1]==="=";)--i;let a=new Uint8Array(i*t/8|0),f=0,c=0,y=0;for(let p=0;p<i;++p){let h=o[r[p]];if(h===void 0)throw new SyntaxError(`Non-${n} character`);c=c<<t|h,f+=t,f>=8&&(f-=8,a[y++]=255&c>>f)}if(f>=t||255&c<<8-f)throw new SyntaxError("Unexpected end of data");return a}function hr(r,e,t){let n=e[e.length-1]==="=",o=(1<<t)-1,i="",a=0,f=0;for(let c=0;c<r.length;++c)for(f=f<<8|r[c],a+=8;a>t;)a-=t,i+=e[o&f>>a];if(a!==0&&(i+=e[o&f<<t-a]),n)for(;i.length*t&7;)i+="=";return i}function L({name:r,prefix:e,bitsPerChar:t,alphabet:n}){return X({prefix:e,name:r,encode(o){return hr(o,n,t)},decode(o){return ur(o,n,t,r)}})}var F=K({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),lr=K({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var Le={};q(Le,{base32:()=>W,base32hex:()=>xr,base32hexpad:()=>gr,base32hexpadupper:()=>br,base32hexupper:()=>mr,base32pad:()=>dr,base32padupper:()=>Ar,base32upper:()=>pr,base32z:()=>yr});var W=L({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),pr=L({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),dr=L({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Ar=L({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),xr=L({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),mr=L({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),gr=L({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),br=L({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),yr=L({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var Ne={};q(Ne,{base36:()=>se,base36upper:()=>wr});var se=K({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),wr=K({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var Er=mt,At=128,Ir=127,Br=~Ir,vr=Math.pow(2,31);function mt(r,e,t){e=e||[],t=t||0;for(var n=t;r>=vr;)e[t++]=r&255|At,r/=128;for(;r&Br;)e[t++]=r&255|At,r>>>=7;return e[t]=r|0,mt.bytes=t-n+1,e}var Cr=Me,Qr=128,xt=127;function Me(r,n){var t=0,n=n||0,o=0,i=n,a,f=r.length;do{if(i>=f)throw Me.bytes=0,new RangeError("Could not decode varint");a=r[i++],t+=o<28?(a&xt)<<o:(a&xt)*Math.pow(2,o),o+=7}while(a>=Qr);return Me.bytes=i-n,t}var Sr=Math.pow(2,7),Dr=Math.pow(2,14),Ur=Math.pow(2,21),Lr=Math.pow(2,28),Nr=Math.pow(2,35),Mr=Math.pow(2,42),Tr=Math.pow(2,49),_r=Math.pow(2,56),Rr=Math.pow(2,63),qr=function(r){return r<Sr?1:r<Dr?2:r<Ur?3:r<Lr?4:r<Nr?5:r<Mr?6:r<Tr?7:r<_r?8:r<Rr?9:10},zr={encode:Er,decode:Cr,encodingLength:qr},Or=zr,ie=Or;function ae(r,e=0){return[ie.decode(r,e),ie.decode.bytes]}function $(r,e,t=0){return ie.encode(r,e,t),e}function Z(r){return ie.encodingLength(r)}function V(r,e){let t=e.byteLength,n=Z(r),o=n+Z(t),i=new Uint8Array(o+t);return $(r,i,0),$(t,i,n),i.set(e,o),new ee(r,t,e,i)}function gt(r){let e=j(r),[t,n]=ae(e),[o,i]=ae(e.subarray(n)),a=e.subarray(n+i);if(a.byteLength!==o)throw new Error("Incorrect length");return new ee(t,o,a,e)}function bt(r,e){if(r===e)return!0;{let t=e;return r.code===t.code&&r.size===t.size&&t.bytes instanceof Uint8Array&&ct(r.bytes,t.bytes)}}var ee=class{code;size;digest;bytes;constructor(e,t,n,o){this.code=e,this.size=t,this.digest=n,this.bytes=o}};function yt(r,e){let{bytes:t,version:n}=r;switch(n){case 0:return Pr(t,Te(r),e??F.encoder);default:return kr(t,Te(r),e??W.encoder)}}var wt=new WeakMap;function Te(r){let e=wt.get(r);if(e==null){let t=new Map;return wt.set(r,t),t}return e}var de=class r{code;version;multihash;bytes;"/";constructor(e,t,n,o){this.code=t,this.version=e,this.multihash=n,this.bytes=o,this["/"]=o}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{let{code:e,multihash:t}=this;if(e!==ce)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==jr)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return r.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{let{code:e,digest:t}=this.multihash,n=V(e,t);return r.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return r.equals(this,e)}static equals(e,t){let n=t;return n!=null&&e.code===n.code&&e.version===n.version&&bt(e.multihash,n.multihash)}toString(e){return yt(this,e)}toJSON(){return{"/":yt(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;let t=e;if(t instanceof r)return t;if(t["/"]!=null&&t["/"]===t.bytes||t.asCID===t){let{version:n,code:o,multihash:i,bytes:a}=t;return new r(n,o,i,a??Et(n,o,i.bytes))}else if(t[Gr]===!0){let{version:n,multihash:o,code:i}=t,a=gt(o);return r.create(n,i,a)}else return null}static create(e,t,n){if(typeof t!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(t!==ce)throw new Error(`Version 0 CID must use dag-pb (code: ${ce}) block encoding`);return new r(e,t,n,n.bytes)}case 1:{let o=Et(e,t,n.bytes);return new r(e,t,n,o)}default:throw new Error("Invalid version")}}static createV0(e){return r.create(0,ce,e)}static createV1(e,t){return r.create(1,e,t)}static decode(e){let[t,n]=r.decodeFirst(e);if(n.length!==0)throw new Error("Incorrect length");return t}static decodeFirst(e){let t=r.inspectBytes(e),n=t.size-t.multihashSize,o=j(e.subarray(n,n+t.multihashSize));if(o.byteLength!==t.multihashSize)throw new Error("Incorrect length");let i=o.subarray(t.multihashSize-t.digestSize),a=new ee(t.multihashCode,t.digestSize,i,o);return[t.version===0?r.createV0(a):r.createV1(t.codec,a),e.subarray(t.size)]}static inspectBytes(e){let t=0,n=()=>{let[h,I]=ae(e.subarray(t));return t+=I,h},o=n(),i=ce;if(o===18?(o=0,t=0):i=n(),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);let a=t,f=n(),c=n(),y=t+c,p=y-a;return{version:o,codec:i,multihashCode:f,digestSize:c,multihashSize:p,size:y}}static parse(e,t){let[n,o]=Fr(e,t),i=r.decode(o);if(i.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Te(i).set(n,e),i}};function Fr(r,e){switch(r[0]){case"Q":{let t=e??F;return[F.prefix,t.decode(`${F.prefix}${r}`)]}case F.prefix:{let t=e??F;return[F.prefix,t.decode(r)]}case W.prefix:{let t=e??W;return[W.prefix,t.decode(r)]}case se.prefix:{let t=e??se;return[se.prefix,t.decode(r)]}default:{if(e==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],e.decode(r)]}}}function Pr(r,e,t){let{prefix:n}=t;if(n!==F.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);let o=e.get(n);if(o==null){let i=t.encode(r).slice(1);return e.set(n,i),i}else return o}function kr(r,e,t){let{prefix:n}=t,o=e.get(n);if(o==null){let i=t.encode(r);return e.set(n,i),i}else return o}var ce=112,jr=18;function Et(r,e,t){let n=Z(r),o=n+Z(e),i=new Uint8Array(o+t.byteLength);return $(r,i,0),$(e,i,n),i.set(t,o),i}var Gr=Symbol.for("@ipld/js-cid/CID");var _e={};q(_e,{identity:()=>Hr});var It=0,Kr="identity",Bt=j;function Vr(r){return V(It,Bt(r))}var Hr={code:It,name:Kr,encode:Bt,digest:Vr};function vt(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}var H=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function Ct(r=32){if(H&&typeof H.getRandomValues=="function")return H.getRandomValues(new Uint8Array(r));if(H&&typeof H.randomBytes=="function")return H.randomBytes(r);throw new Error("crypto.getRandomValues must be defined")}function G(r=0){return new Uint8Array(r)}function J(r=0){return new Uint8Array(r)}var Re={};q(Re,{base10:()=>Jr});var Jr=K({prefix:"9",name:"base10",alphabet:"0123456789"});var qe={};q(qe,{base16:()=>Yr,base16upper:()=>Xr});var Yr=L({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Xr=L({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var ze={};q(ze,{base2:()=>Wr});var Wr=L({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var Oe={};q(Oe,{base256emoji:()=>rn});var Qt=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),$r=Qt.reduce((r,e,t)=>(r[t]=e,r),[]),Zr=Qt.reduce((r,e,t)=>{let n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);return r[n]=t,r},[]);function en(r){return r.reduce((e,t)=>(e+=$r[t],e),"")}function tn(r){let e=[];for(let t of r){let n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);let o=Zr[n];if(o==null)throw new Error(`Non-base256emoji character: ${t}`);e.push(o)}return new Uint8Array(e)}var rn=X({prefix:"\u{1F680}",name:"base256emoji",encode:en,decode:tn});var Fe={};q(Fe,{base64:()=>nn,base64pad:()=>on,base64url:()=>sn,base64urlpad:()=>an});var nn=L({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),on=L({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),sn=L({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),an=L({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var Pe={};q(Pe,{base8:()=>fn});var fn=L({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var ke={};q(ke,{identity:()=>cn});var cn=X({prefix:"\0",name:"identity",encode:r=>ht(r),decode:r=>ut(r)});var uo=new TextEncoder,ho=new TextDecoder;var Ke={};q(Ke,{sha256:()=>ln,sha512:()=>pn});function Ge({name:r,code:e,encode:t}){return new je(r,e,t)}var je=class{name;code;encode;constructor(e,t,n){this.name=e,this.code=t,this.encode=n}digest(e){if(e instanceof Uint8Array){let t=this.encode(e);return t instanceof Uint8Array?V(this.code,t):t.then(n=>V(this.code,n))}else throw Error("Unknown type, must be binary type")}};function Dt(r){return async e=>new Uint8Array(await crypto.subtle.digest(r,e))}var ln=Ge({name:"sha2-256",code:18,encode:Dt("SHA-256")}),pn=Ge({name:"sha2-512",code:19,encode:Dt("SHA-512")});var Ve={...ke,...ze,...Pe,...Re,...qe,...Le,...Ne,...Ue,...Fe,...Oe},Bo={...Ke,..._e};function Lt(r,e,t,n){return{name:r,prefix:e,encoder:{name:r,prefix:e,encode:t},decoder:{decode:n}}}var Ut=Lt("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),He=Lt("ascii","a",r=>{let e="a";for(let t=0;t<r.length;t++)e+=String.fromCharCode(r[t]);return e},r=>{r=r.substring(1);let e=J(r.length);for(let t=0;t<r.length;t++)e[t]=r.charCodeAt(t);return e}),dn={utf8:Ut,"utf-8":Ut,hex:Ve.base16,latin1:He,ascii:He,binary:He,...Ve},Ae=dn;function xe(r,e="utf8"){let t=Ae[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.decoder.decode(`${t.prefix}${r}`)}function me(r,e="utf8"){let t=Ae[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.encoder.encode(r).substring(1)}function te(r){if(isNaN(r)||r<=0)throw new Y("random bytes length must be a Number bigger than 0");return Ct(r)}function Je(r,e){e==null&&(e=r.reduce((o,i)=>o+i.length,0));let t=J(e),n=0;for(let o of r)t.set(o,n),n+=o.length;return t}function O(){let r={};return r.promise=new Promise((e,t)=>{r.resolve=e,r.reject=t}),r}var ge=class extends Error{type;code;constructor(e,t,n){super(e??"The operation was aborted"),this.type="aborted",this.name=n??"AbortError",this.code=t??"ABORT_ERR"}};async function Nt(r,e,t){if(e==null)return r;if(e.aborted)return Promise.reject(new ge(t?.errorMessage,t?.errorCode,t?.errorName));let n,o=new ge(t?.errorMessage,t?.errorCode,t?.errorName);try{return await Promise.race([r,new Promise((i,a)=>{n=()=>{a(o)},e.addEventListener("abort",n)})])}finally{n!=null&&e.removeEventListener("abort",n)}}var Ye=class{readNext;haveNext;ended;nextResult;constructor(){this.ended=!1,this.readNext=O(),this.haveNext=O()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");let e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=O(),e}async throw(e){return this.ended=!0,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){let e={done:!0,value:void 0};return await this._push(void 0),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=O(),await Nt(this.readNext.promise,t?.signal,t)}};function Mt(){return new Ye}var _t=Symbol.for("@achingbrain/uint8arraylist");function Tt(r,e){if(e==null||e<0)throw new RangeError("index is out of bounds");let t=0;for(let n of r){let o=t+n.byteLength;if(e<o)return{buf:n,index:e-t};t=o}throw new RangeError("index is out of bounds")}function be(r){return!!r?.[_t]}var ue=class r{bufs;length;[_t]=!0;constructor(...e){this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(let n of e)if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.push(n);else if(be(n))t+=n.byteLength,this.bufs.push(...n.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(let n of e.reverse())if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.unshift(n);else if(be(n))t+=n.byteLength,this.bufs.unshift(...n.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}get(e){let t=Tt(this.bufs,e);return t.buf[t.index]}set(e,t){let n=Tt(this.bufs,e);n.buf[n.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let n=0;n<e.length;n++)this.set(t+n,e[n]);else if(be(e))for(let n=0;n<e.length;n++)this.set(t+n,e.get(n));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(e>=this.bufs[0].byteLength)e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}}}slice(e,t){let{bufs:n,length:o}=this._subList(e,t);return Je(n,o)}subarray(e,t){let{bufs:n,length:o}=this._subList(e,t);return n.length===1?n[0]:Je(n,o)}sublist(e,t){let{bufs:n,length:o}=this._subList(e,t),i=new r;return i.length=o,i.bufs=[...n],i}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(e===0&&t===this.length)return{bufs:this.bufs,length:this.length};let n=[],o=0;for(let i=0;i<this.bufs.length;i++){let a=this.bufs[i],f=o,c=f+a.byteLength;if(o=c,e>=c)continue;let y=e>=f&&e<c,p=t>f&&t<=c;if(y&&p){if(e===f&&t===c){n.push(a);break}let h=e-f;n.push(a.subarray(h,h+(t-e)));break}if(y){if(e===0){n.push(a);continue}n.push(a.subarray(e-f));continue}if(p){if(t===c){n.push(a);break}n.push(a.subarray(0,t-f));break}n.push(a)}return{bufs:n,length:t-e}}indexOf(e,t=0){if(!be(e)&&!(e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');let n=e instanceof Uint8Array?e:e.subarray();if(t=Number(t??0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),e.length===0)return t>this.length?this.length:t;let o=n.byteLength;if(o===0)throw new TypeError("search must be at least 1 byte long");let i=256,a=new Int32Array(i);for(let h=0;h<i;h++)a[h]=-1;for(let h=0;h<o;h++)a[n[h]]=h;let f=a,c=this.byteLength-n.byteLength,y=n.byteLength-1,p;for(let h=t;h<=c;h+=p){p=0;for(let I=y;I>=0;I--){let z=this.get(h+I);if(n[I]!==z){p=Math.max(1,I-f[z]);break}}if(p===0)return h}return-1}getInt8(e){let t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,t){let n=J(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt8(0,t),this.write(n,e)}getInt16(e,t){let n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt16(0,t)}setInt16(e,t,n){let o=G(2);new DataView(o.buffer,o.byteOffset,o.byteLength).setInt16(0,t,n),this.write(o,e)}getInt32(e,t){let n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt32(0,t)}setInt32(e,t,n){let o=G(4);new DataView(o.buffer,o.byteOffset,o.byteLength).setInt32(0,t,n),this.write(o,e)}getBigInt64(e,t){let n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigInt64(0,t)}setBigInt64(e,t,n){let o=G(8);new DataView(o.buffer,o.byteOffset,o.byteLength).setBigInt64(0,t,n),this.write(o,e)}getUint8(e){let t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,t){let n=J(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint8(0,t),this.write(n,e)}getUint16(e,t){let n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint16(0,t)}setUint16(e,t,n){let o=G(2);new DataView(o.buffer,o.byteOffset,o.byteLength).setUint16(0,t,n),this.write(o,e)}getUint32(e,t){let n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint32(0,t)}setUint32(e,t,n){let o=G(4);new DataView(o.buffer,o.byteOffset,o.byteLength).setUint32(0,t,n),this.write(o,e)}getBigUint64(e,t){let n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigUint64(0,t)}setBigUint64(e,t,n){let o=G(8);new DataView(o.buffer,o.byteOffset,o.byteLength).setBigUint64(0,t,n),this.write(o,e)}getFloat32(e,t){let n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat32(0,t)}setFloat32(e,t,n){let o=G(4);new DataView(o.buffer,o.byteOffset,o.byteLength).setFloat32(0,t,n),this.write(o,e)}getFloat64(e,t){let n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat64(0,t)}setFloat64(e,t,n){let o=G(8);new DataView(o.buffer,o.byteOffset,o.byteLength).setFloat64(0,t,n),this.write(o,e)}equals(e){if(e==null||!(e instanceof r)||e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!vt(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){let n=new r;return n.bufs=e,t==null&&(t=e.reduce((o,i)=>o+i.byteLength,0)),n.length=t,n}};var ye=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};var Xe=class extends Error{code;constructor(e,t){super(e),this.code=t}},We=class extends Xe{type;constructor(e){super(e,"ABORT_ERR"),this.type="aborted",this.name="AbortError"}};function Rt(r,e){let t=Mt();r.sink(t).catch(async a=>{await t.end(a)}),r.sink=async a=>{for await(let f of a)await t.push(f);await t.end()};let n=r.source;r.source[Symbol.iterator]!=null?n=r.source[Symbol.iterator]():r.source[Symbol.asyncIterator]!=null&&(n=r.source[Symbol.asyncIterator]());let o=new ue;return{read:async(a,f)=>{f?.signal?.throwIfAborted();let c,y=new Promise((p,h)=>{c=()=>{h(new We("Read aborted"))},f?.signal?.addEventListener("abort",c)});try{if(a==null){let{done:h,value:I}=await Promise.race([n.next(),y]);return h===!0?new ue:I}for(;o.byteLength<a;){let{value:h,done:I}=await Promise.race([n.next(),y]);if(I===!0)throw new ye("unexpected end of input");o.append(h)}let p=o.sublist(0,a);return o.consume(a),p}finally{c!=null&&f?.signal?.removeEventListener("abort",c)}},write:async(a,f)=>{f?.signal?.throwIfAborted(),a instanceof Uint8Array?await t.push(a,f):await t.push(a.subarray(),f)},unwrap:()=>{if(o.byteLength>0){let a=r.source;r.source=async function*(){e?.yieldBytes===!1?yield o:yield*o,yield*a}()}return r}}}function An(r){let[e,t]=r[Symbol.asyncIterator]!=null?[r[Symbol.asyncIterator](),Symbol.asyncIterator]:[r[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>e.next(),push:o=>{n.push(o)},next:()=>n.length>0?{done:!1,value:n.shift()}:e.next(),[t](){return this}}}var qt=An;function xn(r){return r[Symbol.asyncIterator]!=null}function mn(r,e){let t=0;if(xn(r))return async function*(){for await(let c of r)yield e(c,t++)}();let n=qt(r),{value:o,done:i}=n.next();if(i===!0)return function*(){}();let a=e(o,t++);if(typeof a.then=="function")return async function*(){yield await a;for await(let c of n)yield e(c,t++)}();let f=e;return function*(){yield a;for(let c of n)yield f(c,t++)}()}var zt=mn;function $e(){let r=O(),e=!1;return{sink:async t=>{if(e)throw new Error("already piped");e=!0,r.resolve(t)},source:async function*(){yield*await r.promise}()}}function Ot(){let r=$e(),e=$e();return[{source:r.source,sink:e.sink},{source:e.source,sink:r.sink}]}var we=class{buffer;mask;top;btm;next;constructor(e){if(!(e>0)||e-1&e)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){let e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}},re=class{size;hwm;head;tail;constructor(e={}){this.hwm=e.splitLimit??16,this.head=new we(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return e?.byteLength!=null?e.byteLength:1}push(e){if(e?.value!=null&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){let t=this.head;this.head=t.next=new we(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next!=null){let t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return e?.value!=null&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}};var Ze=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}};function Ee(r={}){return gn(t=>{let n=t.shift();if(n==null)return{done:!0};if(n.error!=null)throw n.error;return{done:n.done===!0,value:n.value}},r)}function gn(r,e){e=e??{};let t=e.onEnd,n=new re,o,i,a,f=O(),c=async()=>{try{return n.isEmpty()?a?{done:!0}:await new Promise((u,E)=>{i=N=>{i=null,n.push(N);try{u(r(n))}catch(U){E(U)}return o}}):r(n)}finally{n.isEmpty()&&queueMicrotask(()=>{f.resolve(),f=O()})}},y=u=>i!=null?i(u):(n.push(u),o),p=u=>(n=new re,i!=null?i({error:u}):(n.push({error:u}),o)),h=u=>{if(a)return o;if(e?.objectMode!==!0&&u?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return y({done:!1,value:u})},I=u=>a?o:(a=!0,u!=null?p(u):y({done:!0})),z=()=>(n=new re,I(),{done:!0}),d=u=>(I(u),{done:!0});if(o={[Symbol.asyncIterator](){return this},next:c,return:z,throw:d,push:h,end:I,get readableLength(){return n.size},onEmpty:async u=>{let E=u?.signal;if(E?.throwIfAborted(),n.isEmpty())return;let N,U;E!=null&&(N=new Promise((l,A)=>{U=()=>{A(new Ze)},E.addEventListener("abort",U)}));try{await Promise.race([f.promise,N])}finally{U!=null&&E!=null&&E?.removeEventListener("abort",U)}}},t==null)return o;let w=o;return o={[Symbol.asyncIterator](){return this},next(){return w.next()},throw(u){return w.throw(u),t!=null&&(t(u),t=void 0),{done:!0}},return(){return w.return(),t!=null&&(t(),t=void 0),{done:!0}},push:h,end(u){return w.end(u),t!=null&&(t(u),t=void 0),o},get readableLength(){return w.readableLength},onEmpty:u=>w.onEmpty(u)},o}function bn(r){return r[Symbol.asyncIterator]!=null}function yn(...r){let e=[];for(let t of r)bn(t)||e.push(t);return e.length===r.length?function*(){for(let t of e)yield*t}():async function*(){let t=Ee({objectMode:!0});Promise.resolve().then(async()=>{try{await Promise.all(r.map(async n=>{for await(let o of n)t.push(o)})),t.end()}catch(n){t.end(n)}}),yield*t}()}var Ft=yn;function Pt(r,...e){if(r==null)throw new Error("Empty pipeline");if(et(r)){let n=r;r=()=>n.source}else if(jt(r)||kt(r)){let n=r;r=()=>n}let t=[r,...e];if(t.length>1&&et(t[t.length-1])&&(t[t.length-1]=t[t.length-1].sink),t.length>2)for(let n=1;n<t.length-1;n++)et(t[n])&&(t[n]=En(t[n]));return wn(...t)}var wn=(...r)=>{let e;for(;r.length>0;)e=r.shift()(e);return e},kt=r=>r?.[Symbol.asyncIterator]!=null,jt=r=>r?.[Symbol.iterator]!=null,et=r=>r==null?!1:r.sink!=null&&r.source!=null,En=r=>e=>{let t=r.sink(e);if(t?.then!=null){let n=Ee({objectMode:!0});t.then(()=>{n.end()},a=>{n.end(a)});let o,i=r.source;if(kt(i))o=async function*(){yield*i,n.end()};else if(jt(i))o=function*(){yield*i,n.end()};else throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");return Ft(n,o())}return r.source};var st=sr(Yt(),1);var rt="Your private shared key is invalid";function Xt(r){let e=me(te(ot),"base16"),t=xe(`/key/swarm/psk/1.0.0/
./node_modules/@libp2p/pubsub/dist/index.min.js:2:"use strict";var Libp2PPubsub=(()=>{var eu=Object.create;var qr=Object.defineProperty;var ru=Object.getOwnPropertyDescriptor;var nu=Object.getOwnPropertyNames;var su=Object.getPrototypeOf,iu=Object.prototype.hasOwnProperty;var uo=(r,t)=>()=>(t||r((t={exports:{}}).exports,t),t.exports),bt=(r,t)=>{for(var e in t)qr(r,e,{get:t[e],enumerable:!0})},lo=(r,t,e,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of nu(t))!iu.call(r,s)&&s!==e&&qr(r,s,{get:()=>t[s],enumerable:!(n=ru(t,s))||n.enumerable});return r};var fo=(r,t,e)=>(e=r!=null?eu(su(r)):{},lo(t||!r||!r.__esModule?qr(e,"default",{value:r,enumerable:!0}):e,r)),ou=r=>lo(qr({},"__esModule",{value:!0}),r);var ma=uo(Je=>{"use strict";var Lf="[object ArrayBuffer]",Wt=class r{static isArrayBuffer(t){return Object.prototype.toString.call(t)===Lf}static toArrayBuffer(t){return this.isArrayBuffer(t)?t:t.byteLength===t.buffer.byteLength||t.byteOffset===0&&t.byteLength===t.buffer.byteLength?t.buffer:this.toUint8Array(t.buffer).slice(t.byteOffset,t.byteOffset+t.byteLength).buffer}static toUint8Array(t){return this.toView(t,Uint8Array)}static toView(t,e){if(t.constructor===e)return t;if(this.isArrayBuffer(t))return new e(t);if(this.isArrayBufferView(t))return new e(t.buffer,t.byteOffset,t.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(t){return this.isArrayBufferView(t)||this.isArrayBuffer(t)}static isArrayBufferView(t){return ArrayBuffer.isView(t)||t&&this.isArrayBuffer(t.buffer)}static isEqual(t,e){let n=r.toUint8Array(t),s=r.toUint8Array(e);if(n.length!==s.byteLength)return!1;for(let i=0;i<n.length;i++)if(n[i]!==s[i])return!1;return!0}static concat(...t){let e;Array.isArray(t[0])&&!(t[1]instanceof Function)||Array.isArray(t[0])&&t[1]instanceof Function?e=t[0]:t[t.length-1]instanceof Function?e=t.slice(0,t.length-1):e=t;let n=0;for(let o of e)n+=o.byteLength;let s=new Uint8Array(n),i=0;for(let o of e){let c=this.toUint8Array(o);s.set(c,i),i+=c.length}return t[t.length-1]instanceof Function?this.toView(s,t[t.length-1]):s.buffer}},Ui="string",Rf=/^[0-9a-f\s]+$/i,_f=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,Vf=/^[a-zA-Z0-9-_]+$/,pn=class{static fromString(t){let e=unescape(encodeURIComponent(t)),n=new Uint8Array(e.length);for(let s=0;s<e.length;s++)n[s]=e.charCodeAt(s);return n.buffer}static toString(t){let e=Wt.toUint8Array(t),n="";for(let i=0;i<e.length;i++)n+=String.fromCharCode(e[i]);return decodeURIComponent(escape(n))}},It=class{static toString(t,e=!1){let n=Wt.toArrayBuffer(t),s=new DataView(n),i="";for(let o=0;o<n.byteLength;o+=2){let c=s.getUint16(o,e);i+=String.fromCharCode(c)}return i}static fromString(t,e=!1){let n=new ArrayBuffer(t.length*2),s=new DataView(n);for(let i=0;i<t.length;i++)s.setUint16(i*2,t.charCodeAt(i),e);return n}},gn=class r{static isHex(t){return typeof t===Ui&&Rf.test(t)}static isBase64(t){return typeof t===Ui&&_f.test(t)}static isBase64Url(t){return typeof t===Ui&&Vf.test(t)}static ToString(t,e="utf8"){let n=Wt.toUint8Array(t);switch(e.toLowerCase()){case"utf8":return this.ToUtf8String(n);case"binary":return this.ToBinary(n);case"hex":return this.ToHex(n);case"base64":return this.ToBase64(n);case"base64url":return this.ToBase64Url(n);case"utf16le":return It.toString(n,!0);case"utf16":case"utf16be":return It.toString(n);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromString(t,e="utf8"){if(!t)return new ArrayBuffer(0);switch(e.toLowerCase()){case"utf8":return this.FromUtf8String(t);case"binary":return this.FromBinary(t);case"hex":return this.FromHex(t);case"base64":return this.FromBase64(t);case"base64url":return this.FromBase64Url(t);case"utf16le":return It.fromString(t,!0);case"utf16":case"utf16be":return It.fromString(t);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToBase64(t){let e=Wt.toUint8Array(t);if(typeof btoa<"u"){let n=this.ToString(e,"binary");return btoa(n)}else return Buffer.from(e).toString("base64")}static FromBase64(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isBase64(e))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return typeof atob<"u"?this.FromBinary(atob(e)):new Uint8Array(Buffer.from(e,"base64")).buffer}static FromBase64Url(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isBase64Url(e))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(e.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(t){return this.ToBase64(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(t,e=r.DEFAULT_UTF8_ENCODING){switch(e){case"ascii":return this.FromBinary(t);case"utf8":return pn.fromString(t);case"utf16":case"utf16be":return It.fromString(t);case"utf16le":case"usc2":return It.fromString(t,!0);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToUtf8String(t,e=r.DEFAULT_UTF8_ENCODING){switch(e){case"ascii":return this.ToBinary(t);case"utf8":return pn.toString(t);case"utf16":case"utf16be":return It.toString(t);case"utf16le":case"usc2":return It.toString(t,!0);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromBinary(t){let e=t.length,n=new Uint8Array(e);for(let s=0;s<e;s++)n[s]=t.charCodeAt(s);return n.buffer}static ToBinary(t){let e=Wt.toUint8Array(t),n="";for(let s=0;s<e.length;s++)n+=String.fromCharCode(e[s]);return n}static ToHex(t){let e=Wt.toUint8Array(t),n="",s=e.length;for(let i=0;i<s;i++){let o=e[i];o<16&&(n+="0"),n+=o.toString(16)}return n}static FromHex(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isHex(e))throw new TypeError("Argument 'hexString' is not HEX encoded");e.length%2&&(e=`0${e}`);let n=new Uint8Array(e.length/2);for(let s=0;s<e.length;s=s+2){let i=e.slice(s,s+2);n[s/2]=parseInt(i,16)}return n.buffer}static ToUtf16String(t,e=!1){return It.toString(t,e)}static FromUtf16String(t,e=!1){return It.fromString(t,e)}static Base64Padding(t){let e=4-t.length%4;if(e<4)for(let n=0;n<e;n++)t+="=";return t}static formatString(t){return t?.replace(/[\n\r\t ]/g,"")||""}};gn.DEFAULT_UTF8_ENCODING="utf8";function Hf(r,...t){let e=arguments[0];for(let n=1;n<arguments.length;n++){let s=arguments[n];for(let i in s)e[i]=s[i]}return e}function Mf(...r){let t=r.map(s=>s.byteLength).reduce((s,i)=>s+i),e=new Uint8Array(t),n=0;return r.map(s=>new Uint8Array(s)).forEach(s=>{for(let i of s)e[n++]=i}),e.buffer}function Of(r,t){if(!(r&&t)||r.byteLength!==t.byteLength)return!1;let e=new Uint8Array(r),n=new Uint8Array(t);for(let s=0;s<r.byteLength;s++)if(e[s]!==n[s])return!1;return!0}Je.BufferSourceConverter=Wt;Je.Convert=gn;Je.assign=Hf;Je.combine=Mf;Je.isEqual=Of});var Rc=uo((Em,Wi)=>{"use strict";var lh=Object.prototype.hasOwnProperty,wt="~";function Hr(){}Object.create&&(Hr.prototype=Object.create(null),new Hr().__proto__||(wt=!1));function fh(r,t,e){this.fn=r,this.context=t,this.once=e||!1}function Lc(r,t,e,n,s){if(typeof e!="function")throw new TypeError("The listener must be a function");var i=new fh(e,n||r,s),o=wt?wt+t:t;return r._events[o]?r._events[o].fn?r._events[o]=[r._events[o],i]:r._events[o].push(i):(r._events[o]=i,r._eventsCount++),r}function ds(r,t){--r._eventsCount===0?r._events=new Hr:delete r._events[t]}function gt(){this._events=new Hr,this._eventsCount=0}gt.prototype.eventNames=function(){var t=[],e,n;if(this._eventsCount===0)return t;for(n in e=this._events)lh.call(e,n)&&t.push(wt?n.slice(1):n);return Object.getOwnPropertySymbols?t.concat(Object.getOwnPropertySymbols(e)):t};gt.prototype.listeners=function(t){var e=wt?wt+t:t,n=this._events[e];if(!n)return[];if(n.fn)return[n.fn];for(var s=0,i=n.length,o=new Array(i);s<i;s++)o[s]=n[s].fn;return o};gt.prototype.listenerCount=function(t){var e=wt?wt+t:t,n=this._events[e];return n?n.fn?1:n.length:0};gt.prototype.emit=function(t,e,n,s,i,o){var c=wt?wt+t:t;if(!this._events[c])return!1;var a=this._events[c],f=arguments.length,l,u;if(a.fn){switch(a.once&&this.removeListener(t,a.fn,void 0,!0),f){case 1:return a.fn.call(a.context),!0;case 2:return a.fn.call(a.context,e),!0;case 3:return a.fn.call(a.context,e,n),!0;case 4:return a.fn.call(a.context,e,n,s),!0;case 5:return a.fn.call(a.context,e,n,s,i),!0;case 6:return a.fn.call(a.context,e,n,s,i,o),!0}for(u=1,l=new Array(f-1);u<f;u++)l[u-1]=arguments[u];a.fn.apply(a.context,l)}else{var d=a.length,m;for(u=0;u<d;u++)switch(a[u].once&&this.removeListener(t,a[u].fn,void 0,!0),f){case 1:a[u].fn.call(a[u].context);break;case 2:a[u].fn.call(a[u].context,e);break;case 3:a[u].fn.call(a[u].context,e,n);break;case 4:a[u].fn.call(a[u].context,e,n,s);break;default:if(!l)for(m=1,l=new Array(f-1);m<f;m++)l[m-1]=arguments[m];a[u].fn.apply(a[u].context,l)}}return!0};gt.prototype.on=function(t,e,n){return Lc(this,t,e,n,!1)};gt.prototype.once=function(t,e,n){return Lc(this,t,e,n,!0)};gt.prototype.removeListener=function(t,e,n,s){var i=wt?wt+t:t;if(!this._events[i])return this;if(!e)return ds(this,i),this;var o=this._events[i];if(o.fn)o.fn===e&&(!s||o.once)&&(!n||o.context===n)&&ds(this,i);else{for(var c=0,a=[],f=o.length;c<f;c++)(o[c].fn!==e||s&&!o[c].once||n&&o[c].context!==n)&&a.push(o[c]);a.length?this._events[i]=a.length===1?a[0]:a:ds(this,i)}return this};gt.prototype.removeAllListeners=function(t){var e;return t?(e=wt?wt+t:t,this._events[e]&&ds(this,e)):(this._events=new Hr,this._eventsCount=0),this};gt.prototype.off=gt.prototype.removeListener;gt.prototype.addListener=gt.prototype.on;gt.prefixed=wt;gt.EventEmitter=gt;typeof Wi<"u"&&(Wi.exports=gt)});var wh={};bt(wh,{PubSubBaseProtocol:()=>eo});var Es=Symbol.for("@libp2p/peer-id");var or;(function(r){r.Accept="accept",r.Ignore="ignore",r.Reject="reject"})(or||(or={}));var Eh=Symbol.for("@libp2p/pubsub");var et=class extends Error{static name="InvalidParametersError";constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}},He=class extends Error{static name="InvalidPublicKeyError";constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}};var zr=class extends Error{static name="InvalidMultihashError";constructor(t="Invalid Multihash"){super(t),this.name="InvalidMultihashError"}};var X=class extends Error{static name="InvalidMessageError";constructor(t="Invalid message"){super(t),this.name="InvalidMessageError"}};var $r=class extends Error{static name="NotStartedError";constructor(t="Not started"){super(t),this.name="NotStartedError"}};var xe=class extends Error{static name="UnsupportedKeyTypeError";constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}};var ho=(r,...t)=>{try{[...t]}catch{}};var Me=class extends EventTarget{#t=new Map;constructor(){super(),ho(1/0,this)}listenerCount(t){let e=this.#t.get(t);return e==null?0:e.length}addEventListener(t,e,n){super.addEventListener(t,e,n);let s=this.#t.get(t);s==null&&(s=[],this.#t.set(t,s)),s.push({callback:e,once:(n!==!0&&n!==!1&&n?.once)??!1})}removeEventListener(t,e,n){super.removeEventListener(t.toString(),e??null,n);let s=this.#t.get(t);s!=null&&(s=s.filter(({callback:i})=>i!==e),this.#t.set(t,s))}dispatchEvent(t){let e=super.dispatchEvent(t),n=this.#t.get(t.type);return n==null||(n=n.filter(({once:s})=>!s),this.#t.set(t.type,n)),e}safeDispatchEvent(t,e={}){return this.dispatchEvent(new CustomEvent(t,e))}};var Is={};bt(Is,{base58btc:()=>Q,base58flickr:()=>hu});var Nh=new Uint8Array(0);function po(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function Kt(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function go(r){return new TextEncoder().encode(r)}function mo(r){return new TextDecoder().decode(r)}function au(r,t){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),n=0;n<e.length;n++)e[n]=255;for(var s=0;s<r.length;s++){var i=r.charAt(s),o=i.charCodeAt(0);if(e[o]!==255)throw new TypeError(i+" is ambiguous");e[o]=s}var c=r.length,a=r.charAt(0),f=Math.log(c)/Math.log(256),l=Math.log(256)/Math.log(c);function u(x){if(x instanceof Uint8Array||(ArrayBuffer.isView(x)?x=new Uint8Array(x.buffer,x.byteOffset,x.byteLength):Array.isArray(x)&&(x=Uint8Array.from(x))),!(x instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(x.length===0)return"";for(var y=0,h=0,w=0,E=x.length;w!==E&&x[w]===0;)w++,y++;for(var g=(E-w)*l+1>>>0,k=new Uint8Array(g);w!==E;){for(var U=x[w],L=0,I=g-1;(U!==0||L<h)&&I!==-1;I--,L++)U+=256*k[I]>>>0,k[I]=U%c>>>0,U=U/c>>>0;if(U!==0)throw new Error("Non-zero carry");h=L,w++}for(var T=g-h;T!==g&&k[T]===0;)T++;for(var N=a.repeat(y);T<g;++T)N+=r.charAt(k[T]);return N}function d(x){if(typeof x!="string")throw new TypeError("Expected String");if(x.length===0)return new Uint8Array;var y=0;if(x[y]!==" "){for(var h=0,w=0;x[y]===a;)h++,y++;for(var E=(x.length-y)*f+1>>>0,g=new Uint8Array(E);x[y];){var k=e[x.charCodeAt(y)];if(k===255)return;for(var U=0,L=E-1;(k!==0||U<w)&&L!==-1;L--,U++)k+=c*g[L]>>>0,g[L]=k%256>>>0,k=k/256>>>0;if(k!==0)throw new Error("Non-zero carry");w=U,y++}if(x[y]!==" "){for(var I=E-w;I!==E&&g[I]===0;)I++;for(var T=new Uint8Array(h+(E-I)),N=h;I!==E;)T[N++]=g[I++];return T}}}function m(x){var y=d(x);if(y)return y;throw new Error(`Non-${t} character`)}return{encode:u,decodeUnsafe:d,decode:m}}var cu=au,uu=cu,yo=uu;var Bs=class{name;prefix;baseEncode;constructor(t,e,n){this.name=t,this.prefix=e,this.baseEncode=n}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}},Ss=class{name;prefix;baseDecode;prefixCodePoint;constructor(t,e,n){this.name=t,this.prefix=e;let s=e.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=n}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return wo(this,t)}},As=class{decoders;constructor(t){this.decoders=t}or(t){return wo(this,t)}decode(t){let e=t[0],n=this.decoders[e];if(n!=null)return n.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};function wo(r,t){return new As({...r.decoders??{[r.prefix]:r},...t.decoders??{[t.prefix]:t}})}var ks=class{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(t,e,n,s){this.name=t,this.prefix=e,this.baseEncode=n,this.baseDecode=s,this.encoder=new Bs(t,e,n),this.decoder=new Ss(t,e,s)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}};function Oe({name:r,prefix:t,encode:e,decode:n}){return new ks(r,t,e,n)}function se({name:r,prefix:t,alphabet:e}){let{encode:n,decode:s}=yo(e,r);return Oe({prefix:t,name:r,encode:n,decode:i=>Kt(s(i))})}function lu(r,t,e,n){let s={};for(let l=0;l<t.length;++l)s[t[l]]=l;let i=r.length;for(;r[i-1]==="=";)--i;let o=new Uint8Array(i*e/8|0),c=0,a=0,f=0;for(let l=0;l<i;++l){let u=s[r[l]];if(u===void 0)throw new SyntaxError(`Non-${n} character`);a=a<<e|u,c+=e,c>=8&&(c-=8,o[f++]=255&a>>c)}if(c>=e||255&a<<8-c)throw new SyntaxError("Unexpected end of data");return o}function fu(r,t,e){let n=t[t.length-1]==="=",s=(1<<e)-1,i="",o=0,c=0;for(let a=0;a<r.length;++a)for(c=c<<8|r[a],o+=8;o>e;)o-=e,i+=t[s&c>>o];if(o!==0&&(i+=t[s&c<<e-o]),n)for(;i.length*e&7;)i+="=";return i}function J({name:r,prefix:t,bitsPerChar:e,alphabet:n}){return Oe({prefix:t,name:r,encode(s){return fu(s,n,e)},decode(s){return lu(s,n,e,r)}})}var Q=se({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),hu=se({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var Ns={};bt(Ns,{base32:()=>De,base32hex:()=>mu,base32hexpad:()=>yu,base32hexpadupper:()=>wu,base32hexupper:()=>bu,base32pad:()=>pu,base32padupper:()=>gu,base32upper:()=>du,base32z:()=>xu});var De=J({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),du=J({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),pu=J({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),gu=J({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),mu=J({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),bu=J({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),yu=J({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),wu=J({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),xu=J({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var Cs={};bt(Cs,{base36:()=>ar,base36upper:()=>vu});var ar=se({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),vu=se({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var Eu=Eo,xo=128,Bu=127,Su=~Bu,Au=Math.pow(2,31);function Eo(r,t,e){t=t||[],e=e||0;for(var n=e;r>=Au;)t[e++]=r&255|xo,r/=128;for(;r&Su;)t[e++]=r&255|xo,r>>>=7;return t[e]=r|0,Eo.bytes=e-n+1,t}var ku=Ts,Iu=128,vo=127;function Ts(r,n){var e=0,n=n||0,s=0,i=n,o,c=r.length;do{if(i>=c)throw Ts.bytes=0,new RangeError("Could not decode varint");o=r[i++],e+=s<28?(o&vo)<<s:(o&vo)*Math.pow(2,s),s+=7}while(o>=Iu);return Ts.bytes=i-n,e}var Nu=Math.pow(2,7),Cu=Math.pow(2,14),Tu=Math.pow(2,21),Uu=Math.pow(2,28),Lu=Math.pow(2,35),Ru=Math.pow(2,42),_u=Math.pow(2,49),Vu=Math.pow(2,56),Hu=Math.pow(2,63),Mu=function(r){return r<Nu?1:r<Cu?2:r<Tu?3:r<Uu?4:r<Lu?5:r<Ru?6:r<_u?7:r<Vu?8:r<Hu?9:10},Ou={encode:Eu,decode:ku,encodingLength:Mu},Du=Ou,cr=Du;function ur(r,t=0){return[cr.decode(r,t),cr.decode.bytes]}function Pe(r,t,e=0){return cr.encode(r,t,e),t}function Fe(r){return cr.encodingLength(r)}function Nt(r,t){let e=t.byteLength,n=Fe(r),s=n+Fe(e),i=new Uint8Array(s+e);return Pe(r,i,0),Pe(e,i,n),i.set(t,s),new Ke(r,e,t,i)}function ie(r){let t=Kt(r),[e,n]=ur(t),[s,i]=ur(t.subarray(n)),o=t.subarray(n+i);if(o.byteLength!==s)throw new Error("Incorrect length");return new Ke(e,s,o,t)}function Bo(r,t){if(r===t)return!0;{let e=t;return r.code===e.code&&r.size===e.size&&e.bytes instanceof Uint8Array&&po(r.bytes,e.bytes)}}var Ke=class{code;size;digest;bytes;constructor(t,e,n,s){this.code=t,this.size=e,this.digest=n,this.bytes=s}};function So(r,t){let{bytes:e,version:n}=r;switch(n){case 0:return Fu(e,Us(r),t??Q.encoder);default:return Ku(e,Us(r),t??De.encoder)}}var Ao=new WeakMap;function Us(r){let t=Ao.get(r);if(t==null){let e=new Map;return Ao.set(r,e),e}return t}var St=class r{code;version;multihash;bytes;"/";constructor(t,e,n,s){this.code=e,this.version=t,this.multihash=n,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{let{code:t,multihash:e}=this;if(t!==lr)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==qu)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return r.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{let{code:t,digest:e}=this.multihash,n=Nt(t,e);return r.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return r.equals(this,t)}static equals(t,e){let n=e;return n!=null&&t.code===n.code&&t.version===n.version&&Bo(t.multihash,n.multihash)}toString(t){return So(this,t)}toJSON(){return{"/":So(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;let e=t;if(e instanceof r)return e;if(e["/"]!=null&&e["/"]===e.bytes||e.asCID===e){let{version:n,code:s,multihash:i,bytes:o}=e;return new r(n,s,i,o??ko(n,s,i.bytes))}else if(e[zu]===!0){let{version:n,multihash:s,code:i}=e,o=ie(s);return r.create(n,i,o)}else return null}static create(t,e,n){if(typeof e!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(e!==lr)throw new Error(`Version 0 CID must use dag-pb (code: ${lr}) block encoding`);return new r(t,e,n,n.bytes)}case 1:{let s=ko(t,e,n.bytes);return new r(t,e,n,s)}default:throw new Error("Invalid version")}}static createV0(t){return r.create(0,lr,t)}static createV1(t,e){return r.create(1,t,e)}static decode(t){let[e,n]=r.decodeFirst(t);if(n.length!==0)throw new Error("Incorrect length");return e}static decodeFirst(t){let e=r.inspectBytes(t),n=e.size-e.multihashSize,s=Kt(t.subarray(n,n+e.multihashSize));if(s.byteLength!==e.multihashSize)throw new Error("Incorrect length");let i=s.subarray(e.multihashSize-e.digestSize),o=new Ke(e.multihashCode,e.digestSize,i,s);return[e.version===0?r.createV0(o):r.createV1(e.codec,o),t.subarray(e.size)]}static inspectBytes(t){let e=0,n=()=>{let[u,d]=ur(t.subarray(e));return e+=d,u},s=n(),i=lr;if(s===18?(s=0,e=0):i=n(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);let o=e,c=n(),a=n(),f=e+a,l=f-o;return{version:s,codec:i,multihashCode:c,digestSize:a,multihashSize:l,size:f}}static parse(t,e){let[n,s]=Pu(t,e),i=r.decode(s);if(i.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Us(i).set(n,t),i}};function Pu(r,t){switch(r[0]){case"Q":{let e=t??Q;return[Q.prefix,e.decode(`${Q.prefix}${r}`)]}case Q.prefix:{let e=t??Q;return[Q.prefix,e.decode(r)]}case De.prefix:{let e=t??De;return[De.prefix,e.decode(r)]}case ar.prefix:{let e=t??ar;return[ar.prefix,e.decode(r)]}default:{if(t==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],t.decode(r)]}}}function Fu(r,t,e){let{prefix:n}=e;if(n!==Q.prefix)throw Error(`Cannot string encode V0 in ${e.name} encoding`);let s=t.get(n);if(s==null){let i=e.encode(r).slice(1);return t.set(n,i),i}else return s}function Ku(r,t,e){let{prefix:n}=e,s=t.get(n);if(s==null){let i=e.encode(r);return t.set(n,i),i}else return s}var lr=112,qu=18;function ko(r,t,e){let n=Fe(r),s=n+Fe(t),i=new Uint8Array(s+e.byteLength);return Pe(r,i,0),Pe(t,i,n),i.set(e,s),i}var zu=Symbol.for("@ipld/js-cid/CID");var Ls={};bt(Ls,{identity:()=>qt});var Io=0,$u="identity",No=Kt;function Gu(r){return Nt(Io,No(r))}var qt={code:Io,name:$u,encode:No,digest:Gu};function kt(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function Co(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function ju(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function qe(r,...t){if(!ju(r))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(r.length))throw new Error("Uint8Array expected of length "+t+", got length="+r.length)}function To(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Co(r.outputLen),Co(r.blockLen)}function ze(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function Uo(r,t){qe(r);let e=t.outputLen;if(r.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}var ve=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var jr=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),Ct=(r,t)=>r<<32-t|r>>>t;function Lo(r){if(typeof r!="string")throw new Error("utf8ToBytes expected string, got "+typeof r);return new Uint8Array(new TextEncoder().encode(r))}function fr(r){return typeof r=="string"&&(r=Lo(r)),qe(r),r}function Rs(...r){let t=0;for(let n=0;n<r.length;n++){let s=r[n];qe(s),t+=s.length}let e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){let i=r[n];e.set(i,s),s+=i.length}return e}var $e=class{clone(){return this._cloneInto()}};function Zr(r){let t=n=>r().update(fr(n)).digest(),e=r();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>r(),t}function Ge(r=32){if(ve&&typeof ve.getRandomValues=="function")return ve.getRandomValues(new Uint8Array(r));if(ve&&typeof ve.randomBytes=="function")return ve.randomBytes(r);throw new Error("crypto.getRandomValues must be defined")}function Zu(r,t,e,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(t,e,n);let s=BigInt(32),i=BigInt(4294967295),o=Number(e>>s&i),c=Number(e&i),a=n?4:0,f=n?0:4;r.setUint32(t+a,o,n),r.setUint32(t+f,c,n)}var Ro=(r,t,e)=>r&t^~r&e,_o=(r,t,e)=>r&t^r&e^t&e,je=class extends $e{constructor(t,e,n,s){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=jr(this.buffer)}update(t){ze(this);let{view:e,buffer:n,blockLen:s}=this;t=fr(t);let i=t.length;for(let o=0;o<i;){let c=Math.min(s-this.pos,i-o);if(c===s){let a=jr(t);for(;s<=i-o;o+=s)this.process(a,o);continue}n.set(t.subarray(o,o+c),this.pos),this.pos+=c,o+=c,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){ze(this),Uo(t,this),this.finished=!0;let{buffer:e,view:n,blockLen:s,isLE:i}=this,{pos:o}=this;e[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>s-o&&(this.process(n,0),o=0);for(let u=o;u<s;u++)e[u]=0;Zu(n,s-8,BigInt(this.length*8),i),this.process(n,0);let c=jr(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let f=a/4,l=this.get();if(f>l.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<f;u++)c.setUint32(4*u,l[u],i)}digest(){let{buffer:t,outputLen:e}=this;this.digestInto(t);let n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:e,buffer:n,length:s,finished:i,destroyed:o,pos:c}=this;return t.length=s,t.pos=c,t.finished=i,t.destroyed=o,s%e&&t.buffer.set(n),t}};var Wr=BigInt(4294967295),_s=BigInt(32);function Vo(r,t=!1){return t?{h:Number(r&Wr),l:Number(r>>_s&Wr)}:{h:Number(r>>_s&Wr)|0,l:Number(r&Wr)|0}}function Wu(r,t=!1){let e=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let s=0;s<r.length;s++){let{h:i,l:o}=Vo(r[s],t);[e[s],n[s]]=[i,o]}return[e,n]}var Yu=(r,t)=>BigInt(r>>>0)<<_s|BigInt(t>>>0),Ju=(r,t,e)=>r>>>e,Xu=(r,t,e)=>r<<32-e|t>>>e,Qu=(r,t,e)=>r>>>e|t<<32-e,tl=(r,t,e)=>r<<32-e|t>>>e,el=(r,t,e)=>r<<64-e|t>>>e-32,rl=(r,t,e)=>r>>>e-32|t<<64-e,nl=(r,t)=>t,sl=(r,t)=>r,il=(r,t,e)=>r<<e|t>>>32-e,ol=(r,t,e)=>t<<e|r>>>32-e,al=(r,t,e)=>t<<e-32|r>>>64-e,cl=(r,t,e)=>r<<e-32|t>>>64-e;function ul(r,t,e,n){let s=(t>>>0)+(n>>>0);return{h:r+e+(s/2**32|0)|0,l:s|0}}var ll=(r,t,e)=>(r>>>0)+(t>>>0)+(e>>>0),fl=(r,t,e,n)=>t+e+n+(r/2**32|0)|0,hl=(r,t,e,n)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0),dl=(r,t,e,n,s)=>t+e+n+s+(r/2**32|0)|0,pl=(r,t,e,n,s)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(s>>>0),gl=(r,t,e,n,s,i)=>t+e+n+s+i+(r/2**32|0)|0;var ml={fromBig:Vo,split:Wu,toBig:Yu,shrSH:Ju,shrSL:Xu,rotrSH:Qu,rotrSL:tl,rotrBH:el,rotrBL:rl,rotr32H:nl,rotr32L:sl,rotlSH:il,rotlSL:ol,rotlBH:al,rotlBL:cl,add:ul,add3L:ll,add3H:fl,add4L:hl,add4H:dl,add5H:gl,add5L:pl},H=ml;var[bl,yl]=H.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),ae=new Uint32Array(80),ce=new Uint32Array(80),Vs=class extends je{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){let{Ah:t,Al:e,Bh:n,Bl:s,Ch:i,Cl:o,Dh:c,Dl:a,Eh:f,El:l,Fh:u,Fl:d,Gh:m,Gl:x,Hh:y,Hl:h}=this;return[t,e,n,s,i,o,c,a,f,l,u,d,m,x,y,h]}set(t,e,n,s,i,o,c,a,f,l,u,d,m,x,y,h){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=c|0,this.Dl=a|0,this.Eh=f|0,this.El=l|0,this.Fh=u|0,this.Fl=d|0,this.Gh=m|0,this.Gl=x|0,this.Hh=y|0,this.Hl=h|0}process(t,e){for(let g=0;g<16;g++,e+=4)ae[g]=t.getUint32(e),ce[g]=t.getUint32(e+=4);for(let g=16;g<80;g++){let k=ae[g-15]|0,U=ce[g-15]|0,L=H.rotrSH(k,U,1)^H.rotrSH(k,U,8)^H.shrSH(k,U,7),I=H.rotrSL(k,U,1)^H.rotrSL(k,U,8)^H.shrSL(k,U,7),T=ae[g-2]|0,N=ce[g-2]|0,G=H.rotrSH(T,N,19)^H.rotrBH(T,N,61)^H.shrSH(T,N,6),F=H.rotrSL(T,N,19)^H.rotrBL(T,N,61)^H.shrSL(T,N,6),O=H.add4L(I,F,ce[g-7],ce[g-16]),tt=H.add4H(O,L,G,ae[g-7],ae[g-16]);ae[g]=tt|0,ce[g]=O|0}let{Ah:n,Al:s,Bh:i,Bl:o,Ch:c,Cl:a,Dh:f,Dl:l,Eh:u,El:d,Fh:m,Fl:x,Gh:y,Gl:h,Hh:w,Hl:E}=this;for(let g=0;g<80;g++){let k=H.rotrSH(u,d,14)^H.rotrSH(u,d,18)^H.rotrBH(u,d,41),U=H.rotrSL(u,d,14)^H.rotrSL(u,d,18)^H.rotrBL(u,d,41),L=u&m^~u&y,I=d&x^~d&h,T=H.add5L(E,U,I,yl[g],ce[g]),N=H.add5H(T,w,k,L,bl[g],ae[g]),G=T|0,F=H.rotrSH(n,s,28)^H.rotrBH(n,s,34)^H.rotrBH(n,s,39),O=H.rotrSL(n,s,28)^H.rotrBL(n,s,34)^H.rotrBL(n,s,39),tt=n&i^n&c^i&c,B=s&o^s&a^o&a;w=y|0,E=h|0,y=m|0,h=x|0,m=u|0,x=d|0,{h:u,l:d}=H.add(f|0,l|0,N|0,G|0),f=c|0,l=a|0,c=i|0,a=o|0,i=n|0,o=s|0;let C=H.add3L(G,O,B);n=H.add3H(C,N,F,tt),s=C|0}({h:n,l:s}=H.add(this.Ah|0,this.Al|0,n|0,s|0)),{h:i,l:o}=H.add(this.Bh|0,this.Bl|0,i|0,o|0),{h:c,l:a}=H.add(this.Ch|0,this.Cl|0,c|0,a|0),{h:f,l}=H.add(this.Dh|0,this.Dl|0,f|0,l|0),{h:u,l:d}=H.add(this.Eh|0,this.El|0,u|0,d|0),{h:m,l:x}=H.add(this.Fh|0,this.Fl|0,m|0,x|0),{h:y,l:h}=H.add(this.Gh|0,this.Gl|0,y|0,h|0),{h:w,l:E}=H.add(this.Hh|0,this.Hl|0,w|0,E|0),this.set(n,s,i,o,c,a,f,l,u,d,m,x,y,h,w,E)}roundClean(){ae.fill(0),ce.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}};var Ho=Zr(()=>new Vs);var Xr={};bt(Xr,{aInRange:()=>vt,abool:()=>Tt,abytes:()=>Ze,bitGet:()=>Sl,bitLen:()=>Ds,bitMask:()=>dr,bitSet:()=>Al,bytesToHex:()=>$t,bytesToNumberBE:()=>Gt,bytesToNumberLE:()=>le,concatBytes:()=>jt,createHmacDrbg:()=>Ps,ensureBytes:()=>W,equalBytes:()=>El,hexToBytes:()=>Be,hexToNumber:()=>Os,inRange:()=>hr,isBytes:()=>ue,memoized:()=>Ae,notImplemented:()=>Il,numberToBytesBE:()=>fe,numberToBytesLE:()=>Se,numberToHexUnpadded:()=>Ee,numberToVarBytesBE:()=>vl,utf8ToBytes:()=>Bl,validateObject:()=>Ht});var Yr=BigInt(0),Jr=BigInt(1),wl=BigInt(2);function ue(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Ze(r){if(!ue(r))throw new Error("Uint8Array expected")}function Tt(r,t){if(typeof t!="boolean")throw new Error(r+" boolean expected, got "+t)}var xl=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function $t(r){Ze(r);let t="";for(let e=0;e<r.length;e++)t+=xl[r[e]];return t}function Ee(r){let t=r.toString(16);return t.length&1?"0"+t:t}function Os(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?Yr:BigInt("0x"+r)}var zt={_0:48,_9:57,A:65,F:70,a:97,f:102};function Mo(r){if(r>=zt._0&&r<=zt._9)return r-zt._0;if(r>=zt.A&&r<=zt.F)return r-(zt.A-10);if(r>=zt.a&&r<=zt.f)return r-(zt.a-10)}function Be(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);let t=r.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);let n=new Uint8Array(e);for(let s=0,i=0;s<e;s++,i+=2){let o=Mo(r.charCodeAt(i)),c=Mo(r.charCodeAt(i+1));if(o===void 0||c===void 0){let a=r[i]+r[i+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+i)}n[s]=o*16+c}return n}function Gt(r){return Os($t(r))}function le(r){return Ze(r),Os($t(Uint8Array.from(r).reverse()))}function fe(r,t){return Be(r.toString(16).padStart(t*2,"0"))}function Se(r,t){return fe(r,t).reverse()}function vl(r){return Be(Ee(r))}function W(r,t,e){let n;if(typeof t=="string")try{n=Be(t)}catch(i){throw new Error(r+" must be hex string or Uint8Array, cause: "+i)}else if(ue(t))n=Uint8Array.from(t);else throw new Error(r+" must be hex string or Uint8Array");let s=n.length;if(typeof e=="number"&&s!==e)throw new Error(r+" of length "+e+" expected, got "+s);return n}function jt(...r){let t=0;for(let n=0;n<r.length;n++){let s=r[n];Ze(s),t+=s.length}let e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){let i=r[n];e.set(i,s),s+=i.length}return e}function El(r,t){if(r.length!==t.length)return!1;let e=0;for(let n=0;n<r.length;n++)e|=r[n]^t[n];return e===0}function Bl(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}var Hs=r=>typeof r=="bigint"&&Yr<=r;function hr(r,t,e){return Hs(r)&&Hs(t)&&Hs(e)&&t<=r&&r<e}function vt(r,t,e,n){if(!hr(t,e,n))throw new Error("expected valid "+r+": "+e+" <= n < "+n+", got "+t)}function Ds(r){let t;for(t=0;r>Yr;r>>=Jr,t+=1);return t}function Sl(r,t){return r>>BigInt(t)&Jr}function Al(r,t,e){return r|(e?Jr:Yr)<<BigInt(t)}var dr=r=>(wl<<BigInt(r-1))-Jr,Ms=r=>new Uint8Array(r),Oo=r=>Uint8Array.from(r);function Ps(r,t,e){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let n=Ms(r),s=Ms(r),i=0,o=()=>{n.fill(1),s.fill(0),i=0},c=(...u)=>e(s,n,...u),a=(u=Ms())=>{s=c(Oo([0]),u),n=c(),u.length!==0&&(s=c(Oo([1]),u),n=c())},f=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let u=0,d=[];for(;u<t;){n=c();let m=n.slice();d.push(m),u+=n.length}return jt(...d)};return(u,d)=>{o(),a(u);let m;for(;!(m=d(f()));)a();return o(),m}}var kl={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||ue(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,t)=>t.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function Ht(r,t,e={}){let n=(s,i,o)=>{let c=kl[i];if(typeof c!="function")throw new Error("invalid validator function");let a=r[s];if(!(o&&a===void 0)&&!c(a,r))throw new Error("param "+String(s)+" is invalid. Expected "+i+", got "+a)};for(let[s,i]of Object.entries(t))n(s,i,!1);for(let[s,i]of Object.entries(e))n(s,i,!0);return r}var Il=()=>{throw new Error("not implemented")};function Ae(r){let t=new WeakMap;return(e,...n)=>{let s=t.get(e);if(s!==void 0)return s;let i=r(e,...n);return t.set(e,i),i}}var rt=BigInt(0),j=BigInt(1),ke=BigInt(2),Nl=BigInt(3),Fs=BigInt(4),Do=BigInt(5),Po=BigInt(8),Cl=BigInt(9),Tl=BigInt(16);function z(r,t){let e=r%t;return e>=rt?e:t+e}function Ul(r,t,e){if(t<rt)throw new Error("invalid exponent, negatives unsupported");if(e<=rt)throw new Error("invalid modulus");if(e===j)return rt;let n=j;for(;t>rt;)t&j&&(n=n*r%e),r=r*r%e,t>>=j;return n}function Z(r,t,e){let n=r;for(;t-- >rt;)n*=n,n%=e;return n}function Qr(r,t){if(r===rt)throw new Error("invert: expected non-zero number");if(t<=rt)throw new Error("invert: expected positive modulus, got "+t);let e=z(r,t),n=t,s=rt,i=j,o=j,c=rt;for(;e!==rt;){let f=n/e,l=n%e,u=s-o*f,d=i-c*f;n=e,e=l,s=o,i=c,o=u,c=d}if(n!==j)throw new Error("invert: does not exist");return z(s,t)}function Ll(r){let t=(r-j)/ke,e,n,s;for(e=r-j,n=0;e%ke===rt;e/=ke,n++);for(s=ke;s<r&&Ul(s,t,r)!==r-j;s++)if(s>1e3)throw new Error("Cannot find square root: likely non-prime P");if(n===1){let o=(r+j)/Fs;return function(a,f){let l=a.pow(f,o);if(!a.eql(a.sqr(l),f))throw new Error("Cannot find square root");return l}}let i=(e+j)/ke;return function(c,a){if(c.pow(a,t)===c.neg(c.ONE))throw new Error("Cannot find square root");let f=n,l=c.pow(c.mul(c.ONE,s),e),u=c.pow(a,i),d=c.pow(a,e);for(;!c.eql(d,c.ONE);){if(c.eql(d,c.ZERO))return c.ZERO;let m=1;for(let y=c.sqr(d);m<f&&!c.eql(y,c.ONE);m++)y=c.sqr(y);let x=c.pow(l,j<<BigInt(f-m-1));l=c.sqr(x),u=c.mul(u,x),d=c.mul(d,l),f=m}return u}}function Rl(r){if(r%Fs===Nl){let t=(r+j)/Fs;return function(n,s){let i=n.pow(s,t);if(!n.eql(n.sqr(i),s))throw new Error("Cannot find square root");return i}}if(r%Po===Do){let t=(r-Do)/Po;return function(n,s){let i=n.mul(s,ke),o=n.pow(i,t),c=n.mul(s,o),a=n.mul(n.mul(c,ke),o),f=n.mul(c,n.sub(a,n.ONE));if(!n.eql(n.sqr(f),s))throw new Error("Cannot find square root");return f}}return r%Tl,Ll(r)}var Fo=(r,t)=>(z(r,t)&j)===j,_l=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ks(r){let t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=_l.reduce((n,s)=>(n[s]="function",n),t);return Ht(r,e)}function Vl(r,t,e){if(e<rt)throw new Error("invalid exponent, negatives unsupported");if(e===rt)return r.ONE;if(e===j)return t;let n=r.ONE,s=t;for(;e>rt;)e&j&&(n=r.mul(n,s)),s=r.sqr(s),e>>=j;return n}function Hl(r,t){let e=new Array(t.length),n=t.reduce((i,o,c)=>r.is0(o)?i:(e[c]=i,r.mul(i,o)),r.ONE),s=r.inv(n);return t.reduceRight((i,o,c)=>r.is0(o)?i:(e[c]=r.mul(i,e[c]),r.mul(i,o)),s),e}function qs(r,t){let e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}function he(r,t,e=!1,n={}){if(r<=rt)throw new Error("invalid field: expected ORDER > 0, got "+r);let{nBitLength:s,nByteLength:i}=qs(r,t);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o,c=Object.freeze({ORDER:r,isLE:e,BITS:s,BYTES:i,MASK:dr(s),ZERO:rt,ONE:j,create:a=>z(a,r),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return rt<=a&&a<r},is0:a=>a===rt,isOdd:a=>(a&j)===j,neg:a=>z(-a,r),eql:(a,f)=>a===f,sqr:a=>z(a*a,r),add:(a,f)=>z(a+f,r),sub:(a,f)=>z(a-f,r),mul:(a,f)=>z(a*f,r),pow:(a,f)=>Vl(c,a,f),div:(a,f)=>z(a*Qr(f,r),r),sqrN:a=>a*a,addN:(a,f)=>a+f,subN:(a,f)=>a-f,mulN:(a,f)=>a*f,inv:a=>Qr(a,r),sqrt:n.sqrt||(a=>(o||(o=Rl(r)),o(c,a))),invertBatch:a=>Hl(c,a),cmov:(a,f,l)=>l?f:a,toBytes:a=>e?Se(a,i):fe(a,i),fromBytes:a=>{if(a.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+a.length);return e?le(a):Gt(a)}});return Object.freeze(c)}function Ko(r){if(typeof r!="bigint")throw new Error("field order must be bigint");let t=r.toString(2).length;return Math.ceil(t/8)}function zs(r){let t=Ko(r);return t+Math.ceil(t/2)}function qo(r,t,e=!1){let n=r.length,s=Ko(t),i=zs(t);if(n<16||n<i||n>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+n);let o=e?le(r):Gt(r),c=z(o,t-j)+j;return e?Se(c,s):fe(c,s)}var zo=BigInt(0),tn=BigInt(1);function $s(r,t){let e=t.negate();return r?e:t}function $o(r,t){if(!Number.isSafeInteger(r)||r<=0||r>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+r)}function Gs(r,t){$o(r,t);let e=Math.ceil(t/r)+1,n=2**(r-1);return{windows:e,windowSize:n}}function Ol(r,t){if(!Array.isArray(r))throw new Error("array expected");r.forEach((e,n)=>{if(!(e instanceof t))throw new Error("invalid point at index "+n)})}function Dl(r,t){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((e,n)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+n)})}var js=new WeakMap,Go=new WeakMap;function Zs(r){return Go.get(r)||1}function en(r,t){return{constTimeNegate:$s,hasPrecomputes(e){return Zs(e)!==1},unsafeLadder(e,n,s=r.ZERO){let i=e;for(;n>zo;)n&tn&&(s=s.add(i)),i=i.double(),n>>=tn;return s},precomputeWindow(e,n){let{windows:s,windowSize:i}=Gs(n,t),o=[],c=e,a=c;for(let f=0;f<s;f++){a=c,o.push(a);for(let l=1;l<i;l++)a=a.add(c),o.push(a);c=a.double()}return o},wNAF(e,n,s){let{windows:i,windowSize:o}=Gs(e,t),c=r.ZERO,a=r.BASE,f=BigInt(2**e-1),l=2**e,u=BigInt(e);for(let d=0;d<i;d++){let m=d*o,x=Number(s&f);s>>=u,x>o&&(x-=l,s+=tn);let y=m,h=m+Math.abs(x)-1,w=d%2!==0,E=x<0;x===0?a=a.add($s(w,n[y])):c=c.add($s(E,n[h]))}return{p:c,f:a}},wNAFUnsafe(e,n,s,i=r.ZERO){let{windows:o,windowSize:c}=Gs(e,t),a=BigInt(2**e-1),f=2**e,l=BigInt(e);for(let u=0;u<o;u++){let d=u*c;if(s===zo)break;let m=Number(s&a);if(s>>=l,m>c&&(m-=f,s+=tn),m===0)continue;let x=n[d+Math.abs(m)-1];m<0&&(x=x.negate()),i=i.add(x)}return i},getPrecomputes(e,n,s){let i=js.get(n);return i||(i=this.precomputeWindow(n,e),e!==1&&js.set(n,s(i))),i},wNAFCached(e,n,s){let i=Zs(e);return this.wNAF(i,this.getPrecomputes(i,e,s),n)},wNAFCachedUnsafe(e,n,s,i){let o=Zs(e);return o===1?this.unsafeLadder(e,n,i):this.wNAFUnsafe(o,this.getPrecomputes(o,e,s),n,i)},setWindowSize(e,n){$o(n,t),Go.set(e,n),js.delete(e)}}}function rn(r,t,e,n){if(Ol(e,r),Dl(n,t),e.length!==n.length)throw new Error("arrays of points and scalars must have equal length");let s=r.ZERO,i=Ds(BigInt(e.length)),o=i>12?i-3:i>4?i-2:i?2:1,c=(1<<o)-1,a=new Array(c+1).fill(s),f=Math.floor((t.BITS-1)/o)*o,l=s;for(let u=f;u>=0;u-=o){a.fill(s);for(let m=0;m<n.length;m++){let x=n[m],y=Number(x>>BigInt(u)&BigInt(c));a[y]=a[y].add(e[m])}let d=s;for(let m=a.length-1,x=s;m>0;m--)x=x.add(a[m]),d=d.add(x);if(l=l.add(d),u!==0)for(let m=0;m<o;m++)l=l.double()}return l}function pr(r){return Ks(r.Fp),Ht(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...qs(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}var Ut=BigInt(0),Et=BigInt(1),nn=BigInt(2),Pl=BigInt(8),Fl={zip215:!0};function Kl(r){let t=pr(r);return Ht(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}function jo(r){let t=Kl(r),{Fp:e,n,prehash:s,hash:i,randomBytes:o,nByteLength:c,h:a}=t,f=nn<<BigInt(c*8)-Et,l=e.create,u=he(t.n,t.nBitLength),d=t.uvRatio||((b,p)=>{try{return{isValid:!0,value:e.sqrt(b*e.inv(p))}}catch{return{isValid:!1,value:Ut}}}),m=t.adjustScalarBytes||(b=>b),x=t.domain||((b,p,v)=>{if(Tt("phflag",v),p.length||v)throw new Error("Contexts/pre-hash are not supported");return b});function y(b,p){vt("coordinate "+b,p,Ut,f)}function h(b){if(!(b instanceof g))throw new Error("ExtendedPoint expected")}let w=Ae((b,p)=>{let{ex:v,ey:A,ez:R}=b,_=b.is0();p==null&&(p=_?Pl:e.inv(R));let M=l(v*p),P=l(A*p),V=l(R*p);if(_)return{x:Ut,y:Et};if(V!==Et)throw new Error("invZ was invalid");return{x:M,y:P}}),E=Ae(b=>{let{a:p,d:v}=t;if(b.is0())throw new Error("bad point: ZERO");let{ex:A,ey:R,ez:_,et:M}=b,P=l(A*A),V=l(R*R),q=l(_*_),$=l(q*q),st=l(P*p),it=l(q*l(st+V)),at=l($+l(v*l(P*V)));if(it!==at)throw new Error("bad point: equation left != right (1)");let lt=l(A*R),xt=l(_*M);if(lt!==xt)throw new Error("bad point: equation left != right (2)");return!0});class g{constructor(p,v,A,R){this.ex=p,this.ey=v,this.ez=A,this.et=R,y("x",p),y("y",v),y("z",A),y("t",R),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(p){if(p instanceof g)throw new Error("extended point not allowed");let{x:v,y:A}=p||{};return y("x",v),y("y",A),new g(v,A,Et,l(v*A))}static normalizeZ(p){let v=e.invertBatch(p.map(A=>A.ez));return p.map((A,R)=>A.toAffine(v[R])).map(g.fromAffine)}static msm(p,v){return rn(g,u,p,v)}_setWindowSize(p){L.setWindowSize(this,p)}assertValidity(){E(this)}equals(p){h(p);let{ex:v,ey:A,ez:R}=this,{ex:_,ey:M,ez:P}=p,V=l(v*P),q=l(_*R),$=l(A*P),st=l(M*R);return V===q&&$===st}is0(){return this.equals(g.ZERO)}negate(){return new g(l(-this.ex),this.ey,this.ez,l(-this.et))}double(){let{a:p}=t,{ex:v,ey:A,ez:R}=this,_=l(v*v),M=l(A*A),P=l(nn*l(R*R)),V=l(p*_),q=v+A,$=l(l(q*q)-_-M),st=V+M,it=st-P,at=V-M,lt=l($*it),xt=l(st*at),mt=l($*at),Vt=l(it*st);return new g(lt,xt,Vt,mt)}add(p){h(p);let{a:v,d:A}=t,{ex:R,ey:_,ez:M,et:P}=this,{ex:V,ey:q,ez:$,et:st}=p;if(v===BigInt(-1)){let ro=l((_-R)*(q+V)),no=l((_+R)*(q-V)),vs=l(no-ro);if(vs===Ut)return this.double();let so=l(M*nn*st),io=l(P*nn*$),oo=io+so,ao=no+ro,co=io-so,Jc=l(oo*vs),Xc=l(ao*co),Qc=l(oo*co),tu=l(vs*ao);return new g(Jc,Xc,tu,Qc)}let it=l(R*V),at=l(_*q),lt=l(P*A*st),xt=l(M*$),mt=l((R+_)*(V+q)-it-at),Vt=xt-lt,Ft=xt+lt,ir=l(at-v*it),jc=l(mt*Vt),Zc=l(Ft*ir),Wc=l(mt*ir),Yc=l(Vt*Ft);return new g(jc,Zc,Yc,Wc)}subtract(p){return this.add(p.negate())}wNAF(p){return L.wNAFCached(this,p,g.normalizeZ)}multiply(p){let v=p;vt("scalar",v,Et,n);let{p:A,f:R}=this.wNAF(v);return g.normalizeZ([A,R])[0]}multiplyUnsafe(p,v=g.ZERO){let A=p;return vt("scalar",A,Ut,n),A===Ut?U:this.is0()||A===Et?this:L.wNAFCachedUnsafe(this,A,g.normalizeZ,v)}isSmallOrder(){return this.multiplyUnsafe(a).is0()}isTorsionFree(){return L.unsafeLadder(this,n).is0()}toAffine(p){return w(this,p)}clearCofactor(){let{h:p}=t;return p===Et?this:this.multiplyUnsafe(p)}static fromHex(p,v=!1){let{d:A,a:R}=t,_=e.BYTES;p=W("pointHex",p,_),Tt("zip215",v);let M=p.slice(),P=p[_-1];M[_-1]=P&-129;let V=le(M),q=v?f:e.ORDER;vt("pointHex.y",V,Ut,q);let $=l(V*V),st=l($-Et),it=l(A*$-R),{isValid:at,value:lt}=d(st,it);if(!at)throw new Error("Point.fromHex: invalid y coordinate");let xt=(lt&Et)===Et,mt=(P&128)!==0;if(!v&&lt===Ut&&mt)throw new Error("Point.fromHex: x=0 and x_0=1");return mt!==xt&&(lt=l(-lt)),g.fromAffine({x:lt,y:V})}static fromPrivateKey(p){return N(p).point}toRawBytes(){let{x:p,y:v}=this.toAffine(),A=Se(v,e.BYTES);return A[A.length-1]|=p&Et?128:0,A}toHex(){return $t(this.toRawBytes())}}g.BASE=new g(t.Gx,t.Gy,Et,l(t.Gx*t.Gy)),g.ZERO=new g(Ut,Et,Et,Ut);let{BASE:k,ZERO:U}=g,L=en(g,c*8);function I(b){return z(b,n)}function T(b){return I(le(b))}function N(b){let p=e.BYTES;b=W("private key",b,p);let v=W("hashed private key",i(b),2*p),A=m(v.slice(0,p)),R=v.slice(p,2*p),_=T(A),M=k.multiply(_),P=M.toRawBytes();return{head:A,prefix:R,scalar:_,point:M,pointBytes:P}}function G(b){return N(b).pointBytes}function F(b=new Uint8Array,...p){let v=jt(...p);return T(i(x(v,W("context",b),!!s)))}function O(b,p,v={}){b=W("message",b),s&&(b=s(b));let{prefix:A,scalar:R,pointBytes:_}=N(p),M=F(v.context,A,b),P=k.multiply(M).toRawBytes(),V=F(v.context,P,_,b),q=I(M+V*R);vt("signature.s",q,Ut,n);let $=jt(P,Se(q,e.BYTES));return W("result",$,e.BYTES*2)}let tt=Fl;function B(b,p,v,A=tt){let{context:R,zip215:_}=A,M=e.BYTES;b=W("signature",b,2*M),p=W("message",p),v=W("publicKey",v,M),_!==void 0&&Tt("zip215",_),s&&(p=s(p));let P=le(b.slice(M,2*M)),V,q,$;try{V=g.fromHex(v,_),q=g.fromHex(b.slice(0,M),_),$=k.multiplyUnsafe(P)}catch{return!1}if(!_&&V.isSmallOrder())return!1;let st=F(R,q.toRawBytes(),V.toRawBytes(),p);return q.add(V.multiplyUnsafe(st)).subtract($).clearCofactor().equals(g.ZERO)}return k._setWindowSize(8),{CURVE:t,getPublicKey:G,sign:O,verify:B,ExtendedPoint:g,utils:{getExtendedPublicKey:N,randomPrivateKey:()=>o(e.BYTES),precompute(b=8,p=g.BASE){return p._setWindowSize(b),p.multiply(BigInt(3)),p}}}}var Ws=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Zo=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),wd=BigInt(0),ql=BigInt(1),Wo=BigInt(2),xd=BigInt(3),zl=BigInt(5),$l=BigInt(8);function Gl(r){let t=BigInt(10),e=BigInt(20),n=BigInt(40),s=BigInt(80),i=Ws,c=r*r%i*r%i,a=Z(c,Wo,i)*c%i,f=Z(a,ql,i)*r%i,l=Z(f,zl,i)*f%i,u=Z(l,t,i)*l%i,d=Z(u,e,i)*u%i,m=Z(d,n,i)*d%i,x=Z(m,s,i)*m%i,y=Z(x,s,i)*m%i,h=Z(y,t,i)*l%i;return{pow_p_5_8:Z(h,Wo,i)*r%i,b2:c}}function jl(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function Zl(r,t){let e=Ws,n=z(t*t*t,e),s=z(n*n*t,e),i=Gl(r*s).pow_p_5_8,o=z(r*n*i,e),c=z(t*o*o,e),a=o,f=z(o*Zo,e),l=c===r,u=c===z(-r,e),d=c===z(-r*Zo,e);return l&&(o=a),(u||d)&&(o=f),Fo(o,e)&&(o=z(-o,e)),{isValid:l||u,value:o}}var Wl=he(Ws,void 0,!0),Yl={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:Wl,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:$l,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Ho,randomBytes:Ge,adjustScalarBytes:jl,uvRatio:Zl},Yo=jo(Yl);var sn=32;function Jo(r,t,e){return Yo.verify(t,e instanceof Uint8Array?e:e.subarray(),r)}var on=class{type="Ed25519";raw;constructor(t){this.raw=Ys(t,sn)}toMultihash(){return qt.digest(Ie(this))}toCID(){return St.createV1(114,this.toMultihash())}toString(){return Q.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:kt(this.raw,t.raw)}verify(t,e){return Jo(this.raw,e,t)}};function Js(r){return r=Ys(r,sn),new on(r)}function Ys(r,t){if(r=Uint8Array.from(r??[]),r.length!==t)throw new et(`Key must be a Uint8Array of length ${t}, got ${r.length}`);return r}function Zt(r=0){return new Uint8Array(r)}function ft(r=0){return new Uint8Array(r)}var Xl=Math.pow(2,7),Ql=Math.pow(2,14),tf=Math.pow(2,21),Xs=Math.pow(2,28),Qs=Math.pow(2,35),ti=Math.pow(2,42),ei=Math.pow(2,49),K=128,ht=127;function Lt(r){if(r<Xl)return 1;if(r<Ql)return 2;if(r<tf)return 3;if(r<Xs)return 4;if(r<Qs)return 5;if(r<ti)return 6;if(r<ei)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function ri(r,t,e=0){switch(Lt(r)){case 8:t[e++]=r&255|K,r/=128;case 7:t[e++]=r&255|K,r/=128;case 6:t[e++]=r&255|K,r/=128;case 5:t[e++]=r&255|K,r/=128;case 4:t[e++]=r&255|K,r>>>=7;case 3:t[e++]=r&255|K,r>>>=7;case 2:t[e++]=r&255|K,r>>>=7;case 1:{t[e++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return t}function ef(r,t,e=0){switch(Lt(r)){case 8:t.set(e++,r&255|K),r/=128;case 7:t.set(e++,r&255|K),r/=128;case 6:t.set(e++,r&255|K),r/=128;case 5:t.set(e++,r&255|K),r/=128;case 4:t.set(e++,r&255|K),r>>>=7;case 3:t.set(e++,r&255|K),r>>>=7;case 2:t.set(e++,r&255|K),r>>>=7;case 1:{t.set(e++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return t}function ni(r,t){let e=r[t],n=0;if(n+=e&ht,e<K||(e=r[t+1],n+=(e&ht)<<7,e<K)||(e=r[t+2],n+=(e&ht)<<14,e<K)||(e=r[t+3],n+=(e&ht)<<21,e<K)||(e=r[t+4],n+=(e&ht)*Xs,e<K)||(e=r[t+5],n+=(e&ht)*Qs,e<K)||(e=r[t+6],n+=(e&ht)*ti,e<K)||(e=r[t+7],n+=(e&ht)*ei,e<K))return n;throw new RangeError("Could not decode varint")}function rf(r,t){let e=r.get(t),n=0;if(n+=e&ht,e<K||(e=r.get(t+1),n+=(e&ht)<<7,e<K)||(e=r.get(t+2),n+=(e&ht)<<14,e<K)||(e=r.get(t+3),n+=(e&ht)<<21,e<K)||(e=r.get(t+4),n+=(e&ht)*Xs,e<K)||(e=r.get(t+5),n+=(e&ht)*Qs,e<K)||(e=r.get(t+6),n+=(e&ht)*ti,e<K)||(e=r.get(t+7),n+=(e&ht)*ei,e<K))return n;throw new RangeError("Could not decode varint")}function Qo(r,t,e=0){return t==null&&(t=ft(Lt(r))),t instanceof Uint8Array?ri(r,t,e):ef(r,t,e)}function ta(r,t=0){return r instanceof Uint8Array?ni(r,t):rf(r,t)}var si=new Float32Array([-0]),de=new Uint8Array(si.buffer);function ra(r,t,e){si[0]=r,t[e]=de[0],t[e+1]=de[1],t[e+2]=de[2],t[e+3]=de[3]}function na(r,t){return de[0]=r[t],de[1]=r[t+1],de[2]=r[t+2],de[3]=r[t+3],si[0]}var ii=new Float64Array([-0]),dt=new Uint8Array(ii.buffer);function sa(r,t,e){ii[0]=r,t[e]=dt[0],t[e+1]=dt[1],t[e+2]=dt[2],t[e+3]=dt[3],t[e+4]=dt[4],t[e+5]=dt[5],t[e+6]=dt[6],t[e+7]=dt[7]}function ia(r,t){return dt[0]=r[t],dt[1]=r[t+1],dt[2]=r[t+2],dt[3]=r[t+3],dt[4]=r[t+4],dt[5]=r[t+5],dt[6]=r[t+6],dt[7]=r[t+7],ii[0]}var nf=BigInt(Number.MAX_SAFE_INTEGER),sf=BigInt(Number.MIN_SAFE_INTEGER),At=class r{lo;hi;constructor(t,e){this.lo=t|0,this.hi=e|0}toNumber(t=!1){if(!t&&this.hi>>>31>0){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(e+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(t=!1){if(t)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(BigInt(e)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(t=!1){return this.toBigInt(t).toString()}zzEncode(){let t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this}zzDecode(){let t=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this}length(){let t=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?e===0?t<16384?t<128?1:2:t<2097152?3:4:e<16384?e<128?5:6:e<2097152?7:8:n<128?9:10}static fromBigInt(t){if(t===0n)return Ne;if(t<nf&&t>sf)return this.fromNumber(Number(t));let e=t<0n;e&&(t=-t);let n=t>>32n,s=t-(n<<32n);return e&&(n=~n|0n,s=~s|0n,++s>oa&&(s=0n,++n>oa&&(n=0n))),new r(Number(s),Number(n))}static fromNumber(t){if(t===0)return Ne;let e=t<0;e&&(t=-t);let n=t>>>0,s=(t-n)/4294967296>>>0;return e&&(s=~s>>>0,n=~n>>>0,++n>4294967295&&(n=0,++s>4294967295&&(s=0))),new r(n,s)}static from(t){return typeof t=="number"?r.fromNumber(t):typeof t=="bigint"?r.fromBigInt(t):typeof t=="string"?r.fromBigInt(BigInt(t)):t.low!=null||t.high!=null?new r(t.low>>>0,t.high>>>0):Ne}},Ne=new At(0,0);Ne.toBigInt=function(){return 0n};Ne.zzEncode=Ne.zzDecode=function(){return this};Ne.length=function(){return 1};var oa=4294967296n;function aa(r){let t=0,e=0;for(let n=0;n<r.length;++n)e=r.charCodeAt(n),e<128?t+=1:e<2048?t+=2:(e&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,t+=4):t+=3;return t}function ca(r,t,e){if(e-t<1)return"";let s,i=[],o=0,c;for(;t<e;)c=r[t++],c<128?i[o++]=c:c>191&&c<224?i[o++]=(c&31)<<6|r[t++]&63:c>239&&c<365?(c=((c&7)<<18|(r[t++]&63)<<12|(r[t++]&63)<<6|r[t++]&63)-65536,i[o++]=55296+(c>>10),i[o++]=56320+(c&1023)):i[o++]=(c&15)<<12|(r[t++]&63)<<6|r[t++]&63,o>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,i)),o=0);return s!=null?(o>0&&s.push(String.fromCharCode.apply(String,i.slice(0,o))),s.join("")):String.fromCharCode.apply(String,i.slice(0,o))}function oi(r,t,e){let n=e,s,i;for(let o=0;o<r.length;++o)s=r.charCodeAt(o),s<128?t[e++]=s:s<2048?(t[e++]=s>>6|192,t[e++]=s&63|128):(s&64512)===55296&&((i=r.charCodeAt(o+1))&64512)===56320?(s=65536+((s&1023)<<10)+(i&1023),++o,t[e++]=s>>18|240,t[e++]=s>>12&63|128,t[e++]=s>>6&63|128,t[e++]=s&63|128):(t[e++]=s>>12|224,t[e++]=s>>6&63|128,t[e++]=s&63|128);return e-n}function Rt(r,t){return RangeError(`index out of range: ${r.pos} + ${t??1} > ${r.len}`)}function an(r,t){return(r[t-4]|r[t-3]<<8|r[t-2]<<16|r[t-1]<<24)>>>0}var ai=class{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(t){this.buf=t,this.pos=0,this.len=t.length}uint32(){let t=4294967295;if(t=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(t=(t|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return t;if((this.pos+=5)>this.len)throw this.pos=this.len,Rt(this,10);return t}int32(){return this.uint32()|0}sint32(){let t=this.uint32();return t>>>1^-(t&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw Rt(this,4);return an(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw Rt(this,4);return an(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw Rt(this,4);let t=na(this.buf,this.pos);return this.pos+=4,t}double(){if(this.pos+8>this.len)throw Rt(this,4);let t=ia(this.buf,this.pos);return this.pos+=8,t}bytes(){let t=this.uint32(),e=this.pos,n=this.pos+t;if(n>this.len)throw Rt(this,t);return this.pos+=t,e===n?new Uint8Array(0):this.buf.subarray(e,n)}string(){let t=this.bytes();return ca(t,0,t.length)}skip(t){if(typeof t=="number"){if(this.pos+t>this.len)throw Rt(this,t);this.pos+=t}else do if(this.pos>=this.len)throw Rt(this);while(this.buf[this.pos++]&128);return this}skipType(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${t} at offset ${this.pos}`)}return this}readLongVarint(){let t=new At(0,0),e=0;if(this.len-this.pos>4){for(;e<4;++e)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw Rt(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,t}if(this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw Rt(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw Rt(this,8);let t=an(this.buf,this.pos+=4),e=an(this.buf,this.pos+=4);return new At(t,e)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){let t=ni(this.buf,this.pos);return this.pos+=Lt(t),t}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}};function ci(r){return new ai(r instanceof Uint8Array?r:r.subarray())}function cn(r,t,e){let n=ci(r);return t.decode(n,void 0,e)}var ui={};bt(ui,{base10:()=>of});var of=se({prefix:"9",name:"base10",alphabet:"0123456789"});var li={};bt(li,{base16:()=>af,base16upper:()=>cf});var af=J({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),cf=J({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var fi={};bt(fi,{base2:()=>uf});var uf=J({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var hi={};bt(hi,{base256emoji:()=>pf});var la=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),lf=la.reduce((r,t,e)=>(r[e]=t,r),[]),ff=la.reduce((r,t,e)=>{let n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);return r[n]=e,r},[]);function hf(r){return r.reduce((t,e)=>(t+=lf[e],t),"")}function df(r){let t=[];for(let e of r){let n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);let s=ff[n];if(s==null)throw new Error(`Non-base256emoji character: ${e}`);t.push(s)}return new Uint8Array(t)}var pf=Oe({prefix:"\u{1F680}",name:"base256emoji",encode:hf,decode:df});var di={};bt(di,{base64:()=>gf,base64pad:()=>mf,base64url:()=>bf,base64urlpad:()=>yf});var gf=J({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),mf=J({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),bf=J({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),yf=J({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var pi={};bt(pi,{base8:()=>wf});var wf=J({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var gi={};bt(gi,{identity:()=>xf});var xf=Oe({prefix:"\0",name:"identity",encode:r=>mo(r),decode:r=>go(r)});var r0=new TextEncoder,n0=new TextDecoder;var yi={};bt(yi,{sha256:()=>Ce,sha512:()=>Bf});function bi({name:r,code:t,encode:e}){return new mi(r,t,e)}var mi=class{name;code;encode;constructor(t,e,n){this.name=t,this.code=e,this.encode=n}digest(t){if(t instanceof Uint8Array){let e=this.encode(t);return e instanceof Uint8Array?Nt(this.code,e):e.then(n=>Nt(this.code,n))}else throw Error("Unknown type, must be binary type")}};function ha(r){return async t=>new Uint8Array(await crypto.subtle.digest(r,t))}var Ce=bi({name:"sha2-256",code:18,encode:ha("SHA-256")}),Bf=bi({name:"sha2-512",code:19,encode:ha("SHA-512")});var wi={...gi,...fi,...pi,...ui,...li,...Ns,...Cs,...Is,...di,...hi},g0={...yi,...Ls};function pa(r,t,e,n){return{name:r,prefix:t,encoder:{name:r,prefix:t,encode:e},decoder:{decode:n}}}var da=pa("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),xi=pa("ascii","a",r=>{let t="a";for(let e=0;e<r.length;e++)t+=String.fromCharCode(r[e]);return t},r=>{r=r.substring(1);let t=ft(r.length);for(let e=0;e<r.length;e++)t[e]=r.charCodeAt(e);return t}),Sf={utf8:da,"utf-8":da,hex:wi.base16,latin1:xi,ascii:xi,binary:xi,...wi},un=Sf;function Y(r,t="utf8"){let e=un[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.decoder.decode(`${e.prefix}${r}`)}function vi(r){let t=r??8192,e=t>>>1,n,s=t;return function(o){if(o<1||o>e)return ft(o);s+o>t&&(n=ft(t),s=0);let c=n.subarray(s,s+=o);return s&7&&(s=(s|7)+1),c}}var Te=class{fn;len;next;val;constructor(t,e,n){this.fn=t,this.len=e,this.next=void 0,this.val=n}};function Ei(){}var Si=class{head;tail;len;next;constructor(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}},Af=vi();function kf(r){return globalThis.Buffer!=null?ft(r):Af(r)}var mr=class{len;head;tail;states;constructor(){this.len=0,this.head=new Te(Ei,0,0),this.tail=this.head,this.states=null}_push(t,e,n){return this.tail=this.tail.next=new Te(t,e,n),this.len+=e,this}uint32(t){return this.len+=(this.tail=this.tail.next=new Ai((t=t>>>0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this}int32(t){return t<0?this._push(ln,10,At.fromNumber(t)):this.uint32(t)}sint32(t){return this.uint32((t<<1^t>>31)>>>0)}uint64(t){let e=At.fromBigInt(t);return this._push(ln,e.length(),e)}uint64Number(t){return this._push(ri,Lt(t),t)}uint64String(t){return this.uint64(BigInt(t))}int64(t){return this.uint64(t)}int64Number(t){return this.uint64Number(t)}int64String(t){return this.uint64String(t)}sint64(t){let e=At.fromBigInt(t).zzEncode();return this._push(ln,e.length(),e)}sint64Number(t){let e=At.fromNumber(t).zzEncode();return this._push(ln,e.length(),e)}sint64String(t){return this.sint64(BigInt(t))}bool(t){return this._push(Bi,1,t?1:0)}fixed32(t){return this._push(gr,4,t>>>0)}sfixed32(t){return this.fixed32(t)}fixed64(t){let e=At.fromBigInt(t);return this._push(gr,4,e.lo)._push(gr,4,e.hi)}fixed64Number(t){let e=At.fromNumber(t);return this._push(gr,4,e.lo)._push(gr,4,e.hi)}fixed64String(t){return this.fixed64(BigInt(t))}sfixed64(t){return this.fixed64(t)}sfixed64Number(t){return this.fixed64Number(t)}sfixed64String(t){return this.fixed64String(t)}float(t){return this._push(ra,4,t)}double(t){return this._push(sa,8,t)}bytes(t){let e=t.length>>>0;return e===0?this._push(Bi,1,0):this.uint32(e)._push(Nf,e,t)}string(t){let e=aa(t);return e!==0?this.uint32(e)._push(oi,e,t):this._push(Bi,1,0)}fork(){return this.states=new Si(this),this.head=this.tail=new Te(Ei,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Te(Ei,0,0),this.len=0),this}ldelim(){let t=this.head,e=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=t.next,this.tail=e,this.len+=n),this}finish(){let t=this.head.next,e=kf(this.len),n=0;for(;t!=null;)t.fn(t.val,e,n),n+=t.len,t=t.next;return e}};function Bi(r,t,e){t[e]=r&255}function If(r,t,e){for(;r>127;)t[e++]=r&127|128,r>>>=7;t[e]=r}var Ai=class extends Te{next;constructor(t,e){super(If,t,e),this.next=void 0}};function ln(r,t,e){for(;r.hi!==0;)t[e++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)t[e++]=r.lo&127|128,r.lo=r.lo>>>7;t[e++]=r.lo}function gr(r,t,e){t[e]=r&255,t[e+1]=r>>>8&255,t[e+2]=r>>>16&255,t[e+3]=r>>>24}function Nf(r,t,e){t.set(r,e)}globalThis.Buffer!=null&&(mr.prototype.bytes=function(r){let t=r.length>>>0;return this.uint32(t),t>0&&this._push(Cf,t,r),this},mr.prototype.string=function(r){let t=globalThis.Buffer.byteLength(r);return this.uint32(t),t>0&&this._push(Tf,t,r),this});function Cf(r,t,e){t.set(r,e)}function Tf(r,t,e){r.length<40?oi(r,t,e):t.utf8Write!=null?t.utf8Write(r,e):t.set(Y(r),e)}function ki(){return new mr}function fn(r,t){let e=ki();return t.encode(r,e,{lengthDelimited:!1}),e.finish()}var We;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(We||(We={}));function hn(r,t,e,n){return{name:r,type:t,encode:e,decode:n}}function Ii(r){function t(s){if(r[s.toString()]==null)throw new Error("Invalid enum value");return r[s]}let e=function(i,o){let c=t(i);o.int32(c)},n=function(i){let o=i.int32();return t(o)};return hn("enum",We.VARINT,e,n)}function dn(r,t){return hn("message",We.LENGTH_DELIMITED,r,t)}var nt;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1"})(nt||(nt={}));var Ni;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1"})(Ni||(Ni={}));(function(r){r.codec=()=>Ii(Ni)})(nt||(nt={}));var Mt;(function(r){let t;r.codec=()=>(t==null&&(t=dn((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),nt.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{let i={},o=n==null?e.len:e.pos+n;for(;e.pos<o;){let c=e.uint32();switch(c>>>3){case 1:{i.Type=nt.codec().decode(e);break}case 2:{i.Data=e.bytes();break}default:{e.skipType(c&7);break}}}return i})),t),r.encode=e=>fn(e,r.codec()),r.decode=(e,n)=>cn(e,r.codec(),n)})(Mt||(Mt={}));var Ci;(function(r){let t;r.codec=()=>(t==null&&(t=dn((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),nt.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{let i={},o=n==null?e.len:e.pos+n;for(;e.pos<o;){let c=e.uint32();switch(c>>>3){case 1:{i.Type=nt.codec().decode(e);break}case 2:{i.Data=e.bytes();break}default:{e.skipType(c&7);break}}}return i})),t),r.encode=e=>fn(e,r.codec()),r.decode=(e,n)=>cn(e,r.codec(),n)})(Ci||(Ci={}));var kr={};bt(kr,{MAX_RSA_KEY_SIZE:()=>is,generateRSAKeyPair:()=>fc,jwkToJWKKeyPair:()=>hc,jwkToPkcs1:()=>Gf,jwkToPkix:()=>Oi,jwkToRSAPrivateKey:()=>lc,pkcs1ToJwk:()=>ac,pkcs1ToRSAPrivateKey:()=>uc,pkixToJwk:()=>cc,pkixToRSAPublicKey:()=>Di});var Uf=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),pe=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ge=new Uint32Array(64),Ti=class extends je{constructor(){super(64,32,8,!1),this.A=pe[0]|0,this.B=pe[1]|0,this.C=pe[2]|0,this.D=pe[3]|0,this.E=pe[4]|0,this.F=pe[5]|0,this.G=pe[6]|0,this.H=pe[7]|0}get(){let{A:t,B:e,C:n,D:s,E:i,F:o,G:c,H:a}=this;return[t,e,n,s,i,o,c,a]}set(t,e,n,s,i,o,c,a){this.A=t|0,this.B=e|0,this.C=n|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=c|0,this.H=a|0}process(t,e){for(let u=0;u<16;u++,e+=4)ge[u]=t.getUint32(e,!1);for(let u=16;u<64;u++){let d=ge[u-15],m=ge[u-2],x=Ct(d,7)^Ct(d,18)^d>>>3,y=Ct(m,17)^Ct(m,19)^m>>>10;ge[u]=y+ge[u-7]+x+ge[u-16]|0}let{A:n,B:s,C:i,D:o,E:c,F:a,G:f,H:l}=this;for(let u=0;u<64;u++){let d=Ct(c,6)^Ct(c,11)^Ct(c,25),m=l+d+Ro(c,a,f)+Uf[u]+ge[u]|0,y=(Ct(n,2)^Ct(n,13)^Ct(n,22))+_o(n,s,i)|0;l=f,f=a,a=c,c=o+m|0,o=i,i=s,s=n,n=m+y|0}n=n+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,c=c+this.E|0,a=a+this.F|0,f=f+this.G|0,l=l+this.H|0,this.set(n,s,i,o,c,a,f,l)}roundClean(){ge.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var Ye=Zr(()=>new Ti);var D=fo(ma());function Ue(r,t){let e=0;if(r.length===1)return r[0];for(let n=r.length-1;n>=0;n--)e+=r[r.length-1-n]*Math.pow(2,t*n);return e}function me(r,t,e=-1){let n=e,s=r,i=0,o=Math.pow(2,t);for(let c=1;c<8;c++){if(r<o){let a;if(n<0)a=new ArrayBuffer(c),i=c;else{if(n<c)return new ArrayBuffer(0);a=new ArrayBuffer(n),i=n}let f=new Uint8Array(a);for(let l=c-1;l>=0;l--){let u=Math.pow(2,l*t);f[i-l-1]=Math.floor(s/u),s-=f[i-l-1]*u}return a}o*=Math.pow(2,t)}return new ArrayBuffer(0)}function mn(...r){let t=0,e=0;for(let i of r)t+=i.length;let n=new ArrayBuffer(t),s=new Uint8Array(n);for(let i of r)s.set(i,e),e+=i.length;return s}function Li(){let r=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){let c=r[0]===255&&r[1]&128,a=r[0]===0&&(r[1]&128)===0;(c||a)&&this.warnings.push("Needlessly long format")}let t=new ArrayBuffer(this.valueHex.byteLength),e=new Uint8Array(t);for(let c=0;c<this.valueHex.byteLength;c++)e[c]=0;e[0]=r[0]&128;let n=Ue(e,8),s=new ArrayBuffer(this.valueHex.byteLength),i=new Uint8Array(s);for(let c=0;c<this.valueHex.byteLength;c++)i[c]=r[c];return i[0]&=127,Ue(i,8)-n}function ba(r){let t=r<0?r*-1:r,e=128;for(let n=1;n<8;n++){if(t<=e){if(r<0){let o=e-t,c=me(o,8,n),a=new Uint8Array(c);return a[0]|=128,c}let s=me(t,8,n),i=new Uint8Array(s);if(i[0]&128){let o=s.slice(0),c=new Uint8Array(o);s=new ArrayBuffer(s.byteLength+1),i=new Uint8Array(s);for(let a=0;a<o.byteLength;a++)i[a+1]=c[a];i[0]=0}return s}e*=Math.pow(2,8)}return new ArrayBuffer(0)}function ya(r,t){if(r.byteLength!==t.byteLength)return!1;let e=new Uint8Array(r),n=new Uint8Array(t);for(let s=0;s<e.length;s++)if(e[s]!==n[s])return!1;return!0}function Bt(r,t){let e=r.toString(10);if(t<e.length)return"";let n=t-e.length,s=new Array(n);for(let o=0;o<n;o++)s[o]="0";return s.join("").concat(e)}var Y0=Math.log(2);function bn(){if(typeof BigInt>"u")throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function Ri(r){let t=0,e=0;for(let s=0;s<r.length;s++){let i=r[s];t+=i.byteLength}let n=new Uint8Array(t);for(let s=0;s<r.length;s++){let i=r[s];n.set(new Uint8Array(i),e),e+=i.byteLength}return n.buffer}function Qt(r,t,e,n){return t instanceof Uint8Array?t.byteLength?e<0?(r.error="Wrong parameter: inputOffset less than zero",!1):n<0?(r.error="Wrong parameter: inputLength less than zero",!1):t.byteLength-e-n<0?(r.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):!0:(r.error="Wrong parameter: inputBuffer has zero length",!1):(r.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}var yr=class{constructor(){this.items=[]}write(t){this.items.push(t)}final(){return Ri(this.items)}},br=[new Uint8Array([1])],wa="0123456789";var er="",_t=new ArrayBuffer(0),_i=new Uint8Array(0),wr="EndOfContent",va="OCTET STRING",Ea="BIT STRING";function te(r){var t;return t=class extends r{constructor(...n){var s;super(...n);let i=n[0]||{};this.isHexOnly=(s=i.isHexOnly)!==null&&s!==void 0?s:!1,this.valueHexView=i.valueHex?D.BufferSourceConverter.toUint8Array(i.valueHex):_i}get valueHex(){return this.valueHexView.slice().buffer}set valueHex(n){this.valueHexView=new Uint8Array(n)}fromBER(n,s,i){let o=n instanceof ArrayBuffer?new Uint8Array(n):n;if(!Qt(this,o,s,i))return-1;let c=s+i;return this.valueHexView=o.subarray(s,c),this.valueHexView.length?(this.blockLength=i,c):(this.warnings.push("Zero buffer length"),s)}toBER(n=!1){return this.isHexOnly?n?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",_t)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:D.Convert.ToHex(this.valueHexView)}}},t.NAME="hexBlock",t}var Yt=class{constructor({blockLength:t=0,error:e=er,warnings:n=[],valueBeforeDecode:s=_i}={}){this.blockLength=t,this.error=e,this.warnings=n,this.valueBeforeDecodeView=D.BufferSourceConverter.toUint8Array(s)}static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(t){this.valueBeforeDecodeView=new Uint8Array(t)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:D.Convert.ToHex(this.valueBeforeDecodeView)}}};Yt.NAME="baseBlock";var pt=class extends Yt{fromBER(t,e,n){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(t,e){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}};pt.NAME="valueBlock";var yn=class extends te(Yt){constructor({idBlock:t={}}={}){var e,n,s,i;super(),t?(this.isHexOnly=(e=t.isHexOnly)!==null&&e!==void 0?e:!1,this.valueHexView=t.valueHex?D.BufferSourceConverter.toUint8Array(t.valueHex):_i,this.tagClass=(n=t.tagClass)!==null&&n!==void 0?n:-1,this.tagNumber=(s=t.tagNumber)!==null&&s!==void 0?s:-1,this.isConstructed=(i=t.isConstructed)!==null&&i!==void 0?i:!1):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(t=!1){let e=0;switch(this.tagClass){case 1:e|=0;break;case 2:e|=64;break;case 3:e|=128;break;case 4:e|=192;break;default:return this.error="Unknown tag class",_t}if(this.isConstructed&&(e|=32),this.tagNumber<31&&!this.isHexOnly){let s=new Uint8Array(1);if(!t){let i=this.tagNumber;i&=31,e|=i,s[0]=e}return s.buffer}if(!this.isHexOnly){let s=me(this.tagNumber,7),i=new Uint8Array(s),o=s.byteLength,c=new Uint8Array(o+1);if(c[0]=e|31,!t){for(let a=0;a<o-1;a++)c[a+1]=i[a]|128;c[o]=i[o-1]}return c.buffer}let n=new Uint8Array(this.valueHexView.byteLength+1);if(n[0]=e|31,!t){let s=this.valueHexView;for(let i=0;i<s.length-1;i++)n[i+1]=s[i]|128;n[this.valueHexView.byteLength]=s[s.length-1]}return n.buffer}fromBER(t,e,n){let s=D.BufferSourceConverter.toUint8Array(t);if(!Qt(this,s,e,n))return-1;let i=s.subarray(e,e+n);if(i.length===0)return this.error="Zero buffer length",-1;switch(i[0]&192){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=(i[0]&32)===32,this.isHexOnly=!1;let c=i[0]&31;if(c!==31)this.tagNumber=c,this.blockLength=1;else{let a=1,f=this.valueHexView=new Uint8Array(255),l=255;for(;i[a]&128;){if(f[a-1]=i[a]&127,a++,a>=i.length)return this.error="End of input reached before message was fully decoded",-1;if(a===l){l+=255;let d=new Uint8Array(l);for(let m=0;m<f.length;m++)d[m]=f[m];f=this.valueHexView=new Uint8Array(l)}}this.blockLength=a+1,f[a-1]=i[a]&127;let u=new Uint8Array(a);for(let d=0;d<a;d++)u[d]=f[d];f=this.valueHexView=new Uint8Array(a),f.set(u),this.blockLength<=9?this.tagNumber=Ue(f,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(this.tagClass===1&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return e+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}};yn.NAME="identificationBlock";var wn=class extends Yt{constructor({lenBlock:t={}}={}){var e,n,s;super(),this.isIndefiniteForm=(e=t.isIndefiniteForm)!==null&&e!==void 0?e:!1,this.longFormUsed=(n=t.longFormUsed)!==null&&n!==void 0?n:!1,this.length=(s=t.length)!==null&&s!==void 0?s:0}fromBER(t,e,n){let s=D.BufferSourceConverter.toUint8Array(t);if(!Qt(this,s,e,n))return-1;let i=s.subarray(e,e+n);if(i.length===0)return this.error="Zero buffer length",-1;if(i[0]===255)return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=i[0]===128,this.isIndefiniteForm)return this.blockLength=1,e+this.blockLength;if(this.longFormUsed=!!(i[0]&128),this.longFormUsed===!1)return this.length=i[0],this.blockLength=1,e+this.blockLength;let o=i[0]&127;if(o>8)return this.error="Too big integer",-1;if(o+1>i.length)return this.error="End of input reached before message was fully decoded",-1;let c=e+1,a=s.subarray(c,c+o);return a[o-1]===0&&this.warnings.push("Needlessly long encoded length"),this.length=Ue(a,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=o+1,e+this.blockLength}toBER(t=!1){let e,n;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return e=new ArrayBuffer(1),t===!1&&(n=new Uint8Array(e),n[0]=128),e;if(this.longFormUsed){let s=me(this.length,8);if(s.byteLength>127)return this.error="Too big length",_t;if(e=new ArrayBuffer(s.byteLength+1),t)return e;let i=new Uint8Array(s);n=new Uint8Array(e),n[0]=s.byteLength|128;for(let o=0;o<s.byteLength;o++)n[o+1]=i[o];return e}return e=new ArrayBuffer(1),t===!1&&(n=new Uint8Array(e),n[0]=this.length),e}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}};wn.NAME="lengthBlock";var S={},ct=class extends Yt{constructor({name:t=er,optional:e=!1,primitiveSchema:n,...s}={},i){super(s),this.name=t,this.optional=e,n&&(this.primitiveSchema=n),this.idBlock=new yn(s),this.lenBlock=new wn(s),this.valueBlock=i?new i(s):new pt(s)}fromBER(t,e,n){let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}toBER(t,e){let n=e||new yr;e||Ba(this);let s=this.idBlock.toBER(t);if(n.write(s),this.lenBlock.isIndefiniteForm)n.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(t,n),n.write(new ArrayBuffer(2));else{let i=this.valueBlock.toBER(t);this.lenBlock.length=i.byteLength;let o=this.lenBlock.toBER(t);n.write(o),n.write(i)}return e?_t:n.final()}toJSON(){let t={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(t.primitiveSchema=this.primitiveSchema.toJSON()),t}toString(t="ascii"){return t==="ascii"?this.onAsciiEncoding():D.Convert.ToHex(this.toBER())}onAsciiEncoding(){return`${this.constructor.NAME} : ${D.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`}isEqual(t){if(this===t)return!0;if(!(t instanceof this.constructor))return!1;let e=this.toBER(),n=t.toBER();return ya(e,n)}};ct.NAME="BaseBlock";function Ba(r){if(r instanceof S.Constructed)for(let t of r.valueBlock.value)Ba(t)&&(r.lenBlock.isIndefiniteForm=!0);return!!r.lenBlock.isIndefiniteForm}var xn=class extends ct{constructor({value:t=er,...e}={},n){super(e,n),t&&this.fromString(t)}getValue(){return this.valueBlock.value}setValue(t){this.valueBlock.value=t}fromBER(t,e,n){let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}};xn.NAME="BaseStringBlock";var vn=class extends te(pt){constructor({isHexOnly:t=!0,...e}={}){super(e),this.isHexOnly=t}};vn.NAME="PrimitiveValueBlock";var Sa,En=class extends ct{constructor(t={}){super(t,vn),this.idBlock.isConstructed=!1}};Sa=En;S.Primitive=Sa;En.NAME="PRIMITIVE";function Pf(r,t){if(r instanceof t)return r;let e=new t;return e.idBlock=r.idBlock,e.lenBlock=r.lenBlock,e.warnings=r.warnings,e.valueBeforeDecodeView=r.valueBeforeDecodeView,e}function rs(r,t=0,e=r.length){let n=t,s=new ct({},pt),i=new Yt;if(!Qt(i,r,t,e))return s.error=i.error,{offset:-1,result:s};if(!r.subarray(t,t+e).length)return s.error="Zero buffer length",{offset:-1,result:s};let c=s.idBlock.fromBER(r,t,e);if(s.idBlock.warnings.length&&s.warnings.concat(s.idBlock.warnings),c===-1)return s.error=s.idBlock.error,{offset:-1,result:s};if(t=c,e-=s.idBlock.blockLength,c=s.lenBlock.fromBER(r,t,e),s.lenBlock.warnings.length&&s.warnings.concat(s.lenBlock.warnings),c===-1)return s.error=s.lenBlock.error,{offset:-1,result:s};if(t=c,e-=s.lenBlock.blockLength,!s.idBlock.isConstructed&&s.lenBlock.isIndefiniteForm)return s.error="Indefinite length form used for primitive encoding form",{offset:-1,result:s};let a=ct;switch(s.idBlock.tagClass){case 1:if(s.idBlock.tagNumber>=37&&s.idBlock.isHexOnly===!1)return s.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:s};switch(s.idBlock.tagNumber){case 0:if(s.idBlock.isConstructed&&s.lenBlock.length>0)return s.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:s};a=S.EndOfContent;break;case 1:a=S.Boolean;break;case 2:a=S.Integer;break;case 3:a=S.BitString;break;case 4:a=S.OctetString;break;case 5:a=S.Null;break;case 6:a=S.ObjectIdentifier;break;case 10:a=S.Enumerated;break;case 12:a=S.Utf8String;break;case 13:a=S.RelativeObjectIdentifier;break;case 14:a=S.TIME;break;case 15:return s.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:s};case 16:a=S.Sequence;break;case 17:a=S.Set;break;case 18:a=S.NumericString;break;case 19:a=S.PrintableString;break;case 20:a=S.TeletexString;break;case 21:a=S.VideotexString;break;case 22:a=S.IA5String;break;case 23:a=S.UTCTime;break;case 24:a=S.GeneralizedTime;break;case 25:a=S.GraphicString;break;case 26:a=S.VisibleString;break;case 27:a=S.GeneralString;break;case 28:a=S.UniversalString;break;case 29:a=S.CharacterString;break;case 30:a=S.BmpString;break;case 31:a=S.DATE;break;case 32:a=S.TimeOfDay;break;case 33:a=S.DateTime;break;case 34:a=S.Duration;break;default:{let f=s.idBlock.isConstructed?new S.Constructed:new S.Primitive;f.idBlock=s.idBlock,f.lenBlock=s.lenBlock,f.warnings=s.warnings,s=f}}break;case 2:case 3:case 4:default:a=s.idBlock.isConstructed?S.Constructed:S.Primitive}return s=Pf(s,a),c=s.fromBER(r,t,s.lenBlock.isIndefiniteForm?e:s.lenBlock.length),s.valueBeforeDecodeView=r.subarray(n,n+s.blockLength),{offset:c,result:s}}function Vi(r){if(!r.byteLength){let t=new ct({},pt);return t.error="Input buffer has zero length",{offset:-1,result:t}}return rs(D.BufferSourceConverter.toUint8Array(r).slice(),0,r.byteLength)}function Ff(r,t){return r?1:t}var Ot=class extends pt{constructor({value:t=[],isIndefiniteForm:e=!1,...n}={}){super(n),this.value=t,this.isIndefiniteForm=e}fromBER(t,e,n){let s=D.BufferSourceConverter.toUint8Array(t);if(!Qt(this,s,e,n))return-1;if(this.valueBeforeDecodeView=s.subarray(e,e+n),this.valueBeforeDecodeView.length===0)return this.warnings.push("Zero buffer length"),e;let i=e;for(;Ff(this.isIndefiniteForm,n)>0;){let o=rs(s,i,n);if(o.offset===-1)return this.error=o.result.error,this.warnings.concat(o.result.warnings),-1;if(i=o.offset,this.blockLength+=o.result.blockLength,n-=o.result.blockLength,this.value.push(o.result),this.isIndefiniteForm&&o.result.constructor.NAME===wr)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===wr?this.value.pop():this.warnings.push("No EndOfContent block encoded")),i}toBER(t,e){let n=e||new yr;for(let s=0;s<this.value.length;s++)this.value[s].toBER(t,n);return e?_t:n.final()}toJSON(){let t={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(let e of this.value)t.value.push(e.toJSON());return t}};Ot.NAME="ConstructedValueBlock";var Aa,be=class extends ct{constructor(t={}){super(t,Ot),this.idBlock.isConstructed=!0}fromBER(t,e,n){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){let t=[];for(let n of this.valueBlock.value)t.push(n.toString("ascii").split(`
./node_modules/@libp2p/autonat/dist/index.min.js:2:"use strict";var Libp2PAutonat=(()=>{var wa=Object.create;var ir=Object.defineProperty;var ba=Object.getOwnPropertyDescriptor;var ya=Object.getOwnPropertyNames;var Ea=Object.getPrototypeOf,va=Object.prototype.hasOwnProperty;var dn=(r,t)=>()=>(t||r((t={exports:{}}).exports,t),t.exports),dt=(r,t)=>{for(var e in t)ir(r,e,{get:t[e],enumerable:!0})},us=(r,t,e,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of ya(t))!va.call(r,o)&&o!==e&&ir(r,o,{get:()=>t[o],enumerable:!(n=ba(t,o))||n.enumerable});return r};var fs=(r,t,e)=>(e=r!=null?wa(Ea(r)):{},us(t||!r||!r.__esModule?ir(e,"default",{value:r,enumerable:!0}):e,r)),Sa=r=>us(ir({},"__esModule",{value:!0}),r);var Bi=dn((tr,zr)=>{(function(r,t){"use strict";var e={version:"3.0.0",x86:{},x64:{},inputValidation:!0};function n(u){if(!Array.isArray(u)&&!ArrayBuffer.isView(u))return!1;for(var p=0;p<u.length;p++)if(!Number.isInteger(u[p])||u[p]<0||u[p]>255)return!1;return!0}function o(u,p){return(u&65535)*p+(((u>>>16)*p&65535)<<16)}function s(u,p){return u<<p|u>>>32-p}function i(u){return u^=u>>>16,u=o(u,2246822507),u^=u>>>13,u=o(u,3266489909),u^=u>>>16,u}function a(u,p){u=[u[0]>>>16,u[0]&65535,u[1]>>>16,u[1]&65535],p=[p[0]>>>16,p[0]&65535,p[1]>>>16,p[1]&65535];var g=[0,0,0,0];return g[3]+=u[3]+p[3],g[2]+=g[3]>>>16,g[3]&=65535,g[2]+=u[2]+p[2],g[1]+=g[2]>>>16,g[2]&=65535,g[1]+=u[1]+p[1],g[0]+=g[1]>>>16,g[1]&=65535,g[0]+=u[0]+p[0],g[0]&=65535,[g[0]<<16|g[1],g[2]<<16|g[3]]}function c(u,p){u=[u[0]>>>16,u[0]&65535,u[1]>>>16,u[1]&65535],p=[p[0]>>>16,p[0]&65535,p[1]>>>16,p[1]&65535];var g=[0,0,0,0];return g[3]+=u[3]*p[3],g[2]+=g[3]>>>16,g[3]&=65535,g[2]+=u[2]*p[3],g[1]+=g[2]>>>16,g[2]&=65535,g[2]+=u[3]*p[2],g[1]+=g[2]>>>16,g[2]&=65535,g[1]+=u[1]*p[3],g[0]+=g[1]>>>16,g[1]&=65535,g[1]+=u[2]*p[2],g[0]+=g[1]>>>16,g[1]&=65535,g[1]+=u[3]*p[1],g[0]+=g[1]>>>16,g[1]&=65535,g[0]+=u[0]*p[3]+u[1]*p[2]+u[2]*p[1]+u[3]*p[0],g[0]&=65535,[g[0]<<16|g[1],g[2]<<16|g[3]]}function l(u,p){return p%=64,p===32?[u[1],u[0]]:p<32?[u[0]<<p|u[1]>>>32-p,u[1]<<p|u[0]>>>32-p]:(p-=32,[u[1]<<p|u[0]>>>32-p,u[0]<<p|u[1]>>>32-p])}function h(u,p){return p%=64,p===0?u:p<32?[u[0]<<p|u[1]>>>32-p,u[1]<<p]:[u[1]<<p-32,0]}function f(u,p){return[u[0]^p[0],u[1]^p[1]]}function d(u){return u=f(u,[0,u[0]>>>1]),u=c(u,[4283543511,3981806797]),u=f(u,[0,u[0]>>>1]),u=c(u,[3301882366,444984403]),u=f(u,[0,u[0]>>>1]),u}e.x86.hash32=function(u,p){if(e.inputValidation&&!n(u))return t;p=p||0;for(var g=u.length%4,x=u.length-g,w=p,b=0,m=3432918353,v=461845907,_=0;_<x;_=_+4)b=u[_]|u[_+1]<<8|u[_+2]<<16|u[_+3]<<24,b=o(b,m),b=s(b,15),b=o(b,v),w^=b,w=s(w,13),w=o(w,5)+3864292196;switch(b=0,g){case 3:b^=u[_+2]<<16;case 2:b^=u[_+1]<<8;case 1:b^=u[_],b=o(b,m),b=s(b,15),b=o(b,v),w^=b}return w^=u.length,w=i(w),w>>>0},e.x86.hash128=function(u,p){if(e.inputValidation&&!n(u))return t;p=p||0;for(var g=u.length%16,x=u.length-g,w=p,b=p,m=p,v=p,_=0,I=0,y=0,B=0,T=597399067,V=2869860233,F=951274213,O=2716044179,N=0;N<x;N=N+16)_=u[N]|u[N+1]<<8|u[N+2]<<16|u[N+3]<<24,I=u[N+4]|u[N+5]<<8|u[N+6]<<16|u[N+7]<<24,y=u[N+8]|u[N+9]<<8|u[N+10]<<16|u[N+11]<<24,B=u[N+12]|u[N+13]<<8|u[N+14]<<16|u[N+15]<<24,_=o(_,T),_=s(_,15),_=o(_,V),w^=_,w=s(w,19),w+=b,w=o(w,5)+1444728091,I=o(I,V),I=s(I,16),I=o(I,F),b^=I,b=s(b,17),b+=m,b=o(b,5)+197830471,y=o(y,F),y=s(y,17),y=o(y,O),m^=y,m=s(m,15),m+=v,m=o(m,5)+2530024501,B=o(B,O),B=s(B,18),B=o(B,T),v^=B,v=s(v,13),v+=w,v=o(v,5)+850148119;switch(_=0,I=0,y=0,B=0,g){case 15:B^=u[N+14]<<16;case 14:B^=u[N+13]<<8;case 13:B^=u[N+12],B=o(B,O),B=s(B,18),B=o(B,T),v^=B;case 12:y^=u[N+11]<<24;case 11:y^=u[N+10]<<16;case 10:y^=u[N+9]<<8;case 9:y^=u[N+8],y=o(y,F),y=s(y,17),y=o(y,O),m^=y;case 8:I^=u[N+7]<<24;case 7:I^=u[N+6]<<16;case 6:I^=u[N+5]<<8;case 5:I^=u[N+4],I=o(I,V),I=s(I,16),I=o(I,F),b^=I;case 4:_^=u[N+3]<<24;case 3:_^=u[N+2]<<16;case 2:_^=u[N+1]<<8;case 1:_^=u[N],_=o(_,T),_=s(_,15),_=o(_,V),w^=_}return w^=u.length,b^=u.length,m^=u.length,v^=u.length,w+=b,w+=m,w+=v,b+=w,m+=w,v+=w,w=i(w),b=i(b),m=i(m),v=i(v),w+=b,w+=m,w+=v,b+=w,m+=w,v+=w,("00000000"+(w>>>0).toString(16)).slice(-8)+("00000000"+(b>>>0).toString(16)).slice(-8)+("00000000"+(m>>>0).toString(16)).slice(-8)+("00000000"+(v>>>0).toString(16)).slice(-8)},e.x64.hash128=function(u,p){if(e.inputValidation&&!n(u))return t;p=p||0;for(var g=u.length%16,x=u.length-g,w=[0,p],b=[0,p],m=[0,0],v=[0,0],_=[2277735313,289559509],I=[1291169091,658871167],y=0;y<x;y=y+16)m=[u[y+4]|u[y+5]<<8|u[y+6]<<16|u[y+7]<<24,u[y]|u[y+1]<<8|u[y+2]<<16|u[y+3]<<24],v=[u[y+12]|u[y+13]<<8|u[y+14]<<16|u[y+15]<<24,u[y+8]|u[y+9]<<8|u[y+10]<<16|u[y+11]<<24],m=c(m,_),m=l(m,31),m=c(m,I),w=f(w,m),w=l(w,27),w=a(w,b),w=a(c(w,[0,5]),[0,1390208809]),v=c(v,I),v=l(v,33),v=c(v,_),b=f(b,v),b=l(b,31),b=a(b,w),b=a(c(b,[0,5]),[0,944331445]);switch(m=[0,0],v=[0,0],g){case 15:v=f(v,h([0,u[y+14]],48));case 14:v=f(v,h([0,u[y+13]],40));case 13:v=f(v,h([0,u[y+12]],32));case 12:v=f(v,h([0,u[y+11]],24));case 11:v=f(v,h([0,u[y+10]],16));case 10:v=f(v,h([0,u[y+9]],8));case 9:v=f(v,[0,u[y+8]]),v=c(v,I),v=l(v,33),v=c(v,_),b=f(b,v);case 8:m=f(m,h([0,u[y+7]],56));case 7:m=f(m,h([0,u[y+6]],48));case 6:m=f(m,h([0,u[y+5]],40));case 5:m=f(m,h([0,u[y+4]],32));case 4:m=f(m,h([0,u[y+3]],24));case 3:m=f(m,h([0,u[y+2]],16));case 2:m=f(m,h([0,u[y+1]],8));case 1:m=f(m,[0,u[y]]),m=c(m,_),m=l(m,31),m=c(m,I),w=f(w,m)}return w=f(w,[0,u.length]),b=f(b,[0,u.length]),w=a(w,b),b=a(b,w),w=d(w),b=d(b),w=a(w,b),b=a(b,w),("00000000"+(w[0]>>>0).toString(16)).slice(-8)+("00000000"+(w[1]>>>0).toString(16)).slice(-8)+("00000000"+(b[0]>>>0).toString(16)).slice(-8)+("00000000"+(b[1]>>>0).toString(16)).slice(-8)},typeof tr<"u"?(typeof zr<"u"&&zr.exports&&(tr=zr.exports=e),tr.murmurHash3=e):typeof define=="function"&&define.amd?define([],function(){return e}):(e._murmurHash3=r.murmurHash3,e.noConflict=function(){return r.murmurHash3=e._murmurHash3,e._murmurHash3=t,e.noConflict=t,e},r.murmurHash3=e)})(tr)});var Ti=dn((Tp,Li)=>{Li.exports=Bi()});var Hi=dn(or=>{(function(){var r,t,e,n,o,s,i,a;a=function(c){var l,h,f,d;return l=(c&255<<24)>>>24,h=(c&255<<16)>>>16,f=(c&65280)>>>8,d=c&255,[l,h,f,d].join(".")},i=function(c){var l,h,f,d,u,p;for(l=[],f=d=0;d<=3&&c.length!==0;f=++d){if(f>0){if(c[0]!==".")throw new Error("Invalid IP");c=c.substring(1)}p=t(c),u=p[0],h=p[1],c=c.substring(h),l.push(u)}if(c.length!==0)throw new Error("Invalid IP");switch(l.length){case 1:if(l[0]>4294967295)throw new Error("Invalid IP");return l[0]>>>0;case 2:if(l[0]>255||l[1]>16777215)throw new Error("Invalid IP");return(l[0]<<24|l[1])>>>0;case 3:if(l[0]>255||l[1]>255||l[2]>65535)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2])>>>0;case 4:if(l[0]>255||l[1]>255||l[2]>255||l[3]>255)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2]<<8|l[3])>>>0;default:throw new Error("Invalid IP")}},e=function(c){return c.charCodeAt(0)},n=e("0"),s=e("a"),o=e("A"),t=function(c){var l,h,f,d,u;for(d=0,l=10,h="9",f=0,c.length>1&&c[f]==="0"&&(c[f+1]==="x"||c[f+1]==="X"?(f+=2,l=16):"0"<=c[f+1]&&c[f+1]<="9"&&(f++,l=8,h="7")),u=f;f<c.length;){if("0"<=c[f]&&c[f]<=h)d=d*l+(e(c[f])-n)>>>0;else if(l===16)if("a"<=c[f]&&c[f]<="f")d=d*l+(10+e(c[f])-s)>>>0;else if("A"<=c[f]&&c[f]<="F")d=d*l+(10+e(c[f])-o)>>>0;else break;else break;if(d>4294967295)throw new Error("too large");f++}if(f===u)throw new Error("empty octet");return[d,f]},r=function(){function c(l,h){var f,d,u,p;if(typeof l!="string")throw new Error("Missing `net' parameter");if(h||(p=l.split("/",2),l=p[0],h=p[1]),h||(h=32),typeof h=="string"&&h.indexOf(".")>-1){try{this.maskLong=i(h)}catch(g){throw f=g,new Error("Invalid mask: "+h)}for(d=u=32;u>=0;d=--u)if(this.maskLong===4294967295<<32-d>>>0){this.bitmask=d;break}}else if(h||h===0)this.bitmask=parseInt(h,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(i(l)&this.maskLong)>>>0}catch(g){throw f=g,new Error("Invalid net address: "+l)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+h);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return c.prototype.contains=function(l){return typeof l=="string"&&(l.indexOf("/")>0||l.split(".").length!==4)&&(l=new c(l)),l instanceof c?this.contains(l.base)&&this.contains(l.broadcast||l.last):(i(l)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},c.prototype.next=function(l){return l==null&&(l=1),new c(a(this.netLong+this.size*l),this.mask)},c.prototype.forEach=function(l){var h,f,d;for(d=i(this.first),f=i(this.last),h=0;d<=f;)l(a(d),d,h),h++,d++},c.prototype.toString=function(){return this.base+"/"+this.bitmask},c}(),or.ip2long=i,or.long2ip=a,or.Netmask=r}).call(or)});var rl={};dt(rl,{autoNAT:()=>el});var pn=Symbol.for("@libp2p/peer-id");var Nt=class extends Error{static name="AbortError";constructor(t="The operation was aborted"){super(t),this.name="AbortError"}};var Oe=class extends Error{static name="InvalidParametersError";constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}},ar=class extends Error{static name="InvalidPublicKeyError";constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}};var cr=class extends Error{static name="InvalidMultihashError";constructor(t="Invalid Multihash"){super(t),this.name="InvalidMultihashError"}};var Fe=class extends Error{static name="UnsupportedKeyTypeError";constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}};var Tt=(r,...t)=>{try{[...t]}catch{}};var ur=class extends EventTarget{#t=new Map;constructor(){super(),Tt(1/0,this)}listenerCount(t){let e=this.#t.get(t);return e==null?0:e.length}addEventListener(t,e,n){super.addEventListener(t,e,n);let o=this.#t.get(t);o==null&&(o=[],this.#t.set(t,o)),o.push({callback:e,once:(n!==!0&&n!==!1&&n?.once)??!1})}removeEventListener(t,e,n){super.removeEventListener(t.toString(),e??null,n);let o=this.#t.get(t);o!=null&&(o=o.filter(({callback:s})=>s!==e),this.#t.set(t,o))}dispatchEvent(t){let e=super.dispatchEvent(t),n=this.#t.get(t.type);return n==null||(n=n.filter(({once:o})=>!o),this.#t.set(t.type,n)),e}safeDispatchEvent(t,e={}){return this.dispatchEvent(new CustomEvent(t,e))}};var ls=Symbol.for("@libp2p/service-capabilities"),hs=Symbol.for("@libp2p/service-dependencies");var bn={};dt(bn,{base58btc:()=>W,base58flickr:()=>Ta});var Nl=new Uint8Array(0);function ds(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function Pt(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function ps(r){return new TextEncoder().encode(r)}function ms(r){return new TextDecoder().decode(r)}function _a(r,t){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),n=0;n<e.length;n++)e[n]=255;for(var o=0;o<r.length;o++){var s=r.charAt(o),i=s.charCodeAt(0);if(e[i]!==255)throw new TypeError(s+" is ambiguous");e[i]=o}var a=r.length,c=r.charAt(0),l=Math.log(a)/Math.log(256),h=Math.log(256)/Math.log(a);function f(p){if(p instanceof Uint8Array||(ArrayBuffer.isView(p)?p=new Uint8Array(p.buffer,p.byteOffset,p.byteLength):Array.isArray(p)&&(p=Uint8Array.from(p))),!(p instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(p.length===0)return"";for(var g=0,x=0,w=0,b=p.length;w!==b&&p[w]===0;)w++,g++;for(var m=(b-w)*h+1>>>0,v=new Uint8Array(m);w!==b;){for(var _=p[w],I=0,y=m-1;(_!==0||I<x)&&y!==-1;y--,I++)_+=256*v[y]>>>0,v[y]=_%a>>>0,_=_/a>>>0;if(_!==0)throw new Error("Non-zero carry");x=I,w++}for(var B=m-x;B!==m&&v[B]===0;)B++;for(var T=c.repeat(g);B<m;++B)T+=r.charAt(v[B]);return T}function d(p){if(typeof p!="string")throw new TypeError("Expected String");if(p.length===0)return new Uint8Array;var g=0;if(p[g]!==" "){for(var x=0,w=0;p[g]===c;)x++,g++;for(var b=(p.length-g)*l+1>>>0,m=new Uint8Array(b);p[g];){var v=e[p.charCodeAt(g)];if(v===255)return;for(var _=0,I=b-1;(v!==0||_<w)&&I!==-1;I--,_++)v+=a*m[I]>>>0,m[I]=v%256>>>0,v=v/256>>>0;if(v!==0)throw new Error("Non-zero carry");w=_,g++}if(p[g]!==" "){for(var y=b-w;y!==b&&m[y]===0;)y++;for(var B=new Uint8Array(x+(b-y)),T=x;y!==b;)B[T++]=m[y++];return B}}}function u(p){var g=d(p);if(g)return g;throw new Error(`Non-${t} character`)}return{encode:f,decodeUnsafe:d,decode:u}}var Aa=_a,Ia=Aa,xs=Ia;var mn=class{name;prefix;baseEncode;constructor(t,e,n){this.name=t,this.prefix=e,this.baseEncode=n}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}},gn=class{name;prefix;baseDecode;prefixCodePoint;constructor(t,e,n){this.name=t,this.prefix=e;let o=e.codePointAt(0);if(o===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=o,this.baseDecode=n}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return ws(this,t)}},xn=class{decoders;constructor(t){this.decoders=t}or(t){return ws(this,t)}decode(t){let e=t[0],n=this.decoders[e];if(n!=null)return n.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};function ws(r,t){return new xn({...r.decoders??{[r.prefix]:r},...t.decoders??{[t.prefix]:t}})}var wn=class{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(t,e,n,o){this.name=t,this.prefix=e,this.baseEncode=n,this.baseDecode=o,this.encoder=new mn(t,e,n),this.decoder=new gn(t,e,o)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}};function Ee({name:r,prefix:t,encode:e,decode:n}){return new wn(r,t,e,n)}function Xt({name:r,prefix:t,alphabet:e}){let{encode:n,decode:o}=xs(e,r);return Ee({prefix:t,name:r,encode:n,decode:s=>Pt(o(s))})}function Ba(r,t,e,n){let o={};for(let h=0;h<t.length;++h)o[t[h]]=h;let s=r.length;for(;r[s-1]==="=";)--s;let i=new Uint8Array(s*e/8|0),a=0,c=0,l=0;for(let h=0;h<s;++h){let f=o[r[h]];if(f===void 0)throw new SyntaxError(`Non-${n} character`);c=c<<e|f,a+=e,a>=8&&(a-=8,i[l++]=255&c>>a)}if(a>=e||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return i}function La(r,t,e){let n=t[t.length-1]==="=",o=(1<<e)-1,s="",i=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],i+=8;i>e;)i-=e,s+=t[o&a>>i];if(i!==0&&(s+=t[o&a<<e-i]),n)for(;s.length*e&7;)s+="=";return s}function Q({name:r,prefix:t,bitsPerChar:e,alphabet:n}){return Ee({prefix:t,name:r,encode(o){return La(o,n,e)},decode(o){return Ba(o,n,e,r)}})}var W=Xt({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Ta=Xt({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var yn={};dt(yn,{base32:()=>kt,base32hex:()=>Pa,base32hexpad:()=>Ua,base32hexpadupper:()=>Ca,base32hexupper:()=>ka,base32pad:()=>Da,base32padupper:()=>Na,base32upper:()=>Ra,base32z:()=>Oa});var kt=Q({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Ra=Q({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Da=Q({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Na=Q({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Pa=Q({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),ka=Q({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Ua=Q({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Ca=Q({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Oa=Q({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var En={};dt(En,{base36:()=>Me,base36upper:()=>Fa});var Me=Xt({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Fa=Xt({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var Ma=Es,bs=128,za=127,qa=~za,Va=Math.pow(2,31);function Es(r,t,e){t=t||[],e=e||0;for(var n=e;r>=Va;)t[e++]=r&255|bs,r/=128;for(;r&qa;)t[e++]=r&255|bs,r>>>=7;return t[e]=r|0,Es.bytes=e-n+1,t}var Ha=vn,Ka=128,ys=127;function vn(r,n){var e=0,n=n||0,o=0,s=n,i,a=r.length;do{if(s>=a)throw vn.bytes=0,new RangeError("Could not decode varint");i=r[s++],e+=o<28?(i&ys)<<o:(i&ys)*Math.pow(2,o),o+=7}while(i>=Ka);return vn.bytes=s-n,e}var Ga=Math.pow(2,7),ja=Math.pow(2,14),Za=Math.pow(2,21),$a=Math.pow(2,28),Xa=Math.pow(2,35),Wa=Math.pow(2,42),Ya=Math.pow(2,49),Qa=Math.pow(2,56),Ja=Math.pow(2,63),tc=function(r){return r<Ga?1:r<ja?2:r<Za?3:r<$a?4:r<Xa?5:r<Wa?6:r<Ya?7:r<Qa?8:r<Ja?9:10},ec={encode:Ma,decode:Ha,encodingLength:tc},rc=ec,ze=rc;function qe(r,t=0){return[ze.decode(r,t),ze.decode.bytes]}function ve(r,t,e=0){return ze.encode(r,t,e),t}function Se(r){return ze.encodingLength(r)}function ie(r,t){let e=t.byteLength,n=Se(r),o=n+Se(e),s=new Uint8Array(o+e);return ve(r,s,0),ve(e,s,n),s.set(t,o),new _e(r,e,t,s)}function Ut(r){let t=Pt(r),[e,n]=qe(t),[o,s]=qe(t.subarray(n)),i=t.subarray(n+s);if(i.byteLength!==o)throw new Error("Incorrect length");return new _e(e,o,i,t)}function vs(r,t){if(r===t)return!0;{let e=t;return r.code===e.code&&r.size===e.size&&e.bytes instanceof Uint8Array&&ds(r.bytes,e.bytes)}}var _e=class{code;size;digest;bytes;constructor(t,e,n,o){this.code=t,this.size=e,this.digest=n,this.bytes=o}};function Ss(r,t){let{bytes:e,version:n}=r;switch(n){case 0:return oc(e,Sn(r),t??W.encoder);default:return sc(e,Sn(r),t??kt.encoder)}}var _s=new WeakMap;function Sn(r){let t=_s.get(r);if(t==null){let e=new Map;return _s.set(r,e),e}return t}var lt=class r{code;version;multihash;bytes;"/";constructor(t,e,n,o){this.code=e,this.version=t,this.multihash=n,this.bytes=o,this["/"]=o}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{let{code:t,multihash:e}=this;if(t!==Ve)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==ic)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return r.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{let{code:t,digest:e}=this.multihash,n=ie(t,e);return r.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return r.equals(this,t)}static equals(t,e){let n=e;return n!=null&&t.code===n.code&&t.version===n.version&&vs(t.multihash,n.multihash)}toString(t){return Ss(this,t)}toJSON(){return{"/":Ss(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;let e=t;if(e instanceof r)return e;if(e["/"]!=null&&e["/"]===e.bytes||e.asCID===e){let{version:n,code:o,multihash:s,bytes:i}=e;return new r(n,o,s,i??As(n,o,s.bytes))}else if(e[ac]===!0){let{version:n,multihash:o,code:s}=e,i=Ut(o);return r.create(n,s,i)}else return null}static create(t,e,n){if(typeof e!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(e!==Ve)throw new Error(`Version 0 CID must use dag-pb (code: ${Ve}) block encoding`);return new r(t,e,n,n.bytes)}case 1:{let o=As(t,e,n.bytes);return new r(t,e,n,o)}default:throw new Error("Invalid version")}}static createV0(t){return r.create(0,Ve,t)}static createV1(t,e){return r.create(1,t,e)}static decode(t){let[e,n]=r.decodeFirst(t);if(n.length!==0)throw new Error("Incorrect length");return e}static decodeFirst(t){let e=r.inspectBytes(t),n=e.size-e.multihashSize,o=Pt(t.subarray(n,n+e.multihashSize));if(o.byteLength!==e.multihashSize)throw new Error("Incorrect length");let s=o.subarray(e.multihashSize-e.digestSize),i=new _e(e.multihashCode,e.digestSize,s,o);return[e.version===0?r.createV0(i):r.createV1(e.codec,i),t.subarray(e.size)]}static inspectBytes(t){let e=0,n=()=>{let[f,d]=qe(t.subarray(e));return e+=d,f},o=n(),s=Ve;if(o===18?(o=0,e=0):s=n(),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);let i=e,a=n(),c=n(),l=e+c,h=l-i;return{version:o,codec:s,multihashCode:a,digestSize:c,multihashSize:h,size:l}}static parse(t,e){let[n,o]=nc(t,e),s=r.decode(o);if(s.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Sn(s).set(n,t),s}};function nc(r,t){switch(r[0]){case"Q":{let e=t??W;return[W.prefix,e.decode(`${W.prefix}${r}`)]}case W.prefix:{let e=t??W;return[W.prefix,e.decode(r)]}case kt.prefix:{let e=t??kt;return[kt.prefix,e.decode(r)]}case Me.prefix:{let e=t??Me;return[Me.prefix,e.decode(r)]}default:{if(t==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],t.decode(r)]}}}function oc(r,t,e){let{prefix:n}=e;if(n!==W.prefix)throw Error(`Cannot string encode V0 in ${e.name} encoding`);let o=t.get(n);if(o==null){let s=e.encode(r).slice(1);return t.set(n,s),s}else return o}function sc(r,t,e){let{prefix:n}=e,o=t.get(n);if(o==null){let s=e.encode(r);return t.set(n,s),s}else return o}var Ve=112,ic=18;function As(r,t,e){let n=Se(r),o=n+Se(t),s=new Uint8Array(o+e.byteLength);return ve(r,s,0),ve(t,s,n),s.set(e,o),s}var ac=Symbol.for("@ipld/js-cid/CID");var _n={};dt(_n,{identity:()=>Ot});var Is=0,cc="identity",Bs=Pt;function uc(r){return ie(Is,Bs(r))}var Ot={code:Is,name:cc,encode:Bs,digest:uc};function xt(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function Ls(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function fc(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Ae(r,...t){if(!fc(r))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(r.length))throw new Error("Uint8Array expected of length "+t+", got length="+r.length)}function Ts(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Ls(r.outputLen),Ls(r.blockLen)}function Ie(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function Rs(r,t){Ae(r);let e=t.outputLen;if(r.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}var ae=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var lr=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),Et=(r,t)=>r<<32-t|r>>>t;function Ds(r){if(typeof r!="string")throw new Error("utf8ToBytes expected string, got "+typeof r);return new Uint8Array(new TextEncoder().encode(r))}function He(r){return typeof r=="string"&&(r=Ds(r)),Ae(r),r}function An(...r){let t=0;for(let n=0;n<r.length;n++){let o=r[n];Ae(o),t+=o.length}let e=new Uint8Array(t);for(let n=0,o=0;n<r.length;n++){let s=r[n];e.set(s,o),o+=s.length}return e}var Be=class{clone(){return this._cloneInto()}};function hr(r){let t=n=>r().update(He(n)).digest(),e=r();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>r(),t}function dr(r=32){if(ae&&typeof ae.getRandomValues=="function")return ae.getRandomValues(new Uint8Array(r));if(ae&&typeof ae.randomBytes=="function")return ae.randomBytes(r);throw new Error("crypto.getRandomValues must be defined")}function lc(r,t,e,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(t,e,n);let o=BigInt(32),s=BigInt(4294967295),i=Number(e>>o&s),a=Number(e&s),c=n?4:0,l=n?0:4;r.setUint32(t+c,i,n),r.setUint32(t+l,a,n)}var Ns=(r,t,e)=>r&t^~r&e,Ps=(r,t,e)=>r&t^r&e^t&e,Le=class extends Be{constructor(t,e,n,o){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=lr(this.buffer)}update(t){Ie(this);let{view:e,buffer:n,blockLen:o}=this;t=He(t);let s=t.length;for(let i=0;i<s;){let a=Math.min(o-this.pos,s-i);if(a===o){let c=lr(t);for(;o<=s-i;i+=o)this.process(c,i);continue}n.set(t.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===o&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Ie(this),Rs(t,this),this.finished=!0;let{buffer:e,view:n,blockLen:o,isLE:s}=this,{pos:i}=this;e[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>o-i&&(this.process(n,0),i=0);for(let f=i;f<o;f++)e[f]=0;lc(n,o-8,BigInt(this.length*8),s),this.process(n,0);let a=lr(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let l=c/4,h=this.get();if(l>h.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<l;f++)a.setUint32(4*f,h[f],s)}digest(){let{buffer:t,outputLen:e}=this;this.digestInto(t);let n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:e,buffer:n,length:o,finished:s,destroyed:i,pos:a}=this;return t.length=o,t.pos=a,t.finished=s,t.destroyed=i,o%e&&t.buffer.set(n),t}};var pr=BigInt(4294967295),In=BigInt(32);function ks(r,t=!1){return t?{h:Number(r&pr),l:Number(r>>In&pr)}:{h:Number(r>>In&pr)|0,l:Number(r&pr)|0}}function hc(r,t=!1){let e=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let o=0;o<r.length;o++){let{h:s,l:i}=ks(r[o],t);[e[o],n[o]]=[s,i]}return[e,n]}var dc=(r,t)=>BigInt(r>>>0)<<In|BigInt(t>>>0),pc=(r,t,e)=>r>>>e,mc=(r,t,e)=>r<<32-e|t>>>e,gc=(r,t,e)=>r>>>e|t<<32-e,xc=(r,t,e)=>r<<32-e|t>>>e,wc=(r,t,e)=>r<<64-e|t>>>e-32,bc=(r,t,e)=>r>>>e-32|t<<64-e,yc=(r,t)=>t,Ec=(r,t)=>r,vc=(r,t,e)=>r<<e|t>>>32-e,Sc=(r,t,e)=>t<<e|r>>>32-e,_c=(r,t,e)=>t<<e-32|r>>>64-e,Ac=(r,t,e)=>r<<e-32|t>>>64-e;function Ic(r,t,e,n){let o=(t>>>0)+(n>>>0);return{h:r+e+(o/2**32|0)|0,l:o|0}}var Bc=(r,t,e)=>(r>>>0)+(t>>>0)+(e>>>0),Lc=(r,t,e,n)=>t+e+n+(r/2**32|0)|0,Tc=(r,t,e,n)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0),Rc=(r,t,e,n,o)=>t+e+n+o+(r/2**32|0)|0,Dc=(r,t,e,n,o)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(o>>>0),Nc=(r,t,e,n,o,s)=>t+e+n+o+s+(r/2**32|0)|0;var Pc={fromBig:ks,split:hc,toBig:dc,shrSH:pc,shrSL:mc,rotrSH:gc,rotrSL:xc,rotrBH:wc,rotrBL:bc,rotr32H:yc,rotr32L:Ec,rotlSH:vc,rotlSL:Sc,rotlBH:_c,rotlBL:Ac,add:Ic,add3L:Bc,add3H:Lc,add4L:Tc,add4H:Rc,add5H:Nc,add5L:Dc},C=Pc;var[kc,Uc]=C.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),Wt=new Uint32Array(80),Yt=new Uint32Array(80),Bn=class extends Le{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){let{Ah:t,Al:e,Bh:n,Bl:o,Ch:s,Cl:i,Dh:a,Dl:c,Eh:l,El:h,Fh:f,Fl:d,Gh:u,Gl:p,Hh:g,Hl:x}=this;return[t,e,n,o,s,i,a,c,l,h,f,d,u,p,g,x]}set(t,e,n,o,s,i,a,c,l,h,f,d,u,p,g,x){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=o|0,this.Ch=s|0,this.Cl=i|0,this.Dh=a|0,this.Dl=c|0,this.Eh=l|0,this.El=h|0,this.Fh=f|0,this.Fl=d|0,this.Gh=u|0,this.Gl=p|0,this.Hh=g|0,this.Hl=x|0}process(t,e){for(let m=0;m<16;m++,e+=4)Wt[m]=t.getUint32(e),Yt[m]=t.getUint32(e+=4);for(let m=16;m<80;m++){let v=Wt[m-15]|0,_=Yt[m-15]|0,I=C.rotrSH(v,_,1)^C.rotrSH(v,_,8)^C.shrSH(v,_,7),y=C.rotrSL(v,_,1)^C.rotrSL(v,_,8)^C.shrSL(v,_,7),B=Wt[m-2]|0,T=Yt[m-2]|0,V=C.rotrSH(B,T,19)^C.rotrBH(B,T,61)^C.shrSH(B,T,6),F=C.rotrSL(B,T,19)^C.rotrBL(B,T,61)^C.shrSL(B,T,6),O=C.add4L(y,F,Yt[m-7],Yt[m-16]),N=C.add4H(O,I,V,Wt[m-7],Wt[m-16]);Wt[m]=N|0,Yt[m]=O|0}let{Ah:n,Al:o,Bh:s,Bl:i,Ch:a,Cl:c,Dh:l,Dl:h,Eh:f,El:d,Fh:u,Fl:p,Gh:g,Gl:x,Hh:w,Hl:b}=this;for(let m=0;m<80;m++){let v=C.rotrSH(f,d,14)^C.rotrSH(f,d,18)^C.rotrBH(f,d,41),_=C.rotrSL(f,d,14)^C.rotrSL(f,d,18)^C.rotrBL(f,d,41),I=f&u^~f&g,y=d&p^~d&x,B=C.add5L(b,_,y,Uc[m],Yt[m]),T=C.add5H(B,w,v,I,kc[m],Wt[m]),V=B|0,F=C.rotrSH(n,o,28)^C.rotrBH(n,o,34)^C.rotrBH(n,o,39),O=C.rotrSL(n,o,28)^C.rotrBL(n,o,34)^C.rotrBL(n,o,39),N=n&s^n&a^s&a,L=o&i^o&c^i&c;w=g|0,b=x|0,g=u|0,x=p|0,u=f|0,p=d|0,{h:f,l:d}=C.add(l|0,h|0,T|0,V|0),l=a|0,h=c|0,a=s|0,c=i|0,s=n|0,i=o|0;let D=C.add3L(V,O,L);n=C.add3H(D,T,F,N),o=D|0}({h:n,l:o}=C.add(this.Ah|0,this.Al|0,n|0,o|0)),{h:s,l:i}=C.add(this.Bh|0,this.Bl|0,s|0,i|0),{h:a,l:c}=C.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:l,l:h}=C.add(this.Dh|0,this.Dl|0,l|0,h|0),{h:f,l:d}=C.add(this.Eh|0,this.El|0,f|0,d|0),{h:u,l:p}=C.add(this.Fh|0,this.Fl|0,u|0,p|0),{h:g,l:x}=C.add(this.Gh|0,this.Gl|0,g|0,x|0),{h:w,l:b}=C.add(this.Hh|0,this.Hl|0,w|0,b|0),this.set(n,o,s,i,a,c,l,h,f,d,u,p,g,x,w,b)}roundClean(){Wt.fill(0),Yt.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}};var Us=hr(()=>new Bn);var xr={};dt(xr,{aInRange:()=>pt,abool:()=>vt,abytes:()=>Te,bitGet:()=>qc,bitLen:()=>Dn,bitMask:()=>Ge,bitSet:()=>Vc,bytesToHex:()=>Mt,bytesToNumberBE:()=>zt,bytesToNumberLE:()=>Jt,concatBytes:()=>qt,createHmacDrbg:()=>Nn,ensureBytes:()=>Y,equalBytes:()=>Mc,hexToBytes:()=>ue,hexToNumber:()=>Rn,inRange:()=>Ke,isBytes:()=>Qt,memoized:()=>le,notImplemented:()=>Kc,numberToBytesBE:()=>te,numberToBytesLE:()=>fe,numberToHexUnpadded:()=>ce,numberToVarBytesBE:()=>Fc,utf8ToBytes:()=>zc,validateObject:()=>Rt});var mr=BigInt(0),gr=BigInt(1),Cc=BigInt(2);function Qt(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Te(r){if(!Qt(r))throw new Error("Uint8Array expected")}function vt(r,t){if(typeof t!="boolean")throw new Error(r+" boolean expected, got "+t)}var Oc=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function Mt(r){Te(r);let t="";for(let e=0;e<r.length;e++)t+=Oc[r[e]];return t}function ce(r){let t=r.toString(16);return t.length&1?"0"+t:t}function Rn(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?mr:BigInt("0x"+r)}var Ft={_0:48,_9:57,A:65,F:70,a:97,f:102};function Cs(r){if(r>=Ft._0&&r<=Ft._9)return r-Ft._0;if(r>=Ft.A&&r<=Ft.F)return r-(Ft.A-10);if(r>=Ft.a&&r<=Ft.f)return r-(Ft.a-10)}function ue(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);let t=r.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);let n=new Uint8Array(e);for(let o=0,s=0;o<e;o++,s+=2){let i=Cs(r.charCodeAt(s)),a=Cs(r.charCodeAt(s+1));if(i===void 0||a===void 0){let c=r[s]+r[s+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+s)}n[o]=i*16+a}return n}function zt(r){return Rn(Mt(r))}function Jt(r){return Te(r),Rn(Mt(Uint8Array.from(r).reverse()))}function te(r,t){return ue(r.toString(16).padStart(t*2,"0"))}function fe(r,t){return te(r,t).reverse()}function Fc(r){return ue(ce(r))}function Y(r,t,e){let n;if(typeof t=="string")try{n=ue(t)}catch(s){throw new Error(r+" must be hex string or Uint8Array, cause: "+s)}else if(Qt(t))n=Uint8Array.from(t);else throw new Error(r+" must be hex string or Uint8Array");let o=n.length;if(typeof e=="number"&&o!==e)throw new Error(r+" of length "+e+" expected, got "+o);return n}function qt(...r){let t=0;for(let n=0;n<r.length;n++){let o=r[n];Te(o),t+=o.length}let e=new Uint8Array(t);for(let n=0,o=0;n<r.length;n++){let s=r[n];e.set(s,o),o+=s.length}return e}function Mc(r,t){if(r.length!==t.length)return!1;let e=0;for(let n=0;n<r.length;n++)e|=r[n]^t[n];return e===0}function zc(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}var Ln=r=>typeof r=="bigint"&&mr<=r;function Ke(r,t,e){return Ln(r)&&Ln(t)&&Ln(e)&&t<=r&&r<e}function pt(r,t,e,n){if(!Ke(t,e,n))throw new Error("expected valid "+r+": "+e+" <= n < "+n+", got "+t)}function Dn(r){let t;for(t=0;r>mr;r>>=gr,t+=1);return t}function qc(r,t){return r>>BigInt(t)&gr}function Vc(r,t,e){return r|(e?gr:mr)<<BigInt(t)}var Ge=r=>(Cc<<BigInt(r-1))-gr,Tn=r=>new Uint8Array(r),Os=r=>Uint8Array.from(r);function Nn(r,t,e){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let n=Tn(r),o=Tn(r),s=0,i=()=>{n.fill(1),o.fill(0),s=0},a=(...f)=>e(o,n,...f),c=(f=Tn())=>{o=a(Os([0]),f),n=a(),f.length!==0&&(o=a(Os([1]),f),n=a())},l=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let f=0,d=[];for(;f<t;){n=a();let u=n.slice();d.push(u),f+=n.length}return qt(...d)};return(f,d)=>{i(),c(f);let u;for(;!(u=d(l()));)c();return i(),u}}var Hc={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||Qt(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,t)=>t.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function Rt(r,t,e={}){let n=(o,s,i)=>{let a=Hc[s];if(typeof a!="function")throw new Error("invalid validator function");let c=r[o];if(!(i&&c===void 0)&&!a(c,r))throw new Error("param "+String(o)+" is invalid. Expected "+s+", got "+c)};for(let[o,s]of Object.entries(t))n(o,s,!1);for(let[o,s]of Object.entries(e))n(o,s,!0);return r}var Kc=()=>{throw new Error("not implemented")};function le(r){let t=new WeakMap;return(e,...n)=>{let o=t.get(e);if(o!==void 0)return o;let s=r(e,...n);return t.set(e,s),s}}var J=BigInt(0),$=BigInt(1),he=BigInt(2),Gc=BigInt(3),Pn=BigInt(4),Fs=BigInt(5),Ms=BigInt(8),jc=BigInt(9),Zc=BigInt(16);function G(r,t){let e=r%t;return e>=J?e:t+e}function $c(r,t,e){if(t<J)throw new Error("invalid exponent, negatives unsupported");if(e<=J)throw new Error("invalid modulus");if(e===$)return J;let n=$;for(;t>J;)t&$&&(n=n*r%e),r=r*r%e,t>>=$;return n}function X(r,t,e){let n=r;for(;t-- >J;)n*=n,n%=e;return n}function wr(r,t){if(r===J)throw new Error("invert: expected non-zero number");if(t<=J)throw new Error("invert: expected positive modulus, got "+t);let e=G(r,t),n=t,o=J,s=$,i=$,a=J;for(;e!==J;){let l=n/e,h=n%e,f=o-i*l,d=s-a*l;n=e,e=h,o=i,s=a,i=f,a=d}if(n!==$)throw new Error("invert: does not exist");return G(o,t)}function Xc(r){let t=(r-$)/he,e,n,o;for(e=r-$,n=0;e%he===J;e/=he,n++);for(o=he;o<r&&$c(o,t,r)!==r-$;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(n===1){let i=(r+$)/Pn;return function(c,l){let h=c.pow(l,i);if(!c.eql(c.sqr(h),l))throw new Error("Cannot find square root");return h}}let s=(e+$)/he;return function(a,c){if(a.pow(c,t)===a.neg(a.ONE))throw new Error("Cannot find square root");let l=n,h=a.pow(a.mul(a.ONE,o),e),f=a.pow(c,s),d=a.pow(c,e);for(;!a.eql(d,a.ONE);){if(a.eql(d,a.ZERO))return a.ZERO;let u=1;for(let g=a.sqr(d);u<l&&!a.eql(g,a.ONE);u++)g=a.sqr(g);let p=a.pow(h,$<<BigInt(l-u-1));h=a.sqr(p),f=a.mul(f,p),d=a.mul(d,h),l=u}return f}}function Wc(r){if(r%Pn===Gc){let t=(r+$)/Pn;return function(n,o){let s=n.pow(o,t);if(!n.eql(n.sqr(s),o))throw new Error("Cannot find square root");return s}}if(r%Ms===Fs){let t=(r-Fs)/Ms;return function(n,o){let s=n.mul(o,he),i=n.pow(s,t),a=n.mul(o,i),c=n.mul(n.mul(a,he),i),l=n.mul(a,n.sub(c,n.ONE));if(!n.eql(n.sqr(l),o))throw new Error("Cannot find square root");return l}}return r%Zc,Xc(r)}var zs=(r,t)=>(G(r,t)&$)===$,Yc=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function kn(r){let t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Yc.reduce((n,o)=>(n[o]="function",n),t);return Rt(r,e)}function Qc(r,t,e){if(e<J)throw new Error("invalid exponent, negatives unsupported");if(e===J)return r.ONE;if(e===$)return t;let n=r.ONE,o=t;for(;e>J;)e&$&&(n=r.mul(n,o)),o=r.sqr(o),e>>=$;return n}function Jc(r,t){let e=new Array(t.length),n=t.reduce((s,i,a)=>r.is0(i)?s:(e[a]=s,r.mul(s,i)),r.ONE),o=r.inv(n);return t.reduceRight((s,i,a)=>r.is0(i)?s:(e[a]=r.mul(s,e[a]),r.mul(s,i)),o),e}function Un(r,t){let e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}function ee(r,t,e=!1,n={}){if(r<=J)throw new Error("invalid field: expected ORDER > 0, got "+r);let{nBitLength:o,nByteLength:s}=Un(r,t);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let i,a=Object.freeze({ORDER:r,isLE:e,BITS:o,BYTES:s,MASK:Ge(o),ZERO:J,ONE:$,create:c=>G(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return J<=c&&c<r},is0:c=>c===J,isOdd:c=>(c&$)===$,neg:c=>G(-c,r),eql:(c,l)=>c===l,sqr:c=>G(c*c,r),add:(c,l)=>G(c+l,r),sub:(c,l)=>G(c-l,r),mul:(c,l)=>G(c*l,r),pow:(c,l)=>Qc(a,c,l),div:(c,l)=>G(c*wr(l,r),r),sqrN:c=>c*c,addN:(c,l)=>c+l,subN:(c,l)=>c-l,mulN:(c,l)=>c*l,inv:c=>wr(c,r),sqrt:n.sqrt||(c=>(i||(i=Wc(r)),i(a,c))),invertBatch:c=>Jc(a,c),cmov:(c,l,h)=>h?l:c,toBytes:c=>e?fe(c,s):te(c,s),fromBytes:c=>{if(c.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+c.length);return e?Jt(c):zt(c)}});return Object.freeze(a)}function qs(r){if(typeof r!="bigint")throw new Error("field order must be bigint");let t=r.toString(2).length;return Math.ceil(t/8)}function Cn(r){let t=qs(r);return t+Math.ceil(t/2)}function Vs(r,t,e=!1){let n=r.length,o=qs(t),s=Cn(t);if(n<16||n<s||n>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+n);let i=e?Jt(r):zt(r),a=G(i,t-$)+$;return e?fe(a,o):te(a,o)}var Hs=BigInt(0),br=BigInt(1);function On(r,t){let e=t.negate();return r?e:t}function Ks(r,t){if(!Number.isSafeInteger(r)||r<=0||r>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+r)}function Fn(r,t){Ks(r,t);let e=Math.ceil(t/r)+1,n=2**(r-1);return{windows:e,windowSize:n}}function eu(r,t){if(!Array.isArray(r))throw new Error("array expected");r.forEach((e,n)=>{if(!(e instanceof t))throw new Error("invalid point at index "+n)})}function ru(r,t){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((e,n)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+n)})}var Mn=new WeakMap,Gs=new WeakMap;function zn(r){return Gs.get(r)||1}function yr(r,t){return{constTimeNegate:On,hasPrecomputes(e){return zn(e)!==1},unsafeLadder(e,n,o=r.ZERO){let s=e;for(;n>Hs;)n&br&&(o=o.add(s)),s=s.double(),n>>=br;return o},precomputeWindow(e,n){let{windows:o,windowSize:s}=Fn(n,t),i=[],a=e,c=a;for(let l=0;l<o;l++){c=a,i.push(c);for(let h=1;h<s;h++)c=c.add(a),i.push(c);a=c.double()}return i},wNAF(e,n,o){let{windows:s,windowSize:i}=Fn(e,t),a=r.ZERO,c=r.BASE,l=BigInt(2**e-1),h=2**e,f=BigInt(e);for(let d=0;d<s;d++){let u=d*i,p=Number(o&l);o>>=f,p>i&&(p-=h,o+=br);let g=u,x=u+Math.abs(p)-1,w=d%2!==0,b=p<0;p===0?c=c.add(On(w,n[g])):a=a.add(On(b,n[x]))}return{p:a,f:c}},wNAFUnsafe(e,n,o,s=r.ZERO){let{windows:i,windowSize:a}=Fn(e,t),c=BigInt(2**e-1),l=2**e,h=BigInt(e);for(let f=0;f<i;f++){let d=f*a;if(o===Hs)break;let u=Number(o&c);if(o>>=h,u>a&&(u-=l,o+=br),u===0)continue;let p=n[d+Math.abs(u)-1];u<0&&(p=p.negate()),s=s.add(p)}return s},getPrecomputes(e,n,o){let s=Mn.get(n);return s||(s=this.precomputeWindow(n,e),e!==1&&Mn.set(n,o(s))),s},wNAFCached(e,n,o){let s=zn(e);return this.wNAF(s,this.getPrecomputes(s,e,o),n)},wNAFCachedUnsafe(e,n,o,s){let i=zn(e);return i===1?this.unsafeLadder(e,n,s):this.wNAFUnsafe(i,this.getPrecomputes(i,e,o),n,s)},setWindowSize(e,n){Ks(n,t),Gs.set(e,n),Mn.delete(e)}}}function Er(r,t,e,n){if(eu(e,r),ru(n,t),e.length!==n.length)throw new Error("arrays of points and scalars must have equal length");let o=r.ZERO,s=Dn(BigInt(e.length)),i=s>12?s-3:s>4?s-2:s?2:1,a=(1<<i)-1,c=new Array(a+1).fill(o),l=Math.floor((t.BITS-1)/i)*i,h=o;for(let f=l;f>=0;f-=i){c.fill(o);for(let u=0;u<n.length;u++){let p=n[u],g=Number(p>>BigInt(f)&BigInt(a));c[g]=c[g].add(e[u])}let d=o;for(let u=c.length-1,p=o;u>0;u--)p=p.add(c[u]),d=d.add(p);if(h=h.add(d),f!==0)for(let u=0;u<i;u++)h=h.double()}return h}function je(r){return kn(r.Fp),Rt(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Un(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}var St=BigInt(0),mt=BigInt(1),vr=BigInt(2),nu=BigInt(8),ou={zip215:!0};function su(r){let t=je(r);return Rt(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}function js(r){let t=su(r),{Fp:e,n,prehash:o,hash:s,randomBytes:i,nByteLength:a,h:c}=t,l=vr<<BigInt(a*8)-mt,h=e.create,f=ee(t.n,t.nBitLength),d=t.uvRatio||((S,E)=>{try{return{isValid:!0,value:e.sqrt(S*e.inv(E))}}catch{return{isValid:!1,value:St}}}),u=t.adjustScalarBytes||(S=>S),p=t.domain||((S,E,A)=>{if(vt("phflag",A),E.length||A)throw new Error("Contexts/pre-hash are not supported");return S});function g(S,E){pt("coordinate "+S,E,St,l)}function x(S){if(!(S instanceof m))throw new Error("ExtendedPoint expected")}let w=le((S,E)=>{let{ex:A,ey:R,ez:P}=S,k=S.is0();E==null&&(E=k?nu:e.inv(P));let M=h(A*E),z=h(R*E),U=h(P*E);if(k)return{x:St,y:mt};if(U!==mt)throw new Error("invZ was invalid");return{x:M,y:z}}),b=le(S=>{let{a:E,d:A}=t;if(S.is0())throw new Error("bad point: ZERO");let{ex:R,ey:P,ez:k,et:M}=S,z=h(R*R),U=h(P*P),H=h(k*k),j=h(H*H),rt=h(z*E),nt=h(H*h(rt+U)),st=h(j+h(A*h(z*U)));if(nt!==st)throw new Error("bad point: equation left != right (1)");let it=h(R*P),ht=h(k*M);if(it!==ht)throw new Error("bad point: equation left != right (2)");return!0});class m{constructor(E,A,R,P){this.ex=E,this.ey=A,this.ez=R,this.et=P,g("x",E),g("y",A),g("z",R),g("t",P),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(E){if(E instanceof m)throw new Error("extended point not allowed");let{x:A,y:R}=E||{};return g("x",A),g("y",R),new m(A,R,mt,h(A*R))}static normalizeZ(E){let A=e.invertBatch(E.map(R=>R.ez));return E.map((R,P)=>R.toAffine(A[P])).map(m.fromAffine)}static msm(E,A){return Er(m,f,E,A)}_setWindowSize(E){I.setWindowSize(this,E)}assertValidity(){b(this)}equals(E){x(E);let{ex:A,ey:R,ez:P}=this,{ex:k,ey:M,ez:z}=E,U=h(A*z),H=h(k*P),j=h(R*z),rt=h(M*P);return U===H&&j===rt}is0(){return this.equals(m.ZERO)}negate(){return new m(h(-this.ex),this.ey,this.ez,h(-this.et))}double(){let{a:E}=t,{ex:A,ey:R,ez:P}=this,k=h(A*A),M=h(R*R),z=h(vr*h(P*P)),U=h(E*k),H=A+R,j=h(h(H*H)-k-M),rt=U+M,nt=rt-z,st=U-M,it=h(j*nt),ht=h(rt*st),ft=h(j*st),Lt=h(nt*rt);return new m(it,ht,Lt,ft)}add(E){x(E);let{a:A,d:R}=t,{ex:P,ey:k,ez:M,et:z}=this,{ex:U,ey:H,ez:j,et:rt}=E;if(A===BigInt(-1)){let rs=h((k-P)*(H+U)),ns=h((k+P)*(H-U)),hn=h(ns-rs);if(hn===St)return this.double();let os=h(M*vr*rt),ss=h(z*vr*j),is=ss+os,as=ns+rs,cs=ss-os,pa=h(is*hn),ma=h(as*cs),ga=h(is*cs),xa=h(hn*as);return new m(pa,ma,xa,ga)}let nt=h(P*U),st=h(k*H),it=h(z*R*rt),ht=h(M*j),ft=h((P+k)*(U+H)-nt-st),Lt=ht-it,Dt=ht+it,Ce=h(st-A*nt),fa=h(ft*Lt),la=h(Dt*Ce),ha=h(ft*Ce),da=h(Lt*Dt);return new m(fa,la,da,ha)}subtract(E){return this.add(E.negate())}wNAF(E){return I.wNAFCached(this,E,m.normalizeZ)}multiply(E){let A=E;pt("scalar",A,mt,n);let{p:R,f:P}=this.wNAF(A);return m.normalizeZ([R,P])[0]}multiplyUnsafe(E,A=m.ZERO){let R=E;return pt("scalar",R,St,n),R===St?_:this.is0()||R===mt?this:I.wNAFCachedUnsafe(this,R,m.normalizeZ,A)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return I.unsafeLadder(this,n).is0()}toAffine(E){return w(this,E)}clearCofactor(){let{h:E}=t;return E===mt?this:this.multiplyUnsafe(E)}static fromHex(E,A=!1){let{d:R,a:P}=t,k=e.BYTES;E=Y("pointHex",E,k),vt("zip215",A);let M=E.slice(),z=E[k-1];M[k-1]=z&-129;let U=Jt(M),H=A?l:e.ORDER;pt("pointHex.y",U,St,H);let j=h(U*U),rt=h(j-mt),nt=h(R*j-P),{isValid:st,value:it}=d(rt,nt);if(!st)throw new Error("Point.fromHex: invalid y coordinate");let ht=(it&mt)===mt,ft=(z&128)!==0;if(!A&&it===St&&ft)throw new Error("Point.fromHex: x=0 and x_0=1");return ft!==ht&&(it=h(-it)),m.fromAffine({x:it,y:U})}static fromPrivateKey(E){return T(E).point}toRawBytes(){let{x:E,y:A}=this.toAffine(),R=fe(A,e.BYTES);return R[R.length-1]|=E&mt?128:0,R}toHex(){return Mt(this.toRawBytes())}}m.BASE=new m(t.Gx,t.Gy,mt,h(t.Gx*t.Gy)),m.ZERO=new m(St,mt,mt,St);let{BASE:v,ZERO:_}=m,I=yr(m,a*8);function y(S){return G(S,n)}function B(S){return y(Jt(S))}function T(S){let E=e.BYTES;S=Y("private key",S,E);let A=Y("hashed private key",s(S),2*E),R=u(A.slice(0,E)),P=A.slice(E,2*E),k=B(R),M=v.multiply(k),z=M.toRawBytes();return{head:R,prefix:P,scalar:k,point:M,pointBytes:z}}function V(S){return T(S).pointBytes}function F(S=new Uint8Array,...E){let A=qt(...E);return B(s(p(A,Y("context",S),!!o)))}function O(S,E,A={}){S=Y("message",S),o&&(S=o(S));let{prefix:R,scalar:P,pointBytes:k}=T(E),M=F(A.context,R,S),z=v.multiply(M).toRawBytes(),U=F(A.context,z,k,S),H=y(M+U*P);pt("signature.s",H,St,n);let j=qt(z,fe(H,e.BYTES));return Y("result",j,e.BYTES*2)}let N=ou;function L(S,E,A,R=N){let{context:P,zip215:k}=R,M=e.BYTES;S=Y("signature",S,2*M),E=Y("message",E),A=Y("publicKey",A,M),k!==void 0&&vt("zip215",k),o&&(E=o(E));let z=Jt(S.slice(M,2*M)),U,H,j;try{U=m.fromHex(A,k),H=m.fromHex(S.slice(0,M),k),j=v.multiplyUnsafe(z)}catch{return!1}if(!k&&U.isSmallOrder())return!1;let rt=F(P,H.toRawBytes(),U.toRawBytes(),E);return H.add(U.multiplyUnsafe(rt)).subtract(j).clearCofactor().equals(m.ZERO)}return v._setWindowSize(8),{CURVE:t,getPublicKey:V,sign:O,verify:L,ExtendedPoint:m,utils:{getExtendedPublicKey:T,randomPrivateKey:()=>i(e.BYTES),precompute(S=8,E=m.BASE){return E._setWindowSize(S),E.multiply(BigInt(3)),E}}}}var qn=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Zs=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),Sh=BigInt(0),iu=BigInt(1),$s=BigInt(2),_h=BigInt(3),au=BigInt(5),cu=BigInt(8);function uu(r){let t=BigInt(10),e=BigInt(20),n=BigInt(40),o=BigInt(80),s=qn,a=r*r%s*r%s,c=X(a,$s,s)*a%s,l=X(c,iu,s)*r%s,h=X(l,au,s)*l%s,f=X(h,t,s)*h%s,d=X(f,e,s)*f%s,u=X(d,n,s)*d%s,p=X(u,o,s)*u%s,g=X(p,o,s)*u%s,x=X(g,t,s)*h%s;return{pow_p_5_8:X(x,$s,s)*r%s,b2:a}}function fu(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function lu(r,t){let e=qn,n=G(t*t*t,e),o=G(n*n*t,e),s=uu(r*o).pow_p_5_8,i=G(r*n*s,e),a=G(t*i*i,e),c=i,l=G(i*Zs,e),h=a===r,f=a===G(-r,e),d=a===G(-r*Zs,e);return h&&(i=c),(f||d)&&(i=l),zs(i,e)&&(i=G(-i,e)),{isValid:h||f,value:i}}var hu=ee(qn,void 0,!0),du={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:hu,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:cu,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Us,randomBytes:dr,adjustScalarBytes:fu,uvRatio:lu},Xs=js(du);var Sr=32;function Ws(r,t,e){return Xs.verify(t,e instanceof Uint8Array?e:e.subarray(),r)}var _r=class{type="Ed25519";raw;constructor(t){this.raw=Vn(t,Sr)}toMultihash(){return Ot.digest(Ar(this))}toCID(){return lt.createV1(114,this.toMultihash())}toString(){return W.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:xt(this.raw,t.raw)}verify(t,e){return Ws(this.raw,e,t)}};function Qs(r){return r=Vn(r,Sr),new _r(r)}function Vn(r,t){if(r=Uint8Array.from(r??[]),r.length!==t)throw new Oe(`Key must be a Uint8Array of length ${t}, got ${r.length}`);return r}function _t(r=0){return new Uint8Array(r)}function gt(r=0){return new Uint8Array(r)}var mu=Math.pow(2,7),gu=Math.pow(2,14),xu=Math.pow(2,21),Hn=Math.pow(2,28),Kn=Math.pow(2,35),Gn=Math.pow(2,42),jn=Math.pow(2,49),q=128,at=127;function ct(r){if(r<mu)return 1;if(r<gu)return 2;if(r<xu)return 3;if(r<Hn)return 4;if(r<Kn)return 5;if(r<Gn)return 6;if(r<jn)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function Zn(r,t,e=0){switch(ct(r)){case 8:t[e++]=r&255|q,r/=128;case 7:t[e++]=r&255|q,r/=128;case 6:t[e++]=r&255|q,r/=128;case 5:t[e++]=r&255|q,r/=128;case 4:t[e++]=r&255|q,r>>>=7;case 3:t[e++]=r&255|q,r>>>=7;case 2:t[e++]=r&255|q,r>>>=7;case 1:{t[e++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return t}function wu(r,t,e=0){switch(ct(r)){case 8:t.set(e++,r&255|q),r/=128;case 7:t.set(e++,r&255|q),r/=128;case 6:t.set(e++,r&255|q),r/=128;case 5:t.set(e++,r&255|q),r/=128;case 4:t.set(e++,r&255|q),r>>>=7;case 3:t.set(e++,r&255|q),r>>>=7;case 2:t.set(e++,r&255|q),r>>>=7;case 1:{t.set(e++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return t}function $n(r,t){let e=r[t],n=0;if(n+=e&at,e<q||(e=r[t+1],n+=(e&at)<<7,e<q)||(e=r[t+2],n+=(e&at)<<14,e<q)||(e=r[t+3],n+=(e&at)<<21,e<q)||(e=r[t+4],n+=(e&at)*Hn,e<q)||(e=r[t+5],n+=(e&at)*Kn,e<q)||(e=r[t+6],n+=(e&at)*Gn,e<q)||(e=r[t+7],n+=(e&at)*jn,e<q))return n;throw new RangeError("Could not decode varint")}function bu(r,t){let e=r.get(t),n=0;if(n+=e&at,e<q||(e=r.get(t+1),n+=(e&at)<<7,e<q)||(e=r.get(t+2),n+=(e&at)<<14,e<q)||(e=r.get(t+3),n+=(e&at)<<21,e<q)||(e=r.get(t+4),n+=(e&at)*Hn,e<q)||(e=r.get(t+5),n+=(e&at)*Kn,e<q)||(e=r.get(t+6),n+=(e&at)*Gn,e<q)||(e=r.get(t+7),n+=(e&at)*jn,e<q))return n;throw new RangeError("Could not decode varint")}function re(r,t,e=0){return t==null&&(t=gt(ct(r))),t instanceof Uint8Array?Zn(r,t,e):wu(r,t,e)}function Vt(r,t=0){return r instanceof Uint8Array?$n(r,t):bu(r,t)}var Wn=new Float32Array([-0]),ne=new Uint8Array(Wn.buffer);function Js(r,t,e){Wn[0]=r,t[e]=ne[0],t[e+1]=ne[1],t[e+2]=ne[2],t[e+3]=ne[3]}function ti(r,t){return ne[0]=r[t],ne[1]=r[t+1],ne[2]=r[t+2],ne[3]=r[t+3],Wn[0]}var Yn=new Float64Array([-0]),ut=new Uint8Array(Yn.buffer);function ei(r,t,e){Yn[0]=r,t[e]=ut[0],t[e+1]=ut[1],t[e+2]=ut[2],t[e+3]=ut[3],t[e+4]=ut[4],t[e+5]=ut[5],t[e+6]=ut[6],t[e+7]=ut[7]}function ri(r,t){return ut[0]=r[t],ut[1]=r[t+1],ut[2]=r[t+2],ut[3]=r[t+3],ut[4]=r[t+4],ut[5]=r[t+5],ut[6]=r[t+6],ut[7]=r[t+7],Yn[0]}var yu=BigInt(Number.MAX_SAFE_INTEGER),Eu=BigInt(Number.MIN_SAFE_INTEGER),wt=class r{lo;hi;constructor(t,e){this.lo=t|0,this.hi=e|0}toNumber(t=!1){if(!t&&this.hi>>>31>0){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(e+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(t=!1){if(t)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(BigInt(e)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(t=!1){return this.toBigInt(t).toString()}zzEncode(){let t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this}zzDecode(){let t=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this}length(){let t=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?e===0?t<16384?t<128?1:2:t<2097152?3:4:e<16384?e<128?5:6:e<2097152?7:8:n<128?9:10}static fromBigInt(t){if(t===0n)return de;if(t<yu&&t>Eu)return this.fromNumber(Number(t));let e=t<0n;e&&(t=-t);let n=t>>32n,o=t-(n<<32n);return e&&(n=~n|0n,o=~o|0n,++o>ni&&(o=0n,++n>ni&&(n=0n))),new r(Number(o),Number(n))}static fromNumber(t){if(t===0)return de;let e=t<0;e&&(t=-t);let n=t>>>0,o=(t-n)/4294967296>>>0;return e&&(o=~o>>>0,n=~n>>>0,++n>4294967295&&(n=0,++o>4294967295&&(o=0))),new r(n,o)}static from(t){return typeof t=="number"?r.fromNumber(t):typeof t=="bigint"?r.fromBigInt(t):typeof t=="string"?r.fromBigInt(BigInt(t)):t.low!=null||t.high!=null?new r(t.low>>>0,t.high>>>0):de}},de=new wt(0,0);de.toBigInt=function(){return 0n};de.zzEncode=de.zzDecode=function(){return this};de.length=function(){return 1};var ni=4294967296n;function oi(r){let t=0,e=0;for(let n=0;n<r.length;++n)e=r.charCodeAt(n),e<128?t+=1:e<2048?t+=2:(e&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,t+=4):t+=3;return t}function si(r,t,e){if(e-t<1)return"";let o,s=[],i=0,a;for(;t<e;)a=r[t++],a<128?s[i++]=a:a>191&&a<224?s[i++]=(a&31)<<6|r[t++]&63:a>239&&a<365?(a=((a&7)<<18|(r[t++]&63)<<12|(r[t++]&63)<<6|r[t++]&63)-65536,s[i++]=55296+(a>>10),s[i++]=56320+(a&1023)):s[i++]=(a&15)<<12|(r[t++]&63)<<6|r[t++]&63,i>8191&&((o??(o=[])).push(String.fromCharCode.apply(String,s)),i=0);return o!=null?(i>0&&o.push(String.fromCharCode.apply(String,s.slice(0,i))),o.join("")):String.fromCharCode.apply(String,s.slice(0,i))}function Qn(r,t,e){let n=e,o,s;for(let i=0;i<r.length;++i)o=r.charCodeAt(i),o<128?t[e++]=o:o<2048?(t[e++]=o>>6|192,t[e++]=o&63|128):(o&64512)===55296&&((s=r.charCodeAt(i+1))&64512)===56320?(o=65536+((o&1023)<<10)+(s&1023),++i,t[e++]=o>>18|240,t[e++]=o>>12&63|128,t[e++]=o>>6&63|128,t[e++]=o&63|128):(t[e++]=o>>12|224,t[e++]=o>>6&63|128,t[e++]=o&63|128);return e-n}function At(r,t){return RangeError(`index out of range: ${r.pos} + ${t??1} > ${r.len}`)}function Ir(r,t){return(r[t-4]|r[t-3]<<8|r[t-2]<<16|r[t-1]<<24)>>>0}var Jn=class{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(t){this.buf=t,this.pos=0,this.len=t.length}uint32(){let t=4294967295;if(t=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(t=(t|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return t;if((this.pos+=5)>this.len)throw this.pos=this.len,At(this,10);return t}int32(){return this.uint32()|0}sint32(){let t=this.uint32();return t>>>1^-(t&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw At(this,4);return Ir(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw At(this,4);return Ir(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw At(this,4);let t=ti(this.buf,this.pos);return this.pos+=4,t}double(){if(this.pos+8>this.len)throw At(this,4);let t=ri(this.buf,this.pos);return this.pos+=8,t}bytes(){let t=this.uint32(),e=this.pos,n=this.pos+t;if(n>this.len)throw At(this,t);return this.pos+=t,e===n?new Uint8Array(0):this.buf.subarray(e,n)}string(){let t=this.bytes();return si(t,0,t.length)}skip(t){if(typeof t=="number"){if(this.pos+t>this.len)throw At(this,t);this.pos+=t}else do if(this.pos>=this.len)throw At(this);while(this.buf[this.pos++]&128);return this}skipType(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${t} at offset ${this.pos}`)}return this}readLongVarint(){let t=new wt(0,0),e=0;if(this.len-this.pos>4){for(;e<4;++e)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw At(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,t}if(this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw At(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw At(this,8);let t=Ir(this.buf,this.pos+=4),e=Ir(this.buf,this.pos+=4);return new wt(t,e)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){let t=$n(this.buf,this.pos);return this.pos+=ct(t),t}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}};function to(r){return new Jn(r instanceof Uint8Array?r:r.subarray())}function Ht(r,t,e){let n=to(r);return t.decode(n,void 0,e)}var eo={};dt(eo,{base10:()=>vu});var vu=Xt({prefix:"9",name:"base10",alphabet:"0123456789"});var ro={};dt(ro,{base16:()=>Su,base16upper:()=>_u});var Su=Q({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),_u=Q({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var no={};dt(no,{base2:()=>Au});var Au=Q({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var oo={};dt(oo,{base256emoji:()=>Ru});var ai=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),Iu=ai.reduce((r,t,e)=>(r[e]=t,r),[]),Bu=ai.reduce((r,t,e)=>{let n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);return r[n]=e,r},[]);function Lu(r){return r.reduce((t,e)=>(t+=Iu[e],t),"")}function Tu(r){let t=[];for(let e of r){let n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);let o=Bu[n];if(o==null)throw new Error(`Non-base256emoji character: ${e}`);t.push(o)}return new Uint8Array(t)}var Ru=Ee({prefix:"\u{1F680}",name:"base256emoji",encode:Lu,decode:Tu});var so={};dt(so,{base64:()=>Du,base64pad:()=>Nu,base64url:()=>Pu,base64urlpad:()=>ku});var Du=Q({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Nu=Q({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Pu=Q({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),ku=Q({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var io={};dt(io,{base8:()=>Uu});var Uu=Q({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var ao={};dt(ao,{identity:()=>Cu});var Cu=Ee({prefix:"\0",name:"identity",encode:r=>ms(r),decode:r=>ps(r)});var id=new TextEncoder,ad=new TextDecoder;var fo={};dt(fo,{sha256:()=>Ze,sha512:()=>Mu});function uo({name:r,code:t,encode:e}){return new co(r,t,e)}var co=class{name;code;encode;constructor(t,e,n){this.name=t,this.code=e,this.encode=n}digest(t){if(t instanceof Uint8Array){let e=this.encode(t);return e instanceof Uint8Array?ie(this.code,e):e.then(n=>ie(this.code,n))}else throw Error("Unknown type, must be binary type")}};function ui(r){return async t=>new Uint8Array(await crypto.subtle.digest(r,t))}var Ze=uo({name:"sha2-256",code:18,encode:ui("SHA-256")}),Mu=uo({name:"sha2-512",code:19,encode:ui("SHA-512")});var $e={...ao,...no,...io,...eo,...ro,...yn,...En,...bn,...so,...oo},bd={...fo,..._n};function li(r,t,e,n){return{name:r,prefix:t,encoder:{name:r,prefix:t,encode:e},decoder:{decode:n}}}var fi=li("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),lo=li("ascii","a",r=>{let t="a";for(let e=0;e<r.length;e++)t+=String.fromCharCode(r[e]);return t},r=>{r=r.substring(1);let t=gt(r.length);for(let e=0;e<r.length;e++)t[e]=r.charCodeAt(e);return t}),zu={utf8:fi,"utf-8":fi,hex:$e.base16,latin1:lo,ascii:lo,binary:lo,...$e},Br=zu;function tt(r,t="utf8"){let e=Br[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.decoder.decode(`${e.prefix}${r}`)}function ho(r){let t=r??8192,e=t>>>1,n,o=t;return function(i){if(i<1||i>e)return gt(i);o+i>t&&(n=gt(t),o=0);let a=n.subarray(o,o+=i);return o&7&&(o=(o|7)+1),a}}var pe=class{fn;len;next;val;constructor(t,e,n){this.fn=t,this.len=e,this.next=void 0,this.val=n}};function po(){}var go=class{head;tail;len;next;constructor(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}},qu=ho();function Vu(r){return globalThis.Buffer!=null?gt(r):qu(r)}var We=class{len;head;tail;states;constructor(){this.len=0,this.head=new pe(po,0,0),this.tail=this.head,this.states=null}_push(t,e,n){return this.tail=this.tail.next=new pe(t,e,n),this.len+=e,this}uint32(t){return this.len+=(this.tail=this.tail.next=new xo((t=t>>>0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this}int32(t){return t<0?this._push(Lr,10,wt.fromNumber(t)):this.uint32(t)}sint32(t){return this.uint32((t<<1^t>>31)>>>0)}uint64(t){let e=wt.fromBigInt(t);return this._push(Lr,e.length(),e)}uint64Number(t){return this._push(Zn,ct(t),t)}uint64String(t){return this.uint64(BigInt(t))}int64(t){return this.uint64(t)}int64Number(t){return this.uint64Number(t)}int64String(t){return this.uint64String(t)}sint64(t){let e=wt.fromBigInt(t).zzEncode();return this._push(Lr,e.length(),e)}sint64Number(t){let e=wt.fromNumber(t).zzEncode();return this._push(Lr,e.length(),e)}sint64String(t){return this.sint64(BigInt(t))}bool(t){return this._push(mo,1,t?1:0)}fixed32(t){return this._push(Xe,4,t>>>0)}sfixed32(t){return this.fixed32(t)}fixed64(t){let e=wt.fromBigInt(t);return this._push(Xe,4,e.lo)._push(Xe,4,e.hi)}fixed64Number(t){let e=wt.fromNumber(t);return this._push(Xe,4,e.lo)._push(Xe,4,e.hi)}fixed64String(t){return this.fixed64(BigInt(t))}sfixed64(t){return this.fixed64(t)}sfixed64Number(t){return this.fixed64Number(t)}sfixed64String(t){return this.fixed64String(t)}float(t){return this._push(Js,4,t)}double(t){return this._push(ei,8,t)}bytes(t){let e=t.length>>>0;return e===0?this._push(mo,1,0):this.uint32(e)._push(Ku,e,t)}string(t){let e=oi(t);return e!==0?this.uint32(e)._push(Qn,e,t):this._push(mo,1,0)}fork(){return this.states=new go(this),this.head=this.tail=new pe(po,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new pe(po,0,0),this.len=0),this}ldelim(){let t=this.head,e=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=t.next,this.tail=e,this.len+=n),this}finish(){let t=this.head.next,e=Vu(this.len),n=0;for(;t!=null;)t.fn(t.val,e,n),n+=t.len,t=t.next;return e}};function mo(r,t,e){t[e]=r&255}function Hu(r,t,e){for(;r>127;)t[e++]=r&127|128,r>>>=7;t[e]=r}var xo=class extends pe{next;constructor(t,e){super(Hu,t,e),this.next=void 0}};function Lr(r,t,e){for(;r.hi!==0;)t[e++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)t[e++]=r.lo&127|128,r.lo=r.lo>>>7;t[e++]=r.lo}function Xe(r,t,e){t[e]=r&255,t[e+1]=r>>>8&255,t[e+2]=r>>>16&255,t[e+3]=r>>>24}function Ku(r,t,e){t.set(r,e)}globalThis.Buffer!=null&&(We.prototype.bytes=function(r){let t=r.length>>>0;return this.uint32(t),t>0&&this._push(Gu,t,r),this},We.prototype.string=function(r){let t=globalThis.Buffer.byteLength(r);return this.uint32(t),t>0&&this._push(ju,t,r),this});function Gu(r,t,e){t.set(r,e)}function ju(r,t,e){r.length<40?Qn(r,t,e):t.utf8Write!=null?t.utf8Write(r,e):t.set(tt(r),e)}function wo(){return new We}function Kt(r,t){let e=wo();return t.encode(r,e,{lengthDelimited:!1}),e.finish()}var Re;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(Re||(Re={}));function Tr(r,t,e,n){return{name:r,type:t,encode:e,decode:n}}function De(r){function t(o){if(r[o.toString()]==null)throw new Error("Invalid enum value");return r[o]}let e=function(s,i){let a=t(s);i.int32(a)},n=function(s){let i=s.int32();return t(i)};return Tr("enum",Re.VARINT,e,n)}function Gt(r,t){return Tr("message",Re.LENGTH_DELIMITED,r,t)}var Rr=class extends Error{code="ERR_MAX_LENGTH";name="MaxLengthError"};var yt;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1"})(yt||(yt={}));var bo;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1"})(bo||(bo={}));(function(r){r.codec=()=>De(bo)})(yt||(yt={}));var Ye;(function(r){let t;r.codec=()=>(t==null&&(t=Gt((e,n,o={})=>{o.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),yt.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),o.lengthDelimited!==!1&&n.ldelim()},(e,n,o={})=>{let s={},i=n==null?e.len:e.pos+n;for(;e.pos<i;){let a=e.uint32();switch(a>>>3){case 1:{s.Type=yt.codec().decode(e);break}case 2:{s.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return s})),t),r.encode=e=>Kt(e,r.codec()),r.decode=(e,n)=>Ht(e,r.codec(),n)})(Ye||(Ye={}));var yo;(function(r){let t;r.codec=()=>(t==null&&(t=Gt((e,n,o={})=>{o.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),yt.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),o.lengthDelimited!==!1&&n.ldelim()},(e,n,o={})=>{let s={},i=n==null?e.len:e.pos+n;for(;e.pos<i;){let a=e.uint32();switch(a>>>3){case 1:{s.Type=yt.codec().decode(e);break}case 2:{s.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return s})),t),r.encode=e=>Kt(e,r.codec()),r.decode=(e,n)=>Ht(e,r.codec(),n)})(yo||(yo={}));var $u=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),oe=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),se=new Uint32Array(64),Eo=class extends Le{constructor(){super(64,32,8,!1),this.A=oe[0]|0,this.B=oe[1]|0,this.C=oe[2]|0,this.D=oe[3]|0,this.E=oe[4]|0,this.F=oe[5]|0,this.G=oe[6]|0,this.H=oe[7]|0}get(){let{A:t,B:e,C:n,D:o,E:s,F:i,G:a,H:c}=this;return[t,e,n,o,s,i,a,c]}set(t,e,n,o,s,i,a,c){this.A=t|0,this.B=e|0,this.C=n|0,this.D=o|0,this.E=s|0,this.F=i|0,this.G=a|0,this.H=c|0}process(t,e){for(let f=0;f<16;f++,e+=4)se[f]=t.getUint32(e,!1);for(let f=16;f<64;f++){let d=se[f-15],u=se[f-2],p=Et(d,7)^Et(d,18)^d>>>3,g=Et(u,17)^Et(u,19)^u>>>10;se[f]=g+se[f-7]+p+se[f-16]|0}let{A:n,B:o,C:s,D:i,E:a,F:c,G:l,H:h}=this;for(let f=0;f<64;f++){let d=Et(a,6)^Et(a,11)^Et(a,25),u=h+d+Ns(a,c,l)+$u[f]+se[f]|0,g=(Et(n,2)^Et(n,13)^Et(n,22))+Ps(n,o,s)|0;h=l,l=c,c=a,a=i+u|0,i=s,s=o,o=n,n=u+g|0}n=n+this.A|0,o=o+this.B|0,s=s+this.C|0,i=i+this.D|0,a=a+this.E|0,c=c+this.F|0,l=l+this.G|0,h=h+this.H|0,this.set(n,o,s,i,a,c,l,h)}roundClean(){se.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var hi=hr(()=>new Eo);function et(r,t="utf8"){let e=Br[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.encoder.encode(r).substring(1)}var Qe=class extends Error{constructor(t="An error occurred while verifying a message"){super(t),this.name="VerificationError"}};var Dr=class extends Be{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,Ts(t);let n=He(e);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let o=this.blockLen,s=new Uint8Array(o);s.set(n.length>o?t.create().update(n).digest():n);for(let i=0;i<s.length;i++)s[i]^=54;this.iHash.update(s),this.oHash=t.create();for(let i=0;i<s.length;i++)s[i]^=106;this.oHash.update(s),s.fill(0)}update(t){return Ie(this),this.iHash.update(t),this}digestInto(t){Ie(this),Ae(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){let t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));let{oHash:e,iHash:n,finished:o,destroyed:s,blockLen:i,outputLen:a}=this;return t=t,t.finished=o,t.destroyed=s,t.blockLen=i,t.outputLen=a,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},vo=(r,t,e)=>new Dr(r,t).update(e).digest();vo.create=(r,t)=>new Dr(r,t);function di(r){r.lowS!==void 0&&vt("lowS",r.lowS),r.prehash!==void 0&&vt("prehash",r.prehash)}function Xu(r){let t=je(r);Rt(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:e,Fp:n,a:o}=t;if(e){if(!n.eql(o,n.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...t})}var{bytesToNumberBE:Wu,hexToBytes:Yu}=xr,So=class extends Error{constructor(t=""){super(t)}},jt={Err:So,_tlv:{encode:(r,t)=>{let{Err:e}=jt;if(r<0||r>256)throw new e("tlv.encode: wrong tag");if(t.length&1)throw new e("tlv.encode: unpadded data");let n=t.length/2,o=ce(n);if(o.length/2&128)throw new e("tlv.encode: long form length too big");let s=n>127?ce(o.length/2|128):"";return ce(r)+s+o+t},decode(r,t){let{Err:e}=jt,n=0;if(r<0||r>256)throw new e("tlv.encode: wrong tag");if(t.length<2||t[n++]!==r)throw new e("tlv.decode: wrong tlv");let o=t[n++],s=!!(o&128),i=0;if(!s)i=o;else{let c=o&127;if(!c)throw new e("tlv.decode(long): indefinite length not supported");if(c>4)throw new e("tlv.decode(long): byte length is too big");let l=t.subarray(n,n+c);if(l.length!==c)throw new e("tlv.decode: length bytes not complete");if(l[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(let h of l)i=i<<8|h;if(n+=c,i<128)throw new e("tlv.decode(long): not minimal encoding")}let a=t.subarray(n,n+i);if(a.length!==i)throw new e("tlv.decode: wrong value length");return{v:a,l:t.subarray(n+i)}}},_int:{encode(r){let{Err:t}=jt;if(r<Zt)throw new t("integer: negative integers are not allowed");let e=ce(r);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return e},decode(r){let{Err:t}=jt;if(r[0]&128)throw new t("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return Wu(r)}},toSig(r){let{Err:t,_int:e,_tlv:n}=jt,o=typeof r=="string"?Yu(r):r;Te(o);let{v:s,l:i}=n.decode(48,o);if(i.length)throw new t("invalid signature: left bytes after parsing");let{v:a,l:c}=n.decode(2,s),{v:l,l:h}=n.decode(2,c);if(h.length)throw new t("invalid signature: left bytes after parsing");return{r:e.decode(a),s:e.decode(l)}},hexFromSig(r){let{_tlv:t,_int:e}=jt,n=t.encode(2,e.encode(r.r)),o=t.encode(2,e.encode(r.s)),s=n+o;return t.encode(48,s)}},Zt=BigInt(0),ot=BigInt(1),a0=BigInt(2),pi=BigInt(3),c0=BigInt(4);function Qu(r){let t=Xu(r),{Fp:e}=t,n=ee(t.n,t.nBitLength),o=t.toBytes||((g,x,w)=>{let b=x.toAffine();return qt(Uint8Array.from([4]),e.toBytes(b.x),e.toBytes(b.y))}),s=t.fromBytes||(g=>{let x=g.subarray(1),w=e.fromBytes(x.subarray(0,e.BYTES)),b=e.fromBytes(x.subarray(e.BYTES,2*e.BYTES));return{x:w,y:b}});function i(g){let{a:x,b:w}=t,b=e.sqr(g),m=e.mul(b,g);return e.add(e.add(m,e.mul(g,x)),w)}if(!e.eql(e.sqr(t.Gy),i(t.Gx)))throw new Error("bad generator point: equation left != right");function a(g){return Ke(g,ot,t.n)}function c(g){let{allowedPrivateKeyLengths:x,nByteLength:w,wrapPrivateKey:b,n:m}=t;if(x&&typeof g!="bigint"){if(Qt(g)&&(g=Mt(g)),typeof g!="string"||!x.includes(g.length))throw new Error("invalid private key");g=g.padStart(w*2,"0")}let v;try{v=typeof g=="bigint"?g:zt(Y("private key",g,w))}catch{throw new Error("invalid private key, expected hex or "+w+" bytes, got "+typeof g)}return b&&(v=G(v,m)),pt("private key",v,ot,m),v}function l(g){if(!(g instanceof d))throw new Error("ProjectivePoint expected")}let h=le((g,x)=>{let{px:w,py:b,pz:m}=g;if(e.eql(m,e.ONE))return{x:w,y:b};let v=g.is0();x==null&&(x=v?e.ONE:e.inv(m));let _=e.mul(w,x),I=e.mul(b,x),y=e.mul(m,x);if(v)return{x:e.ZERO,y:e.ZERO};if(!e.eql(y,e.ONE))throw new Error("invZ was invalid");return{x:_,y:I}}),f=le(g=>{if(g.is0()){if(t.allowInfinityPoint&&!e.is0(g.py))return;throw new Error("bad point: ZERO")}let{x,y:w}=g.toAffine();if(!e.isValid(x)||!e.isValid(w))throw new Error("bad point: x or y not FE");let b=e.sqr(w),m=i(x);if(!e.eql(b,m))throw new Error("bad point: equation left != right");if(!g.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class d{constructor(x,w,b){if(this.px=x,this.py=w,this.pz=b,x==null||!e.isValid(x))throw new Error("x required");if(w==null||!e.isValid(w))throw new Error("y required");if(b==null||!e.isValid(b))throw new Error("z required");Object.freeze(this)}static fromAffine(x){let{x:w,y:b}=x||{};if(!x||!e.isValid(w)||!e.isValid(b))throw new Error("invalid affine point");if(x instanceof d)throw new Error("projective point not allowed");let m=v=>e.eql(v,e.ZERO);return m(w)&&m(b)?d.ZERO:new d(w,b,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(x){let w=e.invertBatch(x.map(b=>b.pz));return x.map((b,m)=>b.toAffine(w[m])).map(d.fromAffine)}static fromHex(x){let w=d.fromAffine(s(Y("pointHex",x)));return w.assertValidity(),w}static fromPrivateKey(x){return d.BASE.multiply(c(x))}static msm(x,w){return Er(d,n,x,w)}_setWindowSize(x){p.setWindowSize(this,x)}assertValidity(){f(this)}hasEvenY(){let{y:x}=this.toAffine();if(e.isOdd)return!e.isOdd(x);throw new Error("Field doesn't support isOdd")}equals(x){l(x);let{px:w,py:b,pz:m}=this,{px:v,py:_,pz:I}=x,y=e.eql(e.mul(w,I),e.mul(v,m)),B=e.eql(e.mul(b,I),e.mul(_,m));return y&&B}negate(){return new d(this.px,e.neg(this.py),this.pz)}double(){let{a:x,b:w}=t,b=e.mul(w,pi),{px:m,py:v,pz:_}=this,I=e.ZERO,y=e.ZERO,B=e.ZERO,T=e.mul(m,m),V=e.mul(v,v),F=e.mul(_,_),O=e.mul(m,v);return O=e.add(O,O),B=e.mul(m,_),B=e.add(B,B),I=e.mul(x,B),y=e.mul(b,F),y=e.add(I,y),I=e.sub(V,y),y=e.add(V,y),y=e.mul(I,y),I=e.mul(O,I),B=e.mul(b,B),F=e.mul(x,F),O=e.sub(T,F),O=e.mul(x,O),O=e.add(O,B),B=e.add(T,T),T=e.add(B,T),T=e.add(T,F),T=e.mul(T,O),y=e.add(y,T),F=e.mul(v,_),F=e.add(F,F),T=e.mul(F,O),I=e.sub(I,T),B=e.mul(F,V),B=e.add(B,B),B=e.add(B,B),new d(I,y,B)}add(x){l(x);let{px:w,py:b,pz:m}=this,{px:v,py:_,pz:I}=x,y=e.ZERO,B=e.ZERO,T=e.ZERO,V=t.a,F=e.mul(t.b,pi),O=e.mul(w,v),N=e.mul(b,_),L=e.mul(m,I),D=e.add(w,b),S=e.add(v,_);D=e.mul(D,S),S=e.add(O,N),D=e.sub(D,S),S=e.add(w,m);let E=e.add(v,I);return S=e.mul(S,E),E=e.add(O,L),S=e.sub(S,E),E=e.add(b,m),y=e.add(_,I),E=e.mul(E,y),y=e.add(N,L),E=e.sub(E,y),T=e.mul(V,S),y=e.mul(F,L),T=e.add(y,T),y=e.sub(N,T),T=e.add(N,T),B=e.mul(y,T),N=e.add(O,O),N=e.add(N,O),L=e.mul(V,L),S=e.mul(F,S),N=e.add(N,L),L=e.sub(O,L),L=e.mul(V,L),S=e.add(S,L),O=e.mul(N,S),B=e.add(B,O),O=e.mul(E,S),y=e.mul(D,y),y=e.sub(y,O),O=e.mul(D,N),T=e.mul(E,T),T=e.add(T,O),new d(y,B,T)}subtract(x){return this.add(x.negate())}is0(){return this.equals(d.ZERO)}wNAF(x){return p.wNAFCached(this,x,d.normalizeZ)}multiplyUnsafe(x){let{endo:w,n:b}=t;pt("scalar",x,Zt,b);let m=d.ZERO;if(x===Zt)return m;if(this.is0()||x===ot)return this;if(!w||p.hasPrecomputes(this))return p.wNAFCachedUnsafe(this,x,d.normalizeZ);let{k1neg:v,k1:_,k2neg:I,k2:y}=w.splitScalar(x),B=m,T=m,V=this;for(;_>Zt||y>Zt;)_&ot&&(B=B.add(V)),y&ot&&(T=T.add(V)),V=V.double(),_>>=ot,y>>=ot;return v&&(B=B.negate()),I&&(T=T.negate()),T=new d(e.mul(T.px,w.beta),T.py,T.pz),B.add(T)}multiply(x){let{endo:w,n:b}=t;pt("scalar",x,ot,b);let m,v;if(w){let{k1neg:_,k1:I,k2neg:y,k2:B}=w.splitScalar(x),{p:T,f:V}=this.wNAF(I),{p:F,f:O}=this.wNAF(B);T=p.constTimeNegate(_,T),F=p.constTimeNegate(y,F),F=new d(e.mul(F.px,w.beta),F.py,F.pz),m=T.add(F),v=V.add(O)}else{let{p:_,f:I}=this.wNAF(x);m=_,v=I}return d.normalizeZ([m,v])[0]}multiplyAndAddUnsafe(x,w,b){let m=d.BASE,v=(I,y)=>y===Zt||y===ot||!I.equals(m)?I.multiplyUnsafe(y):I.multiply(y),_=v(this,w).add(v(x,b));return _.is0()?void 0:_}toAffine(x){return h(this,x)}isTorsionFree(){let{h:x,isTorsionFree:w}=t;if(x===ot)return!0;if(w)return w(d,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:x,clearCofactor:w}=t;return x===ot?this:w?w(d,this):this.multiplyUnsafe(t.h)}toRawBytes(x=!0){return vt("isCompressed",x),this.assertValidity(),o(d,this,x)}toHex(x=!0){return vt("isCompressed",x),Mt(this.toRawBytes(x))}}d.BASE=new d(t.Gx,t.Gy,e.ONE),d.ZERO=new d(e.ZERO,e.ONE,e.ZERO);let u=t.nBitLength,p=yr(d,t.endo?Math.ceil(u/2):u);return{CURVE:t,ProjectivePoint:d,normPrivateKeyToScalar:c,weierstrassEquation:i,isWithinCurveOrder:a}}function Ju(r){let t=je(r);return Rt(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function mi(r){let t=Ju(r),{Fp:e,n}=t,o=e.BYTES+1,s=2*e.BYTES+1;function i(L){return G(L,n)}function a(L){return wr(L,n)}let{ProjectivePoint:c,normPrivateKeyToScalar:l,weierstrassEquation:h,isWithinCurveOrder:f}=Qu({...t,toBytes(L,D,S){let E=D.toAffine(),A=e.toBytes(E.x),R=qt;return vt("isCompressed",S),S?R(Uint8Array.from([D.hasEvenY()?2:3]),A):R(Uint8Array.from([4]),A,e.toBytes(E.y))},fromBytes(L){let D=L.length,S=L[0],E=L.subarray(1);if(D===o&&(S===2||S===3)){let A=zt(E);if(!Ke(A,ot,e.ORDER))throw new Error("Point is not on curve");let R=h(A),P;try{P=e.sqrt(R)}catch(z){let U=z instanceof Error?": "+z.message:"";throw new Error("Point is not on curve"+U)}let k=(P&ot)===ot;return(S&1)===1!==k&&(P=e.neg(P)),{x:A,y:P}}else if(D===s&&S===4){let A=e.fromBytes(E.subarray(0,e.BYTES)),R=e.fromBytes(E.subarray(e.BYTES,2*e.BYTES));return{x:A,y:R}}else{let A=o,R=s;throw new Error("invalid Point, expected length of "+A+", or uncompressed "+R+", got "+D)}}}),d=L=>Mt(te(L,t.nByteLength));function u(L){let D=n>>ot;return L>D}function p(L){return u(L)?i(-L):L}let g=(L,D,S)=>zt(L.slice(D,S));class x{constructor(D,S,E){this.r=D,this.s=S,this.recovery=E,this.assertValidity()}static fromCompact(D){let S=t.nByteLength;return D=Y("compactSignature",D,S*2),new x(g(D,0,S),g(D,S,2*S))}static fromDER(D){let{r:S,s:E}=jt.toSig(Y("DER",D));return new x(S,E)}assertValidity(){pt("r",this.r,ot,n),pt("s",this.s,ot,n)}addRecoveryBit(D){return new x(this.r,this.s,D)}recoverPublicKey(D){let{r:S,s:E,recovery:A}=this,R=I(Y("msgHash",D));if(A==null||![0,1,2,3].includes(A))throw new Error("recovery id invalid");let P=A===2||A===3?S+t.n:S;if(P>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");let k=A&1?"03":"02",M=c.fromHex(k+d(P)),z=a(P),U=i(-R*z),H=i(E*z),j=c.BASE.multiplyAndAddUnsafe(M,U,H);if(!j)throw new Error("point at infinify");return j.assertValidity(),j}hasHighS(){return u(this.s)}normalizeS(){return this.hasHighS()?new x(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return ue(this.toDERHex())}toDERHex(){return jt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ue(this.toCompactHex())}toCompactHex(){return d(this.r)+d(this.s)}}let w={isValidPrivateKey(L){try{return l(L),!0}catch{return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{let L=Cn(t.n);return Vs(t.randomBytes(L),t.n)},precompute(L=8,D=c.BASE){return D._setWindowSize(L),D.multiply(BigInt(3)),D}};function b(L,D=!0){return c.fromPrivateKey(L).toRawBytes(D)}function m(L){let D=Qt(L),S=typeof L=="string",E=(D||S)&&L.length;return D?E===o||E===s:S?E===2*o||E===2*s:L instanceof c}function v(L,D,S=!0){if(m(L))throw new Error("first arg must be private key");if(!m(D))throw new Error("second arg must be public key");return c.fromHex(D).multiply(l(L)).toRawBytes(S)}let _=t.bits2int||function(L){if(L.length>8192)throw new Error("input is too large");let D=zt(L),S=L.length*8-t.nBitLength;return S>0?D>>BigInt(S):D},I=t.bits2int_modN||function(L){return i(_(L))},y=Ge(t.nBitLength);function B(L){return pt("num < 2^"+t.nBitLength,L,Zt,y),te(L,t.nByteLength)}function T(L,D,S=V){if(["recovered","canonical"].some(nt=>nt in S))throw new Error("sign() legacy options not supported");let{hash:E,randomBytes:A}=t,{lowS:R,prehash:P,extraEntropy:k}=S;R==null&&(R=!0),L=Y("msgHash",L),di(S),P&&(L=Y("prehashed msgHash",E(L)));let M=I(L),z=l(D),U=[B(z),B(M)];if(k!=null&&k!==!1){let nt=k===!0?A(e.BYTES):k;U.push(Y("extraEntropy",nt))}let H=qt(...U),j=M;function rt(nt){let st=_(nt);if(!f(st))return;let it=a(st),ht=c.BASE.multiply(st).toAffine(),ft=i(ht.x);if(ft===Zt)return;let Lt=i(it*i(j+ft*z));if(Lt===Zt)return;let Dt=(ht.x===ft?0:2)|Number(ht.y&ot),Ce=Lt;return R&&u(Lt)&&(Ce=p(Lt),Dt^=1),new x(ft,Ce,Dt)}return{seed:H,k2sig:rt}}let V={lowS:t.lowS,prehash:!1},F={lowS:t.lowS,prehash:!1};function O(L,D,S=V){let{seed:E,k2sig:A}=T(L,D,S),R=t;return Nn(R.hash.outputLen,R.nByteLength,R.hmac)(E,A)}c.BASE._setWindowSize(8);function N(L,D,S,E=F){let A=L;D=Y("msgHash",D),S=Y("publicKey",S);let{lowS:R,prehash:P,format:k}=E;if(di(E),"strict"in E)throw new Error("options.strict was renamed to lowS");if(k!==void 0&&k!=="compact"&&k!=="der")throw new Error("format must be compact or der");let M=typeof A=="string"||Qt(A),z=!M&&!k&&typeof A=="object"&&A!==null&&typeof A.r=="bigint"&&typeof A.s=="bigint";if(!M&&!z)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let U,H;try{if(z&&(U=new x(A.r,A.s)),M){try{k!=="compact"&&(U=x.fromDER(A))}catch(Dt){if(!(Dt instanceof jt.Err))throw Dt}!U&&k!=="der"&&(U=x.fromCompact(A))}H=c.fromHex(S)}catch{return!1}if(!U||R&&U.hasHighS())return!1;P&&(D=t.hash(D));let{r:j,s:rt}=U,nt=I(D),st=a(rt),it=i(nt*st),ht=i(j*st),ft=c.BASE.multiplyAndAddUnsafe(H,it,ht)?.toAffine();return ft?i(ft.x)===j:!1}return{CURVE:t,getPublicKey:b,getSharedSecret:v,sign:O,verify:N,ProjectivePoint:c,Signature:x,utils:w}}function tf(r){return{hash:r,hmac:(t,...e)=>vo(r,t,An(...e)),randomBytes:dr}}function gi(r,t){let e=n=>mi({...r,...tf(n)});return{...e(t),create:e}}var bi=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),xi=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),ef=BigInt(1),_o=BigInt(2),wi=(r,t)=>(r+t/_o)/t;function rf(r){let t=bi,e=BigInt(3),n=BigInt(6),o=BigInt(11),s=BigInt(22),i=BigInt(23),a=BigInt(44),c=BigInt(88),l=r*r*r%t,h=l*l*r%t,f=X(h,e,t)*h%t,d=X(f,e,t)*h%t,u=X(d,_o,t)*l%t,p=X(u,o,t)*u%t,g=X(p,s,t)*p%t,x=X(g,a,t)*g%t,w=X(x,c,t)*x%t,b=X(w,a,t)*g%t,m=X(b,e,t)*h%t,v=X(m,i,t)*p%t,_=X(v,n,t)*l%t,I=X(_,_o,t);if(!Ao.eql(Ao.sqr(I),r))throw new Error("Cannot find square root");return I}var Ao=ee(bi,void 0,void 0,{sqrt:rf}),me=gi({a:BigInt(0),b:BigInt(7),Fp:Ao,n:xi,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{let t=xi,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-ef*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=e,i=BigInt("0x100000000000000000000000000000000"),a=wi(s*r,t),c=wi(-n*r,t),l=G(r-a*e-c*o,t),h=G(-a*n-c*s,t),f=l>i,d=h>i;if(f&&(l=t-l),d&&(h=t-h),l>i||h>i)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:f,k1:l,k2neg:d,k2:h}}}},hi),x0=BigInt(0);var w0=me.ProjectivePoint;function bt(r,t){t==null&&(t=r.reduce((o,s)=>o+s.length,0));let e=gt(t),n=0;for(let o of r)e.set(o,n),n+=o.length;return e}function yi(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}function Ei(r,t,e){let n=Ze.digest(e instanceof Uint8Array?e:e.subarray());if(yi(n))return n.then(({digest:o})=>me.verify(t,o,r)).catch(o=>{throw new Qe(String(o))});try{return me.verify(t,n.digest,r)}catch(o){throw new Qe(String(o))}}var Nr=class{type="secp256k1";raw;_key;constructor(t){this._key=Si(t),this.raw=vi(this._key)}toMultihash(){return Ot.digest(Ar(this))}toCID(){return lt.createV1(114,this.toMultihash())}toString(){return W.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:xt(this.raw,t.raw)}verify(t,e){return Ei(this._key,e,t)}};function _i(r){return new Nr(r)}function vi(r){return me.ProjectivePoint.fromHex(r).toRawBytes(!0)}function Si(r){try{return me.ProjectivePoint.fromHex(r),r}catch(t){throw new ar(String(t))}}function Ai(r){let{Type:t,Data:e}=Ye.decode(r.digest),n=e??new Uint8Array;switch(t){case yt.Ed25519:return Qs(n);case yt.secp256k1:return _i(n);default:throw new Fe}}function Ar(r){return Ye.encode({Type:yt[r.type],Data:r.raw})}var Ii=Symbol.for("nodejs.util.inspect.custom"),nf=114,Je=class{type;multihash;publicKey;string;constructor(t){this.type=t.type,this.multihash=t.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}[pn]=!0;toString(){return this.string==null&&(this.string=W.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return lt.createV1(nf,this.multihash)}toJSON(){return this.toString()}equals(t){if(t==null)return!1;if(t instanceof Uint8Array)return xt(this.multihash.bytes,t);if(typeof t=="string")return this.toString()===t;if(t?.toMultihash()?.bytes!=null)return xt(this.multihash.bytes,t.toMultihash().bytes);throw new Error("not valid Id")}[Ii](){return`PeerId(${this.toString()})`}},Pr=class extends Je{type="RSA";publicKey;constructor(t){super({...t,type:"RSA"}),this.publicKey=t.publicKey}},kr=class extends Je{type="Ed25519";publicKey;constructor(t){super({...t,type:"Ed25519"}),this.publicKey=t.publicKey}},Ur=class extends Je{type="secp256k1";publicKey;constructor(t){super({...t,type:"secp256k1"}),this.publicKey=t.publicKey}},of=2336,Cr=class{type="url";multihash;publicKey;url;constructor(t){this.url=t.toString(),this.multihash=Ot.digest(tt(this.url))}[Ii](){return`PeerId(${this.url})`}[pn]=!0;toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return lt.createV1(of,this.toMultihash())}toJSON(){return this.toString()}equals(t){return t==null?!1:(t instanceof Uint8Array&&(t=et(t)),t.toString()===this.toString())}};function Or(r){if(af(r))return new Pr({multihash:r});if(sf(r))try{let t=Ai(r);if(t.type==="Ed25519")return new kr({multihash:r,publicKey:t});if(t.type==="secp256k1")return new Ur({multihash:r,publicKey:t})}catch{let e=et(r.digest);return new Cr(new URL(e))}throw new cr("Supplied PeerID Multihash is invalid")}function sf(r){return r.code===Ot.code}function af(r){return r.code===Ze.code}function Io(r,t){let e={[Symbol.iterator]:()=>e,next:()=>{let n=r.next(),o=n.value;return n.done===!0||o==null?{done:!0,value:void 0}:{done:!1,value:t(o)}}};return e}function Fr(r){let t=Ut(W.decode(`z${r}`));return Or(t)}var Mr=class r{set;constructor(t){if(this.set=new Set,t!=null)for(let e of t)this.set.add(e.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(t){this.set.add(t.toString())}clear(){this.set.clear()}delete(t){this.set.delete(t.toString())}entries(){return Io(this.set.entries(),t=>{let e=Fr(t[0]);return[e,e]})}forEach(t){this.set.forEach(e=>{let n=Fr(e);t(n,n,this)})}has(t){return this.set.has(t.toString())}values(){return Io(this.set.values(),t=>Fr(t))}intersection(t){let e=new r;for(let n of t)this.has(n)&&e.add(n);return e}difference(t){let e=new r;for(let n of this)t.has(n)||e.add(n);return e}union(t){let e=new r;for(let n of t)e.add(n);for(let n of this)e.add(n);return e}};function Bo(){return new Mr}var Di=Symbol.for("@achingbrain/uint8arraylist");function Ri(r,t){if(t==null||t<0)throw new RangeError("index is out of bounds");let e=0;for(let n of r){let o=e+n.byteLength;if(t<o)return{buf:n,index:t-e};e=o}throw new RangeError("index is out of bounds")}function qr(r){return!!r?.[Di]}var $t=class r{bufs;length;[Di]=!0;constructor(...t){this.bufs=[],this.length=0,t.length>0&&this.appendAll(t)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...t){this.appendAll(t)}appendAll(t){let e=0;for(let n of t)if(n instanceof Uint8Array)e+=n.byteLength,this.bufs.push(n);else if(qr(n))e+=n.byteLength,this.bufs.push(...n.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}prepend(...t){this.prependAll(t)}prependAll(t){let e=0;for(let n of t.reverse())if(n instanceof Uint8Array)e+=n.byteLength,this.bufs.unshift(n);else if(qr(n))e+=n.byteLength,this.bufs.unshift(...n.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}get(t){let e=Ri(this.bufs,t);return e.buf[e.index]}set(t,e){let n=Ri(this.bufs,t);n.buf[n.index]=e}write(t,e=0){if(t instanceof Uint8Array)for(let n=0;n<t.length;n++)this.set(e+n,t[n]);else if(qr(t))for(let n=0;n<t.length;n++)this.set(e+n,t.get(n));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(t){if(t=Math.trunc(t),!(Number.isNaN(t)||t<=0)){if(t===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(t>=this.bufs[0].byteLength)t-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(t),this.length-=t;break}}}slice(t,e){let{bufs:n,length:o}=this._subList(t,e);return bt(n,o)}subarray(t,e){let{bufs:n,length:o}=this._subList(t,e);return n.length===1?n[0]:bt(n,o)}sublist(t,e){let{bufs:n,length:o}=this._subList(t,e),s=new r;return s.length=o,s.bufs=[...n],s}_subList(t,e){if(t=t??0,e=e??this.length,t<0&&(t=this.length+t),e<0&&(e=this.length+e),t<0||e>this.length)throw new RangeError("index is out of bounds");if(t===e)return{bufs:[],length:0};if(t===0&&e===this.length)return{bufs:this.bufs,length:this.length};let n=[],o=0;for(let s=0;s<this.bufs.length;s++){let i=this.bufs[s],a=o,c=a+i.byteLength;if(o=c,t>=c)continue;let l=t>=a&&t<c,h=e>a&&e<=c;if(l&&h){if(t===a&&e===c){n.push(i);break}let f=t-a;n.push(i.subarray(f,f+(e-t)));break}if(l){if(t===0){n.push(i);continue}n.push(i.subarray(t-a));continue}if(h){if(e===c){n.push(i);break}n.push(i.subarray(0,e-a));break}n.push(i)}return{bufs:n,length:e-t}}indexOf(t,e=0){if(!qr(t)&&!(t instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');let n=t instanceof Uint8Array?t:t.subarray();if(e=Number(e??0),isNaN(e)&&(e=0),e<0&&(e=this.length+e),e<0&&(e=0),t.length===0)return e>this.length?this.length:e;let o=n.byteLength;if(o===0)throw new TypeError("search must be at least 1 byte long");let s=256,i=new Int32Array(s);for(let f=0;f<s;f++)i[f]=-1;for(let f=0;f<o;f++)i[n[f]]=f;let a=i,c=this.byteLength-n.byteLength,l=n.byteLength-1,h;for(let f=e;f<=c;f+=h){h=0;for(let d=l;d>=0;d--){let u=this.get(f+d);if(n[d]!==u){h=Math.max(1,d-a[u]);break}}if(h===0)return f}return-1}getInt8(t){let e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getInt8(0)}setInt8(t,e){let n=gt(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt8(0,e),this.write(n,t)}getInt16(t,e){let n=this.subarray(t,t+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt16(0,e)}setInt16(t,e,n){let o=_t(2);new DataView(o.buffer,o.byteOffset,o.byteLength).setInt16(0,e,n),this.write(o,t)}getInt32(t,e){let n=this.subarray(t,t+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt32(0,e)}setInt32(t,e,n){let o=_t(4);new DataView(o.buffer,o.byteOffset,o.byteLength).setInt32(0,e,n),this.write(o,t)}getBigInt64(t,e){let n=this.subarray(t,t+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigInt64(0,e)}setBigInt64(t,e,n){let o=_t(8);new DataView(o.buffer,o.byteOffset,o.byteLength).setBigInt64(0,e,n),this.write(o,t)}getUint8(t){let e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getUint8(0)}setUint8(t,e){let n=gt(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint8(0,e),this.write(n,t)}getUint16(t,e){let n=this.subarray(t,t+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint16(0,e)}setUint16(t,e,n){let o=_t(2);new DataView(o.buffer,o.byteOffset,o.byteLength).setUint16(0,e,n),this.write(o,t)}getUint32(t,e){let n=this.subarray(t,t+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint32(0,e)}setUint32(t,e,n){let o=_t(4);new DataView(o.buffer,o.byteOffset,o.byteLength).setUint32(0,e,n),this.write(o,t)}getBigUint64(t,e){let n=this.subarray(t,t+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigUint64(0,e)}setBigUint64(t,e,n){let o=_t(8);new DataView(o.buffer,o.byteOffset,o.byteLength).setBigUint64(0,e,n),this.write(o,t)}getFloat32(t,e){let n=this.subarray(t,t+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat32(0,e)}setFloat32(t,e,n){let o=_t(4);new DataView(o.buffer,o.byteOffset,o.byteLength).setFloat32(0,e,n),this.write(o,t)}getFloat64(t,e){let n=this.subarray(t,t+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat64(0,e)}setFloat64(t,e,n){let o=_t(8);new DataView(o.buffer,o.byteOffset,o.byteLength).setFloat64(0,e,n),this.write(o,t)}equals(t){if(t==null||!(t instanceof r)||t.bufs.length!==this.bufs.length)return!1;for(let e=0;e<this.bufs.length;e++)if(!xt(this.bufs[e],t.bufs[e]))return!1;return!0}static fromUint8Arrays(t,e){let n=new r;return n.bufs=t,e==null&&(e=t.reduce((o,s)=>o+s.byteLength,0)),n.length=e,n}};var Lo=64,It=class{fp;h;seed;constructor(t,e,n,o=2){if(o>Lo)throw new TypeError("Invalid Fingerprint Size");let s=e.hashV(t,n),i=_t(o);for(let a=0;a<i.length;a++)i[a]=s[a];i.length===0&&(i[0]=7),this.fp=i,this.h=e,this.seed=n}hash(){return this.h.hash(this.fp,this.seed)}equals(t){return t?.fp instanceof Uint8Array?xt(this.fp,t.fp):!1}};function ge(r,t){return Math.floor(Math.random()*(t-r))+r}var xe=class{contents;constructor(t){this.contents=new Array(t).fill(null)}has(t){if(!(t instanceof It))throw new TypeError("Invalid Fingerprint");return this.contents.some(e=>t.equals(e))}add(t){if(!(t instanceof It))throw new TypeError("Invalid Fingerprint");for(let e=0;e<this.contents.length;e++)if(this.contents[e]==null)return this.contents[e]=t,!0;return!0}swap(t){if(!(t instanceof It))throw new TypeError("Invalid Fingerprint");let e=ge(0,this.contents.length-1),n=this.contents[e];return this.contents[e]=t,n}remove(t){if(!(t instanceof It))throw new TypeError("Invalid Fingerprint");let e=this.contents.findIndex(n=>t.equals(n));return e>-1?(this.contents[e]=null,!0):!1}};var To={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},Ni={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},Pi=new globalThis.TextEncoder;function cf(r,t){let e=To[t],n=Ni[t];for(let o=0;o<r.length;o++)n^=BigInt(r[o]),n=BigInt.asUintN(t,n*e);return n}function uf(r,t,e){if(e.length===0)throw new Error("The `utf8Buffer` option must have a length greater than zero");let n=To[t],o=Ni[t],s=r;for(;s.length>0;){let i=Pi.encodeInto(s,e);s=s.slice(i.read);for(let a=0;a<i.written;a++)o^=BigInt(e[a]),o=BigInt.asUintN(t,o*n)}return o}function Ro(r,{size:t=32,utf8Buffer:e}={}){if(!To[t])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if(typeof r=="string"){if(e)return uf(r,t,e);r=Pi.encode(r)}return cf(r,t)}var ff=fs(Ti(),1);var er={hash:r=>Number(Ro(r,{size:32})),hashV:(r,t)=>lf(er.hash(r,t))};function lf(r){let t=r.toString(16);return t.length%2===1&&(t=`0${t}`),tt(t,"base16")}var hf=500,rr=class{bucketSize;filterSize;fingerprintSize;buckets;count;hash;seed;constructor(t){this.filterSize=t.filterSize,this.bucketSize=t.bucketSize??4,this.fingerprintSize=t.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=t.hash??er,this.seed=t.seed??ge(0,Math.pow(2,10))}add(t){typeof t=="string"&&(t=tt(t));let e=new It(t,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(t,this.seed)%this.filterSize,o=(n^e.hash())%this.filterSize;if(this.buckets[n]==null&&(this.buckets[n]=new xe(this.bucketSize)),this.buckets[o]==null&&(this.buckets[o]=new xe(this.bucketSize)),this.buckets[n].add(e)||this.buckets[o].add(e))return this.count++,!0;let s=[n,o],i=s[ge(0,s.length-1)];this.buckets[i]==null&&(this.buckets[i]=new xe(this.bucketSize));for(let a=0;a<hf;a++){let c=this.buckets[i].swap(e);if(c!=null&&(i=(i^c.hash())%this.filterSize,this.buckets[i]==null&&(this.buckets[i]=new xe(this.bucketSize)),this.buckets[i].add(c)))return this.count++,!0}return!1}has(t){typeof t=="string"&&(t=tt(t));let e=new It(t,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(t,this.seed)%this.filterSize,o=this.buckets[n]?.has(e)??!1;if(o)return o;let s=(n^e.hash())%this.filterSize;return this.buckets[s]?.has(e)??!1}remove(t){typeof t=="string"&&(t=tt(t));let e=new It(t,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(t,this.seed)%this.filterSize,o=this.buckets[n]?.remove(e)??!1;if(o)return this.count--,o;let s=(n^e.hash())%this.filterSize,i=this.buckets[s]?.remove(e)??!1;return i&&this.count--,i}get reliable(){return Math.floor(100*(this.count/this.filterSize))<=90}},df={1:.5,2:.84,4:.95,8:.98};function pf(r=.001){return r>.002?2:r>1e-5?4:8}function ki(r,t=.001){let e=pf(t),n=df[e],o=Math.round(r/n),s=Math.min(Math.ceil(Math.log2(1/t)+Math.log2(2*e)),Lo);return{filterSize:o,bucketSize:e,fingerprintSize:s}}var Vr=class{filterSize;bucketSize;fingerprintSize;scale;filterSeries;hash;seed;constructor(t){this.bucketSize=t.bucketSize??4,this.filterSize=t.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=t.fingerprintSize??2,this.scale=t.scale??2,this.hash=t.hash??er,this.seed=t.seed??ge(0,Math.pow(2,10)),this.filterSeries=[new rr({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(t){if(typeof t=="string"&&(t=tt(t)),this.has(t))return!0;let e=this.filterSeries.find(n=>n.reliable);if(e==null){let n=this.filterSize*Math.pow(this.scale,this.filterSeries.length);e=new rr({filterSize:n,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(e)}return e.add(t)}has(t){typeof t=="string"&&(t=tt(t));for(let e=0;e<this.filterSeries.length;e++)if(this.filterSeries[e].has(t))return!0;return!1}remove(t){typeof t=="string"&&(t=tt(t));for(let e=0;e<this.filterSeries.length;e++)if(this.filterSeries[e].remove(t))return!0;return!1}get count(){return this.filterSeries.reduce((t,e)=>t+e.count,0)}};function Do(r,t=.001,e){return new Vr({...ki(r,t),...e??{}})}var Hr=class{index=0;input="";new(t){return this.index=0,this.input=t,this}readAtomically(t){let e=this.index,n=t();return n===void 0&&(this.index=e),n}parseWith(t){let e=t();if(this.index===this.input.length)return e}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(t){return this.readAtomically(()=>{let e=this.readChar();if(e===t)return e})}readSeparator(t,e,n){return this.readAtomically(()=>{if(!(e>0&&this.readGivenChar(t)===void 0))return n()})}readNumber(t,e,n,o){return this.readAtomically(()=>{let s=0,i=0,a=this.peekChar();if(a===void 0)return;let c=a==="0",l=2**(8*o)-1;for(;;){let h=this.readAtomically(()=>{let f=this.readChar();if(f===void 0)return;let d=Number.parseInt(f,t);if(!Number.isNaN(d))return d});if(h===void 0)break;if(s*=t,s+=h,s>l||(i+=1,e!==void 0&&i>e))return}if(i!==0)return!n&&c&&i>1?void 0:s})}readIPv4Addr(){return this.readAtomically(()=>{let t=new Uint8Array(4);for(let e=0;e<t.length;e++){let n=this.readSeparator(".",e,()=>this.readNumber(10,3,!1,1));if(n===void 0)return;t[e]=n}return t})}readIPv6Addr(){let t=e=>{for(let n=0;n<e.length/2;n++){let o=n*2;if(n<e.length-3){let i=this.readSeparator(":",n,()=>this.readIPv4Addr());if(i!==void 0)return e[o]=i[0],e[o+1]=i[1],e[o+2]=i[2],e[o+3]=i[3],[o+4,!0]}let s=this.readSeparator(":",n,()=>this.readNumber(16,4,!0,2));if(s===void 0)return[o,!1];e[o]=s>>8,e[o+1]=s&255}return[e.length,!1]};return this.readAtomically(()=>{let e=new Uint8Array(16),[n,o]=t(e);if(n===16)return e;if(o||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;let s=new Uint8Array(14),i=16-(n+2),[a]=t(s.subarray(0,i));return e.set(s.subarray(0,a),16-a),e})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}};var Ui=45,mf=15,Ne=new Hr;function Kr(r){if(!(r.length>mf))return Ne.new(r).parseWith(()=>Ne.readIPv4Addr())}function Gr(r){if(r.includes("%")&&(r=r.split("%")[0]),!(r.length>Ui))return Ne.new(r).parseWith(()=>Ne.readIPv6Addr())}function we(r){if(r.includes("%")&&(r=r.split("%")[0]),!(r.length>Ui))return Ne.new(r).parseWith(()=>Ne.readIPAddr())}function Ci(r,t,e){let n=0;for(let o of r)if(!(n<t)){if(n>e)break;if(o!==255)return!1;n++}return!0}function Oi(r,t,e,n){let o=0;for(let s of r)if(!(o<e)){if(o>n)break;if(s!==t[o])return!1;o++}return!0}function No(r){switch(r.length){case be:return r.join(".");case ye:{let t=[];for(let e=0;e<r.length;e++)e%2===0&&t.push(r[e].toString(16).padStart(2,"0")+r[e+1].toString(16).padStart(2,"0"));return t.join(":")}default:throw new Error("Invalid ip length")}}function Fi(r){let t=0;for(let[e,n]of r.entries()){if(n===255){t+=8;continue}for(;n&128;)t++,n=n<<1;if(n&128)return-1;for(let o=e+1;o<r.length;o++)if(r[o]!=0)return-1;break}return t}function Mi(r){let t="0x";for(let e of r)t+=(e>>4).toString(16)+(e&15).toString(16);return t}var be=4,ye=16,dm=parseInt("0xFFFF",16),gf=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function nr(r,t){t.length===ye&&r.length===be&&Ci(t,0,11)&&(t=t.slice(12)),t.length===be&&r.length===ye&&Oi(r,gf,0,11)&&(r=r.slice(12));let e=r.length;if(e!=t.length)throw new Error("Failed to mask ip");let n=new Uint8Array(e);for(let o=0;o<e;o++)n[o]=r[o]&t[o];return n}function zi(r,t){if(typeof t=="string"&&(t=we(t)),t==null)throw new Error("Invalid ip");if(t.length!==r.network.length)return!1;for(let e=0;e<t.length;e++)if((r.network[e]&r.mask[e])!==(t[e]&r.mask[e]))return!1;return!0}function Po(r){let[t,e]=r.split("/");if(!t||!e)throw new Error("Failed to parse given CIDR: "+r);let n=be,o=Kr(t);if(o==null&&(n=ye,o=Gr(t),o==null))throw new Error("Failed to parse given CIDR: "+r);let s=parseInt(e,10);if(Number.isNaN(s)||String(s).length!==e.length||s<0||s>n*8)throw new Error("Failed to parse given CIDR: "+r);let i=ko(s,8*n);return{network:nr(o,i),mask:i}}function ko(r,t){if(t!==8*be&&t!==8*ye)throw new Error("Invalid CIDR mask");if(r<0||r>t)throw new Error("Invalid CIDR mask");let e=t/8,n=new Uint8Array(e);for(let o=0;o<e;o++){if(r>=8){n[o]=255,r-=8;continue}n[o]=255-(255>>r),r=0}return n}var Pe=class{constructor(t,e){if(e==null)({network:this.network,mask:this.mask}=Po(t));else{let n=we(t);if(n==null)throw new Error("Failed to parse network");e=String(e);let o=parseInt(e,10);if(Number.isNaN(o)||String(o).length!==e.length||o<0||o>n.length*8){let s=we(e);if(s==null)throw new Error("Failed to parse mask");this.mask=s}else this.mask=ko(o,8*n.length);this.network=nr(n,this.mask)}}contains(t){return zi({network:this.network,mask:this.mask},t)}toString(){let t=Fi(this.mask),e=t!==-1?String(t):Mi(this.mask);return No(this.network)+"/"+e}};function qi(r,t){return new Pe(r).contains(t)}var xf=41;function Vi(r){try{let[[t,e]]=r.stringTuples();if(e==null)return!1;if(t===xf)return qi("2000::/3",e)}catch{}return!1}function jr(r){return!!Kr(r)}function Zr(r){return!!Gr(r)}function $r(r){return!!we(r)}var Ki=fs(Hi(),1),wf=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"],bf=wf.map(r=>new Ki.Netmask(r));function Uo(r){for(let t of bf)if(t.contains(r))return!0;return!1}function yf(r){return/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(r)}function Ef(r){let t=r.split(":");if(t.length<2)return!1;let e=t[t.length-1].padStart(4,"0"),n=t[t.length-2].padStart(4,"0"),o=`${parseInt(n.substring(0,2),16)}.${parseInt(n.substring(2),16)}.${parseInt(e.substring(0,2),16)}.${parseInt(e.substring(2),16)}`;return Uo(o)}function vf(r){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)}function Sf(r){let t=r.split(":"),e=t[t.length-1];return Uo(e)}function _f(r){return/^::$/.test(r)||/^::1$/.test(r)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(r)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(r)||/^ff([0-9a-fA-F]{2,2}):/i.test(r)}function Gi(r){return jr(r)?Uo(r):yf(r)?Ef(r):vf(r)?Sf(r):Zr(r)?_f(r):void 0}var Af=4,If=41,Bf=53,Lf=54,Tf=55,Rf=56;function Co(r){try{let[[t,e]]=r.stringTuples();if(e==null)return!0;if(t===Bf||t===Lf||t===Tf||t===Rf)return!1;if(t===Af||t===If)return Gi(e)??!1}catch{}return!0}function Bt(){let r={};return r.promise=new Promise((t,e)=>{r.resolve=t,r.reject=e}),r}var Xr=class{buffer;mask;top;btm;next;constructor(t){if(!(t>0)||t-1&t)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(t),this.mask=t-1,this.top=0,this.btm=0,this.next=null}push(t){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=t,this.top=this.top+1&this.mask,!0)}shift(){let t=this.buffer[this.btm];if(t!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,t}isEmpty(){return this.buffer[this.btm]===void 0}},ke=class{size;hwm;head;tail;constructor(t={}){this.hwm=t.splitLimit??16,this.head=new Xr(this.hwm),this.tail=this.head,this.size=0}calculateSize(t){return t?.byteLength!=null?t.byteLength:1}push(t){if(t?.value!=null&&(this.size+=this.calculateSize(t.value)),!this.head.push(t)){let e=this.head;this.head=e.next=new Xr(2*this.head.buffer.length),this.head.push(t)}}shift(){let t=this.tail.shift();if(t===void 0&&this.tail.next!=null){let e=this.tail.next;this.tail.next=null,this.tail=e,t=this.tail.shift()}return t?.value!=null&&(this.size-=this.calculateSize(t.value)),t}isEmpty(){return this.head.isEmpty()}};var Oo=class extends Error{type;code;constructor(t,e){super(t??"The operation was aborted"),this.type="aborted",this.code=e??"ABORT_ERR"}};function ji(r={}){return Df(e=>{let n=e.shift();if(n==null)return{done:!0};if(n.error!=null)throw n.error;return{done:n.done===!0,value:n.value}},r)}function Df(r,t){t=t??{};let e=t.onEnd,n=new ke,o,s,i,a=Bt(),c=async()=>{try{return n.isEmpty()?i?{done:!0}:await new Promise((x,w)=>{s=b=>{s=null,n.push(b);try{x(r(n))}catch(m){w(m)}return o}}):r(n)}finally{n.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=Bt()})}},l=x=>s!=null?s(x):(n.push(x),o),h=x=>(n=new ke,s!=null?s({error:x}):(n.push({error:x}),o)),f=x=>{if(i)return o;if(t?.objectMode!==!0&&x?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return l({done:!1,value:x})},d=x=>i?o:(i=!0,x!=null?h(x):l({done:!0})),u=()=>(n=new ke,d(),{done:!0}),p=x=>(d(x),{done:!0});if(o={[Symbol.asyncIterator](){return this},next:c,return:u,throw:p,push:f,end:d,get readableLength(){return n.size},onEmpty:async x=>{let w=x?.signal;if(w?.throwIfAborted(),n.isEmpty())return;let b,m;w!=null&&(b=new Promise((v,_)=>{m=()=>{_(new Oo)},w.addEventListener("abort",m)}));try{await Promise.race([a.promise,b])}finally{m!=null&&w!=null&&w?.removeEventListener("abort",m)}}},e==null)return o;let g=o;return o={[Symbol.asyncIterator](){return this},next(){return g.next()},throw(x){return g.throw(x),e!=null&&(e(x),e=void 0),{done:!0}},return(){return g.return(),e!=null&&(e(),e=void 0),{done:!0}},push:f,end(x){return g.end(x),e!=null&&(e(x),e=void 0),o},get readableLength(){return g.readableLength},onEmpty:x=>g.onEmpty(x)},o}var Fo=class extends Error{type;code;constructor(t,e){super(t??"The operation was aborted"),this.type="aborted",this.name="AbortError",this.code=e??"ABORT_ERR"}};async function Wr(r,t,e,n){let o=new Fo(n?.errorMessage,n?.errorCode);return e?.aborted===!0?Promise.reject(o):new Promise((s,i)=>{function a(){e?.removeEventListener("abort",h),r.removeEventListener(t,c),n?.errorEvent!=null&&r.removeEventListener(n.errorEvent,l)}let c=f=>{try{if(n?.filter?.(f)===!1)return}catch(d){a(),i(d);return}a(),s(f)},l=f=>{a(),i(f.detail)},h=()=>{a(),i(o)};e?.addEventListener("abort",h),r.addEventListener(t,c),n?.errorEvent!=null&&r.addEventListener(n.errorEvent,l)})}var Yr=class extends Error{static name="QueueFullError";constructor(t="The queue was full"){super(t),this.name="QueueFullError"}};var Qr=class extends Error{type;code;constructor(t,e,n){super(t??"The operation was aborted"),this.type="aborted",this.name=n??"AbortError",this.code=e??"ABORT_ERR"}};async function Jr(r,t,e){if(t==null)return r;if(t.aborted)return Promise.reject(new Qr(e?.errorMessage,e?.errorCode,e?.errorName));let n,o=new Qr(e?.errorMessage,e?.errorCode,e?.errorName);try{return await Promise.race([r,new Promise((s,i)=>{n=()=>{i(o)},t.addEventListener("abort",n)})])}finally{n!=null&&t.removeEventListener("abort",n)}}var tn=class{deferred;signal;constructor(t){this.signal=t,this.deferred=Bt(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new Nt)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}};function Nf(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}var en=class{id;fn;options;recipients;status;timeline;controller;constructor(t,e){this.id=Nf(),this.status="queued",this.fn=t,this.options=e,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,Tt(1/0,this.controller.signal),this.onAbort=this.onAbort.bind(this)}abort(t){this.controller.abort(t)}onAbort(){this.recipients.reduce((e,n)=>e&&n.signal?.aborted===!0,!0)&&(this.controller.abort(new Nt),this.cleanup())}async join(t={}){let e=new tn(t.signal);return this.recipients.push(e),t.signal?.addEventListener("abort",this.onAbort),e.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();let t=await Jr(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(e=>{e.deferred.resolve(t)}),this.status="complete"}catch(t){this.recipients.forEach(e=>{e.deferred.reject(t)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(t=>{t.cleanup(),t.signal?.removeEventListener("abort",this.onAbort)})}};var rn=class extends ur{concurrency;maxSize;queue;pending;sort;constructor(t={}){super(),this.concurrency=t.concurrency??Number.POSITIVE_INFINITY,this.maxSize=t.maxSize??Number.POSITIVE_INFINITY,this.pending=0,t.metricName!=null&&t.metrics?.registerMetricGroup(t.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})}),this.sort=t.sort,this.queue=[]}tryToStartAnother(){if(this.size===0)return queueMicrotask(()=>{this.safeDispatchEvent("empty")}),this.running===0&&queueMicrotask(()=>{this.safeDispatchEvent("idle")}),!1;if(this.pending<this.concurrency){let t;for(let e of this.queue)if(e.status==="queued"){t=e;break}return t==null?!1:(this.safeDispatchEvent("active"),this.pending++,t.run().finally(()=>{for(let e=0;e<this.queue.length;e++)if(this.queue[e]===t){this.queue.splice(e,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(t){this.queue.push(t),this.sort!=null&&this.queue.sort(this.sort)}async add(t,e){if(e?.signal?.throwIfAborted(),this.size===this.maxSize)throw new Yr;let n=new en(t,e);return this.enqueue(n),this.safeDispatchEvent("add"),this.tryToStartAnother(),n.join(e).then(o=>(this.safeDispatchEvent("completed",{detail:o}),this.safeDispatchEvent("success",{detail:{job:n,result:o}}),o)).catch(o=>{if(n.status==="queued"){for(let s=0;s<this.queue.length;s++)if(this.queue[s]===n){this.queue.splice(s,1);break}}throw this.safeDispatchEvent("error",{detail:o}),this.safeDispatchEvent("failure",{detail:{job:n,error:o}}),o})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(t=>{t.abort(new Nt)}),this.clear()}async onEmpty(t){this.size!==0&&await Wr(this,"empty",t?.signal)}async onSizeLessThan(t,e){this.size<t||await Wr(this,"next",e?.signal,{filter:()=>this.size<t})}async onIdle(t){this.pending===0&&this.size===0||await Wr(this,"idle",t?.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(t){t?.signal?.throwIfAborted();let e=ji({objectMode:!0}),n=c=>{c!=null?this.abort():this.clear(),e.end(c)},o=c=>{c.detail!=null&&e.push(c.detail)},s=c=>{n(c.detail)},i=()=>{n()},a=()=>{n(new Nt("Queue aborted"))};this.addEventListener("completed",o),this.addEventListener("error",s),this.addEventListener("idle",i),t?.signal?.addEventListener("abort",a);try{yield*e}finally{this.removeEventListener("completed",o),this.removeEventListener("error",s),this.removeEventListener("idle",i),t?.signal?.removeEventListener("abort",a),n()}}};var nn=class extends rn{has(t){return this.find(t)!=null}find(t){return this.queue.find(e=>t.equals(e.options.peerId))}};function on(r){let t=new globalThis.AbortController;function e(){t.abort();for(let s of r)s?.removeEventListener!=null&&s.removeEventListener("abort",e)}for(let s of r){if(s?.aborted===!0){e();break}s?.addEventListener!=null&&s.addEventListener("abort",e)}function n(){for(let s of r)s?.removeEventListener!=null&&s.removeEventListener("abort",e)}let o=t.signal;return o.clear=n,o}function Zi(r,t,e){let n,o;function s(){let a={signal:o.signal};if(e?.timeout!=null){let c=on([o.signal,AbortSignal.timeout(e.timeout)]);Tt(1/0,c),a.signal=c}Promise.resolve().then(async()=>{await r(a)}).catch(()=>{}).finally(()=>{o.signal.aborted||(n=setTimeout(s,t))})}let i=!1;return{start:()=>{i||(i=!0,o=new AbortController,Tt(1/0,o.signal),e?.runImmediately===!0?queueMicrotask(()=>{s()}):n=setTimeout(s,t))},stop:()=>{clearTimeout(n),o?.abort(),i=!1}}}var $i=jr,Pf=Zr,Mo=function(r){let t=0;if(r=r.toString().trim(),$i(r)){let e=new Uint8Array(t+4);return r.split(/\./g).forEach(n=>{e[t++]=parseInt(n,10)&255}),e}if(Pf(r)){let e=r.split(":",8),n;for(n=0;n<e.length;n++){let s=$i(e[n]),i;s&&(i=Mo(e[n]),e[n]=et(i.slice(0,2),"base16")),i!=null&&++n<8&&e.splice(n,0,et(i.slice(2,4),"base16"))}if(e[0]==="")for(;e.length<8;)e.unshift("0");else if(e[e.length-1]==="")for(;e.length<8;)e.push("0");else if(e.length<8){for(n=0;n<e.length&&e[n]!=="";n++);let s=[n,1];for(n=9-e.length;n>0;n--)s.push("0");e.splice.apply(e,s)}let o=new Uint8Array(t+16);for(n=0;n<e.length;n++){let s=parseInt(e[n],16);o[t++]=s>>8&255,o[t++]=s&255}return o}throw new Error("invalid ip address")},Xi=function(r,t=0,e){t=~~t,e=e??r.length-t;let n=new DataView(r.buffer);if(e===4){let o=[];for(let s=0;s<e;s++)o.push(r[t+s]);return o.join(".")}if(e===16){let o=[];for(let s=0;s<e;s+=2)o.push(n.getUint16(t+s).toString(16));return o.join(":").replace(/(^|:)0(:0)*:0(:|$)/,"$1::$3").replace(/:{3,4}/,"::")}return""};var Ue={},zo={},Uf=[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,-1,"ip6zone"],[43,8,"ipcidr"],[53,-1,"dns",!0],[54,-1,"dns4",!0],[55,-1,"dns6",!0],[56,-1,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc-direct"],[281,0,"webrtc"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,-1,"unix",!1,!0],[421,-1,"ipfs"],[421,-1,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,-1,"garlic64"],[448,0,"tls"],[449,-1,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,-1,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[481,-1,"http-path"],[777,-1,"memory"]];Uf.forEach(r=>{let t=Cf(...r);zo[t.code]=t,Ue[t.name]=t});function Cf(r,t,e,n,o){return{code:r,size:t,name:e,resolvable:!!n,path:!!o}}function K(r){if(typeof r=="number"){if(zo[r]!=null)return zo[r];throw new Error(`no protocol with code: ${r}`)}else if(typeof r=="string"){if(Ue[r]!=null)return Ue[r];throw new Error(`no protocol with name: ${r}`)}throw new Error(`invalid protocol id type: ${typeof r}`)}var Ig=K("ip4"),Bg=K("ip6"),Lg=K("ipcidr");function Ko(r,t){switch(K(r).code){case 4:case 41:return Ff(t);case 42:return Ho(t);case 43:return et(t,"base10");case 6:case 273:case 33:case 132:return Qi(t).toString();case 53:case 54:case 55:case 56:case 400:case 449:case 777:return Ho(t);case 421:return Vf(t);case 444:return Yi(t);case 445:return Yi(t);case 466:return qf(t);case 481:return globalThis.encodeURIComponent(Ho(t));default:return et(t,"base16")}}function Go(r,t){switch(K(r).code){case 4:return Wi(t);case 41:return Wi(t);case 42:return Vo(t);case 43:return tt(t,"base10");case 6:case 273:case 33:case 132:return jo(parseInt(t,10));case 53:case 54:case 55:case 56:case 400:case 449:case 777:return Vo(t);case 421:return Mf(t);case 444:return Hf(t);case 445:return Kf(t);case 466:return zf(t);case 481:return Vo(globalThis.decodeURIComponent(t));default:return tt(t,"base16")}}var qo=Object.values($e).map(r=>r.decoder),Of=function(){let r=qo[0].or(qo[1]);return qo.slice(2).forEach(t=>r=r.or(t)),r}();function Wi(r){if(!$r(r))throw new Error("invalid ip address");return Mo(r)}function Ff(r){let t=Xi(r,0,r.length);if(t==null)throw new Error("ipBuff is required");if(!$r(t))throw new Error("invalid ip address");return t}function jo(r){let t=new ArrayBuffer(2);return new DataView(t).setUint16(0,r),new Uint8Array(t)}function Qi(r){return new DataView(r.buffer).getUint16(r.byteOffset)}function Vo(r){let t=tt(r),e=Uint8Array.from(re(t.length));return bt([e,t],e.length+t.length)}function Ho(r){let t=Vt(r);if(r=r.slice(ct(t)),r.length!==t)throw new Error("inconsistent lengths");return et(r)}function Mf(r){let t;r[0]==="Q"||r[0]==="1"?t=Ut(W.decode(`z${r}`)).bytes:t=lt.parse(r).multihash.bytes;let e=Uint8Array.from(re(t.length));return bt([e,t],e.length+t.length)}function zf(r){let t=Of.decode(r),e=Uint8Array.from(re(t.length));return bt([e,t],e.length+t.length)}function qf(r){let t=Vt(r),e=r.slice(ct(t));if(e.length!==t)throw new Error("inconsistent lengths");return"u"+et(e,"base64url")}function Vf(r){let t=Vt(r),e=r.slice(ct(t));if(e.length!==t)throw new Error("inconsistent lengths");return et(e,"base58btc")}function Hf(r){let t=r.split(":");if(t.length!==2)throw new Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(t[0].length!==16)throw new Error(`failed to parse onion addr: ${t[0]} not a Tor onion address.`);let e=kt.decode("b"+t[0]),n=parseInt(t[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");let o=jo(n);return bt([e,o],e.length+o.length)}function Kf(r){let t=r.split(":");if(t.length!==2)throw new Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(t[0].length!==56)throw new Error(`failed to parse onion addr: ${t[0]} not a Tor onion3 address.`);let e=kt.decode(`b${t[0]}`),n=parseInt(t[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");let o=jo(n);return bt([e,o],e.length+o.length)}function Yi(r){let t=r.slice(0,r.length-2),e=r.slice(r.length-2),n=et(t,"base32"),o=Qi(e);return`${n}:${o}`}function Ji(r){r=Zo(r);let t=[],e=[],n=null,o=r.split("/").slice(1);if(o.length===1&&o[0]==="")return{bytes:new Uint8Array,string:"/",tuples:[],stringTuples:[],path:null};for(let s=0;s<o.length;s++){let i=o[s],a=K(i);if(a.size===0){t.push([a.code]),e.push([a.code]);continue}if(s++,s>=o.length)throw ea("invalid address: "+r);if(a.path===!0){n=Zo(o.slice(s).join("/")),t.push([a.code,Go(a.code,n)]),e.push([a.code,n]);break}let c=Go(a.code,o[s]);t.push([a.code,c]),e.push([a.code,Ko(a.code,c)])}return{string:ta(e),bytes:Xo(t),tuples:t,stringTuples:e,path:n}}function $o(r){let t=[],e=[],n=null,o=0;for(;o<r.length;){let s=Vt(r,o),i=ct(s),a=K(s),c=Gf(a,r.slice(o+i));if(c===0){t.push([s]),e.push([s]),o+=i;continue}let l=r.slice(o+i,o+i+c);if(o+=c+i,o>r.length)throw ea("Invalid address Uint8Array: "+et(r,"base16"));t.push([s,l]);let h=Ko(s,l);if(e.push([s,h]),a.path===!0){n=h;break}}return{bytes:Uint8Array.from(r),string:ta(e),tuples:t,stringTuples:e,path:n}}function ta(r){let t=[];return r.map(e=>{let n=K(e[0]);return t.push(n.name),e.length>1&&e[1]!=null&&t.push(e[1]),null}),Zo(t.join("/"))}function Xo(r){return bt(r.map(t=>{let e=K(t[0]),n=Uint8Array.from(re(e.code));return t.length>1&&t[1]!=null&&(n=bt([n,t[1]])),n}))}function Gf(r,t){if(r.size>0)return r.size/8;if(r.size===0)return 0;{let e=Vt(t instanceof Uint8Array?t:Uint8Array.from(t));return e+ct(e)}}function Zo(r){return"/"+r.trim().split("/").filter(t=>t).join("/")}function ea(r){return new Error("Error parsing address: "+r)}var jf=Symbol.for("nodejs.util.inspect.custom"),Yo=Symbol.for("@multiformats/js-multiaddr/multiaddr"),Zf=[K("dns").code,K("dns4").code,K("dns6").code,K("dnsaddr").code],Wo=class extends Error{constructor(t="No available resolver"){super(t),this.name="NoAvailableResolverError"}},sn=class r{bytes;#t;#e;#r;#n;[Yo]=!0;constructor(t){t==null&&(t="");let e;if(t instanceof Uint8Array)e=$o(t);else if(typeof t=="string"){if(t.length>0&&t.charAt(0)!=="/")throw new Error(`multiaddr "${t}" must start with a "/"`);e=Ji(t)}else if(na(t))e=$o(t.bytes);else throw new Error("addr must be a string, Buffer, or another Multiaddr");this.bytes=e.bytes,this.#t=e.string,this.#e=e.tuples,this.#r=e.stringTuples,this.#n=e.path}toString(){return this.#t}toJSON(){return this.toString()}toOptions(){let t,e,n,o,s="",i=K("tcp"),a=K("udp"),c=K("ip4"),l=K("ip6"),h=K("dns6"),f=K("ip6zone");for(let[u,p]of this.stringTuples())u===f.code&&(s=`%${p??""}`),Zf.includes(u)&&(e=i.name,o=443,n=`${p??""}${s}`,t=u===h.code?6:4),(u===i.code||u===a.code)&&(e=K(u).name,o=parseInt(p??"")),(u===c.code||u===l.code)&&(e=K(u).name,n=`${p??""}${s}`,t=u===l.code?6:4);if(t==null||e==null||n==null||o==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:t,host:n,transport:e,port:o}}protos(){return this.#e.map(([t])=>Object.assign({},K(t)))}protoCodes(){return this.#e.map(([t])=>t)}protoNames(){return this.#e.map(([t])=>K(t).name)}tuples(){return this.#e.map(([t,e])=>e==null?[t]:[t,e])}stringTuples(){return this.#r.map(([t,e])=>e==null?[t]:[t,e])}encapsulate(t){return t=new r(t),new r(this.toString()+t.toString())}decapsulate(t){let e=t.toString(),n=this.toString(),o=n.lastIndexOf(e);if(o<0)throw new Error(`Address ${this.toString()} does not contain subaddress: ${t.toString()}`);return new r(n.slice(0,o))}decapsulateCode(t){let e=this.tuples();for(let n=e.length-1;n>=0;n--)if(e[n][0]===t)return new r(Xo(e.slice(0,n)));return this}getPeerId(){try{let t=[];this.stringTuples().forEach(([n,o])=>{n===Ue.p2p.code&&t.push([n,o]),n===Ue["p2p-circuit"].code&&(t=[])});let e=t.pop();if(e?.[1]!=null){let n=e[1];return n[0]==="Q"||n[0]==="1"?et(W.decode(`z${n}`),"base58btc"):et(lt.parse(n).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){return this.#n}equals(t){return xt(this.bytes,t.bytes)}async resolve(t){let e=this.protos().find(s=>s.resolvable);if(e==null)return[this];let n=ra.get(e.name);if(n==null)throw new Wo(`no available resolver for ${e.name}`);return(await n(this,t)).map(s=>sr(s))}nodeAddress(){let t=this.toOptions();if(t.transport!=="tcp"&&t.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${t.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:t.family,address:t.host,port:t.port}}isThinWaistAddress(t){let e=(t??this).protos();return!(e.length!==2||e[0].code!==4&&e[0].code!==41||e[1].code!==6&&e[1].code!==273)}[jf](){return`Multiaddr(${this.#t})`}};var ra=new Map;function na(r){return!!r?.[Yo]}function sr(r){return new sn(r)}var Qo=class{readNext;haveNext;ended;nextResult;constructor(){this.ended=!1,this.readNext=Bt(),this.haveNext=Bt()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");let t=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=Bt(),t}async throw(t){return this.ended=!0,t!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(t)),{done:!0,value:void 0}}async return(){let t={done:!0,value:void 0};return await this._push(void 0),t}async push(t,e){await this._push(t,e)}async end(t,e){t!=null?await this.throw(t):await this._push(void 0,e)}async _push(t,e){if(t!=null&&this.ended)throw new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;t!=null?this.nextResult={done:!1,value:t}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=Bt(),await Jr(this.readNext.promise,e?.signal,e)}};function oa(){return new Qo}var an=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};var Jo=class extends Error{code;constructor(t,e){super(t),this.code=e}},ts=class extends Jo{type;constructor(t){super(t,"ABORT_ERR"),this.type="aborted",this.name="AbortError"}};function sa(r,t){let e=oa();r.sink(e).catch(async i=>{await e.end(i)}),r.sink=async i=>{for await(let a of i)await e.push(a);await e.end()};let n=r.source;r.source[Symbol.iterator]!=null?n=r.source[Symbol.iterator]():r.source[Symbol.asyncIterator]!=null&&(n=r.source[Symbol.asyncIterator]());let o=new $t;return{read:async(i,a)=>{a?.signal?.throwIfAborted();let c,l=new Promise((h,f)=>{c=()=>{f(new ts("Read aborted"))},a?.signal?.addEventListener("abort",c)});try{if(i==null){let{done:f,value:d}=await Promise.race([n.next(),l]);return f===!0?new $t:d}for(;o.byteLength<i;){let{value:f,done:d}=await Promise.race([n.next(),l]);if(d===!0)throw new an("unexpected end of input");o.append(f)}let h=o.sublist(0,i);return o.consume(i),h}finally{c!=null&&a?.signal?.removeEventListener("abort",c)}},write:async(i,a)=>{a?.signal?.throwIfAborted(),i instanceof Uint8Array?await e.push(i,a):await e.push(i.subarray(),a)},unwrap:()=>{if(o.byteLength>0){let i=r.source;r.source=async function*(){t?.yieldBytes===!1?yield o:yield*o,yield*i}()}return r}}}var cn=class extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"},un=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"},fn=class extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"};function ia(r,t={}){let e=sa(r,t);t.maxDataLength!=null&&t.maxLengthLength==null&&(t.maxLengthLength=ct(t.maxDataLength));let n=t?.lengthDecoder??Vt,o=t?.lengthEncoder??re;return{read:async i=>{let a=-1,c=new $t;for(;;){c.append(await e.read(1,i));try{a=n(c)}catch(l){if(l instanceof RangeError)continue;throw l}if(a<0)throw new cn("Invalid message length");if(t?.maxLengthLength!=null&&c.byteLength>t.maxLengthLength)throw new fn("message length length too long");if(a>-1)break}if(t?.maxDataLength!=null&&a>t.maxDataLength)throw new un("message length too long");return e.read(a,i)},write:async(i,a)=>{await e.write(new $t(o(i.byteLength),i),a)},writeV:async(i,a)=>{let c=new $t(...i.flatMap(l=>[o(l.byteLength),l]));await e.write(c,a)},unwrap:()=>e.unwrap()}}function es(r,t){let e=ia(r,t),n={read:async(o,s)=>{let i=await e.read(s);return o.decode(i)},write:async(o,s,i)=>{await e.write(s.encode(o),i)},writeV:async(o,s,i)=>{await e.writeV(o.map(a=>s.encode(a)),i)},pb:o=>({read:async s=>n.read(o,s),write:async(s,i)=>n.write(s,o,i),writeV:async(s,i)=>n.writeV(s,o,i),unwrap:()=>n}),unwrap:()=>e.unwrap()};return n}var aa="libp2p",ca="autonat",ua="1.0.0";var Z;(function(r){let t;(function(l){l.DIAL="DIAL",l.DIAL_RESPONSE="DIAL_RESPONSE"})(t=r.MessageType||(r.MessageType={}));let e;(function(l){l[l.DIAL=0]="DIAL",l[l.DIAL_RESPONSE=1]="DIAL_RESPONSE"})(e||(e={})),function(l){l.codec=()=>De(e)}(t=r.MessageType||(r.MessageType={}));let n;(function(l){l.OK="OK",l.E_DIAL_ERROR="E_DIAL_ERROR",l.E_DIAL_REFUSED="E_DIAL_REFUSED",l.E_BAD_REQUEST="E_BAD_REQUEST",l.E_INTERNAL_ERROR="E_INTERNAL_ERROR"})(n=r.ResponseStatus||(r.ResponseStatus={}));let o;(function(l){l[l.OK=0]="OK",l[l.E_DIAL_ERROR=100]="E_DIAL_ERROR",l[l.E_DIAL_REFUSED=101]="E_DIAL_REFUSED",l[l.E_BAD_REQUEST=200]="E_BAD_REQUEST",l[l.E_INTERNAL_ERROR=300]="E_INTERNAL_ERROR"})(o||(o={})),function(l){l.codec=()=>De(o)}(n=r.ResponseStatus||(r.ResponseStatus={}));let s;(function(l){let h;l.codec=()=>(h==null&&(h=Gt((f,d,u={})=>{if(u.lengthDelimited!==!1&&d.fork(),f.id!=null&&(d.uint32(10),d.bytes(f.id)),f.addrs!=null)for(let p of f.addrs)d.uint32(18),d.bytes(p);u.lengthDelimited!==!1&&d.ldelim()},(f,d,u={})=>{let p={addrs:[]},g=d==null?f.len:f.pos+d;for(;f.pos<g;){let x=f.uint32();switch(x>>>3){case 1:{p.id=f.bytes();break}case 2:{if(u.limits?.addrs!=null&&p.addrs.length===u.limits.addrs)throw new Rr('Decode error - map field "addrs" had too many elements');p.addrs.push(f.bytes());break}default:{f.skipType(x&7);break}}}return p})),h),l.encode=f=>Kt(f,l.codec()),l.decode=(f,d)=>Ht(f,l.codec(),d)})(s=r.PeerInfo||(r.PeerInfo={}));let i;(function(l){let h;l.codec=()=>(h==null&&(h=Gt((f,d,u={})=>{u.lengthDelimited!==!1&&d.fork(),f.peer!=null&&(d.uint32(10),r.PeerInfo.codec().encode(f.peer,d)),u.lengthDelimited!==!1&&d.ldelim()},(f,d,u={})=>{let p={},g=d==null?f.len:f.pos+d;for(;f.pos<g;){let x=f.uint32();switch(x>>>3){case 1:{p.peer=r.PeerInfo.codec().decode(f,f.uint32(),{limits:u.limits?.peer});break}default:{f.skipType(x&7);break}}}return p})),h),l.encode=f=>Kt(f,l.codec()),l.decode=(f,d)=>Ht(f,l.codec(),d)})(i=r.Dial||(r.Dial={}));let a;(function(l){let h;l.codec=()=>(h==null&&(h=Gt((f,d,u={})=>{u.lengthDelimited!==!1&&d.fork(),f.status!=null&&(d.uint32(8),r.ResponseStatus.codec().encode(f.status,d)),f.statusText!=null&&(d.uint32(18),d.string(f.statusText)),f.addr!=null&&(d.uint32(26),d.bytes(f.addr)),u.lengthDelimited!==!1&&d.ldelim()},(f,d,u={})=>{let p={},g=d==null?f.len:f.pos+d;for(;f.pos<g;){let x=f.uint32();switch(x>>>3){case 1:{p.status=r.ResponseStatus.codec().decode(f);break}case 2:{p.statusText=f.string();break}case 3:{p.addr=f.bytes();break}default:{f.skipType(x&7);break}}}return p})),h),l.encode=f=>Kt(f,l.codec()),l.decode=(f,d)=>Ht(f,l.codec(),d)})(a=r.DialResponse||(r.DialResponse={}));let c;r.codec=()=>(c==null&&(c=Gt((l,h,f={})=>{f.lengthDelimited!==!1&&h.fork(),l.type!=null&&(h.uint32(8),r.MessageType.codec().encode(l.type,h)),l.dial!=null&&(h.uint32(18),r.Dial.codec().encode(l.dial,h)),l.dialResponse!=null&&(h.uint32(26),r.DialResponse.codec().encode(l.dialResponse,h)),f.lengthDelimited!==!1&&h.ldelim()},(l,h,f={})=>{let d={},u=h==null?l.len:l.pos+h;for(;l.pos<u;){let p=l.uint32();switch(p>>>3){case 1:{d.type=r.MessageType.codec().decode(l);break}case 2:{d.dial=r.Dial.codec().decode(l,l.uint32(),{limits:f.limits?.dial});break}case 3:{d.dialResponse=r.DialResponse.codec().decode(l,l.uint32(),{limits:f.limits?.dialResponse});break}default:{l.skipType(p&7);break}}}return d})),c),r.encode=l=>Kt(l,r.codec()),r.decode=(l,h)=>Ht(l,r.codec(),h)})(Z||(Z={}));var Jf=4,tl=8,ln=class{components;protocol;timeout;maxInboundStreams;maxOutboundStreams;maxMessageSize;started;log;topologyId;dialResults;findPeers;addressFilter;connectionThreshold;constructor(t,e){this.components=t,this.log=t.logger.forComponent("libp2p:auto-nat"),this.started=!1,this.protocol=`/${e.protocolPrefix??aa}/${ca}/${ua}`,this.timeout=e.timeout??3e4,this.maxInboundStreams=e.maxInboundStreams??2,this.maxOutboundStreams=e.maxOutboundStreams??20,this.connectionThreshold=e.connectionThreshold??80,this.maxMessageSize=e.maxMessageSize??8192,this.dialResults=new Map,this.findPeers=Zi(this.findRandomPeers.bind(this),6e4),this.addressFilter=Do(1024)}[Symbol.toStringTag]="@libp2p/autonat";[ls]=["@libp2p/autonat"];get[hs](){return["@libp2p/identify"]}isStarted(){return this.started}async start(){this.started||(await this.components.registrar.handle(this.protocol,t=>{this.handleIncomingAutonatStream(t).catch(e=>{this.log.error("error handling incoming autonat stream - %e",e)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams}),this.topologyId=await this.components.registrar.register(this.protocol,{onConnect:(t,e)=>{this.verifyExternalAddresses(e).catch(n=>{this.log.error("could not verify addresses - %e",n)})}}),this.findPeers.start(),this.started=!0)}async stop(){await this.components.registrar.unhandle(this.protocol),this.topologyId!=null&&await this.components.registrar.unhandle(this.topologyId),this.dialResults.clear(),this.findPeers.stop(),this.started=!1}allAddressesAreVerified(){return this.components.addressManager.getAddressesWithMetadata().every(t=>t.expires>Date.now()?!0:t.verified)}async findRandomPeers(t){if(this.allAddressesAreVerified())return;let e=on([AbortSignal.timeout(1e4),t?.signal]);try{this.log("starting random walk to find peers to run AutoNAT");for await(let n of this.components.randomWalk.walk({signal:e})){if(!await this.components.connectionManager.isDialable(n.multiaddrs)){this.log.trace("random peer %p was not dialable %s",n.id,n.multiaddrs.map(o=>o.toString()).join(", "));continue}try{this.log.trace("dial random peer %p",n.id),await this.components.connectionManager.openConnection(n.multiaddrs,{signal:e})}catch{}if(this.allAddressesAreVerified()){this.log("stopping random walk, all addresses are verified");return}if(!this.hasConnectionCapacity()){this.log("stopping random walk, too close to max connections");return}}}catch{}}async handleIncomingAutonatStream(t){let e=AbortSignal.timeout(this.timeout);Tt(1/0,e);let n=es(t.stream,{maxDataLength:this.maxMessageSize}).pb(Z);try{let o=await n.read({signal:e}),s=await this.handleAutonatMessage(o,t.connection,{signal:e});await n.write(s,{signal:e}),await n.unwrap().unwrap().close({signal:e})}catch(o){this.log.error("error handling incoming autonat stream - %e",o),t.stream.abort(o)}}async handleAutonatMessage(t,e,n){let o=this.components.addressManager.getAddresses().map(f=>f.toOptions().host),s=t.dial;if(s==null)return this.log.error("dial was missing from message"),{type:Z.MessageType.DIAL_RESPONSE,dialResponse:{status:Z.ResponseStatus.E_BAD_REQUEST,statusText:"No Dial message found in message"}};let i,a=s.peer;if(a?.id==null)return this.log.error("PeerId missing from message"),{type:Z.MessageType.DIAL_RESPONSE,dialResponse:{status:Z.ResponseStatus.E_BAD_REQUEST,statusText:"missing peer info"}};try{let f=Ut(a.id);i=Or(f)}catch(f){return this.log.error("invalid PeerId - %e",f),{type:Z.MessageType.DIAL_RESPONSE,dialResponse:{status:Z.ResponseStatus.E_BAD_REQUEST,statusText:"bad peer id"}}}if(this.log("incoming request from %p",i),!e.remotePeer.equals(i))return this.log("target peer %p did not equal sending peer %p",i,e.remotePeer),{type:Z.MessageType.DIAL_RESPONSE,dialResponse:{status:Z.ResponseStatus.E_BAD_REQUEST,statusText:"peer id mismatch"}};let c=a.addrs.map(f=>sr(f)).filter(f=>{let d=f.toOptions();return Co(f)?!1:d.host!==e.remoteAddr.toOptions().host?(this.log.trace("not dialing %a - target host did not match remote host %a",f,e.remoteAddr),!1):o.includes(d.host)?!1:this.components.transportManager.dialTransportForMultiaddr(f)==null?(this.log.trace("not dialing %a - transport unsupported",f),!1):!0}).map(f=>(f.getPeerId()==null&&(f=f.encapsulate(`/p2p/${i.toString()}`)),f));if(c.length===0)return this.log("refused to dial all multiaddrs for %p from message",i),{type:Z.MessageType.DIAL_RESPONSE,dialResponse:{status:Z.ResponseStatus.E_DIAL_REFUSED,statusText:"no dialable addresses"}};this.log("dial multiaddrs %s for peer %p",c.map(f=>f.toString()).join(", "),i);let l="",h=c[0];for await(let f of c){let d;h=f;try{if(d=await this.components.connectionManager.openConnection(f,n),!d.remoteAddr.equals(f))throw this.log.error("tried to dial %a but dialed %a",f,d.remoteAddr),new Error("Unexpected remote address");return this.log("successfully dialed %p via %a",i,f),{type:Z.MessageType.DIAL_RESPONSE,dialResponse:{status:Z.ResponseStatus.OK,addr:d.remoteAddr.decapsulateCode(K("p2p").code).bytes}}}catch(u){this.log.error("could not dial %p - %e",i,u),l=u.message}finally{d!=null&&await d.close()}}return{type:Z.MessageType.DIAL_RESPONSE,dialResponse:{status:Z.ResponseStatus.E_DIAL_ERROR,statusText:l,addr:h.bytes}}}getFirstUnverifiedMultiaddr(t,e){let n=this.components.addressManager.getAddressesWithMetadata().sort((o,s)=>o.type==="observed"&&s.type!=="observed"?1:s.type==="observed"&&o.type!=="observed"?-1:0).filter(o=>!(!(o.expires<Date.now())||o.multiaddr.toOptions().family===6&&(!e||!Vi(o.multiaddr))||Co(o.multiaddr)));for(let o of n){let s=o.multiaddr.toString(),i=this.dialResults.get(s);if(i!=null){if(i.networkSegments.includes(t)){this.log.trace("%a already has a network segment result from %s",i.multiaddr,t);continue}if(i.queue.size>10){this.log.trace("%a already has enough peers queued",i.multiaddr);continue}}if(i==null){let a=o.expires<Date.now();if(a&&this.addressFilter.remove?.(s),this.addressFilter.has(s))continue;this.addressFilter.add(s),this.log.trace("creating dial result %s %s",a?"to revalidate":"for",s),i={multiaddr:o.multiaddr,success:0,failure:0,networkSegments:[],verifyingPeers:Bo(),queue:new nn({concurrency:3,maxSize:50}),type:o.type,lastVerified:o.lastVerified},this.dialResults.set(s,i)}return i}}removeOutdatedMultiaddrResults(){let t=new Set(this.components.addressManager.getAddressesWithMetadata().filter(({expires:e})=>e<Date.now()).map(({multiaddr:e})=>e.toString()));for(let e of this.dialResults.keys())t.has(e)||(this.log.trace("remove results for %a",e),this.dialResults.delete(e))}async verifyExternalAddresses(t){if(!this.isStarted())return;this.removeOutdatedMultiaddrResults();let n=(await this.components.peerStore.get(t.remotePeer)).addresses.some(({multiaddr:i})=>i.toOptions().family===6),o=this.getNetworkSegment(t.remoteAddr),s=this.getFirstUnverifiedMultiaddr(o,n);if(s==null){this.log.trace("no unverified public addresses found for peer %p to verify, not requesting verification",t.remotePeer);return}if(!this.hasConnectionCapacity()){s.lastVerified!=null?(this.log("automatically re-verifying %a because we are too close to the connection limit",s.multiaddr),this.confirmAddress(s)):this.log("skipping verifying %a because we are too close to the connection limit",s.multiaddr);return}s.queue.add(async i=>{await this.askPeerToVerify(t,o,i)},{peerId:t.remotePeer,multiaddr:s.multiaddr}).catch(i=>{s?.result==null&&this.log.error("error from %p verifying address %a - %e",t.remotePeer,s?.multiaddr,i)})}async askPeerToVerify(t,e,n){let o=this.dialResults.get(n.multiaddr.toString());if(o==null){this.log("%a was verified while %p was queued",n.multiaddr,t.remotePeer);return}let s=AbortSignal.timeout(this.timeout);Tt(1/0,s),this.log.trace("asking %p to verify multiaddr %s",t.remotePeer,n.multiaddr);let i=await t.newStream(this.protocol,{signal:s});try{let a=es(i).pb(Z),[,c]=await Promise.all([a.write({type:Z.MessageType.DIAL,dial:{peer:{id:this.components.peerId.toMultihash().bytes,addrs:[n.multiaddr.bytes]}}},{signal:s}),a.read({signal:s})]);if(c.type!==Z.MessageType.DIAL_RESPONSE||c.dialResponse==null){this.log("invalid autonat response from %p - %j",t.remotePeer,c);return}let l=c.dialResponse.status;if(this.log.trace("autonat response from %p for %a is %s",t.remotePeer,n.multiaddr,l),l!==Z.ResponseStatus.OK&&l!==Z.ResponseStatus.E_DIAL_ERROR)return;if(o=this.dialResults.get(n.multiaddr.toString()),o==null){this.log.trace("peer reported %a as %s but there is no result object",n.multiaddr,c.dialResponse.status);return}if(o.networkSegments.includes(e)){this.log.trace("%a results included network segment %s",n.multiaddr,e);return}if(o.result!=null){this.log.trace("already resolved result for %a, ignoring response from",n.multiaddr,t.remotePeer);return}if(o.verifyingPeers.has(t.remotePeer)){this.log.trace("peer %p has already verified %a, ignoring response",t.remotePeer,n.multiaddr);return}if(o.verifyingPeers.add(t.remotePeer),o.networkSegments.push(e),l===Z.ResponseStatus.OK){if(o.success++,o.type!=="observed"){this.confirmAddress(o);return}}else l===Z.ResponseStatus.E_DIAL_ERROR&&o.failure++;this.log("%a success %d failure %d",o.multiaddr,o.success,o.failure),o.success===Jf&&this.confirmAddress(o),o.failure===tl&&this.unconfirmAddress(o)}finally{try{await i.close({signal:s})}catch(a){i.abort(a)}}}hasConnectionCapacity(){let e=this.components.connectionManager.getConnections().length,n=this.components.connectionManager.getMaxConnections();return e/n*100<this.connectionThreshold}confirmAddress(t){this.log("%s address %a is externally dialable",t.type,t.multiaddr),this.components.addressManager.confirmObservedAddr(t.multiaddr),this.dialResults.delete(t.multiaddr.toString()),t.result=!0,t.queue.abort()}unconfirmAddress(t){this.log("%s address %a is not externally dialable",t.type,t.multiaddr),this.components.addressManager.removeObservedAddr(t.multiaddr),this.dialResults.delete(t.multiaddr.toString()),t.result=!1,t.queue.abort()}getNetworkSegment(t){let e=t.toOptions();return e.family===4?e.host.split(".")[0].padStart(3,"0"):e.host.split(":")[0].padStart(4,"0")}};function el(r={}){return t=>new ln(t,r)}return Sa(rl);})();
./node_modules/@libp2p/peer-collections/dist/index.min.js:2:"use strict";var Libp2PPeerCollections=(()=>{var Ms=Object.create;var ze=Object.defineProperty;var Ds=Object.getOwnPropertyDescriptor;var Os=Object.getOwnPropertyNames;var Ps=Object.getPrototypeOf,zs=Object.prototype.hasOwnProperty;var Fn=(r,t)=>()=>(t||r((t={exports:{}}).exports,t),t.exports),ct=(r,t)=>{for(var e in t)ze(r,e,{get:t[e],enumerable:!0})},Vn=(r,t,e,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of Os(t))!zs.call(r,o)&&o!==e&&ze(r,o,{get:()=>t[o],enumerable:!(n=Ds(t,o))||n.enumerable});return r};var Hs=(r,t,e)=>(e=r!=null?Ms(Ps(r)):{},Vn(t||!r||!r.__esModule?ze(e,"default",{value:r,enumerable:!0}):e,r)),Ks=r=>Vn(ze({},"__esModule",{value:!0}),r);var gs=Fn((Me,wr)=>{(function(r,t){"use strict";var e={version:"3.0.0",x86:{},x64:{},inputValidation:!0};function n(i){if(!Array.isArray(i)&&!ArrayBuffer.isView(i))return!1;for(var l=0;l<i.length;l++)if(!Number.isInteger(i[l])||i[l]<0||i[l]>255)return!1;return!0}function o(i,l){return(i&65535)*l+(((i>>>16)*l&65535)<<16)}function s(i,l){return i<<l|i>>>32-l}function c(i){return i^=i>>>16,i=o(i,2246822507),i^=i>>>13,i=o(i,3266489909),i^=i>>>16,i}function a(i,l){i=[i[0]>>>16,i[0]&65535,i[1]>>>16,i[1]&65535],l=[l[0]>>>16,l[0]&65535,l[1]>>>16,l[1]&65535];var d=[0,0,0,0];return d[3]+=i[3]+l[3],d[2]+=d[3]>>>16,d[3]&=65535,d[2]+=i[2]+l[2],d[1]+=d[2]>>>16,d[2]&=65535,d[1]+=i[1]+l[1],d[0]+=d[1]>>>16,d[1]&=65535,d[0]+=i[0]+l[0],d[0]&=65535,[d[0]<<16|d[1],d[2]<<16|d[3]]}function f(i,l){i=[i[0]>>>16,i[0]&65535,i[1]>>>16,i[1]&65535],l=[l[0]>>>16,l[0]&65535,l[1]>>>16,l[1]&65535];var d=[0,0,0,0];return d[3]+=i[3]*l[3],d[2]+=d[3]>>>16,d[3]&=65535,d[2]+=i[2]*l[3],d[1]+=d[2]>>>16,d[2]&=65535,d[2]+=i[3]*l[2],d[1]+=d[2]>>>16,d[2]&=65535,d[1]+=i[1]*l[3],d[0]+=d[1]>>>16,d[1]&=65535,d[1]+=i[2]*l[2],d[0]+=d[1]>>>16,d[1]&=65535,d[1]+=i[3]*l[1],d[0]+=d[1]>>>16,d[1]&=65535,d[0]+=i[0]*l[3]+i[1]*l[2]+i[2]*l[1]+i[3]*l[0],d[0]&=65535,[d[0]<<16|d[1],d[2]<<16|d[3]]}function y(i,l){return l%=64,l===32?[i[1],i[0]]:l<32?[i[0]<<l|i[1]>>>32-l,i[1]<<l|i[0]>>>32-l]:(l-=32,[i[1]<<l|i[0]>>>32-l,i[0]<<l|i[1]>>>32-l])}function h(i,l){return l%=64,l===0?i:l<32?[i[0]<<l|i[1]>>>32-l,i[1]<<l]:[i[1]<<l-32,0]}function g(i,l){return[i[0]^l[0],i[1]^l[1]]}function _(i){return i=g(i,[0,i[0]>>>1]),i=f(i,[4283543511,3981806797]),i=g(i,[0,i[0]>>>1]),i=f(i,[3301882366,444984403]),i=g(i,[0,i[0]>>>1]),i}e.x86.hash32=function(i,l){if(e.inputValidation&&!n(i))return t;l=l||0;for(var d=i.length%4,x=i.length-d,p=l,m=0,u=3432918353,E=461845907,B=0;B<x;B=B+4)m=i[B]|i[B+1]<<8|i[B+2]<<16|i[B+3]<<24,m=o(m,u),m=s(m,15),m=o(m,E),p^=m,p=s(p,13),p=o(p,5)+3864292196;switch(m=0,d){case 3:m^=i[B+2]<<16;case 2:m^=i[B+1]<<8;case 1:m^=i[B],m=o(m,u),m=s(m,15),m=o(m,E),p^=m}return p^=i.length,p=c(p),p>>>0},e.x86.hash128=function(i,l){if(e.inputValidation&&!n(i))return t;l=l||0;for(var d=i.length%16,x=i.length-d,p=l,m=l,u=l,E=l,B=0,A=0,b=0,I=0,R=597399067,K=2869860233,P=951274213,O=2716044179,U=0;U<x;U=U+16)B=i[U]|i[U+1]<<8|i[U+2]<<16|i[U+3]<<24,A=i[U+4]|i[U+5]<<8|i[U+6]<<16|i[U+7]<<24,b=i[U+8]|i[U+9]<<8|i[U+10]<<16|i[U+11]<<24,I=i[U+12]|i[U+13]<<8|i[U+14]<<16|i[U+15]<<24,B=o(B,R),B=s(B,15),B=o(B,K),p^=B,p=s(p,19),p+=m,p=o(p,5)+1444728091,A=o(A,K),A=s(A,16),A=o(A,P),m^=A,m=s(m,17),m+=u,m=o(m,5)+197830471,b=o(b,P),b=s(b,17),b=o(b,O),u^=b,u=s(u,15),u+=E,u=o(u,5)+2530024501,I=o(I,O),I=s(I,18),I=o(I,R),E^=I,E=s(E,13),E+=p,E=o(E,5)+850148119;switch(B=0,A=0,b=0,I=0,d){case 15:I^=i[U+14]<<16;case 14:I^=i[U+13]<<8;case 13:I^=i[U+12],I=o(I,O),I=s(I,18),I=o(I,R),E^=I;case 12:b^=i[U+11]<<24;case 11:b^=i[U+10]<<16;case 10:b^=i[U+9]<<8;case 9:b^=i[U+8],b=o(b,P),b=s(b,17),b=o(b,O),u^=b;case 8:A^=i[U+7]<<24;case 7:A^=i[U+6]<<16;case 6:A^=i[U+5]<<8;case 5:A^=i[U+4],A=o(A,K),A=s(A,16),A=o(A,P),m^=A;case 4:B^=i[U+3]<<24;case 3:B^=i[U+2]<<16;case 2:B^=i[U+1]<<8;case 1:B^=i[U],B=o(B,R),B=s(B,15),B=o(B,K),p^=B}return p^=i.length,m^=i.length,u^=i.length,E^=i.length,p+=m,p+=u,p+=E,m+=p,u+=p,E+=p,p=c(p),m=c(m),u=c(u),E=c(E),p+=m,p+=u,p+=E,m+=p,u+=p,E+=p,("00000000"+(p>>>0).toString(16)).slice(-8)+("00000000"+(m>>>0).toString(16)).slice(-8)+("00000000"+(u>>>0).toString(16)).slice(-8)+("00000000"+(E>>>0).toString(16)).slice(-8)},e.x64.hash128=function(i,l){if(e.inputValidation&&!n(i))return t;l=l||0;for(var d=i.length%16,x=i.length-d,p=[0,l],m=[0,l],u=[0,0],E=[0,0],B=[2277735313,289559509],A=[1291169091,658871167],b=0;b<x;b=b+16)u=[i[b+4]|i[b+5]<<8|i[b+6]<<16|i[b+7]<<24,i[b]|i[b+1]<<8|i[b+2]<<16|i[b+3]<<24],E=[i[b+12]|i[b+13]<<8|i[b+14]<<16|i[b+15]<<24,i[b+8]|i[b+9]<<8|i[b+10]<<16|i[b+11]<<24],u=f(u,B),u=y(u,31),u=f(u,A),p=g(p,u),p=y(p,27),p=a(p,m),p=a(f(p,[0,5]),[0,1390208809]),E=f(E,A),E=y(E,33),E=f(E,B),m=g(m,E),m=y(m,31),m=a(m,p),m=a(f(m,[0,5]),[0,944331445]);switch(u=[0,0],E=[0,0],d){case 15:E=g(E,h([0,i[b+14]],48));case 14:E=g(E,h([0,i[b+13]],40));case 13:E=g(E,h([0,i[b+12]],32));case 12:E=g(E,h([0,i[b+11]],24));case 11:E=g(E,h([0,i[b+10]],16));case 10:E=g(E,h([0,i[b+9]],8));case 9:E=g(E,[0,i[b+8]]),E=f(E,A),E=y(E,33),E=f(E,B),m=g(m,E);case 8:u=g(u,h([0,i[b+7]],56));case 7:u=g(u,h([0,i[b+6]],48));case 6:u=g(u,h([0,i[b+5]],40));case 5:u=g(u,h([0,i[b+4]],32));case 4:u=g(u,h([0,i[b+3]],24));case 3:u=g(u,h([0,i[b+2]],16));case 2:u=g(u,h([0,i[b+1]],8));case 1:u=g(u,[0,i[b]]),u=f(u,B),u=y(u,31),u=f(u,A),p=g(p,u)}return p=g(p,[0,i.length]),m=g(m,[0,i.length]),p=a(p,m),m=a(m,p),p=_(p),m=_(m),p=a(p,m),m=a(m,p),("00000000"+(p[0]>>>0).toString(16)).slice(-8)+("00000000"+(p[1]>>>0).toString(16)).slice(-8)+("00000000"+(m[0]>>>0).toString(16)).slice(-8)+("00000000"+(m[1]>>>0).toString(16)).slice(-8)},typeof Me<"u"?(typeof wr<"u"&&wr.exports&&(Me=wr.exports=e),Me.murmurHash3=e):typeof define=="function"&&define.amd?define([],function(){return e}):(e._murmurHash3=r.murmurHash3,e.noConflict=function(){return r.murmurHash3=e._murmurHash3,e._murmurHash3=t,e.noConflict=t,e},r.murmurHash3=e)})(Me)});var ws=Fn((P0,bs)=>{bs.exports=gs()});var Ca={};ct(Ca,{PeerFilter:()=>Pe,PeerList:()=>Zt,PeerMap:()=>Ft,PeerSet:()=>Vt,peerFilter:()=>Ss,peerList:()=>xs,peerMap:()=>ps,peerSet:()=>ms,trackedPeerList:()=>As,trackedPeerMap:()=>Bs,trackedPeerSet:()=>vs});var _r=Symbol.for("@libp2p/peer-id");var ge=class extends Error{static name="InvalidParametersError";constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}},He=class extends Error{static name="InvalidPublicKeyError";constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}};var Ke=class extends Error{static name="InvalidMultihashError";constructor(t="Invalid Multihash"){super(t),this.name="InvalidMultihashError"}};var be=class extends Error{static name="UnsupportedKeyTypeError";constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}};var Ir={};ct(Ir,{base58btc:()=>X,base58flickr:()=>js});var ka=new Uint8Array(0);function Zn(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function _t(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function Gn(r){return new TextEncoder().encode(r)}function jn(r){return new TextDecoder().decode(r)}function qs(r,t){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),n=0;n<e.length;n++)e[n]=255;for(var o=0;o<r.length;o++){var s=r.charAt(o),c=s.charCodeAt(0);if(e[c]!==255)throw new TypeError(s+" is ambiguous");e[c]=o}var a=r.length,f=r.charAt(0),y=Math.log(a)/Math.log(256),h=Math.log(256)/Math.log(a);function g(l){if(l instanceof Uint8Array||(ArrayBuffer.isView(l)?l=new Uint8Array(l.buffer,l.byteOffset,l.byteLength):Array.isArray(l)&&(l=Uint8Array.from(l))),!(l instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(l.length===0)return"";for(var d=0,x=0,p=0,m=l.length;p!==m&&l[p]===0;)p++,d++;for(var u=(m-p)*h+1>>>0,E=new Uint8Array(u);p!==m;){for(var B=l[p],A=0,b=u-1;(B!==0||A<x)&&b!==-1;b--,A++)B+=256*E[b]>>>0,E[b]=B%a>>>0,B=B/a>>>0;if(B!==0)throw new Error("Non-zero carry");x=A,p++}for(var I=u-x;I!==u&&E[I]===0;)I++;for(var R=f.repeat(d);I<u;++I)R+=r.charAt(E[I]);return R}function _(l){if(typeof l!="string")throw new TypeError("Expected String");if(l.length===0)return new Uint8Array;var d=0;if(l[d]!==" "){for(var x=0,p=0;l[d]===f;)x++,d++;for(var m=(l.length-d)*y+1>>>0,u=new Uint8Array(m);l[d];){var E=e[l.charCodeAt(d)];if(E===255)return;for(var B=0,A=m-1;(E!==0||B<p)&&A!==-1;A--,B++)E+=a*u[A]>>>0,u[A]=E%256>>>0,E=E/256>>>0;if(E!==0)throw new Error("Non-zero carry");p=B,d++}if(l[d]!==" "){for(var b=m-p;b!==m&&u[b]===0;)b++;for(var I=new Uint8Array(x+(m-b)),R=x;b!==m;)I[R++]=u[b++];return I}}}function i(l){var d=_(l);if(d)return d;throw new Error(`Non-${t} character`)}return{encode:g,decodeUnsafe:_,decode:i}}var Fs=qs,Vs=Fs,Xn=Vs;var Sr=class{name;prefix;baseEncode;constructor(t,e,n){this.name=t,this.prefix=e,this.baseEncode=n}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}},Br=class{name;prefix;baseDecode;prefixCodePoint;constructor(t,e,n){this.name=t,this.prefix=e;let o=e.codePointAt(0);if(o===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=o,this.baseDecode=n}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return Wn(this,t)}},vr=class{decoders;constructor(t){this.decoders=t}or(t){return Wn(this,t)}decode(t){let e=t[0],n=this.decoders[e];if(n!=null)return n.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};function Wn(r,t){return new vr({...r.decoders??{[r.prefix]:r},...t.decoders??{[t.prefix]:t}})}var Ar=class{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(t,e,n,o){this.name=t,this.prefix=e,this.baseEncode=n,this.baseDecode=o,this.encoder=new Sr(t,e,n),this.decoder=new Br(t,e,o)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}};function se({name:r,prefix:t,encode:e,decode:n}){return new Ar(r,t,e,n)}function Ut({name:r,prefix:t,alphabet:e}){let{encode:n,decode:o}=Xn(e,r);return se({prefix:t,name:r,encode:n,decode:s=>_t(o(s))})}function Zs(r,t,e,n){let o={};for(let h=0;h<t.length;++h)o[t[h]]=h;let s=r.length;for(;r[s-1]==="=";)--s;let c=new Uint8Array(s*e/8|0),a=0,f=0,y=0;for(let h=0;h<s;++h){let g=o[r[h]];if(g===void 0)throw new SyntaxError(`Non-${n} character`);f=f<<e|g,a+=e,a>=8&&(a-=8,c[y++]=255&f>>a)}if(a>=e||255&f<<8-a)throw new SyntaxError("Unexpected end of data");return c}function Gs(r,t,e){let n=t[t.length-1]==="=",o=(1<<e)-1,s="",c=0,a=0;for(let f=0;f<r.length;++f)for(a=a<<8|r[f],c+=8;c>e;)c-=e,s+=t[o&a>>c];if(c!==0&&(s+=t[o&a<<e-c]),n)for(;s.length*e&7;)s+="=";return s}function Y({name:r,prefix:t,bitsPerChar:e,alphabet:n}){return se({prefix:t,name:r,encode(o){return Gs(o,n,e)},decode(o){return Zs(o,n,e,r)}})}var X=Ut({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),js=Ut({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var Tr={};ct(Tr,{base32:()=>ie,base32hex:()=>$s,base32hexpad:()=>Js,base32hexpadupper:()=>ti,base32hexupper:()=>Qs,base32pad:()=>Xs,base32padupper:()=>Ws,base32upper:()=>Ys,base32z:()=>ei});var ie=Y({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Ys=Y({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Xs=Y({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Ws=Y({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),$s=Y({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Qs=Y({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Js=Y({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),ti=Y({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),ei=Y({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var Rr={};ct(Rr,{base36:()=>we,base36upper:()=>ri});var we=Ut({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),ri=Ut({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var ni=Jn,$n=128,oi=127,si=~oi,ii=Math.pow(2,31);function Jn(r,t,e){t=t||[],e=e||0;for(var n=e;r>=ii;)t[e++]=r&255|$n,r/=128;for(;r&si;)t[e++]=r&255|$n,r>>>=7;return t[e]=r|0,Jn.bytes=e-n+1,t}var ci=Cr,ai=128,Qn=127;function Cr(r,n){var e=0,n=n||0,o=0,s=n,c,a=r.length;do{if(s>=a)throw Cr.bytes=0,new RangeError("Could not decode varint");c=r[s++],e+=o<28?(c&Qn)<<o:(c&Qn)*Math.pow(2,o),o+=7}while(c>=ai);return Cr.bytes=s-n,e}var fi=Math.pow(2,7),ui=Math.pow(2,14),hi=Math.pow(2,21),li=Math.pow(2,28),di=Math.pow(2,35),pi=Math.pow(2,42),mi=Math.pow(2,49),xi=Math.pow(2,56),gi=Math.pow(2,63),bi=function(r){return r<fi?1:r<ui?2:r<hi?3:r<li?4:r<di?5:r<pi?6:r<mi?7:r<xi?8:r<gi?9:10},wi={encode:ni,decode:ci,encodingLength:bi},yi=wi,ye=yi;function Ee(r,t=0){return[ye.decode(r,t),ye.decode.bytes]}function ce(r,t,e=0){return ye.encode(r,t,e),t}function ae(r){return ye.encodingLength(r)}function Gt(r,t){let e=t.byteLength,n=ae(r),o=n+ae(e),s=new Uint8Array(o+e);return ce(r,s,0),ce(e,s,n),s.set(t,o),new fe(r,e,t,s)}function _e(r){let t=_t(r),[e,n]=Ee(t),[o,s]=Ee(t.subarray(n)),c=t.subarray(n+s);if(c.byteLength!==o)throw new Error("Incorrect length");return new fe(e,o,c,t)}function to(r,t){if(r===t)return!0;{let e=t;return r.code===e.code&&r.size===e.size&&e.bytes instanceof Uint8Array&&Zn(r.bytes,e.bytes)}}var fe=class{code;size;digest;bytes;constructor(t,e,n,o){this.code=t,this.size=e,this.digest=n,this.bytes=o}};function eo(r,t){let{bytes:e,version:n}=r;switch(n){case 0:return _i(e,Lr(r),t??X.encoder);default:return Si(e,Lr(r),t??ie.encoder)}}var ro=new WeakMap;function Lr(r){let t=ro.get(r);if(t==null){let e=new Map;return ro.set(r,e),e}return t}var lt=class r{code;version;multihash;bytes;"/";constructor(t,e,n,o){this.code=e,this.version=t,this.multihash=n,this.bytes=o,this["/"]=o}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{let{code:t,multihash:e}=this;if(t!==Se)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==Bi)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return r.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{let{code:t,digest:e}=this.multihash,n=Gt(t,e);return r.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return r.equals(this,t)}static equals(t,e){let n=e;return n!=null&&t.code===n.code&&t.version===n.version&&to(t.multihash,n.multihash)}toString(t){return eo(this,t)}toJSON(){return{"/":eo(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;let e=t;if(e instanceof r)return e;if(e["/"]!=null&&e["/"]===e.bytes||e.asCID===e){let{version:n,code:o,multihash:s,bytes:c}=e;return new r(n,o,s,c??no(n,o,s.bytes))}else if(e[vi]===!0){let{version:n,multihash:o,code:s}=e,c=_e(o);return r.create(n,s,c)}else return null}static create(t,e,n){if(typeof e!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(e!==Se)throw new Error(`Version 0 CID must use dag-pb (code: ${Se}) block encoding`);return new r(t,e,n,n.bytes)}case 1:{let o=no(t,e,n.bytes);return new r(t,e,n,o)}default:throw new Error("Invalid version")}}static createV0(t){return r.create(0,Se,t)}static createV1(t,e){return r.create(1,t,e)}static decode(t){let[e,n]=r.decodeFirst(t);if(n.length!==0)throw new Error("Incorrect length");return e}static decodeFirst(t){let e=r.inspectBytes(t),n=e.size-e.multihashSize,o=_t(t.subarray(n,n+e.multihashSize));if(o.byteLength!==e.multihashSize)throw new Error("Incorrect length");let s=o.subarray(e.multihashSize-e.digestSize),c=new fe(e.multihashCode,e.digestSize,s,o);return[e.version===0?r.createV0(c):r.createV1(e.codec,c),t.subarray(e.size)]}static inspectBytes(t){let e=0,n=()=>{let[g,_]=Ee(t.subarray(e));return e+=_,g},o=n(),s=Se;if(o===18?(o=0,e=0):s=n(),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);let c=e,a=n(),f=n(),y=e+f,h=y-c;return{version:o,codec:s,multihashCode:a,digestSize:f,multihashSize:h,size:y}}static parse(t,e){let[n,o]=Ei(t,e),s=r.decode(o);if(s.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Lr(s).set(n,t),s}};function Ei(r,t){switch(r[0]){case"Q":{let e=t??X;return[X.prefix,e.decode(`${X.prefix}${r}`)]}case X.prefix:{let e=t??X;return[X.prefix,e.decode(r)]}case ie.prefix:{let e=t??ie;return[ie.prefix,e.decode(r)]}case we.prefix:{let e=t??we;return[we.prefix,e.decode(r)]}default:{if(t==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],t.decode(r)]}}}function _i(r,t,e){let{prefix:n}=e;if(n!==X.prefix)throw Error(`Cannot string encode V0 in ${e.name} encoding`);let o=t.get(n);if(o==null){let s=e.encode(r).slice(1);return t.set(n,s),s}else return o}function Si(r,t,e){let{prefix:n}=e,o=t.get(n);if(o==null){let s=e.encode(r);return t.set(n,s),s}else return o}var Se=112,Bi=18;function no(r,t,e){let n=ae(r),o=n+ae(t),s=new Uint8Array(o+e.byteLength);return ce(r,s,0),ce(t,s,n),s.set(e,o),s}var vi=Symbol.for("@ipld/js-cid/CID");var Ur={};ct(Ur,{identity:()=>St});var oo=0,Ai="identity",so=_t;function Ii(r){return Gt(oo,so(r))}var St={code:oo,name:Ai,encode:so,digest:Ii};function Bt(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function io(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function Ti(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function ue(r,...t){if(!Ti(r))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(r.length))throw new Error("Uint8Array expected of length "+t+", got length="+r.length)}function co(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");io(r.outputLen),io(r.blockLen)}function he(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function ao(r,t){ue(r);let e=t.outputLen;if(r.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}var Yt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var Fe=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),dt=(r,t)=>r<<32-t|r>>>t;function fo(r){if(typeof r!="string")throw new Error("utf8ToBytes expected string, got "+typeof r);return new Uint8Array(new TextEncoder().encode(r))}function Be(r){return typeof r=="string"&&(r=fo(r)),ue(r),r}function Nr(...r){let t=0;for(let n=0;n<r.length;n++){let o=r[n];ue(o),t+=o.length}let e=new Uint8Array(t);for(let n=0,o=0;n<r.length;n++){let s=r[n];e.set(s,o),o+=s.length}return e}var le=class{clone(){return this._cloneInto()}};function Ve(r){let t=n=>r().update(Be(n)).digest(),e=r();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>r(),t}function Ze(r=32){if(Yt&&typeof Yt.getRandomValues=="function")return Yt.getRandomValues(new Uint8Array(r));if(Yt&&typeof Yt.randomBytes=="function")return Yt.randomBytes(r);throw new Error("crypto.getRandomValues must be defined")}function Ri(r,t,e,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(t,e,n);let o=BigInt(32),s=BigInt(4294967295),c=Number(e>>o&s),a=Number(e&s),f=n?4:0,y=n?0:4;r.setUint32(t+f,c,n),r.setUint32(t+y,a,n)}var uo=(r,t,e)=>r&t^~r&e,ho=(r,t,e)=>r&t^r&e^t&e,de=class extends le{constructor(t,e,n,o){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=Fe(this.buffer)}update(t){he(this);let{view:e,buffer:n,blockLen:o}=this;t=Be(t);let s=t.length;for(let c=0;c<s;){let a=Math.min(o-this.pos,s-c);if(a===o){let f=Fe(t);for(;o<=s-c;c+=o)this.process(f,c);continue}n.set(t.subarray(c,c+a),this.pos),this.pos+=a,c+=a,this.pos===o&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){he(this),ao(t,this),this.finished=!0;let{buffer:e,view:n,blockLen:o,isLE:s}=this,{pos:c}=this;e[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>o-c&&(this.process(n,0),c=0);for(let g=c;g<o;g++)e[g]=0;Ri(n,o-8,BigInt(this.length*8),s),this.process(n,0);let a=Fe(t),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let y=f/4,h=this.get();if(y>h.length)throw new Error("_sha2: outputLen bigger than state");for(let g=0;g<y;g++)a.setUint32(4*g,h[g],s)}digest(){let{buffer:t,outputLen:e}=this;this.digestInto(t);let n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:e,buffer:n,length:o,finished:s,destroyed:c,pos:a}=this;return t.length=o,t.pos=a,t.finished=s,t.destroyed=c,o%e&&t.buffer.set(n),t}};var Ge=BigInt(4294967295),kr=BigInt(32);function lo(r,t=!1){return t?{h:Number(r&Ge),l:Number(r>>kr&Ge)}:{h:Number(r>>kr&Ge)|0,l:Number(r&Ge)|0}}function Ci(r,t=!1){let e=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let o=0;o<r.length;o++){let{h:s,l:c}=lo(r[o],t);[e[o],n[o]]=[s,c]}return[e,n]}var Li=(r,t)=>BigInt(r>>>0)<<kr|BigInt(t>>>0),Ui=(r,t,e)=>r>>>e,Ni=(r,t,e)=>r<<32-e|t>>>e,ki=(r,t,e)=>r>>>e|t<<32-e,Mi=(r,t,e)=>r<<32-e|t>>>e,Di=(r,t,e)=>r<<64-e|t>>>e-32,Oi=(r,t,e)=>r>>>e-32|t<<64-e,Pi=(r,t)=>t,zi=(r,t)=>r,Hi=(r,t,e)=>r<<e|t>>>32-e,Ki=(r,t,e)=>t<<e|r>>>32-e,qi=(r,t,e)=>t<<e-32|r>>>64-e,Fi=(r,t,e)=>r<<e-32|t>>>64-e;function Vi(r,t,e,n){let o=(t>>>0)+(n>>>0);return{h:r+e+(o/2**32|0)|0,l:o|0}}var Zi=(r,t,e)=>(r>>>0)+(t>>>0)+(e>>>0),Gi=(r,t,e,n)=>t+e+n+(r/2**32|0)|0,ji=(r,t,e,n)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0),Yi=(r,t,e,n,o)=>t+e+n+o+(r/2**32|0)|0,Xi=(r,t,e,n,o)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(o>>>0),Wi=(r,t,e,n,o,s)=>t+e+n+o+s+(r/2**32|0)|0;var $i={fromBig:lo,split:Ci,toBig:Li,shrSH:Ui,shrSL:Ni,rotrSH:ki,rotrSL:Mi,rotrBH:Di,rotrBL:Oi,rotr32H:Pi,rotr32L:zi,rotlSH:Hi,rotlSL:Ki,rotlBH:qi,rotlBL:Fi,add:Vi,add3L:Zi,add3H:Gi,add4L:ji,add4H:Yi,add5H:Wi,add5L:Xi},D=$i;var[Qi,Ji]=D.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),Nt=new Uint32Array(80),kt=new Uint32Array(80),Mr=class extends de{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){let{Ah:t,Al:e,Bh:n,Bl:o,Ch:s,Cl:c,Dh:a,Dl:f,Eh:y,El:h,Fh:g,Fl:_,Gh:i,Gl:l,Hh:d,Hl:x}=this;return[t,e,n,o,s,c,a,f,y,h,g,_,i,l,d,x]}set(t,e,n,o,s,c,a,f,y,h,g,_,i,l,d,x){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=o|0,this.Ch=s|0,this.Cl=c|0,this.Dh=a|0,this.Dl=f|0,this.Eh=y|0,this.El=h|0,this.Fh=g|0,this.Fl=_|0,this.Gh=i|0,this.Gl=l|0,this.Hh=d|0,this.Hl=x|0}process(t,e){for(let u=0;u<16;u++,e+=4)Nt[u]=t.getUint32(e),kt[u]=t.getUint32(e+=4);for(let u=16;u<80;u++){let E=Nt[u-15]|0,B=kt[u-15]|0,A=D.rotrSH(E,B,1)^D.rotrSH(E,B,8)^D.shrSH(E,B,7),b=D.rotrSL(E,B,1)^D.rotrSL(E,B,8)^D.shrSL(E,B,7),I=Nt[u-2]|0,R=kt[u-2]|0,K=D.rotrSH(I,R,19)^D.rotrBH(I,R,61)^D.shrSH(I,R,6),P=D.rotrSL(I,R,19)^D.rotrBL(I,R,61)^D.shrSL(I,R,6),O=D.add4L(b,P,kt[u-7],kt[u-16]),U=D.add4H(O,A,K,Nt[u-7],Nt[u-16]);Nt[u]=U|0,kt[u]=O|0}let{Ah:n,Al:o,Bh:s,Bl:c,Ch:a,Cl:f,Dh:y,Dl:h,Eh:g,El:_,Fh:i,Fl:l,Gh:d,Gl:x,Hh:p,Hl:m}=this;for(let u=0;u<80;u++){let E=D.rotrSH(g,_,14)^D.rotrSH(g,_,18)^D.rotrBH(g,_,41),B=D.rotrSL(g,_,14)^D.rotrSL(g,_,18)^D.rotrBL(g,_,41),A=g&i^~g&d,b=_&l^~_&x,I=D.add5L(m,B,b,Ji[u],kt[u]),R=D.add5H(I,p,E,A,Qi[u],Nt[u]),K=I|0,P=D.rotrSH(n,o,28)^D.rotrBH(n,o,34)^D.rotrBH(n,o,39),O=D.rotrSL(n,o,28)^D.rotrBL(n,o,34)^D.rotrBL(n,o,39),U=n&s^n&a^s&a,T=o&c^o&f^c&f;p=d|0,m=x|0,d=i|0,x=l|0,i=g|0,l=_|0,{h:g,l:_}=D.add(y|0,h|0,R|0,K|0),y=a|0,h=f|0,a=s|0,f=c|0,s=n|0,c=o|0;let L=D.add3L(K,O,T);n=D.add3H(L,R,P,U),o=L|0}({h:n,l:o}=D.add(this.Ah|0,this.Al|0,n|0,o|0)),{h:s,l:c}=D.add(this.Bh|0,this.Bl|0,s|0,c|0),{h:a,l:f}=D.add(this.Ch|0,this.Cl|0,a|0,f|0),{h:y,l:h}=D.add(this.Dh|0,this.Dl|0,y|0,h|0),{h:g,l:_}=D.add(this.Eh|0,this.El|0,g|0,_|0),{h:i,l}=D.add(this.Fh|0,this.Fl|0,i|0,l|0),{h:d,l:x}=D.add(this.Gh|0,this.Gl|0,d|0,x|0),{h:p,l:m}=D.add(this.Hh|0,this.Hl|0,p|0,m|0),this.set(n,o,s,c,a,f,y,h,g,_,i,l,d,x,p,m)}roundClean(){Nt.fill(0),kt.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}};var po=Ve(()=>new Mr);var Xe={};ct(Xe,{aInRange:()=>at,abool:()=>pt,abytes:()=>pe,bitGet:()=>sc,bitLen:()=>zr,bitMask:()=>Ae,bitSet:()=>ic,bytesToHex:()=>At,bytesToNumberBE:()=>It,bytesToNumberLE:()=>Dt,concatBytes:()=>Tt,createHmacDrbg:()=>Hr,ensureBytes:()=>j,equalBytes:()=>nc,hexToBytes:()=>Wt,hexToNumber:()=>Pr,inRange:()=>ve,isBytes:()=>Mt,memoized:()=>Qt,notImplemented:()=>ac,numberToBytesBE:()=>Ot,numberToBytesLE:()=>$t,numberToHexUnpadded:()=>Xt,numberToVarBytesBE:()=>rc,utf8ToBytes:()=>oc,validateObject:()=>wt});var je=BigInt(0),Ye=BigInt(1),tc=BigInt(2);function Mt(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function pe(r){if(!Mt(r))throw new Error("Uint8Array expected")}function pt(r,t){if(typeof t!="boolean")throw new Error(r+" boolean expected, got "+t)}var ec=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function At(r){pe(r);let t="";for(let e=0;e<r.length;e++)t+=ec[r[e]];return t}function Xt(r){let t=r.toString(16);return t.length&1?"0"+t:t}function Pr(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?je:BigInt("0x"+r)}var vt={_0:48,_9:57,A:65,F:70,a:97,f:102};function mo(r){if(r>=vt._0&&r<=vt._9)return r-vt._0;if(r>=vt.A&&r<=vt.F)return r-(vt.A-10);if(r>=vt.a&&r<=vt.f)return r-(vt.a-10)}function Wt(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);let t=r.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);let n=new Uint8Array(e);for(let o=0,s=0;o<e;o++,s+=2){let c=mo(r.charCodeAt(s)),a=mo(r.charCodeAt(s+1));if(c===void 0||a===void 0){let f=r[s]+r[s+1];throw new Error('hex string expected, got non-hex character "'+f+'" at index '+s)}n[o]=c*16+a}return n}function It(r){return Pr(At(r))}function Dt(r){return pe(r),Pr(At(Uint8Array.from(r).reverse()))}function Ot(r,t){return Wt(r.toString(16).padStart(t*2,"0"))}function $t(r,t){return Ot(r,t).reverse()}function rc(r){return Wt(Xt(r))}function j(r,t,e){let n;if(typeof t=="string")try{n=Wt(t)}catch(s){throw new Error(r+" must be hex string or Uint8Array, cause: "+s)}else if(Mt(t))n=Uint8Array.from(t);else throw new Error(r+" must be hex string or Uint8Array");let o=n.length;if(typeof e=="number"&&o!==e)throw new Error(r+" of length "+e+" expected, got "+o);return n}function Tt(...r){let t=0;for(let n=0;n<r.length;n++){let o=r[n];pe(o),t+=o.length}let e=new Uint8Array(t);for(let n=0,o=0;n<r.length;n++){let s=r[n];e.set(s,o),o+=s.length}return e}function nc(r,t){if(r.length!==t.length)return!1;let e=0;for(let n=0;n<r.length;n++)e|=r[n]^t[n];return e===0}function oc(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}var Dr=r=>typeof r=="bigint"&&je<=r;function ve(r,t,e){return Dr(r)&&Dr(t)&&Dr(e)&&t<=r&&r<e}function at(r,t,e,n){if(!ve(t,e,n))throw new Error("expected valid "+r+": "+e+" <= n < "+n+", got "+t)}function zr(r){let t;for(t=0;r>je;r>>=Ye,t+=1);return t}function sc(r,t){return r>>BigInt(t)&Ye}function ic(r,t,e){return r|(e?Ye:je)<<BigInt(t)}var Ae=r=>(tc<<BigInt(r-1))-Ye,Or=r=>new Uint8Array(r),xo=r=>Uint8Array.from(r);function Hr(r,t,e){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let n=Or(r),o=Or(r),s=0,c=()=>{n.fill(1),o.fill(0),s=0},a=(...g)=>e(o,n,...g),f=(g=Or())=>{o=a(xo([0]),g),n=a(),g.length!==0&&(o=a(xo([1]),g),n=a())},y=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let g=0,_=[];for(;g<t;){n=a();let i=n.slice();_.push(i),g+=n.length}return Tt(..._)};return(g,_)=>{c(),f(g);let i;for(;!(i=_(y()));)f();return c(),i}}var cc={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||Mt(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,t)=>t.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function wt(r,t,e={}){let n=(o,s,c)=>{let a=cc[s];if(typeof a!="function")throw new Error("invalid validator function");let f=r[o];if(!(c&&f===void 0)&&!a(f,r))throw new Error("param "+String(o)+" is invalid. Expected "+s+", got "+f)};for(let[o,s]of Object.entries(t))n(o,s,!1);for(let[o,s]of Object.entries(e))n(o,s,!0);return r}var ac=()=>{throw new Error("not implemented")};function Qt(r){let t=new WeakMap;return(e,...n)=>{let o=t.get(e);if(o!==void 0)return o;let s=r(e,...n);return t.set(e,s),s}}var W=BigInt(0),Z=BigInt(1),Jt=BigInt(2),fc=BigInt(3),Kr=BigInt(4),go=BigInt(5),bo=BigInt(8),uc=BigInt(9),hc=BigInt(16);function F(r,t){let e=r%t;return e>=W?e:t+e}function lc(r,t,e){if(t<W)throw new Error("invalid exponent, negatives unsupported");if(e<=W)throw new Error("invalid modulus");if(e===Z)return W;let n=Z;for(;t>W;)t&Z&&(n=n*r%e),r=r*r%e,t>>=Z;return n}function G(r,t,e){let n=r;for(;t-- >W;)n*=n,n%=e;return n}function We(r,t){if(r===W)throw new Error("invert: expected non-zero number");if(t<=W)throw new Error("invert: expected positive modulus, got "+t);let e=F(r,t),n=t,o=W,s=Z,c=Z,a=W;for(;e!==W;){let y=n/e,h=n%e,g=o-c*y,_=s-a*y;n=e,e=h,o=c,s=a,c=g,a=_}if(n!==Z)throw new Error("invert: does not exist");return F(o,t)}function dc(r){let t=(r-Z)/Jt,e,n,o;for(e=r-Z,n=0;e%Jt===W;e/=Jt,n++);for(o=Jt;o<r&&lc(o,t,r)!==r-Z;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(n===1){let c=(r+Z)/Kr;return function(f,y){let h=f.pow(y,c);if(!f.eql(f.sqr(h),y))throw new Error("Cannot find square root");return h}}let s=(e+Z)/Jt;return function(a,f){if(a.pow(f,t)===a.neg(a.ONE))throw new Error("Cannot find square root");let y=n,h=a.pow(a.mul(a.ONE,o),e),g=a.pow(f,s),_=a.pow(f,e);for(;!a.eql(_,a.ONE);){if(a.eql(_,a.ZERO))return a.ZERO;let i=1;for(let d=a.sqr(_);i<y&&!a.eql(d,a.ONE);i++)d=a.sqr(d);let l=a.pow(h,Z<<BigInt(y-i-1));h=a.sqr(l),g=a.mul(g,l),_=a.mul(_,h),y=i}return g}}function pc(r){if(r%Kr===fc){let t=(r+Z)/Kr;return function(n,o){let s=n.pow(o,t);if(!n.eql(n.sqr(s),o))throw new Error("Cannot find square root");return s}}if(r%bo===go){let t=(r-go)/bo;return function(n,o){let s=n.mul(o,Jt),c=n.pow(s,t),a=n.mul(o,c),f=n.mul(n.mul(a,Jt),c),y=n.mul(a,n.sub(f,n.ONE));if(!n.eql(n.sqr(y),o))throw new Error("Cannot find square root");return y}}return r%hc,dc(r)}var wo=(r,t)=>(F(r,t)&Z)===Z,mc=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function qr(r){let t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=mc.reduce((n,o)=>(n[o]="function",n),t);return wt(r,e)}function xc(r,t,e){if(e<W)throw new Error("invalid exponent, negatives unsupported");if(e===W)return r.ONE;if(e===Z)return t;let n=r.ONE,o=t;for(;e>W;)e&Z&&(n=r.mul(n,o)),o=r.sqr(o),e>>=Z;return n}function gc(r,t){let e=new Array(t.length),n=t.reduce((s,c,a)=>r.is0(c)?s:(e[a]=s,r.mul(s,c)),r.ONE),o=r.inv(n);return t.reduceRight((s,c,a)=>r.is0(c)?s:(e[a]=r.mul(s,e[a]),r.mul(s,c)),o),e}function Fr(r,t){let e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}function Pt(r,t,e=!1,n={}){if(r<=W)throw new Error("invalid field: expected ORDER > 0, got "+r);let{nBitLength:o,nByteLength:s}=Fr(r,t);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c,a=Object.freeze({ORDER:r,isLE:e,BITS:o,BYTES:s,MASK:Ae(o),ZERO:W,ONE:Z,create:f=>F(f,r),isValid:f=>{if(typeof f!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof f);return W<=f&&f<r},is0:f=>f===W,isOdd:f=>(f&Z)===Z,neg:f=>F(-f,r),eql:(f,y)=>f===y,sqr:f=>F(f*f,r),add:(f,y)=>F(f+y,r),sub:(f,y)=>F(f-y,r),mul:(f,y)=>F(f*y,r),pow:(f,y)=>xc(a,f,y),div:(f,y)=>F(f*We(y,r),r),sqrN:f=>f*f,addN:(f,y)=>f+y,subN:(f,y)=>f-y,mulN:(f,y)=>f*y,inv:f=>We(f,r),sqrt:n.sqrt||(f=>(c||(c=pc(r)),c(a,f))),invertBatch:f=>gc(a,f),cmov:(f,y,h)=>h?y:f,toBytes:f=>e?$t(f,s):Ot(f,s),fromBytes:f=>{if(f.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+f.length);return e?Dt(f):It(f)}});return Object.freeze(a)}function yo(r){if(typeof r!="bigint")throw new Error("field order must be bigint");let t=r.toString(2).length;return Math.ceil(t/8)}function Vr(r){let t=yo(r);return t+Math.ceil(t/2)}function Eo(r,t,e=!1){let n=r.length,o=yo(t),s=Vr(t);if(n<16||n<s||n>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+n);let c=e?Dt(r):It(r),a=F(c,t-Z)+Z;return e?$t(a,o):Ot(a,o)}var _o=BigInt(0),$e=BigInt(1);function Zr(r,t){let e=t.negate();return r?e:t}function So(r,t){if(!Number.isSafeInteger(r)||r<=0||r>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+r)}function Gr(r,t){So(r,t);let e=Math.ceil(t/r)+1,n=2**(r-1);return{windows:e,windowSize:n}}function wc(r,t){if(!Array.isArray(r))throw new Error("array expected");r.forEach((e,n)=>{if(!(e instanceof t))throw new Error("invalid point at index "+n)})}function yc(r,t){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((e,n)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+n)})}var jr=new WeakMap,Bo=new WeakMap;function Yr(r){return Bo.get(r)||1}function Qe(r,t){return{constTimeNegate:Zr,hasPrecomputes(e){return Yr(e)!==1},unsafeLadder(e,n,o=r.ZERO){let s=e;for(;n>_o;)n&$e&&(o=o.add(s)),s=s.double(),n>>=$e;return o},precomputeWindow(e,n){let{windows:o,windowSize:s}=Gr(n,t),c=[],a=e,f=a;for(let y=0;y<o;y++){f=a,c.push(f);for(let h=1;h<s;h++)f=f.add(a),c.push(f);a=f.double()}return c},wNAF(e,n,o){let{windows:s,windowSize:c}=Gr(e,t),a=r.ZERO,f=r.BASE,y=BigInt(2**e-1),h=2**e,g=BigInt(e);for(let _=0;_<s;_++){let i=_*c,l=Number(o&y);o>>=g,l>c&&(l-=h,o+=$e);let d=i,x=i+Math.abs(l)-1,p=_%2!==0,m=l<0;l===0?f=f.add(Zr(p,n[d])):a=a.add(Zr(m,n[x]))}return{p:a,f}},wNAFUnsafe(e,n,o,s=r.ZERO){let{windows:c,windowSize:a}=Gr(e,t),f=BigInt(2**e-1),y=2**e,h=BigInt(e);for(let g=0;g<c;g++){let _=g*a;if(o===_o)break;let i=Number(o&f);if(o>>=h,i>a&&(i-=y,o+=$e),i===0)continue;let l=n[_+Math.abs(i)-1];i<0&&(l=l.negate()),s=s.add(l)}return s},getPrecomputes(e,n,o){let s=jr.get(n);return s||(s=this.precomputeWindow(n,e),e!==1&&jr.set(n,o(s))),s},wNAFCached(e,n,o){let s=Yr(e);return this.wNAF(s,this.getPrecomputes(s,e,o),n)},wNAFCachedUnsafe(e,n,o,s){let c=Yr(e);return c===1?this.unsafeLadder(e,n,s):this.wNAFUnsafe(c,this.getPrecomputes(c,e,o),n,s)},setWindowSize(e,n){So(n,t),Bo.set(e,n),jr.delete(e)}}}function Je(r,t,e,n){if(wc(e,r),yc(n,t),e.length!==n.length)throw new Error("arrays of points and scalars must have equal length");let o=r.ZERO,s=zr(BigInt(e.length)),c=s>12?s-3:s>4?s-2:s?2:1,a=(1<<c)-1,f=new Array(a+1).fill(o),y=Math.floor((t.BITS-1)/c)*c,h=o;for(let g=y;g>=0;g-=c){f.fill(o);for(let i=0;i<n.length;i++){let l=n[i],d=Number(l>>BigInt(g)&BigInt(a));f[d]=f[d].add(e[i])}let _=o;for(let i=f.length-1,l=o;i>0;i--)l=l.add(f[i]),_=_.add(l);if(h=h.add(_),g!==0)for(let i=0;i<c;i++)h=h.double()}return h}function Ie(r){return qr(r.Fp),wt(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Fr(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}var mt=BigInt(0),ft=BigInt(1),tr=BigInt(2),Ec=BigInt(8),_c={zip215:!0};function Sc(r){let t=Ie(r);return wt(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}function vo(r){let t=Sc(r),{Fp:e,n,prehash:o,hash:s,randomBytes:c,nByteLength:a,h:f}=t,y=tr<<BigInt(a*8)-ft,h=e.create,g=Pt(t.n,t.nBitLength),_=t.uvRatio||((S,w)=>{try{return{isValid:!0,value:e.sqrt(S*e.inv(w))}}catch{return{isValid:!1,value:mt}}}),i=t.adjustScalarBytes||(S=>S),l=t.domain||((S,w,v)=>{if(pt("phflag",v),w.length||v)throw new Error("Contexts/pre-hash are not supported");return S});function d(S,w){at("coordinate "+S,w,mt,y)}function x(S){if(!(S instanceof u))throw new Error("ExtendedPoint expected")}let p=Qt((S,w)=>{let{ex:v,ey:C,ez:N}=S,k=S.is0();w==null&&(w=k?Ec:e.inv(N));let z=h(v*w),H=h(C*w),M=h(N*w);if(k)return{x:mt,y:ft};if(M!==ft)throw new Error("invZ was invalid");return{x:z,y:H}}),m=Qt(S=>{let{a:w,d:v}=t;if(S.is0())throw new Error("bad point: ZERO");let{ex:C,ey:N,ez:k,et:z}=S,H=h(C*C),M=h(N*N),q=h(k*k),V=h(q*q),$=h(H*w),Q=h(q*h($+M)),tt=h(V+h(v*h(H*M)));if(Q!==tt)throw new Error("bad point: equation left != right (1)");let et=h(C*N),it=h(k*z);if(et!==it)throw new Error("bad point: equation left != right (2)");return!0});class u{constructor(w,v,C,N){this.ex=w,this.ey=v,this.ez=C,this.et=N,d("x",w),d("y",v),d("z",C),d("t",N),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(w){if(w instanceof u)throw new Error("extended point not allowed");let{x:v,y:C}=w||{};return d("x",v),d("y",C),new u(v,C,ft,h(v*C))}static normalizeZ(w){let v=e.invertBatch(w.map(C=>C.ez));return w.map((C,N)=>C.toAffine(v[N])).map(u.fromAffine)}static msm(w,v){return Je(u,g,w,v)}_setWindowSize(w){A.setWindowSize(this,w)}assertValidity(){m(this)}equals(w){x(w);let{ex:v,ey:C,ez:N}=this,{ex:k,ey:z,ez:H}=w,M=h(v*H),q=h(k*N),V=h(C*H),$=h(z*N);return M===q&&V===$}is0(){return this.equals(u.ZERO)}negate(){return new u(h(-this.ex),this.ey,this.ez,h(-this.et))}double(){let{a:w}=t,{ex:v,ey:C,ez:N}=this,k=h(v*v),z=h(C*C),H=h(tr*h(N*N)),M=h(w*k),q=v+C,V=h(h(q*q)-k-z),$=M+z,Q=$-H,tt=M-z,et=h(V*Q),it=h($*tt),nt=h(V*tt),bt=h(Q*$);return new u(et,it,bt,nt)}add(w){x(w);let{a:v,d:C}=t,{ex:N,ey:k,ez:z,et:H}=this,{ex:M,ey:q,ez:V,et:$}=w;if(v===BigInt(-1)){let Dn=h((k-N)*(q+M)),On=h((k+N)*(q-M)),Er=h(On-Dn);if(Er===mt)return this.double();let Pn=h(z*tr*$),zn=h(H*tr*V),Hn=zn+Pn,Kn=On+Dn,qn=zn-Pn,Ls=h(Hn*Er),Us=h(Kn*qn),Ns=h(Hn*qn),ks=h(Er*Kn);return new u(Ls,Us,ks,Ns)}let Q=h(N*M),tt=h(k*q),et=h(H*C*$),it=h(z*V),nt=h((N+k)*(M+q)-Q-tt),bt=it-et,Et=it+et,xe=h(tt-v*Q),Is=h(nt*bt),Ts=h(Et*xe),Rs=h(nt*xe),Cs=h(bt*Et);return new u(Is,Ts,Cs,Rs)}subtract(w){return this.add(w.negate())}wNAF(w){return A.wNAFCached(this,w,u.normalizeZ)}multiply(w){let v=w;at("scalar",v,ft,n);let{p:C,f:N}=this.wNAF(v);return u.normalizeZ([C,N])[0]}multiplyUnsafe(w,v=u.ZERO){let C=w;return at("scalar",C,mt,n),C===mt?B:this.is0()||C===ft?this:A.wNAFCachedUnsafe(this,C,u.normalizeZ,v)}isSmallOrder(){return this.multiplyUnsafe(f).is0()}isTorsionFree(){return A.unsafeLadder(this,n).is0()}toAffine(w){return p(this,w)}clearCofactor(){let{h:w}=t;return w===ft?this:this.multiplyUnsafe(w)}static fromHex(w,v=!1){let{d:C,a:N}=t,k=e.BYTES;w=j("pointHex",w,k),pt("zip215",v);let z=w.slice(),H=w[k-1];z[k-1]=H&-129;let M=Dt(z),q=v?y:e.ORDER;at("pointHex.y",M,mt,q);let V=h(M*M),$=h(V-ft),Q=h(C*V-N),{isValid:tt,value:et}=_($,Q);if(!tt)throw new Error("Point.fromHex: invalid y coordinate");let it=(et&ft)===ft,nt=(H&128)!==0;if(!v&&et===mt&&nt)throw new Error("Point.fromHex: x=0 and x_0=1");return nt!==it&&(et=h(-et)),u.fromAffine({x:et,y:M})}static fromPrivateKey(w){return R(w).point}toRawBytes(){let{x:w,y:v}=this.toAffine(),C=$t(v,e.BYTES);return C[C.length-1]|=w&ft?128:0,C}toHex(){return At(this.toRawBytes())}}u.BASE=new u(t.Gx,t.Gy,ft,h(t.Gx*t.Gy)),u.ZERO=new u(mt,ft,ft,mt);let{BASE:E,ZERO:B}=u,A=Qe(u,a*8);function b(S){return F(S,n)}function I(S){return b(Dt(S))}function R(S){let w=e.BYTES;S=j("private key",S,w);let v=j("hashed private key",s(S),2*w),C=i(v.slice(0,w)),N=v.slice(w,2*w),k=I(C),z=E.multiply(k),H=z.toRawBytes();return{head:C,prefix:N,scalar:k,point:z,pointBytes:H}}function K(S){return R(S).pointBytes}function P(S=new Uint8Array,...w){let v=Tt(...w);return I(s(l(v,j("context",S),!!o)))}function O(S,w,v={}){S=j("message",S),o&&(S=o(S));let{prefix:C,scalar:N,pointBytes:k}=R(w),z=P(v.context,C,S),H=E.multiply(z).toRawBytes(),M=P(v.context,H,k,S),q=b(z+M*N);at("signature.s",q,mt,n);let V=Tt(H,$t(q,e.BYTES));return j("result",V,e.BYTES*2)}let U=_c;function T(S,w,v,C=U){let{context:N,zip215:k}=C,z=e.BYTES;S=j("signature",S,2*z),w=j("message",w),v=j("publicKey",v,z),k!==void 0&&pt("zip215",k),o&&(w=o(w));let H=Dt(S.slice(z,2*z)),M,q,V;try{M=u.fromHex(v,k),q=u.fromHex(S.slice(0,z),k),V=E.multiplyUnsafe(H)}catch{return!1}if(!k&&M.isSmallOrder())return!1;let $=P(N,q.toRawBytes(),M.toRawBytes(),w);return q.add(M.multiplyUnsafe($)).subtract(V).clearCofactor().equals(u.ZERO)}return E._setWindowSize(8),{CURVE:t,getPublicKey:K,sign:O,verify:T,ExtendedPoint:u,utils:{getExtendedPublicKey:R,randomPrivateKey:()=>c(e.BYTES),precompute(S=8,w=u.BASE){return w._setWindowSize(S),w.multiply(BigInt(3)),w}}}}var Xr=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Ao=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),Af=BigInt(0),Bc=BigInt(1),Io=BigInt(2),If=BigInt(3),vc=BigInt(5),Ac=BigInt(8);function Ic(r){let t=BigInt(10),e=BigInt(20),n=BigInt(40),o=BigInt(80),s=Xr,a=r*r%s*r%s,f=G(a,Io,s)*a%s,y=G(f,Bc,s)*r%s,h=G(y,vc,s)*y%s,g=G(h,t,s)*h%s,_=G(g,e,s)*g%s,i=G(_,n,s)*_%s,l=G(i,o,s)*i%s,d=G(l,o,s)*i%s,x=G(d,t,s)*h%s;return{pow_p_5_8:G(x,Io,s)*r%s,b2:a}}function Tc(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function Rc(r,t){let e=Xr,n=F(t*t*t,e),o=F(n*n*t,e),s=Ic(r*o).pow_p_5_8,c=F(r*n*s,e),a=F(t*c*c,e),f=c,y=F(c*Ao,e),h=a===r,g=a===F(-r,e),_=a===F(-r*Ao,e);return h&&(c=f),(g||_)&&(c=y),wo(c,e)&&(c=F(-c,e)),{isValid:h||g,value:c}}var Cc=Pt(Xr,void 0,!0),Lc={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:Cc,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:Ac,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:po,randomBytes:Ze,adjustScalarBytes:Tc,uvRatio:Rc},To=vo(Lc);var er=32;function Ro(r,t,e){return To.verify(t,e instanceof Uint8Array?e:e.subarray(),r)}var rr=class{type="Ed25519";raw;constructor(t){this.raw=Wr(t,er)}toMultihash(){return St.digest(nr(this))}toCID(){return lt.createV1(114,this.toMultihash())}toString(){return X.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:Bt(this.raw,t.raw)}verify(t,e){return Ro(this.raw,e,t)}};function Lo(r){return r=Wr(r,er),new rr(r)}function Wr(r,t){if(r=Uint8Array.from(r??[]),r.length!==t)throw new ge(`Key must be a Uint8Array of length ${t}, got ${r.length}`);return r}function Uo(r=0){return new Uint8Array(r)}function Rt(r=0){return new Uint8Array(r)}var Nc=Math.pow(2,7),kc=Math.pow(2,14),Mc=Math.pow(2,21),No=Math.pow(2,28),ko=Math.pow(2,35),Mo=Math.pow(2,42),Do=Math.pow(2,49),ot=128,zt=127;function Te(r){if(r<Nc)return 1;if(r<kc)return 2;if(r<Mc)return 3;if(r<No)return 4;if(r<ko)return 5;if(r<Mo)return 6;if(r<Do)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function Oo(r,t,e=0){switch(Te(r)){case 8:t[e++]=r&255|ot,r/=128;case 7:t[e++]=r&255|ot,r/=128;case 6:t[e++]=r&255|ot,r/=128;case 5:t[e++]=r&255|ot,r/=128;case 4:t[e++]=r&255|ot,r>>>=7;case 3:t[e++]=r&255|ot,r>>>=7;case 2:t[e++]=r&255|ot,r>>>=7;case 1:{t[e++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return t}function Po(r,t){let e=r[t],n=0;if(n+=e&zt,e<ot||(e=r[t+1],n+=(e&zt)<<7,e<ot)||(e=r[t+2],n+=(e&zt)<<14,e<ot)||(e=r[t+3],n+=(e&zt)<<21,e<ot)||(e=r[t+4],n+=(e&zt)*No,e<ot)||(e=r[t+5],n+=(e&zt)*ko,e<ot)||(e=r[t+6],n+=(e&zt)*Mo,e<ot)||(e=r[t+7],n+=(e&zt)*Do,e<ot))return n;throw new RangeError("Could not decode varint")}var $r=new Float32Array([-0]),Ht=new Uint8Array($r.buffer);function zo(r,t,e){$r[0]=r,t[e]=Ht[0],t[e+1]=Ht[1],t[e+2]=Ht[2],t[e+3]=Ht[3]}function Ho(r,t){return Ht[0]=r[t],Ht[1]=r[t+1],Ht[2]=r[t+2],Ht[3]=r[t+3],$r[0]}var Qr=new Float64Array([-0]),rt=new Uint8Array(Qr.buffer);function Ko(r,t,e){Qr[0]=r,t[e]=rt[0],t[e+1]=rt[1],t[e+2]=rt[2],t[e+3]=rt[3],t[e+4]=rt[4],t[e+5]=rt[5],t[e+6]=rt[6],t[e+7]=rt[7]}function qo(r,t){return rt[0]=r[t],rt[1]=r[t+1],rt[2]=r[t+2],rt[3]=r[t+3],rt[4]=r[t+4],rt[5]=r[t+5],rt[6]=r[t+6],rt[7]=r[t+7],Qr[0]}var Dc=BigInt(Number.MAX_SAFE_INTEGER),Oc=BigInt(Number.MIN_SAFE_INTEGER),ut=class r{lo;hi;constructor(t,e){this.lo=t|0,this.hi=e|0}toNumber(t=!1){if(!t&&this.hi>>>31>0){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(e+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(t=!1){if(t)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(BigInt(e)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(t=!1){return this.toBigInt(t).toString()}zzEncode(){let t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this}zzDecode(){let t=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this}length(){let t=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?e===0?t<16384?t<128?1:2:t<2097152?3:4:e<16384?e<128?5:6:e<2097152?7:8:n<128?9:10}static fromBigInt(t){if(t===0n)return te;if(t<Dc&&t>Oc)return this.fromNumber(Number(t));let e=t<0n;e&&(t=-t);let n=t>>32n,o=t-(n<<32n);return e&&(n=~n|0n,o=~o|0n,++o>Fo&&(o=0n,++n>Fo&&(n=0n))),new r(Number(o),Number(n))}static fromNumber(t){if(t===0)return te;let e=t<0;e&&(t=-t);let n=t>>>0,o=(t-n)/4294967296>>>0;return e&&(o=~o>>>0,n=~n>>>0,++n>4294967295&&(n=0,++o>4294967295&&(o=0))),new r(n,o)}static from(t){return typeof t=="number"?r.fromNumber(t):typeof t=="bigint"?r.fromBigInt(t):typeof t=="string"?r.fromBigInt(BigInt(t)):t.low!=null||t.high!=null?new r(t.low>>>0,t.high>>>0):te}},te=new ut(0,0);te.toBigInt=function(){return 0n};te.zzEncode=te.zzDecode=function(){return this};te.length=function(){return 1};var Fo=4294967296n;function Vo(r){let t=0,e=0;for(let n=0;n<r.length;++n)e=r.charCodeAt(n),e<128?t+=1:e<2048?t+=2:(e&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,t+=4):t+=3;return t}function Zo(r,t,e){if(e-t<1)return"";let o,s=[],c=0,a;for(;t<e;)a=r[t++],a<128?s[c++]=a:a>191&&a<224?s[c++]=(a&31)<<6|r[t++]&63:a>239&&a<365?(a=((a&7)<<18|(r[t++]&63)<<12|(r[t++]&63)<<6|r[t++]&63)-65536,s[c++]=55296+(a>>10),s[c++]=56320+(a&1023)):s[c++]=(a&15)<<12|(r[t++]&63)<<6|r[t++]&63,c>8191&&((o??(o=[])).push(String.fromCharCode.apply(String,s)),c=0);return o!=null?(c>0&&o.push(String.fromCharCode.apply(String,s.slice(0,c))),o.join("")):String.fromCharCode.apply(String,s.slice(0,c))}function Jr(r,t,e){let n=e,o,s;for(let c=0;c<r.length;++c)o=r.charCodeAt(c),o<128?t[e++]=o:o<2048?(t[e++]=o>>6|192,t[e++]=o&63|128):(o&64512)===55296&&((s=r.charCodeAt(c+1))&64512)===56320?(o=65536+((o&1023)<<10)+(s&1023),++c,t[e++]=o>>18|240,t[e++]=o>>12&63|128,t[e++]=o>>6&63|128,t[e++]=o&63|128):(t[e++]=o>>12|224,t[e++]=o>>6&63|128,t[e++]=o&63|128);return e-n}function xt(r,t){return RangeError(`index out of range: ${r.pos} + ${t??1} > ${r.len}`)}function or(r,t){return(r[t-4]|r[t-3]<<8|r[t-2]<<16|r[t-1]<<24)>>>0}var tn=class{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(t){this.buf=t,this.pos=0,this.len=t.length}uint32(){let t=4294967295;if(t=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(t=(t|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return t;if((this.pos+=5)>this.len)throw this.pos=this.len,xt(this,10);return t}int32(){return this.uint32()|0}sint32(){let t=this.uint32();return t>>>1^-(t&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw xt(this,4);return or(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw xt(this,4);return or(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw xt(this,4);let t=Ho(this.buf,this.pos);return this.pos+=4,t}double(){if(this.pos+8>this.len)throw xt(this,4);let t=qo(this.buf,this.pos);return this.pos+=8,t}bytes(){let t=this.uint32(),e=this.pos,n=this.pos+t;if(n>this.len)throw xt(this,t);return this.pos+=t,e===n?new Uint8Array(0):this.buf.subarray(e,n)}string(){let t=this.bytes();return Zo(t,0,t.length)}skip(t){if(typeof t=="number"){if(this.pos+t>this.len)throw xt(this,t);this.pos+=t}else do if(this.pos>=this.len)throw xt(this);while(this.buf[this.pos++]&128);return this}skipType(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${t} at offset ${this.pos}`)}return this}readLongVarint(){let t=new ut(0,0),e=0;if(this.len-this.pos>4){for(;e<4;++e)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw xt(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,t}if(this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw xt(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw xt(this,8);let t=or(this.buf,this.pos+=4),e=or(this.buf,this.pos+=4);return new ut(t,e)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){let t=Po(this.buf,this.pos);return this.pos+=Te(t),t}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}};function en(r){return new tn(r instanceof Uint8Array?r:r.subarray())}function sr(r,t,e){let n=en(r);return t.decode(n,void 0,e)}var rn={};ct(rn,{base10:()=>Pc});var Pc=Ut({prefix:"9",name:"base10",alphabet:"0123456789"});var nn={};ct(nn,{base16:()=>zc,base16upper:()=>Hc});var zc=Y({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Hc=Y({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var on={};ct(on,{base2:()=>Kc});var Kc=Y({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var sn={};ct(sn,{base256emoji:()=>Gc});var jo=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),qc=jo.reduce((r,t,e)=>(r[e]=t,r),[]),Fc=jo.reduce((r,t,e)=>{let n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);return r[n]=e,r},[]);function Vc(r){return r.reduce((t,e)=>(t+=qc[e],t),"")}function Zc(r){let t=[];for(let e of r){let n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);let o=Fc[n];if(o==null)throw new Error(`Non-base256emoji character: ${e}`);t.push(o)}return new Uint8Array(t)}var Gc=se({prefix:"\u{1F680}",name:"base256emoji",encode:Vc,decode:Zc});var cn={};ct(cn,{base64:()=>jc,base64pad:()=>Yc,base64url:()=>Xc,base64urlpad:()=>Wc});var jc=Y({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Yc=Y({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Xc=Y({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Wc=Y({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var an={};ct(an,{base8:()=>$c});var $c=Y({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var fn={};ct(fn,{identity:()=>Qc});var Qc=se({prefix:"\0",name:"identity",encode:r=>jn(r),decode:r=>Gn(r)});var uu=new TextEncoder,hu=new TextDecoder;var ln={};ct(ln,{sha256:()=>Re,sha512:()=>ea});function hn({name:r,code:t,encode:e}){return new un(r,t,e)}var un=class{name;code;encode;constructor(t,e,n){this.name=t,this.code=e,this.encode=n}digest(t){if(t instanceof Uint8Array){let e=this.encode(t);return e instanceof Uint8Array?Gt(this.code,e):e.then(n=>Gt(this.code,n))}else throw Error("Unknown type, must be binary type")}};function Xo(r){return async t=>new Uint8Array(await crypto.subtle.digest(r,t))}var Re=hn({name:"sha2-256",code:18,encode:Xo("SHA-256")}),ea=hn({name:"sha2-512",code:19,encode:Xo("SHA-512")});var dn={...fn,...on,...an,...rn,...nn,...Tr,...Rr,...Ir,...cn,...sn},Su={...ln,...Ur};function $o(r,t,e,n){return{name:r,prefix:t,encoder:{name:r,prefix:t,encode:e},decoder:{decode:n}}}var Wo=$o("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),pn=$o("ascii","a",r=>{let t="a";for(let e=0;e<r.length;e++)t+=String.fromCharCode(r[e]);return t},r=>{r=r.substring(1);let t=Rt(r.length);for(let e=0;e<r.length;e++)t[e]=r.charCodeAt(e);return t}),ra={utf8:Wo,"utf-8":Wo,hex:dn.base16,latin1:pn,ascii:pn,binary:pn,...dn},ir=ra;function st(r,t="utf8"){let e=ir[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.decoder.decode(`${e.prefix}${r}`)}function mn(r){let t=r??8192,e=t>>>1,n,o=t;return function(c){if(c<1||c>e)return Rt(c);o+c>t&&(n=Rt(t),o=0);let a=n.subarray(o,o+=c);return o&7&&(o=(o|7)+1),a}}var ee=class{fn;len;next;val;constructor(t,e,n){this.fn=t,this.len=e,this.next=void 0,this.val=n}};function xn(){}var bn=class{head;tail;len;next;constructor(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}},na=mn();function oa(r){return globalThis.Buffer!=null?Rt(r):na(r)}var Le=class{len;head;tail;states;constructor(){this.len=0,this.head=new ee(xn,0,0),this.tail=this.head,this.states=null}_push(t,e,n){return this.tail=this.tail.next=new ee(t,e,n),this.len+=e,this}uint32(t){return this.len+=(this.tail=this.tail.next=new wn((t=t>>>0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this}int32(t){return t<0?this._push(cr,10,ut.fromNumber(t)):this.uint32(t)}sint32(t){return this.uint32((t<<1^t>>31)>>>0)}uint64(t){let e=ut.fromBigInt(t);return this._push(cr,e.length(),e)}uint64Number(t){return this._push(Oo,Te(t),t)}uint64String(t){return this.uint64(BigInt(t))}int64(t){return this.uint64(t)}int64Number(t){return this.uint64Number(t)}int64String(t){return this.uint64String(t)}sint64(t){let e=ut.fromBigInt(t).zzEncode();return this._push(cr,e.length(),e)}sint64Number(t){let e=ut.fromNumber(t).zzEncode();return this._push(cr,e.length(),e)}sint64String(t){return this.sint64(BigInt(t))}bool(t){return this._push(gn,1,t?1:0)}fixed32(t){return this._push(Ce,4,t>>>0)}sfixed32(t){return this.fixed32(t)}fixed64(t){let e=ut.fromBigInt(t);return this._push(Ce,4,e.lo)._push(Ce,4,e.hi)}fixed64Number(t){let e=ut.fromNumber(t);return this._push(Ce,4,e.lo)._push(Ce,4,e.hi)}fixed64String(t){return this.fixed64(BigInt(t))}sfixed64(t){return this.fixed64(t)}sfixed64Number(t){return this.fixed64Number(t)}sfixed64String(t){return this.fixed64String(t)}float(t){return this._push(zo,4,t)}double(t){return this._push(Ko,8,t)}bytes(t){let e=t.length>>>0;return e===0?this._push(gn,1,0):this.uint32(e)._push(ia,e,t)}string(t){let e=Vo(t);return e!==0?this.uint32(e)._push(Jr,e,t):this._push(gn,1,0)}fork(){return this.states=new bn(this),this.head=this.tail=new ee(xn,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new ee(xn,0,0),this.len=0),this}ldelim(){let t=this.head,e=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=t.next,this.tail=e,this.len+=n),this}finish(){let t=this.head.next,e=oa(this.len),n=0;for(;t!=null;)t.fn(t.val,e,n),n+=t.len,t=t.next;return e}};function gn(r,t,e){t[e]=r&255}function sa(r,t,e){for(;r>127;)t[e++]=r&127|128,r>>>=7;t[e]=r}var wn=class extends ee{next;constructor(t,e){super(sa,t,e),this.next=void 0}};function cr(r,t,e){for(;r.hi!==0;)t[e++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)t[e++]=r.lo&127|128,r.lo=r.lo>>>7;t[e++]=r.lo}function Ce(r,t,e){t[e]=r&255,t[e+1]=r>>>8&255,t[e+2]=r>>>16&255,t[e+3]=r>>>24}function ia(r,t,e){t.set(r,e)}globalThis.Buffer!=null&&(Le.prototype.bytes=function(r){let t=r.length>>>0;return this.uint32(t),t>0&&this._push(ca,t,r),this},Le.prototype.string=function(r){let t=globalThis.Buffer.byteLength(r);return this.uint32(t),t>0&&this._push(aa,t,r),this});function ca(r,t,e){t.set(r,e)}function aa(r,t,e){r.length<40?Jr(r,t,e):t.utf8Write!=null?t.utf8Write(r,e):t.set(st(r),e)}function yn(){return new Le}function ar(r,t){let e=yn();return t.encode(r,e,{lengthDelimited:!1}),e.finish()}var me;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(me||(me={}));function fr(r,t,e,n){return{name:r,type:t,encode:e,decode:n}}function En(r){function t(o){if(r[o.toString()]==null)throw new Error("Invalid enum value");return r[o]}let e=function(s,c){let a=t(s);c.int32(a)},n=function(s){let c=s.int32();return t(c)};return fr("enum",me.VARINT,e,n)}function ur(r,t){return fr("message",me.LENGTH_DELIMITED,r,t)}var ht;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1"})(ht||(ht={}));var _n;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1"})(_n||(_n={}));(function(r){r.codec=()=>En(_n)})(ht||(ht={}));var Ue;(function(r){let t;r.codec=()=>(t==null&&(t=ur((e,n,o={})=>{o.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),ht.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),o.lengthDelimited!==!1&&n.ldelim()},(e,n,o={})=>{let s={},c=n==null?e.len:e.pos+n;for(;e.pos<c;){let a=e.uint32();switch(a>>>3){case 1:{s.Type=ht.codec().decode(e);break}case 2:{s.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return s})),t),r.encode=e=>ar(e,r.codec()),r.decode=(e,n)=>sr(e,r.codec(),n)})(Ue||(Ue={}));var Sn;(function(r){let t;r.codec=()=>(t==null&&(t=ur((e,n,o={})=>{o.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),ht.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),o.lengthDelimited!==!1&&n.ldelim()},(e,n,o={})=>{let s={},c=n==null?e.len:e.pos+n;for(;e.pos<c;){let a=e.uint32();switch(a>>>3){case 1:{s.Type=ht.codec().decode(e);break}case 2:{s.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return s})),t),r.encode=e=>ar(e,r.codec()),r.decode=(e,n)=>sr(e,r.codec(),n)})(Sn||(Sn={}));var ua=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Kt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),qt=new Uint32Array(64),Bn=class extends de{constructor(){super(64,32,8,!1),this.A=Kt[0]|0,this.B=Kt[1]|0,this.C=Kt[2]|0,this.D=Kt[3]|0,this.E=Kt[4]|0,this.F=Kt[5]|0,this.G=Kt[6]|0,this.H=Kt[7]|0}get(){let{A:t,B:e,C:n,D:o,E:s,F:c,G:a,H:f}=this;return[t,e,n,o,s,c,a,f]}set(t,e,n,o,s,c,a,f){this.A=t|0,this.B=e|0,this.C=n|0,this.D=o|0,this.E=s|0,this.F=c|0,this.G=a|0,this.H=f|0}process(t,e){for(let g=0;g<16;g++,e+=4)qt[g]=t.getUint32(e,!1);for(let g=16;g<64;g++){let _=qt[g-15],i=qt[g-2],l=dt(_,7)^dt(_,18)^_>>>3,d=dt(i,17)^dt(i,19)^i>>>10;qt[g]=d+qt[g-7]+l+qt[g-16]|0}let{A:n,B:o,C:s,D:c,E:a,F:f,G:y,H:h}=this;for(let g=0;g<64;g++){let _=dt(a,6)^dt(a,11)^dt(a,25),i=h+_+uo(a,f,y)+ua[g]+qt[g]|0,d=(dt(n,2)^dt(n,13)^dt(n,22))+ho(n,o,s)|0;h=y,y=f,f=a,a=c+i|0,c=s,s=o,o=n,n=i+d|0}n=n+this.A|0,o=o+this.B|0,s=s+this.C|0,c=c+this.D|0,a=a+this.E|0,f=f+this.F|0,y=y+this.G|0,h=h+this.H|0,this.set(n,o,s,c,a,f,y,h)}roundClean(){qt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var Qo=Ve(()=>new Bn);function hr(r,t="utf8"){let e=ir[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.encoder.encode(r).substring(1)}var Ne=class extends Error{constructor(t="An error occurred while verifying a message"){super(t),this.name="VerificationError"}};var lr=class extends le{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,co(t);let n=Be(e);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let o=this.blockLen,s=new Uint8Array(o);s.set(n.length>o?t.create().update(n).digest():n);for(let c=0;c<s.length;c++)s[c]^=54;this.iHash.update(s),this.oHash=t.create();for(let c=0;c<s.length;c++)s[c]^=106;this.oHash.update(s),s.fill(0)}update(t){return he(this),this.iHash.update(t),this}digestInto(t){he(this),ue(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){let t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));let{oHash:e,iHash:n,finished:o,destroyed:s,blockLen:c,outputLen:a}=this;return t=t,t.finished=o,t.destroyed=s,t.blockLen=c,t.outputLen=a,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},vn=(r,t,e)=>new lr(r,t).update(e).digest();vn.create=(r,t)=>new lr(r,t);function Jo(r){r.lowS!==void 0&&pt("lowS",r.lowS),r.prehash!==void 0&&pt("prehash",r.prehash)}function ha(r){let t=Ie(r);wt(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:e,Fp:n,a:o}=t;if(e){if(!n.eql(o,n.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...t})}var{bytesToNumberBE:la,hexToBytes:da}=Xe,An=class extends Error{constructor(t=""){super(t)}},Ct={Err:An,_tlv:{encode:(r,t)=>{let{Err:e}=Ct;if(r<0||r>256)throw new e("tlv.encode: wrong tag");if(t.length&1)throw new e("tlv.encode: unpadded data");let n=t.length/2,o=Xt(n);if(o.length/2&128)throw new e("tlv.encode: long form length too big");let s=n>127?Xt(o.length/2|128):"";return Xt(r)+s+o+t},decode(r,t){let{Err:e}=Ct,n=0;if(r<0||r>256)throw new e("tlv.encode: wrong tag");if(t.length<2||t[n++]!==r)throw new e("tlv.decode: wrong tlv");let o=t[n++],s=!!(o&128),c=0;if(!s)c=o;else{let f=o&127;if(!f)throw new e("tlv.decode(long): indefinite length not supported");if(f>4)throw new e("tlv.decode(long): byte length is too big");let y=t.subarray(n,n+f);if(y.length!==f)throw new e("tlv.decode: length bytes not complete");if(y[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(let h of y)c=c<<8|h;if(n+=f,c<128)throw new e("tlv.decode(long): not minimal encoding")}let a=t.subarray(n,n+c);if(a.length!==c)throw new e("tlv.decode: wrong value length");return{v:a,l:t.subarray(n+c)}}},_int:{encode(r){let{Err:t}=Ct;if(r<Lt)throw new t("integer: negative integers are not allowed");let e=Xt(r);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return e},decode(r){let{Err:t}=Ct;if(r[0]&128)throw new t("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return la(r)}},toSig(r){let{Err:t,_int:e,_tlv:n}=Ct,o=typeof r=="string"?da(r):r;pe(o);let{v:s,l:c}=n.decode(48,o);if(c.length)throw new t("invalid signature: left bytes after parsing");let{v:a,l:f}=n.decode(2,s),{v:y,l:h}=n.decode(2,f);if(h.length)throw new t("invalid signature: left bytes after parsing");return{r:e.decode(a),s:e.decode(y)}},hexFromSig(r){let{_tlv:t,_int:e}=Ct,n=t.encode(2,e.encode(r.r)),o=t.encode(2,e.encode(r.s)),s=n+o;return t.encode(48,s)}},Lt=BigInt(0),J=BigInt(1),hh=BigInt(2),ts=BigInt(3),lh=BigInt(4);function pa(r){let t=ha(r),{Fp:e}=t,n=Pt(t.n,t.nBitLength),o=t.toBytes||((d,x,p)=>{let m=x.toAffine();return Tt(Uint8Array.from([4]),e.toBytes(m.x),e.toBytes(m.y))}),s=t.fromBytes||(d=>{let x=d.subarray(1),p=e.fromBytes(x.subarray(0,e.BYTES)),m=e.fromBytes(x.subarray(e.BYTES,2*e.BYTES));return{x:p,y:m}});function c(d){let{a:x,b:p}=t,m=e.sqr(d),u=e.mul(m,d);return e.add(e.add(u,e.mul(d,x)),p)}if(!e.eql(e.sqr(t.Gy),c(t.Gx)))throw new Error("bad generator point: equation left != right");function a(d){return ve(d,J,t.n)}function f(d){let{allowedPrivateKeyLengths:x,nByteLength:p,wrapPrivateKey:m,n:u}=t;if(x&&typeof d!="bigint"){if(Mt(d)&&(d=At(d)),typeof d!="string"||!x.includes(d.length))throw new Error("invalid private key");d=d.padStart(p*2,"0")}let E;try{E=typeof d=="bigint"?d:It(j("private key",d,p))}catch{throw new Error("invalid private key, expected hex or "+p+" bytes, got "+typeof d)}return m&&(E=F(E,u)),at("private key",E,J,u),E}function y(d){if(!(d instanceof _))throw new Error("ProjectivePoint expected")}let h=Qt((d,x)=>{let{px:p,py:m,pz:u}=d;if(e.eql(u,e.ONE))return{x:p,y:m};let E=d.is0();x==null&&(x=E?e.ONE:e.inv(u));let B=e.mul(p,x),A=e.mul(m,x),b=e.mul(u,x);if(E)return{x:e.ZERO,y:e.ZERO};if(!e.eql(b,e.ONE))throw new Error("invZ was invalid");return{x:B,y:A}}),g=Qt(d=>{if(d.is0()){if(t.allowInfinityPoint&&!e.is0(d.py))return;throw new Error("bad point: ZERO")}let{x,y:p}=d.toAffine();if(!e.isValid(x)||!e.isValid(p))throw new Error("bad point: x or y not FE");let m=e.sqr(p),u=c(x);if(!e.eql(m,u))throw new Error("bad point: equation left != right");if(!d.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class _{constructor(x,p,m){if(this.px=x,this.py=p,this.pz=m,x==null||!e.isValid(x))throw new Error("x required");if(p==null||!e.isValid(p))throw new Error("y required");if(m==null||!e.isValid(m))throw new Error("z required");Object.freeze(this)}static fromAffine(x){let{x:p,y:m}=x||{};if(!x||!e.isValid(p)||!e.isValid(m))throw new Error("invalid affine point");if(x instanceof _)throw new Error("projective point not allowed");let u=E=>e.eql(E,e.ZERO);return u(p)&&u(m)?_.ZERO:new _(p,m,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(x){let p=e.invertBatch(x.map(m=>m.pz));return x.map((m,u)=>m.toAffine(p[u])).map(_.fromAffine)}static fromHex(x){let p=_.fromAffine(s(j("pointHex",x)));return p.assertValidity(),p}static fromPrivateKey(x){return _.BASE.multiply(f(x))}static msm(x,p){return Je(_,n,x,p)}_setWindowSize(x){l.setWindowSize(this,x)}assertValidity(){g(this)}hasEvenY(){let{y:x}=this.toAffine();if(e.isOdd)return!e.isOdd(x);throw new Error("Field doesn't support isOdd")}equals(x){y(x);let{px:p,py:m,pz:u}=this,{px:E,py:B,pz:A}=x,b=e.eql(e.mul(p,A),e.mul(E,u)),I=e.eql(e.mul(m,A),e.mul(B,u));return b&&I}negate(){return new _(this.px,e.neg(this.py),this.pz)}double(){let{a:x,b:p}=t,m=e.mul(p,ts),{px:u,py:E,pz:B}=this,A=e.ZERO,b=e.ZERO,I=e.ZERO,R=e.mul(u,u),K=e.mul(E,E),P=e.mul(B,B),O=e.mul(u,E);return O=e.add(O,O),I=e.mul(u,B),I=e.add(I,I),A=e.mul(x,I),b=e.mul(m,P),b=e.add(A,b),A=e.sub(K,b),b=e.add(K,b),b=e.mul(A,b),A=e.mul(O,A),I=e.mul(m,I),P=e.mul(x,P),O=e.sub(R,P),O=e.mul(x,O),O=e.add(O,I),I=e.add(R,R),R=e.add(I,R),R=e.add(R,P),R=e.mul(R,O),b=e.add(b,R),P=e.mul(E,B),P=e.add(P,P),R=e.mul(P,O),A=e.sub(A,R),I=e.mul(P,K),I=e.add(I,I),I=e.add(I,I),new _(A,b,I)}add(x){y(x);let{px:p,py:m,pz:u}=this,{px:E,py:B,pz:A}=x,b=e.ZERO,I=e.ZERO,R=e.ZERO,K=t.a,P=e.mul(t.b,ts),O=e.mul(p,E),U=e.mul(m,B),T=e.mul(u,A),L=e.add(p,m),S=e.add(E,B);L=e.mul(L,S),S=e.add(O,U),L=e.sub(L,S),S=e.add(p,u);let w=e.add(E,A);return S=e.mul(S,w),w=e.add(O,T),S=e.sub(S,w),w=e.add(m,u),b=e.add(B,A),w=e.mul(w,b),b=e.add(U,T),w=e.sub(w,b),R=e.mul(K,S),b=e.mul(P,T),R=e.add(b,R),b=e.sub(U,R),R=e.add(U,R),I=e.mul(b,R),U=e.add(O,O),U=e.add(U,O),T=e.mul(K,T),S=e.mul(P,S),U=e.add(U,T),T=e.sub(O,T),T=e.mul(K,T),S=e.add(S,T),O=e.mul(U,S),I=e.add(I,O),O=e.mul(w,S),b=e.mul(L,b),b=e.sub(b,O),O=e.mul(L,U),R=e.mul(w,R),R=e.add(R,O),new _(b,I,R)}subtract(x){return this.add(x.negate())}is0(){return this.equals(_.ZERO)}wNAF(x){return l.wNAFCached(this,x,_.normalizeZ)}multiplyUnsafe(x){let{endo:p,n:m}=t;at("scalar",x,Lt,m);let u=_.ZERO;if(x===Lt)return u;if(this.is0()||x===J)return this;if(!p||l.hasPrecomputes(this))return l.wNAFCachedUnsafe(this,x,_.normalizeZ);let{k1neg:E,k1:B,k2neg:A,k2:b}=p.splitScalar(x),I=u,R=u,K=this;for(;B>Lt||b>Lt;)B&J&&(I=I.add(K)),b&J&&(R=R.add(K)),K=K.double(),B>>=J,b>>=J;return E&&(I=I.negate()),A&&(R=R.negate()),R=new _(e.mul(R.px,p.beta),R.py,R.pz),I.add(R)}multiply(x){let{endo:p,n:m}=t;at("scalar",x,J,m);let u,E;if(p){let{k1neg:B,k1:A,k2neg:b,k2:I}=p.splitScalar(x),{p:R,f:K}=this.wNAF(A),{p:P,f:O}=this.wNAF(I);R=l.constTimeNegate(B,R),P=l.constTimeNegate(b,P),P=new _(e.mul(P.px,p.beta),P.py,P.pz),u=R.add(P),E=K.add(O)}else{let{p:B,f:A}=this.wNAF(x);u=B,E=A}return _.normalizeZ([u,E])[0]}multiplyAndAddUnsafe(x,p,m){let u=_.BASE,E=(A,b)=>b===Lt||b===J||!A.equals(u)?A.multiplyUnsafe(b):A.multiply(b),B=E(this,p).add(E(x,m));return B.is0()?void 0:B}toAffine(x){return h(this,x)}isTorsionFree(){let{h:x,isTorsionFree:p}=t;if(x===J)return!0;if(p)return p(_,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:x,clearCofactor:p}=t;return x===J?this:p?p(_,this):this.multiplyUnsafe(t.h)}toRawBytes(x=!0){return pt("isCompressed",x),this.assertValidity(),o(_,this,x)}toHex(x=!0){return pt("isCompressed",x),At(this.toRawBytes(x))}}_.BASE=new _(t.Gx,t.Gy,e.ONE),_.ZERO=new _(e.ZERO,e.ONE,e.ZERO);let i=t.nBitLength,l=Qe(_,t.endo?Math.ceil(i/2):i);return{CURVE:t,ProjectivePoint:_,normPrivateKeyToScalar:f,weierstrassEquation:c,isWithinCurveOrder:a}}function ma(r){let t=Ie(r);return wt(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function es(r){let t=ma(r),{Fp:e,n}=t,o=e.BYTES+1,s=2*e.BYTES+1;function c(T){return F(T,n)}function a(T){return We(T,n)}let{ProjectivePoint:f,normPrivateKeyToScalar:y,weierstrassEquation:h,isWithinCurveOrder:g}=pa({...t,toBytes(T,L,S){let w=L.toAffine(),v=e.toBytes(w.x),C=Tt;return pt("isCompressed",S),S?C(Uint8Array.from([L.hasEvenY()?2:3]),v):C(Uint8Array.from([4]),v,e.toBytes(w.y))},fromBytes(T){let L=T.length,S=T[0],w=T.subarray(1);if(L===o&&(S===2||S===3)){let v=It(w);if(!ve(v,J,e.ORDER))throw new Error("Point is not on curve");let C=h(v),N;try{N=e.sqrt(C)}catch(H){let M=H instanceof Error?": "+H.message:"";throw new Error("Point is not on curve"+M)}let k=(N&J)===J;return(S&1)===1!==k&&(N=e.neg(N)),{x:v,y:N}}else if(L===s&&S===4){let v=e.fromBytes(w.subarray(0,e.BYTES)),C=e.fromBytes(w.subarray(e.BYTES,2*e.BYTES));return{x:v,y:C}}else{let v=o,C=s;throw new Error("invalid Point, expected length of "+v+", or uncompressed "+C+", got "+L)}}}),_=T=>At(Ot(T,t.nByteLength));function i(T){let L=n>>J;return T>L}function l(T){return i(T)?c(-T):T}let d=(T,L,S)=>It(T.slice(L,S));class x{constructor(L,S,w){this.r=L,this.s=S,this.recovery=w,this.assertValidity()}static fromCompact(L){let S=t.nByteLength;return L=j("compactSignature",L,S*2),new x(d(L,0,S),d(L,S,2*S))}static fromDER(L){let{r:S,s:w}=Ct.toSig(j("DER",L));return new x(S,w)}assertValidity(){at("r",this.r,J,n),at("s",this.s,J,n)}addRecoveryBit(L){return new x(this.r,this.s,L)}recoverPublicKey(L){let{r:S,s:w,recovery:v}=this,C=A(j("msgHash",L));if(v==null||![0,1,2,3].includes(v))throw new Error("recovery id invalid");let N=v===2||v===3?S+t.n:S;if(N>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");let k=v&1?"03":"02",z=f.fromHex(k+_(N)),H=a(N),M=c(-C*H),q=c(w*H),V=f.BASE.multiplyAndAddUnsafe(z,M,q);if(!V)throw new Error("point at infinify");return V.assertValidity(),V}hasHighS(){return i(this.s)}normalizeS(){return this.hasHighS()?new x(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return Wt(this.toDERHex())}toDERHex(){return Ct.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Wt(this.toCompactHex())}toCompactHex(){return _(this.r)+_(this.s)}}let p={isValidPrivateKey(T){try{return y(T),!0}catch{return!1}},normPrivateKeyToScalar:y,randomPrivateKey:()=>{let T=Vr(t.n);return Eo(t.randomBytes(T),t.n)},precompute(T=8,L=f.BASE){return L._setWindowSize(T),L.multiply(BigInt(3)),L}};function m(T,L=!0){return f.fromPrivateKey(T).toRawBytes(L)}function u(T){let L=Mt(T),S=typeof T=="string",w=(L||S)&&T.length;return L?w===o||w===s:S?w===2*o||w===2*s:T instanceof f}function E(T,L,S=!0){if(u(T))throw new Error("first arg must be private key");if(!u(L))throw new Error("second arg must be public key");return f.fromHex(L).multiply(y(T)).toRawBytes(S)}let B=t.bits2int||function(T){if(T.length>8192)throw new Error("input is too large");let L=It(T),S=T.length*8-t.nBitLength;return S>0?L>>BigInt(S):L},A=t.bits2int_modN||function(T){return c(B(T))},b=Ae(t.nBitLength);function I(T){return at("num < 2^"+t.nBitLength,T,Lt,b),Ot(T,t.nByteLength)}function R(T,L,S=K){if(["recovered","canonical"].some(Q=>Q in S))throw new Error("sign() legacy options not supported");let{hash:w,randomBytes:v}=t,{lowS:C,prehash:N,extraEntropy:k}=S;C==null&&(C=!0),T=j("msgHash",T),Jo(S),N&&(T=j("prehashed msgHash",w(T)));let z=A(T),H=y(L),M=[I(H),I(z)];if(k!=null&&k!==!1){let Q=k===!0?v(e.BYTES):k;M.push(j("extraEntropy",Q))}let q=Tt(...M),V=z;function $(Q){let tt=B(Q);if(!g(tt))return;let et=a(tt),it=f.BASE.multiply(tt).toAffine(),nt=c(it.x);if(nt===Lt)return;let bt=c(et*c(V+nt*H));if(bt===Lt)return;let Et=(it.x===nt?0:2)|Number(it.y&J),xe=bt;return C&&i(bt)&&(xe=l(bt),Et^=1),new x(nt,xe,Et)}return{seed:q,k2sig:$}}let K={lowS:t.lowS,prehash:!1},P={lowS:t.lowS,prehash:!1};function O(T,L,S=K){let{seed:w,k2sig:v}=R(T,L,S),C=t;return Hr(C.hash.outputLen,C.nByteLength,C.hmac)(w,v)}f.BASE._setWindowSize(8);function U(T,L,S,w=P){let v=T;L=j("msgHash",L),S=j("publicKey",S);let{lowS:C,prehash:N,format:k}=w;if(Jo(w),"strict"in w)throw new Error("options.strict was renamed to lowS");if(k!==void 0&&k!=="compact"&&k!=="der")throw new Error("format must be compact or der");let z=typeof v=="string"||Mt(v),H=!z&&!k&&typeof v=="object"&&v!==null&&typeof v.r=="bigint"&&typeof v.s=="bigint";if(!z&&!H)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let M,q;try{if(H&&(M=new x(v.r,v.s)),z){try{k!=="compact"&&(M=x.fromDER(v))}catch(Et){if(!(Et instanceof Ct.Err))throw Et}!M&&k!=="der"&&(M=x.fromCompact(v))}q=f.fromHex(S)}catch{return!1}if(!M||C&&M.hasHighS())return!1;N&&(L=t.hash(L));let{r:V,s:$}=M,Q=A(L),tt=a($),et=c(Q*tt),it=c(V*tt),nt=f.BASE.multiplyAndAddUnsafe(q,et,it)?.toAffine();return nt?c(nt.x)===V:!1}return{CURVE:t,getPublicKey:m,getSharedSecret:E,sign:O,verify:U,ProjectivePoint:f,Signature:x,utils:p}}function xa(r){return{hash:r,hmac:(t,...e)=>vn(r,t,Nr(...e)),randomBytes:Ze}}function rs(r,t){let e=n=>es({...r,...xa(n)});return{...e(t),create:e}}var ss=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),ns=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),ga=BigInt(1),In=BigInt(2),os=(r,t)=>(r+t/In)/t;function ba(r){let t=ss,e=BigInt(3),n=BigInt(6),o=BigInt(11),s=BigInt(22),c=BigInt(23),a=BigInt(44),f=BigInt(88),y=r*r*r%t,h=y*y*r%t,g=G(h,e,t)*h%t,_=G(g,e,t)*h%t,i=G(_,In,t)*y%t,l=G(i,o,t)*i%t,d=G(l,s,t)*l%t,x=G(d,a,t)*d%t,p=G(x,f,t)*x%t,m=G(p,a,t)*d%t,u=G(m,e,t)*h%t,E=G(u,c,t)*l%t,B=G(E,n,t)*y%t,A=G(B,In,t);if(!Tn.eql(Tn.sqr(A),r))throw new Error("Cannot find square root");return A}var Tn=Pt(ss,void 0,void 0,{sqrt:ba}),re=rs({a:BigInt(0),b:BigInt(7),Fp:Tn,n:ns,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{let t=ns,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-ga*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=e,c=BigInt("0x100000000000000000000000000000000"),a=os(s*r,t),f=os(-n*r,t),y=F(r-a*e-f*o,t),h=F(-a*n-f*s,t),g=y>c,_=h>c;if(g&&(y=t-y),_&&(h=t-h),y>c||h>c)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:g,k1:y,k2neg:_,k2:h}}}},Qo),Eh=BigInt(0);var _h=re.ProjectivePoint;function is(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}function cs(r,t,e){let n=Re.digest(e instanceof Uint8Array?e:e.subarray());if(is(n))return n.then(({digest:o})=>re.verify(t,o,r)).catch(o=>{throw new Ne(String(o))});try{return re.verify(t,n.digest,r)}catch(o){throw new Ne(String(o))}}var dr=class{type="secp256k1";raw;_key;constructor(t){this._key=fs(t),this.raw=as(this._key)}toMultihash(){return St.digest(nr(this))}toCID(){return lt.createV1(114,this.toMultihash())}toString(){return X.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:Bt(this.raw,t.raw)}verify(t,e){return cs(this._key,e,t)}};function us(r){return new dr(r)}function as(r){return re.ProjectivePoint.fromHex(r).toRawBytes(!0)}function fs(r){try{return re.ProjectivePoint.fromHex(r),r}catch(t){throw new He(String(t))}}function hs(r){let{Type:t,Data:e}=Ue.decode(r.digest),n=e??new Uint8Array;switch(t){case ht.Ed25519:return Lo(n);case ht.secp256k1:return us(n);default:throw new be}}function nr(r){return Ue.encode({Type:ht[r.type],Data:r.raw})}var ls=Symbol.for("nodejs.util.inspect.custom"),wa=114,ke=class{type;multihash;publicKey;string;constructor(t){this.type=t.type,this.multihash=t.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}[_r]=!0;toString(){return this.string==null&&(this.string=X.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return lt.createV1(wa,this.multihash)}toJSON(){return this.toString()}equals(t){if(t==null)return!1;if(t instanceof Uint8Array)return Bt(this.multihash.bytes,t);if(typeof t=="string")return this.toString()===t;if(t?.toMultihash()?.bytes!=null)return Bt(this.multihash.bytes,t.toMultihash().bytes);throw new Error("not valid Id")}[ls](){return`PeerId(${this.toString()})`}},pr=class extends ke{type="RSA";publicKey;constructor(t){super({...t,type:"RSA"}),this.publicKey=t.publicKey}},mr=class extends ke{type="Ed25519";publicKey;constructor(t){super({...t,type:"Ed25519"}),this.publicKey=t.publicKey}},xr=class extends ke{type="secp256k1";publicKey;constructor(t){super({...t,type:"secp256k1"}),this.publicKey=t.publicKey}},ya=2336,gr=class{type="url";multihash;publicKey;url;constructor(t){this.url=t.toString(),this.multihash=St.digest(st(this.url))}[ls](){return`PeerId(${this.url})`}[_r]=!0;toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return lt.createV1(ya,this.toMultihash())}toJSON(){return this.toString()}equals(t){return t==null?!1:(t instanceof Uint8Array&&(t=hr(t)),t.toString()===this.toString())}};function ds(r){if(_a(r))return new pr({multihash:r});if(Ea(r))try{let t=hs(r);if(t.type==="Ed25519")return new mr({multihash:r,publicKey:t});if(t.type==="secp256k1")return new xr({multihash:r,publicKey:t})}catch{let e=hr(r.digest);return new gr(new URL(e))}throw new Ke("Supplied PeerID Multihash is invalid")}function Ea(r){return r.code===St.code}function _a(r){return r.code===Re.code}function yt(r,t){let e={[Symbol.iterator]:()=>e,next:()=>{let n=r.next(),o=n.value;return n.done===!0||o==null?{done:!0,value:void 0}:{done:!1,value:t(o)}}};return e}function br(r){let t=_e(X.decode(`z${r}`));return ds(t)}var Ft=class{map;constructor(t){if(this.map=new Map,t!=null)for(let[e,n]of t.entries())this.map.set(e.toString(),{key:e,value:n})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(t){return this.map.delete(t.toString())}entries(){return yt(this.map.entries(),t=>[t[1].key,t[1].value])}forEach(t){this.map.forEach((e,n)=>{t(e.value,e.key,this)})}get(t){return this.map.get(t.toString())?.value}has(t){return this.map.has(t.toString())}set(t,e){this.map.set(t.toString(),{key:t,value:e})}keys(){return yt(this.map.values(),t=>t.key)}values(){return yt(this.map.values(),t=>t.value)}get size(){return this.map.size}};function ps(){return new Ft}var Vt=class r{set;constructor(t){if(this.set=new Set,t!=null)for(let e of t)this.set.add(e.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(t){this.set.add(t.toString())}clear(){this.set.clear()}delete(t){this.set.delete(t.toString())}entries(){return yt(this.set.entries(),t=>{let e=br(t[0]);return[e,e]})}forEach(t){this.set.forEach(e=>{let n=br(e);t(n,n,this)})}has(t){return this.set.has(t.toString())}values(){return yt(this.set.values(),t=>br(t))}intersection(t){let e=new r;for(let n of t)this.has(n)&&e.add(n);return e}difference(t){let e=new r;for(let n of this)t.has(n)||e.add(n);return e}union(t){let e=new r;for(let n of t)e.add(n);for(let n of this)e.add(n);return e}};function ms(){return new Vt}var Zt=class r{list;constructor(t){if(this.list=[],t!=null)for(let e of t)this.list.push(e)}[Symbol.iterator](){return yt(this.list.entries(),t=>t[1])}concat(t){let e=new r(this);for(let n of t)e.push(n);return e}entries(){return yt(this.list.entries(),t=>[t[0],t[1]])}every(t){return this.list.every((e,n)=>t(e,n,this))}filter(t){let e=new r;return this.list.forEach((n,o)=>{t(n,o,this)&&e.push(n)}),e}find(t){let e=this.list.find((n,o)=>t(n,o,this));if(e!=null)return e}findIndex(t){return this.list.findIndex((e,n)=>t(e,n,this))}forEach(t){this.list.forEach((e,n)=>{t(e,n,this)})}includes(t){return this.includes(t)}indexOf(t){return this.list.findIndex(e=>e.equals(t))}pop(){let t=this.list.pop();if(t!=null)return t}push(...t){for(let e of t)this.list.push(e)}shift(){let t=this.list.shift();if(t!=null)return t}unshift(...t){let e=this.list.length;for(let n=t.length-1;n>-1;n--)e=this.list.unshift(t[n]);return e}clear(){this.list=[]}get length(){return this.list.length}};function xs(){return new Zt}var Rn=64,gt=class{fp;h;seed;constructor(t,e,n,o=2){if(o>Rn)throw new TypeError("Invalid Fingerprint Size");let s=e.hashV(t,n),c=Uo(o);for(let a=0;a<c.length;a++)c[a]=s[a];c.length===0&&(c[0]=7),this.fp=c,this.h=e,this.seed=n}hash(){return this.h.hash(this.fp,this.seed)}equals(t){return t?.fp instanceof Uint8Array?Bt(this.fp,t.fp):!1}};function ne(r,t){return Math.floor(Math.random()*(t-r))+r}var oe=class{contents;constructor(t){this.contents=new Array(t).fill(null)}has(t){if(!(t instanceof gt))throw new TypeError("Invalid Fingerprint");return this.contents.some(e=>t.equals(e))}add(t){if(!(t instanceof gt))throw new TypeError("Invalid Fingerprint");for(let e=0;e<this.contents.length;e++)if(this.contents[e]==null)return this.contents[e]=t,!0;return!0}swap(t){if(!(t instanceof gt))throw new TypeError("Invalid Fingerprint");let e=ne(0,this.contents.length-1),n=this.contents[e];return this.contents[e]=t,n}remove(t){if(!(t instanceof gt))throw new TypeError("Invalid Fingerprint");let e=this.contents.findIndex(n=>t.equals(n));return e>-1?(this.contents[e]=null,!0):!1}};var Cn={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},ys={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},Es=new globalThis.TextEncoder;function Sa(r,t){let e=Cn[t],n=ys[t];for(let o=0;o<r.length;o++)n^=BigInt(r[o]),n=BigInt.asUintN(t,n*e);return n}function Ba(r,t,e){if(e.length===0)throw new Error("The `utf8Buffer` option must have a length greater than zero");let n=Cn[t],o=ys[t],s=r;for(;s.length>0;){let c=Es.encodeInto(s,e);s=s.slice(c.read);for(let a=0;a<c.written;a++)o^=BigInt(e[a]),o=BigInt.asUintN(t,o*n)}return o}function Ln(r,{size:t=32,utf8Buffer:e}={}){if(!Cn[t])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if(typeof r=="string"){if(e)return Ba(r,t,e);r=Es.encode(r)}return Sa(r,t)}var va=Hs(ws(),1);var De={hash:r=>Number(Ln(r,{size:32})),hashV:(r,t)=>Aa(De.hash(r,t))};function Aa(r){let t=r.toString(16);return t.length%2===1&&(t=`0${t}`),st(t,"base16")}var Ia=500,Oe=class{bucketSize;filterSize;fingerprintSize;buckets;count;hash;seed;constructor(t){this.filterSize=t.filterSize,this.bucketSize=t.bucketSize??4,this.fingerprintSize=t.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=t.hash??De,this.seed=t.seed??ne(0,Math.pow(2,10))}add(t){typeof t=="string"&&(t=st(t));let e=new gt(t,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(t,this.seed)%this.filterSize,o=(n^e.hash())%this.filterSize;if(this.buckets[n]==null&&(this.buckets[n]=new oe(this.bucketSize)),this.buckets[o]==null&&(this.buckets[o]=new oe(this.bucketSize)),this.buckets[n].add(e)||this.buckets[o].add(e))return this.count++,!0;let s=[n,o],c=s[ne(0,s.length-1)];this.buckets[c]==null&&(this.buckets[c]=new oe(this.bucketSize));for(let a=0;a<Ia;a++){let f=this.buckets[c].swap(e);if(f!=null&&(c=(c^f.hash())%this.filterSize,this.buckets[c]==null&&(this.buckets[c]=new oe(this.bucketSize)),this.buckets[c].add(f)))return this.count++,!0}return!1}has(t){typeof t=="string"&&(t=st(t));let e=new gt(t,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(t,this.seed)%this.filterSize,o=this.buckets[n]?.has(e)??!1;if(o)return o;let s=(n^e.hash())%this.filterSize;return this.buckets[s]?.has(e)??!1}remove(t){typeof t=="string"&&(t=st(t));let e=new gt(t,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(t,this.seed)%this.filterSize,o=this.buckets[n]?.remove(e)??!1;if(o)return this.count--,o;let s=(n^e.hash())%this.filterSize,c=this.buckets[s]?.remove(e)??!1;return c&&this.count--,c}get reliable(){return Math.floor(100*(this.count/this.filterSize))<=90}},Ta={1:.5,2:.84,4:.95,8:.98};function Ra(r=.001){return r>.002?2:r>1e-5?4:8}function _s(r,t=.001){let e=Ra(t),n=Ta[e],o=Math.round(r/n),s=Math.min(Math.ceil(Math.log2(1/t)+Math.log2(2*e)),Rn);return{filterSize:o,bucketSize:e,fingerprintSize:s}}var yr=class{filterSize;bucketSize;fingerprintSize;scale;filterSeries;hash;seed;constructor(t){this.bucketSize=t.bucketSize??4,this.filterSize=t.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=t.fingerprintSize??2,this.scale=t.scale??2,this.hash=t.hash??De,this.seed=t.seed??ne(0,Math.pow(2,10)),this.filterSeries=[new Oe({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(t){if(typeof t=="string"&&(t=st(t)),this.has(t))return!0;let e=this.filterSeries.find(n=>n.reliable);if(e==null){let n=this.filterSize*Math.pow(this.scale,this.filterSeries.length);e=new Oe({filterSize:n,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(e)}return e.add(t)}has(t){typeof t=="string"&&(t=st(t));for(let e=0;e<this.filterSeries.length;e++)if(this.filterSeries[e].has(t))return!0;return!1}remove(t){typeof t=="string"&&(t=st(t));for(let e=0;e<this.filterSeries.length;e++)if(this.filterSeries[e].remove(t))return!0;return!1}get count(){return this.filterSeries.reduce((t,e)=>t+e.count,0)}};function Un(r,t=.001,e){return new yr({..._s(r,t),...e??{}})}var Pe=class{filter;constructor(t,e){this.filter=Un(t,e)}has(t){return this.filter.has(t.toMultihash().bytes)}add(t){this.filter.add(t.toMultihash().bytes)}remove(t){this.filter.remove?.(t.toMultihash().bytes)}};function Ss(r,t=.001){return new Pe(r,t)}var Nn=class extends Ft{metric;constructor(t){super();let{name:e,metrics:n}=t;this.metric=n.registerMetric(e),this.updateComponentMetric()}set(t,e){return super.set(t,e),this.updateComponentMetric(),this}delete(t){let e=super.delete(t);return this.updateComponentMetric(),e}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}};function Bs(r){let{name:t,metrics:e}=r,n;return e!=null?n=new Nn({name:t,metrics:e}):n=new Ft,n}var kn=class extends Vt{metric;constructor(t){super();let{name:e,metrics:n}=t;this.metric=n.registerMetric(e),this.updateComponentMetric()}add(t){super.add(t),this.updateComponentMetric()}delete(t){super.delete(t),this.updateComponentMetric()}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}};function vs(r){let{name:t,metrics:e}=r,n;return e!=null?n=new kn({name:t,metrics:e}):n=new Vt,n}var Mn=class extends Zt{metric;constructor(t){super();let{name:e,metrics:n}=t;this.metric=n.registerMetric(e),this.updateComponentMetric()}pop(){let t=super.pop();return this.updateComponentMetric(),t}push(...t){super.push(...t),this.updateComponentMetric()}shift(){let t=super.shift();return this.updateComponentMetric(),t}unshift(...t){let e=super.unshift(...t);return this.updateComponentMetric(),e}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.length)}};function As(r){let{name:t,metrics:e}=r,n;return e!=null?n=new Mn({name:t,metrics:e}):n=new Zt,n}return Ks(Ca);})();
./node_modules/@libp2p/webrtc/dist/index.min.js:2:"use strict";var Libp2PWebrtc=(()=>{var Nh=Object.create;var Fn=Object.defineProperty;var Lh=Object.getOwnPropertyDescriptor;var _h=Object.getOwnPropertyNames;var Rh=Object.getPrototypeOf,Uh=Object.prototype.hasOwnProperty;var Dh=(r,t)=>()=>(t||r((t={exports:{}}).exports,t),t.exports),Ct=(r,t)=>{for(var e in t)Fn(r,e,{get:t[e],enumerable:!0})},Uc=(r,t,e,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of _h(t))!Uh.call(r,o)&&o!==e&&Fn(r,o,{get:()=>t[o],enumerable:!(n=Lh(t,o))||n.enumerable});return r};var Ph=(r,t,e)=>(e=r!=null?Nh(Rh(r)):{},Uc(t||!r||!r.__esModule?Fn(e,"default",{value:r,enumerable:!0}):e,r)),Oh=r=>Uc(Fn({},"__esModule",{value:!0}),r);var Pl=Dh(Nr=>{"use strict";var am="[object ArrayBuffer]",xe=class r{static isArrayBuffer(t){return Object.prototype.toString.call(t)===am}static toArrayBuffer(t){return this.isArrayBuffer(t)?t:t.byteLength===t.buffer.byteLength||t.byteOffset===0&&t.byteLength===t.buffer.byteLength?t.buffer:this.toUint8Array(t.buffer).slice(t.byteOffset,t.byteOffset+t.byteLength).buffer}static toUint8Array(t){return this.toView(t,Uint8Array)}static toView(t,e){if(t.constructor===e)return t;if(this.isArrayBuffer(t))return new e(t);if(this.isArrayBufferView(t))return new e(t.buffer,t.byteOffset,t.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(t){return this.isArrayBufferView(t)||this.isArrayBuffer(t)}static isArrayBufferView(t){return ArrayBuffer.isView(t)||t&&this.isArrayBuffer(t.buffer)}static isEqual(t,e){let n=r.toUint8Array(t),o=r.toUint8Array(e);if(n.length!==o.byteLength)return!1;for(let s=0;s<n.length;s++)if(n[s]!==o[s])return!1;return!0}static concat(...t){let e;Array.isArray(t[0])&&!(t[1]instanceof Function)||Array.isArray(t[0])&&t[1]instanceof Function?e=t[0]:t[t.length-1]instanceof Function?e=t.slice(0,t.length-1):e=t;let n=0;for(let i of e)n+=i.byteLength;let o=new Uint8Array(n),s=0;for(let i of e){let a=this.toUint8Array(i);o.set(a,s),s+=a.length}return t[t.length-1]instanceof Function?this.toView(o,t[t.length-1]):o.buffer}},ha="string",cm=/^[0-9a-f\s]+$/i,lm=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,um=/^[a-zA-Z0-9-_]+$/,go=class{static fromString(t){let e=unescape(encodeURIComponent(t)),n=new Uint8Array(e.length);for(let o=0;o<e.length;o++)n[o]=e.charCodeAt(o);return n.buffer}static toString(t){let e=xe.toUint8Array(t),n="";for(let s=0;s<e.length;s++)n+=String.fromCharCode(e[s]);return decodeURIComponent(escape(n))}},qt=class{static toString(t,e=!1){let n=xe.toArrayBuffer(t),o=new DataView(n),s="";for(let i=0;i<n.byteLength;i+=2){let a=o.getUint16(i,e);s+=String.fromCharCode(a)}return s}static fromString(t,e=!1){let n=new ArrayBuffer(t.length*2),o=new DataView(n);for(let s=0;s<t.length;s++)o.setUint16(s*2,t.charCodeAt(s),e);return n}},yo=class r{static isHex(t){return typeof t===ha&&cm.test(t)}static isBase64(t){return typeof t===ha&&lm.test(t)}static isBase64Url(t){return typeof t===ha&&um.test(t)}static ToString(t,e="utf8"){let n=xe.toUint8Array(t);switch(e.toLowerCase()){case"utf8":return this.ToUtf8String(n);case"binary":return this.ToBinary(n);case"hex":return this.ToHex(n);case"base64":return this.ToBase64(n);case"base64url":return this.ToBase64Url(n);case"utf16le":return qt.toString(n,!0);case"utf16":case"utf16be":return qt.toString(n);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromString(t,e="utf8"){if(!t)return new ArrayBuffer(0);switch(e.toLowerCase()){case"utf8":return this.FromUtf8String(t);case"binary":return this.FromBinary(t);case"hex":return this.FromHex(t);case"base64":return this.FromBase64(t);case"base64url":return this.FromBase64Url(t);case"utf16le":return qt.fromString(t,!0);case"utf16":case"utf16be":return qt.fromString(t);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToBase64(t){let e=xe.toUint8Array(t);if(typeof btoa<"u"){let n=this.ToString(e,"binary");return btoa(n)}else return Buffer.from(e).toString("base64")}static FromBase64(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isBase64(e))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return typeof atob<"u"?this.FromBinary(atob(e)):new Uint8Array(Buffer.from(e,"base64")).buffer}static FromBase64Url(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isBase64Url(e))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(e.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(t){return this.ToBase64(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(t,e=r.DEFAULT_UTF8_ENCODING){switch(e){case"ascii":return this.FromBinary(t);case"utf8":return go.fromString(t);case"utf16":case"utf16be":return qt.fromString(t);case"utf16le":case"usc2":return qt.fromString(t,!0);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToUtf8String(t,e=r.DEFAULT_UTF8_ENCODING){switch(e){case"ascii":return this.ToBinary(t);case"utf8":return go.toString(t);case"utf16":case"utf16be":return qt.toString(t);case"utf16le":case"usc2":return qt.toString(t,!0);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromBinary(t){let e=t.length,n=new Uint8Array(e);for(let o=0;o<e;o++)n[o]=t.charCodeAt(o);return n.buffer}static ToBinary(t){let e=xe.toUint8Array(t),n="";for(let o=0;o<e.length;o++)n+=String.fromCharCode(e[o]);return n}static ToHex(t){let e=xe.toUint8Array(t),n="",o=e.length;for(let s=0;s<o;s++){let i=e[s];i<16&&(n+="0"),n+=i.toString(16)}return n}static FromHex(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isHex(e))throw new TypeError("Argument 'hexString' is not HEX encoded");e.length%2&&(e=`0${e}`);let n=new Uint8Array(e.length/2);for(let o=0;o<e.length;o=o+2){let s=e.slice(o,o+2);n[o/2]=parseInt(s,16)}return n.buffer}static ToUtf16String(t,e=!1){return qt.toString(t,e)}static FromUtf16String(t,e=!1){return qt.fromString(t,e)}static Base64Padding(t){let e=4-t.length%4;if(e<4)for(let n=0;n<e;n++)t+="=";return t}static formatString(t){return t?.replace(/[\n\r\t ]/g,"")||""}};yo.DEFAULT_UTF8_ENCODING="utf8";function fm(r,...t){let e=arguments[0];for(let n=1;n<arguments.length;n++){let o=arguments[n];for(let s in o)e[s]=o[s]}return e}function hm(...r){let t=r.map(o=>o.byteLength).reduce((o,s)=>o+s),e=new Uint8Array(t),n=0;return r.map(o=>new Uint8Array(o)).forEach(o=>{for(let s of o)e[n++]=s}),e.buffer}function dm(r,t){if(!(r&&t)||r.byteLength!==t.byteLength)return!1;let e=new Uint8Array(r),n=new Uint8Array(t);for(let o=0;o<r.byteLength;o++)if(e[o]!==n[o])return!1;return!0}Nr.BufferSourceConverter=xe;Nr.Convert=yo;Nr.assign=fm;Nr.combine=hm;Nr.isEqual=dm});var gg={};Ct(gg,{webRTC:()=>mg,webRTCDirect:()=>pg});var ri=Symbol.for("@libp2p/peer-id");var Kn=Symbol.for("@libp2p/transport");var Dc;(function(r){r[r.FATAL_ALL=0]="FATAL_ALL",r[r.NO_FATAL=1]="NO_FATAL"})(Dc||(Dc={}));var $n=class extends Error{static name="UnexpectedPeerError";constructor(t="Unexpected Peer"){super(t),this.name="UnexpectedPeerError"}};var et=class extends Error{static name="InvalidParametersError";constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}},yr=class extends Error{static name="InvalidPublicKeyError";constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}};var Wn=class extends Error{static name="ConnectionFailedError";constructor(t="Connection failed"){super(t),this.name="ConnectionFailedError"}};var qn=class extends Error{static name="StreamResetError";constructor(t="The stream has been reset"){super(t),this.name="StreamResetError"}},Ze=class extends Error{static name="StreamStateError";constructor(t="The stream is in an invalid state"){super(t),this.name="StreamStateError"}};var zn=class extends Error{static name="InvalidMultihashError";constructor(t="Invalid Multihash"){super(t),this.name="InvalidMultihashError"}};var Gn=class extends Error{static name="InvalidMessageError";constructor(t="Invalid message"){super(t),this.name="InvalidMessageError"}};var jr=class extends Error{static name="TimeoutError";constructor(t="Timed out"){super(t),this.name="TimeoutError"}};var Xe=class extends Error{static name="UnsupportedKeyTypeError";constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}};var jn=(r,...t)=>{try{[...t]}catch{}};var Zn=class extends EventTarget{#t=new Map;constructor(){super(),jn(1/0,this)}listenerCount(t){let e=this.#t.get(t);return e==null?0:e.length}addEventListener(t,e,n){super.addEventListener(t,e,n);let o=this.#t.get(t);o==null&&(o=[],this.#t.set(t,o)),o.push({callback:e,once:(n!==!0&&n!==!1&&n?.once)??!1})}removeEventListener(t,e,n){super.removeEventListener(t.toString(),e??null,n);let o=this.#t.get(t);o!=null&&(o=o.filter(({callback:s})=>s!==e),this.#t.set(t,o))}dispatchEvent(t){let e=super.dispatchEvent(t),n=this.#t.get(t.type);return n==null||(n=n.filter(({once:o})=>!o),this.#t.set(t.type,n)),e}safeDispatchEvent(t,e={}){return this.dispatchEvent(new CustomEvent(t,e))}};var wr=Symbol.for("@libp2p/service-capabilities"),Pc=Symbol.for("@libp2p/service-dependencies");var ai={};Ct(ai,{base58btc:()=>nt,base58flickr:()=>$h});var Gg=new Uint8Array(0);function Oc(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function he(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function Mc(r){return new TextEncoder().encode(r)}function Hc(r){return new TextDecoder().decode(r)}function Mh(r,t){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),n=0;n<e.length;n++)e[n]=255;for(var o=0;o<r.length;o++){var s=r.charAt(o),i=s.charCodeAt(0);if(e[i]!==255)throw new TypeError(s+" is ambiguous");e[i]=o}var a=r.length,c=r.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function f(y){if(y instanceof Uint8Array||(ArrayBuffer.isView(y)?y=new Uint8Array(y.buffer,y.byteOffset,y.byteLength):Array.isArray(y)&&(y=Uint8Array.from(y))),!(y instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(y.length===0)return"";for(var g=0,h=0,w=0,x=y.length;w!==x&&y[w]===0;)w++,g++;for(var m=(x-w)*u+1>>>0,I=new Uint8Array(m);w!==x;){for(var L=y[w],N=0,B=m-1;(L!==0||N<h)&&B!==-1;B--,N++)L+=256*I[B]>>>0,I[B]=L%a>>>0,L=L/a>>>0;if(L!==0)throw new Error("Non-zero carry");h=N,w++}for(var k=m-h;k!==m&&I[k]===0;)k++;for(var S=c.repeat(g);k<m;++k)S+=r.charAt(I[k]);return S}function d(y){if(typeof y!="string")throw new TypeError("Expected String");if(y.length===0)return new Uint8Array;var g=0;if(y[g]!==" "){for(var h=0,w=0;y[g]===c;)h++,g++;for(var x=(y.length-g)*l+1>>>0,m=new Uint8Array(x);y[g];){var I=e[y.charCodeAt(g)];if(I===255)return;for(var L=0,N=x-1;(I!==0||L<w)&&N!==-1;N--,L++)I+=a*m[N]>>>0,m[N]=I%256>>>0,I=I/256>>>0;if(I!==0)throw new Error("Non-zero carry");w=L,g++}if(y[g]!==" "){for(var B=x-w;B!==x&&m[B]===0;)B++;for(var k=new Uint8Array(h+(x-B)),S=h;B!==x;)k[S++]=m[B++];return k}}}function p(y){var g=d(y);if(g)return g;throw new Error(`Non-${t} character`)}return{encode:f,decodeUnsafe:d,decode:p}}var Hh=Mh,Vh=Hh,Fc=Vh;var ni=class{name;prefix;baseEncode;constructor(t,e,n){this.name=t,this.prefix=e,this.baseEncode=n}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}},oi=class{name;prefix;baseDecode;prefixCodePoint;constructor(t,e,n){this.name=t,this.prefix=e;let o=e.codePointAt(0);if(o===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=o,this.baseDecode=n}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return Kc(this,t)}},si=class{decoders;constructor(t){this.decoders=t}or(t){return Kc(this,t)}decode(t){let e=t[0],n=this.decoders[e];if(n!=null)return n.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};function Kc(r,t){return new si({...r.decoders??{[r.prefix]:r},...t.decoders??{[t.prefix]:t}})}var ii=class{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(t,e,n,o){this.name=t,this.prefix=e,this.baseEncode=n,this.baseDecode=o,this.encoder=new ni(t,e,n),this.decoder=new oi(t,e,o)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}};function br({name:r,prefix:t,encode:e,decode:n}){return new ii(r,t,e,n)}function _e({name:r,prefix:t,alphabet:e}){let{encode:n,decode:o}=Fc(e,r);return br({prefix:t,name:r,encode:n,decode:s=>he(o(s))})}function Fh(r,t,e,n){let o={};for(let u=0;u<t.length;++u)o[t[u]]=u;let s=r.length;for(;r[s-1]==="=";)--s;let i=new Uint8Array(s*e/8|0),a=0,c=0,l=0;for(let u=0;u<s;++u){let f=o[r[u]];if(f===void 0)throw new SyntaxError(`Non-${n} character`);c=c<<e|f,a+=e,a>=8&&(a-=8,i[l++]=255&c>>a)}if(a>=e||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return i}function Kh(r,t,e){let n=t[t.length-1]==="=",o=(1<<e)-1,s="",i=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],i+=8;i>e;)i-=e,s+=t[o&a>>i];if(i!==0&&(s+=t[o&a<<e-i]),n)for(;s.length*e&7;)s+="=";return s}function dt({name:r,prefix:t,bitsPerChar:e,alphabet:n}){return br({prefix:t,name:r,encode(o){return Kh(o,n,e)},decode(o){return Fh(o,n,e,r)}})}var nt=_e({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),$h=_e({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var ci={};Ct(ci,{base32:()=>de,base32hex:()=>Gh,base32hexpad:()=>Zh,base32hexpadupper:()=>Xh,base32hexupper:()=>jh,base32pad:()=>qh,base32padupper:()=>zh,base32upper:()=>Wh,base32z:()=>Yh});var de=dt({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Wh=dt({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),qh=dt({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),zh=dt({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Gh=dt({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),jh=dt({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Zh=dt({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Xh=dt({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Yh=dt({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var li={};Ct(li,{base36:()=>Zr,base36upper:()=>Jh});var Zr=_e({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Jh=_e({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var Gt={};Ct(Gt,{Digest:()=>Ye,create:()=>Ot,decode:()=>Re,equals:()=>fi,hasCode:()=>yd});var Qh=qc,$c=128,td=127,ed=~td,rd=Math.pow(2,31);function qc(r,t,e){t=t||[],e=e||0;for(var n=e;r>=rd;)t[e++]=r&255|$c,r/=128;for(;r&ed;)t[e++]=r&255|$c,r>>>=7;return t[e]=r|0,qc.bytes=e-n+1,t}var nd=ui,od=128,Wc=127;function ui(r,n){var e=0,n=n||0,o=0,s=n,i,a=r.length;do{if(s>=a)throw ui.bytes=0,new RangeError("Could not decode varint");i=r[s++],e+=o<28?(i&Wc)<<o:(i&Wc)*Math.pow(2,o),o+=7}while(i>=od);return ui.bytes=s-n,e}var sd=Math.pow(2,7),id=Math.pow(2,14),ad=Math.pow(2,21),cd=Math.pow(2,28),ld=Math.pow(2,35),ud=Math.pow(2,42),fd=Math.pow(2,49),hd=Math.pow(2,56),dd=Math.pow(2,63),pd=function(r){return r<sd?1:r<id?2:r<ad?3:r<cd?4:r<ld?5:r<ud?6:r<fd?7:r<hd?8:r<dd?9:10},md={encode:Qh,decode:nd,encodingLength:pd},gd=md,Xr=gd;function Yr(r,t=0){return[Xr.decode(r,t),Xr.decode.bytes]}function xr(r,t,e=0){return Xr.encode(r,t,e),t}function vr(r){return Xr.encodingLength(r)}function Ot(r,t){let e=t.byteLength,n=vr(r),o=n+vr(e),s=new Uint8Array(o+e);return xr(r,s,0),xr(e,s,n),s.set(t,o),new Ye(r,e,t,s)}function Re(r){let t=he(r),[e,n]=Yr(t),[o,s]=Yr(t.subarray(n)),i=t.subarray(n+s);if(i.byteLength!==o)throw new Error("Incorrect length");return new Ye(e,o,i,t)}function fi(r,t){if(r===t)return!0;{let e=t;return r.code===e.code&&r.size===e.size&&e.bytes instanceof Uint8Array&&Oc(r.bytes,e.bytes)}}var Ye=class{code;size;digest;bytes;constructor(t,e,n,o){this.code=t,this.size=e,this.digest=n,this.bytes=o}};function yd(r,t){return r.code===t}function zc(r,t){let{bytes:e,version:n}=r;switch(n){case 0:return bd(e,hi(r),t??nt.encoder);default:return xd(e,hi(r),t??de.encoder)}}var Gc=new WeakMap;function hi(r){let t=Gc.get(r);if(t==null){let e=new Map;return Gc.set(r,e),e}return t}var vt=class r{code;version;multihash;bytes;"/";constructor(t,e,n,o){this.code=e,this.version=t,this.multihash=n,this.bytes=o,this["/"]=o}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{let{code:t,multihash:e}=this;if(t!==Jr)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==vd)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return r.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{let{code:t,digest:e}=this.multihash,n=Ot(t,e);return r.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return r.equals(this,t)}static equals(t,e){let n=e;return n!=null&&t.code===n.code&&t.version===n.version&&fi(t.multihash,n.multihash)}toString(t){return zc(this,t)}toJSON(){return{"/":zc(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;let e=t;if(e instanceof r)return e;if(e["/"]!=null&&e["/"]===e.bytes||e.asCID===e){let{version:n,code:o,multihash:s,bytes:i}=e;return new r(n,o,s,i??jc(n,o,s.bytes))}else if(e[Ed]===!0){let{version:n,multihash:o,code:s}=e,i=Re(o);return r.create(n,s,i)}else return null}static create(t,e,n){if(typeof e!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(e!==Jr)throw new Error(`Version 0 CID must use dag-pb (code: ${Jr}) block encoding`);return new r(t,e,n,n.bytes)}case 1:{let o=jc(t,e,n.bytes);return new r(t,e,n,o)}default:throw new Error("Invalid version")}}static createV0(t){return r.create(0,Jr,t)}static createV1(t,e){return r.create(1,t,e)}static decode(t){let[e,n]=r.decodeFirst(t);if(n.length!==0)throw new Error("Incorrect length");return e}static decodeFirst(t){let e=r.inspectBytes(t),n=e.size-e.multihashSize,o=he(t.subarray(n,n+e.multihashSize));if(o.byteLength!==e.multihashSize)throw new Error("Incorrect length");let s=o.subarray(e.multihashSize-e.digestSize),i=new Ye(e.multihashCode,e.digestSize,s,o);return[e.version===0?r.createV0(i):r.createV1(e.codec,i),t.subarray(e.size)]}static inspectBytes(t){let e=0,n=()=>{let[f,d]=Yr(t.subarray(e));return e+=d,f},o=n(),s=Jr;if(o===18?(o=0,e=0):s=n(),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);let i=e,a=n(),c=n(),l=e+c,u=l-i;return{version:o,codec:s,multihashCode:a,digestSize:c,multihashSize:u,size:l}}static parse(t,e){let[n,o]=wd(t,e),s=r.decode(o);if(s.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return hi(s).set(n,t),s}};function wd(r,t){switch(r[0]){case"Q":{let e=t??nt;return[nt.prefix,e.decode(`${nt.prefix}${r}`)]}case nt.prefix:{let e=t??nt;return[nt.prefix,e.decode(r)]}case de.prefix:{let e=t??de;return[de.prefix,e.decode(r)]}case Zr.prefix:{let e=t??Zr;return[Zr.prefix,e.decode(r)]}default:{if(t==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],t.decode(r)]}}}function bd(r,t,e){let{prefix:n}=e;if(n!==nt.prefix)throw Error(`Cannot string encode V0 in ${e.name} encoding`);let o=t.get(n);if(o==null){let s=e.encode(r).slice(1);return t.set(n,s),s}else return o}function xd(r,t,e){let{prefix:n}=e,o=t.get(n);if(o==null){let s=e.encode(r);return t.set(n,s),s}else return o}var Jr=112,vd=18;function jc(r,t,e){let n=vr(r),o=n+vr(t),s=new Uint8Array(o+e.byteLength);return xr(r,s,0),xr(t,s,n),s.set(e,o),s}var Ed=Symbol.for("@ipld/js-cid/CID");var di={};Ct(di,{identity:()=>pe});var Zc=0,Ad="identity",Xc=he;function Bd(r){return Ot(Zc,Xc(r))}var pe={code:Zc,name:Ad,encode:Xc,digest:Bd};function Rt(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function Yn(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function Sd(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Er(r,...t){if(!Sd(r))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(r.length))throw new Error("Uint8Array expected of length "+t+", got length="+r.length)}function Qr(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Yn(r.outputLen),Yn(r.blockLen)}function Ar(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function Yc(r,t){Er(r);let e=t.outputLen;if(r.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}var Je=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var Jn=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),jt=(r,t)=>r<<32-t|r>>>t;function Jc(r){if(typeof r!="string")throw new Error("utf8ToBytes expected string, got "+typeof r);return new Uint8Array(new TextEncoder().encode(r))}function Ue(r){return typeof r=="string"&&(r=Jc(r)),Er(r),r}function pi(...r){let t=0;for(let n=0;n<r.length;n++){let o=r[n];Er(o),t+=o.length}let e=new Uint8Array(t);for(let n=0,o=0;n<r.length;n++){let s=r[n];e.set(s,o),o+=s.length}return e}var Br=class{clone(){return this._cloneInto()}};function Qn(r){let t=n=>r().update(Ue(n)).digest(),e=r();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>r(),t}function tn(r=32){if(Je&&typeof Je.getRandomValues=="function")return Je.getRandomValues(new Uint8Array(r));if(Je&&typeof Je.randomBytes=="function")return Je.randomBytes(r);throw new Error("crypto.getRandomValues must be defined")}function Id(r,t,e,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(t,e,n);let o=BigInt(32),s=BigInt(4294967295),i=Number(e>>o&s),a=Number(e&s),c=n?4:0,l=n?0:4;r.setUint32(t+c,i,n),r.setUint32(t+l,a,n)}var Qc=(r,t,e)=>r&t^~r&e,tl=(r,t,e)=>r&t^r&e^t&e,Sr=class extends Br{constructor(t,e,n,o){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=Jn(this.buffer)}update(t){Ar(this);let{view:e,buffer:n,blockLen:o}=this;t=Ue(t);let s=t.length;for(let i=0;i<s;){let a=Math.min(o-this.pos,s-i);if(a===o){let c=Jn(t);for(;o<=s-i;i+=o)this.process(c,i);continue}n.set(t.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===o&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Ar(this),Yc(t,this),this.finished=!0;let{buffer:e,view:n,blockLen:o,isLE:s}=this,{pos:i}=this;e[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>o-i&&(this.process(n,0),i=0);for(let f=i;f<o;f++)e[f]=0;Id(n,o-8,BigInt(this.length*8),s),this.process(n,0);let a=Jn(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let l=c/4,u=this.get();if(l>u.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<l;f++)a.setUint32(4*f,u[f],s)}digest(){let{buffer:t,outputLen:e}=this;this.digestInto(t);let n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:e,buffer:n,length:o,finished:s,destroyed:i,pos:a}=this;return t.length=o,t.pos=a,t.finished=s,t.destroyed=i,o%e&&t.buffer.set(n),t}};var to=BigInt(4294967295),mi=BigInt(32);function el(r,t=!1){return t?{h:Number(r&to),l:Number(r>>mi&to)}:{h:Number(r>>mi&to)|0,l:Number(r&to)|0}}function Cd(r,t=!1){let e=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let o=0;o<r.length;o++){let{h:s,l:i}=el(r[o],t);[e[o],n[o]]=[s,i]}return[e,n]}var kd=(r,t)=>BigInt(r>>>0)<<mi|BigInt(t>>>0),Td=(r,t,e)=>r>>>e,Nd=(r,t,e)=>r<<32-e|t>>>e,Ld=(r,t,e)=>r>>>e|t<<32-e,_d=(r,t,e)=>r<<32-e|t>>>e,Rd=(r,t,e)=>r<<64-e|t>>>e-32,Ud=(r,t,e)=>r>>>e-32|t<<64-e,Dd=(r,t)=>t,Pd=(r,t)=>r,Od=(r,t,e)=>r<<e|t>>>32-e,Md=(r,t,e)=>t<<e|r>>>32-e,Hd=(r,t,e)=>t<<e-32|r>>>64-e,Vd=(r,t,e)=>r<<e-32|t>>>64-e;function Fd(r,t,e,n){let o=(t>>>0)+(n>>>0);return{h:r+e+(o/2**32|0)|0,l:o|0}}var Kd=(r,t,e)=>(r>>>0)+(t>>>0)+(e>>>0),$d=(r,t,e,n)=>t+e+n+(r/2**32|0)|0,Wd=(r,t,e,n)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0),qd=(r,t,e,n,o)=>t+e+n+o+(r/2**32|0)|0,zd=(r,t,e,n,o)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(o>>>0),Gd=(r,t,e,n,o,s)=>t+e+n+o+s+(r/2**32|0)|0;var jd={fromBig:el,split:Cd,toBig:kd,shrSH:Td,shrSL:Nd,rotrSH:Ld,rotrSL:_d,rotrBH:Rd,rotrBL:Ud,rotr32H:Dd,rotr32L:Pd,rotlSH:Od,rotlSL:Md,rotlBH:Hd,rotlBL:Vd,add:Fd,add3L:Kd,add3H:$d,add4L:Wd,add4H:qd,add5H:Gd,add5L:zd},$=jd;var[Zd,Xd]=$.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),De=new Uint32Array(80),Pe=new Uint32Array(80),gi=class extends Sr{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){let{Ah:t,Al:e,Bh:n,Bl:o,Ch:s,Cl:i,Dh:a,Dl:c,Eh:l,El:u,Fh:f,Fl:d,Gh:p,Gl:y,Hh:g,Hl:h}=this;return[t,e,n,o,s,i,a,c,l,u,f,d,p,y,g,h]}set(t,e,n,o,s,i,a,c,l,u,f,d,p,y,g,h){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=o|0,this.Ch=s|0,this.Cl=i|0,this.Dh=a|0,this.Dl=c|0,this.Eh=l|0,this.El=u|0,this.Fh=f|0,this.Fl=d|0,this.Gh=p|0,this.Gl=y|0,this.Hh=g|0,this.Hl=h|0}process(t,e){for(let m=0;m<16;m++,e+=4)De[m]=t.getUint32(e),Pe[m]=t.getUint32(e+=4);for(let m=16;m<80;m++){let I=De[m-15]|0,L=Pe[m-15]|0,N=$.rotrSH(I,L,1)^$.rotrSH(I,L,8)^$.shrSH(I,L,7),B=$.rotrSL(I,L,1)^$.rotrSL(I,L,8)^$.shrSL(I,L,7),k=De[m-2]|0,S=Pe[m-2]|0,H=$.rotrSH(k,S,19)^$.rotrBH(k,S,61)^$.shrSH(k,S,6),_=$.rotrSL(k,S,19)^$.rotrBL(k,S,61)^$.shrSL(k,S,6),M=$.add4L(B,_,Pe[m-7],Pe[m-16]),V=$.add4H(M,N,H,De[m-7],De[m-16]);De[m]=V|0,Pe[m]=M|0}let{Ah:n,Al:o,Bh:s,Bl:i,Ch:a,Cl:c,Dh:l,Dl:u,Eh:f,El:d,Fh:p,Fl:y,Gh:g,Gl:h,Hh:w,Hl:x}=this;for(let m=0;m<80;m++){let I=$.rotrSH(f,d,14)^$.rotrSH(f,d,18)^$.rotrBH(f,d,41),L=$.rotrSL(f,d,14)^$.rotrSL(f,d,18)^$.rotrBL(f,d,41),N=f&p^~f&g,B=d&y^~d&h,k=$.add5L(x,L,B,Xd[m],Pe[m]),S=$.add5H(k,w,I,N,Zd[m],De[m]),H=k|0,_=$.rotrSH(n,o,28)^$.rotrBH(n,o,34)^$.rotrBH(n,o,39),M=$.rotrSL(n,o,28)^$.rotrBL(n,o,34)^$.rotrBL(n,o,39),V=n&s^n&a^s&a,C=o&i^o&c^i&c;w=g|0,x=h|0,g=p|0,h=y|0,p=f|0,y=d|0,{h:f,l:d}=$.add(l|0,u|0,S|0,H|0),l=a|0,u=c|0,a=s|0,c=i|0,s=n|0,i=o|0;let T=$.add3L(H,M,C);n=$.add3H(T,S,_,V),o=T|0}({h:n,l:o}=$.add(this.Ah|0,this.Al|0,n|0,o|0)),{h:s,l:i}=$.add(this.Bh|0,this.Bl|0,s|0,i|0),{h:a,l:c}=$.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:l,l:u}=$.add(this.Dh|0,this.Dl|0,l|0,u|0),{h:f,l:d}=$.add(this.Eh|0,this.El|0,f|0,d|0),{h:p,l:y}=$.add(this.Fh|0,this.Fl|0,p|0,y|0),{h:g,l:h}=$.add(this.Gh|0,this.Gl|0,g|0,h|0),{h:w,l:x}=$.add(this.Hh|0,this.Hl|0,w|0,x|0),this.set(n,o,s,i,a,c,l,u,f,d,p,y,g,h,w,x)}roundClean(){De.fill(0),Pe.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}};var rl=Qn(()=>new gi);var no={};Ct(no,{aInRange:()=>Et,abool:()=>Zt,abytes:()=>Ir,bitGet:()=>rp,bitLen:()=>xi,bitMask:()=>rn,bitSet:()=>np,bytesToHex:()=>ge,bytesToNumberBE:()=>ye,bytesToNumberLE:()=>Xt,concatBytes:()=>be,createHmacDrbg:()=>vi,ensureBytes:()=>ot,equalBytes:()=>tp,hexToBytes:()=>tr,hexToNumber:()=>bi,inRange:()=>en,isBytes:()=>Oe,memoized:()=>er,notImplemented:()=>sp,numberToBytesBE:()=>Me,numberToBytesLE:()=>we,numberToHexUnpadded:()=>Qe,numberToVarBytesBE:()=>Qd,utf8ToBytes:()=>ep,validateObject:()=>Wt});var eo=BigInt(0),ro=BigInt(1),Yd=BigInt(2);function Oe(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Ir(r){if(!Oe(r))throw new Error("Uint8Array expected")}function Zt(r,t){if(typeof t!="boolean")throw new Error(r+" boolean expected, got "+t)}var Jd=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function ge(r){Ir(r);let t="";for(let e=0;e<r.length;e++)t+=Jd[r[e]];return t}function Qe(r){let t=r.toString(16);return t.length&1?"0"+t:t}function bi(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?eo:BigInt("0x"+r)}var me={_0:48,_9:57,A:65,F:70,a:97,f:102};function nl(r){if(r>=me._0&&r<=me._9)return r-me._0;if(r>=me.A&&r<=me.F)return r-(me.A-10);if(r>=me.a&&r<=me.f)return r-(me.a-10)}function tr(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);let t=r.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);let n=new Uint8Array(e);for(let o=0,s=0;o<e;o++,s+=2){let i=nl(r.charCodeAt(s)),a=nl(r.charCodeAt(s+1));if(i===void 0||a===void 0){let c=r[s]+r[s+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+s)}n[o]=i*16+a}return n}function ye(r){return bi(ge(r))}function Xt(r){return Ir(r),bi(ge(Uint8Array.from(r).reverse()))}function Me(r,t){return tr(r.toString(16).padStart(t*2,"0"))}function we(r,t){return Me(r,t).reverse()}function Qd(r){return tr(Qe(r))}function ot(r,t,e){let n;if(typeof t=="string")try{n=tr(t)}catch(s){throw new Error(r+" must be hex string or Uint8Array, cause: "+s)}else if(Oe(t))n=Uint8Array.from(t);else throw new Error(r+" must be hex string or Uint8Array");let o=n.length;if(typeof e=="number"&&o!==e)throw new Error(r+" of length "+e+" expected, got "+o);return n}function be(...r){let t=0;for(let n=0;n<r.length;n++){let o=r[n];Ir(o),t+=o.length}let e=new Uint8Array(t);for(let n=0,o=0;n<r.length;n++){let s=r[n];e.set(s,o),o+=s.length}return e}function tp(r,t){if(r.length!==t.length)return!1;let e=0;for(let n=0;n<r.length;n++)e|=r[n]^t[n];return e===0}function ep(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}var yi=r=>typeof r=="bigint"&&eo<=r;function en(r,t,e){return yi(r)&&yi(t)&&yi(e)&&t<=r&&r<e}function Et(r,t,e,n){if(!en(t,e,n))throw new Error("expected valid "+r+": "+e+" <= n < "+n+", got "+t)}function xi(r){let t;for(t=0;r>eo;r>>=ro,t+=1);return t}function rp(r,t){return r>>BigInt(t)&ro}function np(r,t,e){return r|(e?ro:eo)<<BigInt(t)}var rn=r=>(Yd<<BigInt(r-1))-ro,wi=r=>new Uint8Array(r),ol=r=>Uint8Array.from(r);function vi(r,t,e){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let n=wi(r),o=wi(r),s=0,i=()=>{n.fill(1),o.fill(0),s=0},a=(...f)=>e(o,n,...f),c=(f=wi())=>{o=a(ol([0]),f),n=a(),f.length!==0&&(o=a(ol([1]),f),n=a())},l=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let f=0,d=[];for(;f<t;){n=a();let p=n.slice();d.push(p),f+=n.length}return be(...d)};return(f,d)=>{i(),c(f);let p;for(;!(p=d(l()));)c();return i(),p}}var op={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||Oe(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,t)=>t.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function Wt(r,t,e={}){let n=(o,s,i)=>{let a=op[s];if(typeof a!="function")throw new Error("invalid validator function");let c=r[o];if(!(i&&c===void 0)&&!a(c,r))throw new Error("param "+String(o)+" is invalid. Expected "+s+", got "+c)};for(let[o,s]of Object.entries(t))n(o,s,!1);for(let[o,s]of Object.entries(e))n(o,s,!0);return r}var sp=()=>{throw new Error("not implemented")};function er(r){let t=new WeakMap;return(e,...n)=>{let o=t.get(e);if(o!==void 0)return o;let s=r(e,...n);return t.set(e,s),s}}var mt=BigInt(0),ft=BigInt(1),rr=BigInt(2),ip=BigInt(3),Ei=BigInt(4),sl=BigInt(5),il=BigInt(8),ap=BigInt(9),cp=BigInt(16);function Z(r,t){let e=r%t;return e>=mt?e:t+e}function Ai(r,t,e){if(t<mt)throw new Error("invalid exponent, negatives unsupported");if(e<=mt)throw new Error("invalid modulus");if(e===ft)return mt;let n=ft;for(;t>mt;)t&ft&&(n=n*r%e),r=r*r%e,t>>=ft;return n}function at(r,t,e){let n=r;for(;t-- >mt;)n*=n,n%=e;return n}function oo(r,t){if(r===mt)throw new Error("invert: expected non-zero number");if(t<=mt)throw new Error("invert: expected positive modulus, got "+t);let e=Z(r,t),n=t,o=mt,s=ft,i=ft,a=mt;for(;e!==mt;){let l=n/e,u=n%e,f=o-i*l,d=s-a*l;n=e,e=u,o=i,s=a,i=f,a=d}if(n!==ft)throw new Error("invert: does not exist");return Z(o,t)}function lp(r){let t=(r-ft)/rr,e,n,o;for(e=r-ft,n=0;e%rr===mt;e/=rr,n++);for(o=rr;o<r&&Ai(o,t,r)!==r-ft;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(n===1){let i=(r+ft)/Ei;return function(c,l){let u=c.pow(l,i);if(!c.eql(c.sqr(u),l))throw new Error("Cannot find square root");return u}}let s=(e+ft)/rr;return function(a,c){if(a.pow(c,t)===a.neg(a.ONE))throw new Error("Cannot find square root");let l=n,u=a.pow(a.mul(a.ONE,o),e),f=a.pow(c,s),d=a.pow(c,e);for(;!a.eql(d,a.ONE);){if(a.eql(d,a.ZERO))return a.ZERO;let p=1;for(let g=a.sqr(d);p<l&&!a.eql(g,a.ONE);p++)g=a.sqr(g);let y=a.pow(u,ft<<BigInt(l-p-1));u=a.sqr(y),f=a.mul(f,y),d=a.mul(d,u),l=p}return f}}function up(r){if(r%Ei===ip){let t=(r+ft)/Ei;return function(n,o){let s=n.pow(o,t);if(!n.eql(n.sqr(s),o))throw new Error("Cannot find square root");return s}}if(r%il===sl){let t=(r-sl)/il;return function(n,o){let s=n.mul(o,rr),i=n.pow(s,t),a=n.mul(o,i),c=n.mul(n.mul(a,rr),i),l=n.mul(a,n.sub(c,n.ONE));if(!n.eql(n.sqr(l),o))throw new Error("Cannot find square root");return l}}return r%cp,lp(r)}var al=(r,t)=>(Z(r,t)&ft)===ft,fp=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Bi(r){let t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=fp.reduce((n,o)=>(n[o]="function",n),t);return Wt(r,e)}function hp(r,t,e){if(e<mt)throw new Error("invalid exponent, negatives unsupported");if(e===mt)return r.ONE;if(e===ft)return t;let n=r.ONE,o=t;for(;e>mt;)e&ft&&(n=r.mul(n,o)),o=r.sqr(o),e>>=ft;return n}function dp(r,t){let e=new Array(t.length),n=t.reduce((s,i,a)=>r.is0(i)?s:(e[a]=s,r.mul(s,i)),r.ONE),o=r.inv(n);return t.reduceRight((s,i,a)=>r.is0(i)?s:(e[a]=r.mul(s,e[a]),r.mul(s,i)),o),e}function Si(r,t){let e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}function He(r,t,e=!1,n={}){if(r<=mt)throw new Error("invalid field: expected ORDER > 0, got "+r);let{nBitLength:o,nByteLength:s}=Si(r,t);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let i,a=Object.freeze({ORDER:r,isLE:e,BITS:o,BYTES:s,MASK:rn(o),ZERO:mt,ONE:ft,create:c=>Z(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return mt<=c&&c<r},is0:c=>c===mt,isOdd:c=>(c&ft)===ft,neg:c=>Z(-c,r),eql:(c,l)=>c===l,sqr:c=>Z(c*c,r),add:(c,l)=>Z(c+l,r),sub:(c,l)=>Z(c-l,r),mul:(c,l)=>Z(c*l,r),pow:(c,l)=>hp(a,c,l),div:(c,l)=>Z(c*oo(l,r),r),sqrN:c=>c*c,addN:(c,l)=>c+l,subN:(c,l)=>c-l,mulN:(c,l)=>c*l,inv:c=>oo(c,r),sqrt:n.sqrt||(c=>(i||(i=up(r)),i(a,c))),invertBatch:c=>dp(a,c),cmov:(c,l,u)=>u?l:c,toBytes:c=>e?we(c,s):Me(c,s),fromBytes:c=>{if(c.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+c.length);return e?Xt(c):ye(c)}});return Object.freeze(a)}function cl(r){if(typeof r!="bigint")throw new Error("field order must be bigint");let t=r.toString(2).length;return Math.ceil(t/8)}function Ii(r){let t=cl(r);return t+Math.ceil(t/2)}function ll(r,t,e=!1){let n=r.length,o=cl(t),s=Ii(t);if(n<16||n<s||n>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+n);let i=e?Xt(r):ye(r),a=Z(i,t-ft)+ft;return e?we(a,o):Me(a,o)}var ul=BigInt(0),so=BigInt(1);function Ci(r,t){let e=t.negate();return r?e:t}function fl(r,t){if(!Number.isSafeInteger(r)||r<=0||r>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+r)}function ki(r,t){fl(r,t);let e=Math.ceil(t/r)+1,n=2**(r-1);return{windows:e,windowSize:n}}function mp(r,t){if(!Array.isArray(r))throw new Error("array expected");r.forEach((e,n)=>{if(!(e instanceof t))throw new Error("invalid point at index "+n)})}function gp(r,t){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((e,n)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+n)})}var Ti=new WeakMap,hl=new WeakMap;function Ni(r){return hl.get(r)||1}function io(r,t){return{constTimeNegate:Ci,hasPrecomputes(e){return Ni(e)!==1},unsafeLadder(e,n,o=r.ZERO){let s=e;for(;n>ul;)n&so&&(o=o.add(s)),s=s.double(),n>>=so;return o},precomputeWindow(e,n){let{windows:o,windowSize:s}=ki(n,t),i=[],a=e,c=a;for(let l=0;l<o;l++){c=a,i.push(c);for(let u=1;u<s;u++)c=c.add(a),i.push(c);a=c.double()}return i},wNAF(e,n,o){let{windows:s,windowSize:i}=ki(e,t),a=r.ZERO,c=r.BASE,l=BigInt(2**e-1),u=2**e,f=BigInt(e);for(let d=0;d<s;d++){let p=d*i,y=Number(o&l);o>>=f,y>i&&(y-=u,o+=so);let g=p,h=p+Math.abs(y)-1,w=d%2!==0,x=y<0;y===0?c=c.add(Ci(w,n[g])):a=a.add(Ci(x,n[h]))}return{p:a,f:c}},wNAFUnsafe(e,n,o,s=r.ZERO){let{windows:i,windowSize:a}=ki(e,t),c=BigInt(2**e-1),l=2**e,u=BigInt(e);for(let f=0;f<i;f++){let d=f*a;if(o===ul)break;let p=Number(o&c);if(o>>=u,p>a&&(p-=l,o+=so),p===0)continue;let y=n[d+Math.abs(p)-1];p<0&&(y=y.negate()),s=s.add(y)}return s},getPrecomputes(e,n,o){let s=Ti.get(n);return s||(s=this.precomputeWindow(n,e),e!==1&&Ti.set(n,o(s))),s},wNAFCached(e,n,o){let s=Ni(e);return this.wNAF(s,this.getPrecomputes(s,e,o),n)},wNAFCachedUnsafe(e,n,o,s){let i=Ni(e);return i===1?this.unsafeLadder(e,n,s):this.wNAFUnsafe(i,this.getPrecomputes(i,e,o),n,s)},setWindowSize(e,n){fl(n,t),hl.set(e,n),Ti.delete(e)}}}function ao(r,t,e,n){if(mp(e,r),gp(n,t),e.length!==n.length)throw new Error("arrays of points and scalars must have equal length");let o=r.ZERO,s=xi(BigInt(e.length)),i=s>12?s-3:s>4?s-2:s?2:1,a=(1<<i)-1,c=new Array(a+1).fill(o),l=Math.floor((t.BITS-1)/i)*i,u=o;for(let f=l;f>=0;f-=i){c.fill(o);for(let p=0;p<n.length;p++){let y=n[p],g=Number(y>>BigInt(f)&BigInt(a));c[g]=c[g].add(e[p])}let d=o;for(let p=c.length-1,y=o;p>0;p--)y=y.add(c[p]),d=d.add(y);if(u=u.add(d),f!==0)for(let p=0;p<i;p++)u=u.double()}return u}function nn(r){return Bi(r.Fp),Wt(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Si(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}var Yt=BigInt(0),Mt=BigInt(1),co=BigInt(2),yp=BigInt(8),wp={zip215:!0};function bp(r){let t=nn(r);return Wt(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}function dl(r){let t=bp(r),{Fp:e,n,prehash:o,hash:s,randomBytes:i,nByteLength:a,h:c}=t,l=co<<BigInt(a*8)-Mt,u=e.create,f=He(t.n,t.nBitLength),d=t.uvRatio||((v,b)=>{try{return{isValid:!0,value:e.sqrt(v*e.inv(b))}}catch{return{isValid:!1,value:Yt}}}),p=t.adjustScalarBytes||(v=>v),y=t.domain||((v,b,A)=>{if(Zt("phflag",A),b.length||A)throw new Error("Contexts/pre-hash are not supported");return v});function g(v,b){Et("coordinate "+v,b,Yt,l)}function h(v){if(!(v instanceof m))throw new Error("ExtendedPoint expected")}let w=er((v,b)=>{let{ex:A,ey:E,ez:R}=v,U=v.is0();b==null&&(b=U?yp:e.inv(R));let O=u(A*b),K=u(E*b),F=u(R*b);if(U)return{x:Yt,y:Mt};if(F!==Mt)throw new Error("invZ was invalid");return{x:O,y:K}}),x=er(v=>{let{a:b,d:A}=t;if(v.is0())throw new Error("bad point: ZERO");let{ex:E,ey:R,ez:U,et:O}=v,K=u(E*E),F=u(R*R),W=u(U*U),j=u(W*W),st=u(K*b),it=u(W*u(st+F)),ut=u(j+u(A*u(K*F)));if(it!==ut)throw new Error("bad point: equation left != right (1)");let It=u(E*R),Pt=u(U*O);if(It!==Pt)throw new Error("bad point: equation left != right (2)");return!0});class m{constructor(b,A,E,R){this.ex=b,this.ey=A,this.ez=E,this.et=R,g("x",b),g("y",A),g("z",E),g("t",R),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(b){if(b instanceof m)throw new Error("extended point not allowed");let{x:A,y:E}=b||{};return g("x",A),g("y",E),new m(A,E,Mt,u(A*E))}static normalizeZ(b){let A=e.invertBatch(b.map(E=>E.ez));return b.map((E,R)=>E.toAffine(A[R])).map(m.fromAffine)}static msm(b,A){return ao(m,f,b,A)}_setWindowSize(b){N.setWindowSize(this,b)}assertValidity(){x(this)}equals(b){h(b);let{ex:A,ey:E,ez:R}=this,{ex:U,ey:O,ez:K}=b,F=u(A*K),W=u(U*R),j=u(E*K),st=u(O*R);return F===W&&j===st}is0(){return this.equals(m.ZERO)}negate(){return new m(u(-this.ex),this.ey,this.ez,u(-this.et))}double(){let{a:b}=t,{ex:A,ey:E,ez:R}=this,U=u(A*A),O=u(E*E),K=u(co*u(R*R)),F=u(b*U),W=A+E,j=u(u(W*W)-U-O),st=F+O,it=st-K,ut=F-O,It=u(j*it),Pt=u(st*ut),_t=u(j*ut),oe=u(it*st);return new m(It,Pt,oe,_t)}add(b){h(b);let{a:A,d:E}=t,{ex:R,ey:U,ez:O,et:K}=this,{ex:F,ey:W,ez:j,et:st}=b;if(A===BigInt(-1)){let Cc=u((U-R)*(W+F)),kc=u((U+R)*(W-F)),ei=u(kc-Cc);if(ei===Yt)return this.double();let Tc=u(O*co*st),Nc=u(K*co*j),Lc=Nc+Tc,_c=kc+Cc,Rc=Nc-Tc,Ih=u(Lc*ei),Ch=u(_c*Rc),kh=u(Lc*Rc),Th=u(ei*_c);return new m(Ih,Ch,Th,kh)}let it=u(R*F),ut=u(U*W),It=u(K*E*st),Pt=u(O*j),_t=u((R+U)*(F+W)-it-ut),oe=Pt-It,fe=Pt+It,Gr=u(ut-A*it),Eh=u(_t*oe),Ah=u(fe*Gr),Bh=u(_t*Gr),Sh=u(oe*fe);return new m(Eh,Ah,Sh,Bh)}subtract(b){return this.add(b.negate())}wNAF(b){return N.wNAFCached(this,b,m.normalizeZ)}multiply(b){let A=b;Et("scalar",A,Mt,n);let{p:E,f:R}=this.wNAF(A);return m.normalizeZ([E,R])[0]}multiplyUnsafe(b,A=m.ZERO){let E=b;return Et("scalar",E,Yt,n),E===Yt?L:this.is0()||E===Mt?this:N.wNAFCachedUnsafe(this,E,m.normalizeZ,A)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return N.unsafeLadder(this,n).is0()}toAffine(b){return w(this,b)}clearCofactor(){let{h:b}=t;return b===Mt?this:this.multiplyUnsafe(b)}static fromHex(b,A=!1){let{d:E,a:R}=t,U=e.BYTES;b=ot("pointHex",b,U),Zt("zip215",A);let O=b.slice(),K=b[U-1];O[U-1]=K&-129;let F=Xt(O),W=A?l:e.ORDER;Et("pointHex.y",F,Yt,W);let j=u(F*F),st=u(j-Mt),it=u(E*j-R),{isValid:ut,value:It}=d(st,it);if(!ut)throw new Error("Point.fromHex: invalid y coordinate");let Pt=(It&Mt)===Mt,_t=(K&128)!==0;if(!A&&It===Yt&&_t)throw new Error("Point.fromHex: x=0 and x_0=1");return _t!==Pt&&(It=u(-It)),m.fromAffine({x:It,y:F})}static fromPrivateKey(b){return S(b).point}toRawBytes(){let{x:b,y:A}=this.toAffine(),E=we(A,e.BYTES);return E[E.length-1]|=b&Mt?128:0,E}toHex(){return ge(this.toRawBytes())}}m.BASE=new m(t.Gx,t.Gy,Mt,u(t.Gx*t.Gy)),m.ZERO=new m(Yt,Mt,Mt,Yt);let{BASE:I,ZERO:L}=m,N=io(m,a*8);function B(v){return Z(v,n)}function k(v){return B(Xt(v))}function S(v){let b=e.BYTES;v=ot("private key",v,b);let A=ot("hashed private key",s(v),2*b),E=p(A.slice(0,b)),R=A.slice(b,2*b),U=k(E),O=I.multiply(U),K=O.toRawBytes();return{head:E,prefix:R,scalar:U,point:O,pointBytes:K}}function H(v){return S(v).pointBytes}function _(v=new Uint8Array,...b){let A=be(...b);return k(s(y(A,ot("context",v),!!o)))}function M(v,b,A={}){v=ot("message",v),o&&(v=o(v));let{prefix:E,scalar:R,pointBytes:U}=S(b),O=_(A.context,E,v),K=I.multiply(O).toRawBytes(),F=_(A.context,K,U,v),W=B(O+F*R);Et("signature.s",W,Yt,n);let j=be(K,we(W,e.BYTES));return ot("result",j,e.BYTES*2)}let V=wp;function C(v,b,A,E=V){let{context:R,zip215:U}=E,O=e.BYTES;v=ot("signature",v,2*O),b=ot("message",b),A=ot("publicKey",A,O),U!==void 0&&Zt("zip215",U),o&&(b=o(b));let K=Xt(v.slice(O,2*O)),F,W,j;try{F=m.fromHex(A,U),W=m.fromHex(v.slice(0,O),U),j=I.multiplyUnsafe(K)}catch{return!1}if(!U&&F.isSmallOrder())return!1;let st=_(R,W.toRawBytes(),F.toRawBytes(),b);return W.add(F.multiplyUnsafe(st)).subtract(j).clearCofactor().equals(m.ZERO)}return I._setWindowSize(8),{CURVE:t,getPublicKey:H,sign:M,verify:C,ExtendedPoint:m,utils:{getExtendedPublicKey:S,randomPrivateKey:()=>i(e.BYTES),precompute(v=8,b=m.BASE){return b._setWindowSize(v),b.multiply(BigInt(3)),b}}}}var Cr=BigInt(0),Li=BigInt(1);function xp(r){return Wt(r,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...r})}function pl(r){let t=xp(r),{P:e}=t,n=x=>Z(x,e),o=t.montgomeryBits,s=Math.ceil(o/8),i=t.nByteLength,a=t.adjustScalarBytes||(x=>x),c=t.powPminus2||(x=>Ai(x,e-BigInt(2),e));function l(x,m,I){let L=n(x*(m-I));return m=n(m-L),I=n(I+L),[m,I]}let u=(t.a-BigInt(2))/BigInt(4);function f(x,m){Et("u",x,Cr,e),Et("scalar",m,Cr,e);let I=m,L=x,N=Li,B=Cr,k=x,S=Li,H=Cr,_;for(let V=BigInt(o-1);V>=Cr;V--){let C=I>>V&Li;H^=C,_=l(H,N,k),N=_[0],k=_[1],_=l(H,B,S),B=_[0],S=_[1],H=C;let T=N+B,v=n(T*T),b=N-B,A=n(b*b),E=v-A,R=k+S,U=k-S,O=n(U*T),K=n(R*b),F=O+K,W=O-K;k=n(F*F),S=n(L*n(W*W)),N=n(v*A),B=n(E*(v+n(u*E)))}_=l(H,N,k),N=_[0],k=_[1],_=l(H,B,S),B=_[0],S=_[1];let M=c(B);return n(N*M)}function d(x){return we(n(x),s)}function p(x){let m=ot("u coordinate",x,s);return i===32&&(m[31]&=127),Xt(m)}function y(x){let m=ot("scalar",x),I=m.length;if(I!==s&&I!==i){let L=""+s+" or "+i;throw new Error("invalid scalar, expected "+L+" bytes, got "+I)}return Xt(a(m))}function g(x,m){let I=p(m),L=y(x),N=f(I,L);if(N===Cr)throw new Error("invalid private or public key received");return d(N)}let h=d(t.Gu);function w(x){return g(x,h)}return{scalarMult:g,scalarMultBase:w,getSharedSecret:(x,m)=>g(x,m),getPublicKey:x=>w(x),utils:{randomPrivateKey:()=>t.randomBytes(t.nByteLength)},GuBytes:h}}var on=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),ml=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),Ky=BigInt(0),vp=BigInt(1),gl=BigInt(2),Ep=BigInt(3),Ap=BigInt(5),Bp=BigInt(8);function yl(r){let t=BigInt(10),e=BigInt(20),n=BigInt(40),o=BigInt(80),s=on,a=r*r%s*r%s,c=at(a,gl,s)*a%s,l=at(c,vp,s)*r%s,u=at(l,Ap,s)*l%s,f=at(u,t,s)*u%s,d=at(f,e,s)*f%s,p=at(d,n,s)*d%s,y=at(p,o,s)*p%s,g=at(y,o,s)*p%s,h=at(g,t,s)*u%s;return{pow_p_5_8:at(h,gl,s)*r%s,b2:a}}function wl(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function Sp(r,t){let e=on,n=Z(t*t*t,e),o=Z(n*n*t,e),s=yl(r*o).pow_p_5_8,i=Z(r*n*s,e),a=Z(t*i*i,e),c=i,l=Z(i*ml,e),u=a===r,f=a===Z(-r,e),d=a===Z(-r*ml,e);return u&&(i=c),(f||d)&&(i=l),al(i,e)&&(i=Z(-i,e)),{isValid:u||f,value:i}}var Ip=He(on,void 0,!0),Cp={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:Ip,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:Bp,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:rl,randomBytes:tn,adjustScalarBytes:wl,uvRatio:Sp},bl=dl(Cp);var sn=pl({P:on,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:r=>{let t=on,{pow_p_5_8:e,b2:n}=yl(r);return Z(at(e,Ep,t)*n,t)},adjustScalarBytes:wl,randomBytes:tn});var lo=32;function xl(r,t,e){return bl.verify(t,e instanceof Uint8Array?e:e.subarray(),r)}var uo=class{type="Ed25519";raw;constructor(t){this.raw=_i(t,lo)}toMultihash(){return pe.digest(kr(this))}toCID(){return vt.createV1(114,this.toMultihash())}toString(){return nt.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:Rt(this.raw,t.raw)}verify(t,e){return xl(this.raw,e,t)}};function Ri(r){return r=_i(r,lo),new uo(r)}function _i(r,t){if(r=Uint8Array.from(r??[]),r.length!==t)throw new et(`Key must be a Uint8Array of length ${t}, got ${r.length}`);return r}function gt(r=0){return new Uint8Array(r)}function yt(r=0){return new Uint8Array(r)}var Tp=Math.pow(2,7),Np=Math.pow(2,14),Lp=Math.pow(2,21),Ui=Math.pow(2,28),Di=Math.pow(2,35),Pi=Math.pow(2,42),Oi=Math.pow(2,49),J=128,kt=127;function ct(r){if(r<Tp)return 1;if(r<Np)return 2;if(r<Lp)return 3;if(r<Ui)return 4;if(r<Di)return 5;if(r<Pi)return 6;if(r<Oi)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function Mi(r,t,e=0){switch(ct(r)){case 8:t[e++]=r&255|J,r/=128;case 7:t[e++]=r&255|J,r/=128;case 6:t[e++]=r&255|J,r/=128;case 5:t[e++]=r&255|J,r/=128;case 4:t[e++]=r&255|J,r>>>=7;case 3:t[e++]=r&255|J,r>>>=7;case 2:t[e++]=r&255|J,r>>>=7;case 1:{t[e++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return t}function _p(r,t,e=0){switch(ct(r)){case 8:t.set(e++,r&255|J),r/=128;case 7:t.set(e++,r&255|J),r/=128;case 6:t.set(e++,r&255|J),r/=128;case 5:t.set(e++,r&255|J),r/=128;case 4:t.set(e++,r&255|J),r>>>=7;case 3:t.set(e++,r&255|J),r>>>=7;case 2:t.set(e++,r&255|J),r>>>=7;case 1:{t.set(e++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return t}function Hi(r,t){let e=r[t],n=0;if(n+=e&kt,e<J||(e=r[t+1],n+=(e&kt)<<7,e<J)||(e=r[t+2],n+=(e&kt)<<14,e<J)||(e=r[t+3],n+=(e&kt)<<21,e<J)||(e=r[t+4],n+=(e&kt)*Ui,e<J)||(e=r[t+5],n+=(e&kt)*Di,e<J)||(e=r[t+6],n+=(e&kt)*Pi,e<J)||(e=r[t+7],n+=(e&kt)*Oi,e<J))return n;throw new RangeError("Could not decode varint")}function Rp(r,t){let e=r.get(t),n=0;if(n+=e&kt,e<J||(e=r.get(t+1),n+=(e&kt)<<7,e<J)||(e=r.get(t+2),n+=(e&kt)<<14,e<J)||(e=r.get(t+3),n+=(e&kt)<<21,e<J)||(e=r.get(t+4),n+=(e&kt)*Ui,e<J)||(e=r.get(t+5),n+=(e&kt)*Di,e<J)||(e=r.get(t+6),n+=(e&kt)*Pi,e<J)||(e=r.get(t+7),n+=(e&kt)*Oi,e<J))return n;throw new RangeError("Could not decode varint")}function se(r,t,e=0){return t==null&&(t=yt(ct(r))),t instanceof Uint8Array?Mi(r,t,e):_p(r,t,e)}function Jt(r,t=0){return r instanceof Uint8Array?Hi(r,t):Rp(r,t)}var Vi=new Float32Array([-0]),Ve=new Uint8Array(Vi.buffer);function El(r,t,e){Vi[0]=r,t[e]=Ve[0],t[e+1]=Ve[1],t[e+2]=Ve[2],t[e+3]=Ve[3]}function Al(r,t){return Ve[0]=r[t],Ve[1]=r[t+1],Ve[2]=r[t+2],Ve[3]=r[t+3],Vi[0]}var Fi=new Float64Array([-0]),Tt=new Uint8Array(Fi.buffer);function Bl(r,t,e){Fi[0]=r,t[e]=Tt[0],t[e+1]=Tt[1],t[e+2]=Tt[2],t[e+3]=Tt[3],t[e+4]=Tt[4],t[e+5]=Tt[5],t[e+6]=Tt[6],t[e+7]=Tt[7]}function Sl(r,t){return Tt[0]=r[t],Tt[1]=r[t+1],Tt[2]=r[t+2],Tt[3]=r[t+3],Tt[4]=r[t+4],Tt[5]=r[t+5],Tt[6]=r[t+6],Tt[7]=r[t+7],Fi[0]}var Up=BigInt(Number.MAX_SAFE_INTEGER),Dp=BigInt(Number.MIN_SAFE_INTEGER),Kt=class r{lo;hi;constructor(t,e){this.lo=t|0,this.hi=e|0}toNumber(t=!1){if(!t&&this.hi>>>31>0){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(e+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(t=!1){if(t)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(BigInt(e)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(t=!1){return this.toBigInt(t).toString()}zzEncode(){let t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this}zzDecode(){let t=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this}length(){let t=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?e===0?t<16384?t<128?1:2:t<2097152?3:4:e<16384?e<128?5:6:e<2097152?7:8:n<128?9:10}static fromBigInt(t){if(t===0n)return nr;if(t<Up&&t>Dp)return this.fromNumber(Number(t));let e=t<0n;e&&(t=-t);let n=t>>32n,o=t-(n<<32n);return e&&(n=~n|0n,o=~o|0n,++o>Il&&(o=0n,++n>Il&&(n=0n))),new r(Number(o),Number(n))}static fromNumber(t){if(t===0)return nr;let e=t<0;e&&(t=-t);let n=t>>>0,o=(t-n)/4294967296>>>0;return e&&(o=~o>>>0,n=~n>>>0,++n>4294967295&&(n=0,++o>4294967295&&(o=0))),new r(n,o)}static from(t){return typeof t=="number"?r.fromNumber(t):typeof t=="bigint"?r.fromBigInt(t):typeof t=="string"?r.fromBigInt(BigInt(t)):t.low!=null||t.high!=null?new r(t.low>>>0,t.high>>>0):nr}},nr=new Kt(0,0);nr.toBigInt=function(){return 0n};nr.zzEncode=nr.zzDecode=function(){return this};nr.length=function(){return 1};var Il=4294967296n;function Cl(r){let t=0,e=0;for(let n=0;n<r.length;++n)e=r.charCodeAt(n),e<128?t+=1:e<2048?t+=2:(e&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,t+=4):t+=3;return t}function kl(r,t,e){if(e-t<1)return"";let o,s=[],i=0,a;for(;t<e;)a=r[t++],a<128?s[i++]=a:a>191&&a<224?s[i++]=(a&31)<<6|r[t++]&63:a>239&&a<365?(a=((a&7)<<18|(r[t++]&63)<<12|(r[t++]&63)<<6|r[t++]&63)-65536,s[i++]=55296+(a>>10),s[i++]=56320+(a&1023)):s[i++]=(a&15)<<12|(r[t++]&63)<<6|r[t++]&63,i>8191&&((o??(o=[])).push(String.fromCharCode.apply(String,s)),i=0);return o!=null?(i>0&&o.push(String.fromCharCode.apply(String,s.slice(0,i))),o.join("")):String.fromCharCode.apply(String,s.slice(0,i))}function Ki(r,t,e){let n=e,o,s;for(let i=0;i<r.length;++i)o=r.charCodeAt(i),o<128?t[e++]=o:o<2048?(t[e++]=o>>6|192,t[e++]=o&63|128):(o&64512)===55296&&((s=r.charCodeAt(i+1))&64512)===56320?(o=65536+((o&1023)<<10)+(s&1023),++i,t[e++]=o>>18|240,t[e++]=o>>12&63|128,t[e++]=o>>6&63|128,t[e++]=o&63|128):(t[e++]=o>>12|224,t[e++]=o>>6&63|128,t[e++]=o&63|128);return e-n}function Qt(r,t){return RangeError(`index out of range: ${r.pos} + ${t??1} > ${r.len}`)}function fo(r,t){return(r[t-4]|r[t-3]<<8|r[t-2]<<16|r[t-1]<<24)>>>0}var $i=class{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(t){this.buf=t,this.pos=0,this.len=t.length}uint32(){let t=4294967295;if(t=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(t=(t|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return t;if((this.pos+=5)>this.len)throw this.pos=this.len,Qt(this,10);return t}int32(){return this.uint32()|0}sint32(){let t=this.uint32();return t>>>1^-(t&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw Qt(this,4);return fo(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw Qt(this,4);return fo(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw Qt(this,4);let t=Al(this.buf,this.pos);return this.pos+=4,t}double(){if(this.pos+8>this.len)throw Qt(this,4);let t=Sl(this.buf,this.pos);return this.pos+=8,t}bytes(){let t=this.uint32(),e=this.pos,n=this.pos+t;if(n>this.len)throw Qt(this,t);return this.pos+=t,e===n?new Uint8Array(0):this.buf.subarray(e,n)}string(){let t=this.bytes();return kl(t,0,t.length)}skip(t){if(typeof t=="number"){if(this.pos+t>this.len)throw Qt(this,t);this.pos+=t}else do if(this.pos>=this.len)throw Qt(this);while(this.buf[this.pos++]&128);return this}skipType(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${t} at offset ${this.pos}`)}return this}readLongVarint(){let t=new Kt(0,0),e=0;if(this.len-this.pos>4){for(;e<4;++e)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw Qt(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,t}if(this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw Qt(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw Qt(this,8);let t=fo(this.buf,this.pos+=4),e=fo(this.buf,this.pos+=4);return new Kt(t,e)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){let t=Hi(this.buf,this.pos);return this.pos+=ct(t),t}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}};function Wi(r){return new $i(r instanceof Uint8Array?r:r.subarray())}function te(r,t,e){let n=Wi(r);return t.decode(n,void 0,e)}var qi={};Ct(qi,{base10:()=>Pp});var Pp=_e({prefix:"9",name:"base10",alphabet:"0123456789"});var zi={};Ct(zi,{base16:()=>Op,base16upper:()=>Mp});var Op=dt({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Mp=dt({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var Gi={};Ct(Gi,{base2:()=>Hp});var Hp=dt({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var ji={};Ct(ji,{base256emoji:()=>Wp});var Nl=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),Vp=Nl.reduce((r,t,e)=>(r[e]=t,r),[]),Fp=Nl.reduce((r,t,e)=>{let n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);return r[n]=e,r},[]);function Kp(r){return r.reduce((t,e)=>(t+=Vp[e],t),"")}function $p(r){let t=[];for(let e of r){let n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);let o=Fp[n];if(o==null)throw new Error(`Non-base256emoji character: ${e}`);t.push(o)}return new Uint8Array(t)}var Wp=br({prefix:"\u{1F680}",name:"base256emoji",encode:Kp,decode:$p});var Xi={};Ct(Xi,{base64:()=>qp,base64pad:()=>zp,base64url:()=>Zi,base64urlpad:()=>Gp});var qp=dt({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),zp=dt({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Zi=dt({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Gp=dt({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var Yi={};Ct(Yi,{base8:()=>jp});var jp=dt({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var Ji={};Ct(Ji,{identity:()=>Zp});var Zp=br({prefix:"\0",name:"identity",encode:r=>Hc(r),decode:r=>Mc(r)});var Bw=new TextEncoder,Sw=new TextDecoder;var ea={};Ct(ea,{sha256:()=>cn,sha512:()=>Jp});function ta({name:r,code:t,encode:e}){return new Qi(r,t,e)}var Qi=class{name;code;encode;constructor(t,e,n){this.name=t,this.code=e,this.encode=n}digest(t){if(t instanceof Uint8Array){let e=this.encode(t);return e instanceof Uint8Array?Ot(this.code,e):e.then(n=>Ot(this.code,n))}else throw Error("Unknown type, must be binary type")}};function _l(r){return async t=>new Uint8Array(await crypto.subtle.digest(r,t))}var cn=ta({name:"sha2-256",code:18,encode:_l("SHA-256")}),Jp=ta({name:"sha2-512",code:19,encode:_l("SHA-512")});var or={...Ji,...Gi,...Yi,...qi,...zi,...ci,...li,...ai,...Xi,...ji},Ow={...ea,...di};function Ul(r,t,e,n){return{name:r,prefix:t,encoder:{name:r,prefix:t,encode:e},decoder:{decode:n}}}var Rl=Ul("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),ra=Ul("ascii","a",r=>{let t="a";for(let e=0;e<r.length;e++)t+=String.fromCharCode(r[e]);return t},r=>{r=r.substring(1);let t=yt(r.length);for(let e=0;e<r.length;e++)t[e]=r.charCodeAt(e);return t}),Qp={utf8:Rl,"utf-8":Rl,hex:or.base16,latin1:ra,ascii:ra,binary:ra,...or},ho=Qp;function Q(r,t="utf8"){let e=ho[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.decoder.decode(`${e.prefix}${r}`)}function na(r){let t=r??8192,e=t>>>1,n,o=t;return function(i){if(i<1||i>e)return yt(i);o+i>t&&(n=yt(t),o=0);let a=n.subarray(o,o+=i);return o&7&&(o=(o|7)+1),a}}var sr=class{fn;len;next;val;constructor(t,e,n){this.fn=t,this.len=e,this.next=void 0,this.val=n}};function oa(){}var ia=class{head;tail;len;next;constructor(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}},tm=na();function em(r){return globalThis.Buffer!=null?yt(r):tm(r)}var un=class{len;head;tail;states;constructor(){this.len=0,this.head=new sr(oa,0,0),this.tail=this.head,this.states=null}_push(t,e,n){return this.tail=this.tail.next=new sr(t,e,n),this.len+=e,this}uint32(t){return this.len+=(this.tail=this.tail.next=new aa((t=t>>>0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this}int32(t){return t<0?this._push(po,10,Kt.fromNumber(t)):this.uint32(t)}sint32(t){return this.uint32((t<<1^t>>31)>>>0)}uint64(t){let e=Kt.fromBigInt(t);return this._push(po,e.length(),e)}uint64Number(t){return this._push(Mi,ct(t),t)}uint64String(t){return this.uint64(BigInt(t))}int64(t){return this.uint64(t)}int64Number(t){return this.uint64Number(t)}int64String(t){return this.uint64String(t)}sint64(t){let e=Kt.fromBigInt(t).zzEncode();return this._push(po,e.length(),e)}sint64Number(t){let e=Kt.fromNumber(t).zzEncode();return this._push(po,e.length(),e)}sint64String(t){return this.sint64(BigInt(t))}bool(t){return this._push(sa,1,t?1:0)}fixed32(t){return this._push(ln,4,t>>>0)}sfixed32(t){return this.fixed32(t)}fixed64(t){let e=Kt.fromBigInt(t);return this._push(ln,4,e.lo)._push(ln,4,e.hi)}fixed64Number(t){let e=Kt.fromNumber(t);return this._push(ln,4,e.lo)._push(ln,4,e.hi)}fixed64String(t){return this.fixed64(BigInt(t))}sfixed64(t){return this.fixed64(t)}sfixed64Number(t){return this.fixed64Number(t)}sfixed64String(t){return this.fixed64String(t)}float(t){return this._push(El,4,t)}double(t){return this._push(Bl,8,t)}bytes(t){let e=t.length>>>0;return e===0?this._push(sa,1,0):this.uint32(e)._push(nm,e,t)}string(t){let e=Cl(t);return e!==0?this.uint32(e)._push(Ki,e,t):this._push(sa,1,0)}fork(){return this.states=new ia(this),this.head=this.tail=new sr(oa,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new sr(oa,0,0),this.len=0),this}ldelim(){let t=this.head,e=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=t.next,this.tail=e,this.len+=n),this}finish(){let t=this.head.next,e=em(this.len),n=0;for(;t!=null;)t.fn(t.val,e,n),n+=t.len,t=t.next;return e}};function sa(r,t,e){t[e]=r&255}function rm(r,t,e){for(;r>127;)t[e++]=r&127|128,r>>>=7;t[e]=r}var aa=class extends sr{next;constructor(t,e){super(rm,t,e),this.next=void 0}};function po(r,t,e){for(;r.hi!==0;)t[e++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)t[e++]=r.lo&127|128,r.lo=r.lo>>>7;t[e++]=r.lo}function ln(r,t,e){t[e]=r&255,t[e+1]=r>>>8&255,t[e+2]=r>>>16&255,t[e+3]=r>>>24}function nm(r,t,e){t.set(r,e)}globalThis.Buffer!=null&&(un.prototype.bytes=function(r){let t=r.length>>>0;return this.uint32(t),t>0&&this._push(om,t,r),this},un.prototype.string=function(r){let t=globalThis.Buffer.byteLength(r);return this.uint32(t),t>0&&this._push(sm,t,r),this});function om(r,t,e){t.set(r,e)}function sm(r,t,e){r.length<40?Ki(r,t,e):t.utf8Write!=null?t.utf8Write(r,e):t.set(Q(r),e)}function ca(){return new un}function ee(r,t){let e=ca();return t.encode(r,e,{lengthDelimited:!1}),e.finish()}var Tr;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(Tr||(Tr={}));function mo(r,t,e,n){return{name:r,type:t,encode:e,decode:n}}function ir(r){function t(o){if(r[o.toString()]==null)throw new Error("Invalid enum value");return r[o]}let e=function(s,i){let a=t(s);i.int32(a)},n=function(s){let i=s.int32();return t(i)};return mo("enum",Tr.VARINT,e,n)}function re(r,t){return mo("message",Tr.LENGTH_DELIMITED,r,t)}var wt;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1"})(wt||(wt={}));var la;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1"})(la||(la={}));(function(r){r.codec=()=>ir(la)})(wt||(wt={}));var ie;(function(r){let t;r.codec=()=>(t==null&&(t=re((e,n,o={})=>{o.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),wt.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),o.lengthDelimited!==!1&&n.ldelim()},(e,n,o={})=>{let s={},i=n==null?e.len:e.pos+n;for(;e.pos<i;){let a=e.uint32();switch(a>>>3){case 1:{s.Type=wt.codec().decode(e);break}case 2:{s.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return s})),t),r.encode=e=>ee(e,r.codec()),r.decode=(e,n)=>te(e,r.codec(),n)})(ie||(ie={}));var ua;(function(r){let t;r.codec=()=>(t==null&&(t=re((e,n,o={})=>{o.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),wt.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),o.lengthDelimited!==!1&&n.ldelim()},(e,n,o={})=>{let s={},i=n==null?e.len:e.pos+n;for(;e.pos<i;){let a=e.uint32();switch(a>>>3){case 1:{s.Type=wt.codec().decode(e);break}case 2:{s.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return s})),t),r.encode=e=>ee(e,r.codec()),r.decode=(e,n)=>te(e,r.codec(),n)})(ua||(ua={}));var xn={};Ct(xn,{MAX_RSA_KEY_SIZE:()=>is,generateRSAKeyPair:()=>Lu,jwkToJWKKeyPair:()=>_u,jwkToPkcs1:()=>vm,jwkToPkix:()=>ba,jwkToRSAPrivateKey:()=>Nu,pkcs1ToJwk:()=>Cu,pkcs1ToRSAPrivateKey:()=>Tu,pkixToJwk:()=>ku,pkixToRSAPublicKey:()=>xa});var im=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Fe=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Ke=new Uint32Array(64),fa=class extends Sr{constructor(){super(64,32,8,!1),this.A=Fe[0]|0,this.B=Fe[1]|0,this.C=Fe[2]|0,this.D=Fe[3]|0,this.E=Fe[4]|0,this.F=Fe[5]|0,this.G=Fe[6]|0,this.H=Fe[7]|0}get(){let{A:t,B:e,C:n,D:o,E:s,F:i,G:a,H:c}=this;return[t,e,n,o,s,i,a,c]}set(t,e,n,o,s,i,a,c){this.A=t|0,this.B=e|0,this.C=n|0,this.D=o|0,this.E=s|0,this.F=i|0,this.G=a|0,this.H=c|0}process(t,e){for(let f=0;f<16;f++,e+=4)Ke[f]=t.getUint32(e,!1);for(let f=16;f<64;f++){let d=Ke[f-15],p=Ke[f-2],y=jt(d,7)^jt(d,18)^d>>>3,g=jt(p,17)^jt(p,19)^p>>>10;Ke[f]=g+Ke[f-7]+y+Ke[f-16]|0}let{A:n,B:o,C:s,D:i,E:a,F:c,G:l,H:u}=this;for(let f=0;f<64;f++){let d=jt(a,6)^jt(a,11)^jt(a,25),p=u+d+Qc(a,c,l)+im[f]+Ke[f]|0,g=(jt(n,2)^jt(n,13)^jt(n,22))+tl(n,o,s)|0;u=l,l=c,c=a,a=i+p|0,i=s,s=o,o=n,n=p+g|0}n=n+this.A|0,o=o+this.B|0,s=s+this.C|0,i=i+this.D|0,a=a+this.E|0,c=c+this.F|0,l=l+this.G|0,u=u+this.H|0,this.set(n,o,s,i,a,c,l,u)}roundClean(){Ke.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var ae=Qn(()=>new fa);var z=Ph(Pl());function ar(r,t){let e=0;if(r.length===1)return r[0];for(let n=r.length-1;n>=0;n--)e+=r[r.length-1-n]*Math.pow(2,t*n);return e}function $e(r,t,e=-1){let n=e,o=r,s=0,i=Math.pow(2,t);for(let a=1;a<8;a++){if(r<i){let c;if(n<0)c=new ArrayBuffer(a),s=a;else{if(n<a)return new ArrayBuffer(0);c=new ArrayBuffer(n),s=n}let l=new Uint8Array(c);for(let u=a-1;u>=0;u--){let f=Math.pow(2,u*t);l[s-u-1]=Math.floor(o/f),o-=l[s-u-1]*f}return c}i*=Math.pow(2,t)}return new ArrayBuffer(0)}function wo(...r){let t=0,e=0;for(let s of r)t+=s.length;let n=new ArrayBuffer(t),o=new Uint8Array(n);for(let s of r)o.set(s,e),e+=s.length;return o}function da(){let r=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){let a=r[0]===255&&r[1]&128,c=r[0]===0&&(r[1]&128)===0;(a||c)&&this.warnings.push("Needlessly long format")}let t=new ArrayBuffer(this.valueHex.byteLength),e=new Uint8Array(t);for(let a=0;a<this.valueHex.byteLength;a++)e[a]=0;e[0]=r[0]&128;let n=ar(e,8),o=new ArrayBuffer(this.valueHex.byteLength),s=new Uint8Array(o);for(let a=0;a<this.valueHex.byteLength;a++)s[a]=r[a];return s[0]&=127,ar(s,8)-n}function Ol(r){let t=r<0?r*-1:r,e=128;for(let n=1;n<8;n++){if(t<=e){if(r<0){let i=e-t,a=$e(i,8,n),c=new Uint8Array(a);return c[0]|=128,a}let o=$e(t,8,n),s=new Uint8Array(o);if(s[0]&128){let i=o.slice(0),a=new Uint8Array(i);o=new ArrayBuffer(o.byteLength+1),s=new Uint8Array(o);for(let c=0;c<i.byteLength;c++)s[c+1]=a[c];s[0]=0}return o}e*=Math.pow(2,8)}return new ArrayBuffer(0)}function Ml(r,t){if(r.byteLength!==t.byteLength)return!1;let e=new Uint8Array(r),n=new Uint8Array(t);for(let o=0;o<e.length;o++)if(e[o]!==n[o])return!1;return!0}function Ht(r,t){let e=r.toString(10);if(t<e.length)return"";let n=t-e.length,o=new Array(n);for(let i=0;i<n;i++)o[i]="0";return o.join("").concat(e)}var wb=Math.log(2);function bo(){if(typeof BigInt>"u")throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function pa(r){let t=0,e=0;for(let o=0;o<r.length;o++){let s=r[o];t+=s.byteLength}let n=new Uint8Array(t);for(let o=0;o<r.length;o++){let s=r[o];n.set(new Uint8Array(s),e),e+=s.byteLength}return n.buffer}function Be(r,t,e,n){return t instanceof Uint8Array?t.byteLength?e<0?(r.error="Wrong parameter: inputOffset less than zero",!1):n<0?(r.error="Wrong parameter: inputLength less than zero",!1):t.byteLength-e-n<0?(r.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):!0:(r.error="Wrong parameter: inputBuffer has zero length",!1):(r.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}var hn=class{constructor(){this.items=[]}write(t){this.items.push(t)}final(){return pa(this.items)}},fn=[new Uint8Array([1])],Hl="0123456789";var Ur="",ne=new ArrayBuffer(0),ma=new Uint8Array(0),dn="EndOfContent",Fl="OCTET STRING",Kl="BIT STRING";function Se(r){var t;return t=class extends r{constructor(...n){var o;super(...n);let s=n[0]||{};this.isHexOnly=(o=s.isHexOnly)!==null&&o!==void 0?o:!1,this.valueHexView=s.valueHex?z.BufferSourceConverter.toUint8Array(s.valueHex):ma}get valueHex(){return this.valueHexView.slice().buffer}set valueHex(n){this.valueHexView=new Uint8Array(n)}fromBER(n,o,s){let i=n instanceof ArrayBuffer?new Uint8Array(n):n;if(!Be(this,i,o,s))return-1;let a=o+s;return this.valueHexView=i.subarray(o,a),this.valueHexView.length?(this.blockLength=s,a):(this.warnings.push("Zero buffer length"),o)}toBER(n=!1){return this.isHexOnly?n?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",ne)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:z.Convert.ToHex(this.valueHexView)}}},t.NAME="hexBlock",t}var ve=class{constructor({blockLength:t=0,error:e=Ur,warnings:n=[],valueBeforeDecode:o=ma}={}){this.blockLength=t,this.error=e,this.warnings=n,this.valueBeforeDecodeView=z.BufferSourceConverter.toUint8Array(o)}static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(t){this.valueBeforeDecodeView=new Uint8Array(t)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:z.Convert.ToHex(this.valueBeforeDecodeView)}}};ve.NAME="baseBlock";var Nt=class extends ve{fromBER(t,e,n){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(t,e){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}};Nt.NAME="valueBlock";var xo=class extends Se(ve){constructor({idBlock:t={}}={}){var e,n,o,s;super(),t?(this.isHexOnly=(e=t.isHexOnly)!==null&&e!==void 0?e:!1,this.valueHexView=t.valueHex?z.BufferSourceConverter.toUint8Array(t.valueHex):ma,this.tagClass=(n=t.tagClass)!==null&&n!==void 0?n:-1,this.tagNumber=(o=t.tagNumber)!==null&&o!==void 0?o:-1,this.isConstructed=(s=t.isConstructed)!==null&&s!==void 0?s:!1):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(t=!1){let e=0;switch(this.tagClass){case 1:e|=0;break;case 2:e|=64;break;case 3:e|=128;break;case 4:e|=192;break;default:return this.error="Unknown tag class",ne}if(this.isConstructed&&(e|=32),this.tagNumber<31&&!this.isHexOnly){let o=new Uint8Array(1);if(!t){let s=this.tagNumber;s&=31,e|=s,o[0]=e}return o.buffer}if(!this.isHexOnly){let o=$e(this.tagNumber,7),s=new Uint8Array(o),i=o.byteLength,a=new Uint8Array(i+1);if(a[0]=e|31,!t){for(let c=0;c<i-1;c++)a[c+1]=s[c]|128;a[i]=s[i-1]}return a.buffer}let n=new Uint8Array(this.valueHexView.byteLength+1);if(n[0]=e|31,!t){let o=this.valueHexView;for(let s=0;s<o.length-1;s++)n[s+1]=o[s]|128;n[this.valueHexView.byteLength]=o[o.length-1]}return n.buffer}fromBER(t,e,n){let o=z.BufferSourceConverter.toUint8Array(t);if(!Be(this,o,e,n))return-1;let s=o.subarray(e,e+n);if(s.length===0)return this.error="Zero buffer length",-1;switch(s[0]&192){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=(s[0]&32)===32,this.isHexOnly=!1;let a=s[0]&31;if(a!==31)this.tagNumber=a,this.blockLength=1;else{let c=1,l=this.valueHexView=new Uint8Array(255),u=255;for(;s[c]&128;){if(l[c-1]=s[c]&127,c++,c>=s.length)return this.error="End of input reached before message was fully decoded",-1;if(c===u){u+=255;let d=new Uint8Array(u);for(let p=0;p<l.length;p++)d[p]=l[p];l=this.valueHexView=new Uint8Array(u)}}this.blockLength=c+1,l[c-1]=s[c]&127;let f=new Uint8Array(c);for(let d=0;d<c;d++)f[d]=l[d];l=this.valueHexView=new Uint8Array(c),l.set(f),this.blockLength<=9?this.tagNumber=ar(l,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(this.tagClass===1&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return e+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}};xo.NAME="identificationBlock";var vo=class extends ve{constructor({lenBlock:t={}}={}){var e,n,o;super(),this.isIndefiniteForm=(e=t.isIndefiniteForm)!==null&&e!==void 0?e:!1,this.longFormUsed=(n=t.longFormUsed)!==null&&n!==void 0?n:!1,this.length=(o=t.length)!==null&&o!==void 0?o:0}fromBER(t,e,n){let o=z.BufferSourceConverter.toUint8Array(t);if(!Be(this,o,e,n))return-1;let s=o.subarray(e,e+n);if(s.length===0)return this.error="Zero buffer length",-1;if(s[0]===255)return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=s[0]===128,this.isIndefiniteForm)return this.blockLength=1,e+this.blockLength;if(this.longFormUsed=!!(s[0]&128),this.longFormUsed===!1)return this.length=s[0],this.blockLength=1,e+this.blockLength;let i=s[0]&127;if(i>8)return this.error="Too big integer",-1;if(i+1>s.length)return this.error="End of input reached before message was fully decoded",-1;let a=e+1,c=o.subarray(a,a+i);return c[i-1]===0&&this.warnings.push("Needlessly long encoded length"),this.length=ar(c,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=i+1,e+this.blockLength}toBER(t=!1){let e,n;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return e=new ArrayBuffer(1),t===!1&&(n=new Uint8Array(e),n[0]=128),e;if(this.longFormUsed){let o=$e(this.length,8);if(o.byteLength>127)return this.error="Too big length",ne;if(e=new ArrayBuffer(o.byteLength+1),t)return e;let s=new Uint8Array(o);n=new Uint8Array(e),n[0]=o.byteLength|128;for(let i=0;i<o.byteLength;i++)n[i+1]=s[i];return e}return e=new ArrayBuffer(1),t===!1&&(n=new Uint8Array(e),n[0]=this.length),e}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}};vo.NAME="lengthBlock";var D={},At=class extends ve{constructor({name:t=Ur,optional:e=!1,primitiveSchema:n,...o}={},s){super(o),this.name=t,this.optional=e,n&&(this.primitiveSchema=n),this.idBlock=new xo(o),this.lenBlock=new vo(o),this.valueBlock=s?new s(o):new Nt(o)}fromBER(t,e,n){let o=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return o===-1?(this.error=this.valueBlock.error,o):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),o)}toBER(t,e){let n=e||new hn;e||$l(this);let o=this.idBlock.toBER(t);if(n.write(o),this.lenBlock.isIndefiniteForm)n.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(t,n),n.write(new ArrayBuffer(2));else{let s=this.valueBlock.toBER(t);this.lenBlock.length=s.byteLength;let i=this.lenBlock.toBER(t);n.write(i),n.write(s)}return e?ne:n.final()}toJSON(){let t={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(t.primitiveSchema=this.primitiveSchema.toJSON()),t}toString(t="ascii"){return t==="ascii"?this.onAsciiEncoding():z.Convert.ToHex(this.toBER())}onAsciiEncoding(){return`${this.constructor.NAME} : ${z.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`}isEqual(t){if(this===t)return!0;if(!(t instanceof this.constructor))return!1;let e=this.toBER(),n=t.toBER();return Ml(e,n)}};At.NAME="BaseBlock";function $l(r){if(r instanceof D.Constructed)for(let t of r.valueBlock.value)$l(t)&&(r.lenBlock.isIndefiniteForm=!0);return!!r.lenBlock.isIndefiniteForm}var Eo=class extends At{constructor({value:t=Ur,...e}={},n){super(e,n),t&&this.fromString(t)}getValue(){return this.valueBlock.value}setValue(t){this.valueBlock.value=t}fromBER(t,e,n){let o=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return o===-1?(this.error=this.valueBlock.error,o):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),o)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}};Eo.NAME="BaseStringBlock";var Ao=class extends Se(Nt){constructor({isHexOnly:t=!0,...e}={}){super(e),this.isHexOnly=t}};Ao.NAME="PrimitiveValueBlock";var Wl,Bo=class extends At{constructor(t={}){super(t,Ao),this.idBlock.isConstructed=!1}};Wl=Bo;D.Primitive=Wl;Bo.NAME="PRIMITIVE";function mm(r,t){if(r instanceof t)return r;let e=new t;return e.idBlock=r.idBlock,e.lenBlock=r.lenBlock,e.warnings=r.warnings,e.valueBeforeDecodeView=r.valueBeforeDecodeView,e}function os(r,t=0,e=r.length){let n=t,o=new At({},Nt),s=new ve;if(!Be(s,r,t,e))return o.error=s.error,{offset:-1,result:o};if(!r.subarray(t,t+e).length)return o.error="Zero buffer length",{offset:-1,result:o};let a=o.idBlock.fromBER(r,t,e);if(o.idBlock.warnings.length&&o.warnings.concat(o.idBlock.warnings),a===-1)return o.error=o.idBlock.error,{offset:-1,result:o};if(t=a,e-=o.idBlock.blockLength,a=o.lenBlock.fromBER(r,t,e),o.lenBlock.warnings.length&&o.warnings.concat(o.lenBlock.warnings),a===-1)return o.error=o.lenBlock.error,{offset:-1,result:o};if(t=a,e-=o.lenBlock.blockLength,!o.idBlock.isConstructed&&o.lenBlock.isIndefiniteForm)return o.error="Indefinite length form used for primitive encoding form",{offset:-1,result:o};let c=At;switch(o.idBlock.tagClass){case 1:if(o.idBlock.tagNumber>=37&&o.idBlock.isHexOnly===!1)return o.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:o};switch(o.idBlock.tagNumber){case 0:if(o.idBlock.isConstructed&&o.lenBlock.length>0)return o.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:o};c=D.EndOfContent;break;case 1:c=D.Boolean;break;case 2:c=D.Integer;break;case 3:c=D.BitString;break;case 4:c=D.OctetString;break;case 5:c=D.Null;break;case 6:c=D.ObjectIdentifier;break;case 10:c=D.Enumerated;break;case 12:c=D.Utf8String;break;case 13:c=D.RelativeObjectIdentifier;break;case 14:c=D.TIME;break;case 15:return o.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:o};case 16:c=D.Sequence;break;case 17:c=D.Set;break;case 18:c=D.NumericString;break;case 19:c=D.PrintableString;break;case 20:c=D.TeletexString;break;case 21:c=D.VideotexString;break;case 22:c=D.IA5String;break;case 23:c=D.UTCTime;break;case 24:c=D.GeneralizedTime;break;case 25:c=D.GraphicString;break;case 26:c=D.VisibleString;break;case 27:c=D.GeneralString;break;case 28:c=D.UniversalString;break;case 29:c=D.CharacterString;break;case 30:c=D.BmpString;break;case 31:c=D.DATE;break;case 32:c=D.TimeOfDay;break;case 33:c=D.DateTime;break;case 34:c=D.Duration;break;default:{let l=o.idBlock.isConstructed?new D.Constructed:new D.Primitive;l.idBlock=o.idBlock,l.lenBlock=o.lenBlock,l.warnings=o.warnings,o=l}}break;case 2:case 3:case 4:default:c=o.idBlock.isConstructed?D.Constructed:D.Primitive}return o=mm(o,c),a=o.fromBER(r,t,o.lenBlock.isIndefiniteForm?e:o.lenBlock.length),o.valueBeforeDecodeView=r.subarray(n,n+o.blockLength),{offset:a,result:o}}function ga(r){if(!r.byteLength){let t=new At({},Nt);return t.error="Input buffer has zero length",{offset:-1,result:t}}return os(z.BufferSourceConverter.toUint8Array(r).slice(),0,r.byteLength)}function gm(r,t){return r?1:t}var ce=class extends Nt{constructor({value:t=[],isIndefiniteForm:e=!1,...n}={}){super(n),this.value=t,this.isIndefiniteForm=e}fromBER(t,e,n){let o=z.BufferSourceConverter.toUint8Array(t);if(!Be(this,o,e,n))return-1;if(this.valueBeforeDecodeView=o.subarray(e,e+n),this.valueBeforeDecodeView.length===0)return this.warnings.push("Zero buffer length"),e;let s=e;for(;gm(this.isIndefiniteForm,n)>0;){let i=os(o,s,n);if(i.offset===-1)return this.error=i.result.error,this.warnings.concat(i.result.warnings),-1;if(s=i.offset,this.blockLength+=i.result.blockLength,n-=i.result.blockLength,this.value.push(i.result),this.isIndefiniteForm&&i.result.constructor.NAME===dn)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===dn?this.value.pop():this.warnings.push("No EndOfContent block encoded")),s}toBER(t,e){let n=e||new hn;for(let o=0;o<this.value.length;o++)this.value[o].toBER(t,n);return e?ne:n.final()}toJSON(){let t={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(let e of this.value)t.value.push(e.toJSON());return t}};ce.NAME="ConstructedValueBlock";var ql,We=class extends At{constructor(t={}){super(t,ce),this.idBlock.isConstructed=!0}fromBER(t,e,n){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;let o=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return o===-1?(this.error=this.valueBlock.error,o):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),o)}onAsciiEncoding(){let t=[];for(let n of this.valueBlock.value)t.push(n.toString("ascii").split(`
./node_modules/@libp2p/pubsub-peer-discovery/dist/index.min.js:2:"use strict";var Libp2PPubsubPeerDiscovery=(()=>{var za=Object.create;var Cr=Object.defineProperty;var $a=Object.getOwnPropertyDescriptor;var ja=Object.getOwnPropertyNames;var Ga=Object.getPrototypeOf,Za=Object.prototype.hasOwnProperty;var Wa=(r,t)=>()=>(t||r((t={exports:{}}).exports,t),t.exports),mt=(r,t)=>{for(var e in t)Cr(r,e,{get:t[e],enumerable:!0})},Xo=(r,t,e,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of ja(t))!Za.call(r,s)&&s!==e&&Cr(r,s,{get:()=>t[s],enumerable:!(n=$a(t,s))||n.enumerable});return r};var Ja=(r,t,e)=>(e=r!=null?za(Ga(r)):{},Xo(t||!r||!r.__esModule?Cr(e,"default",{value:r,enumerable:!0}):e,r)),Ya=r=>Xo(Cr({},"__esModule",{value:!0}),r);var cc=Wa(Ze=>{"use strict";var kf="[object ArrayBuffer]",Wt=class r{static isArrayBuffer(t){return Object.prototype.toString.call(t)===kf}static toArrayBuffer(t){return this.isArrayBuffer(t)?t:t.byteLength===t.buffer.byteLength||t.byteOffset===0&&t.byteLength===t.buffer.byteLength?t.buffer:this.toUint8Array(t.buffer).slice(t.byteOffset,t.byteOffset+t.byteLength).buffer}static toUint8Array(t){return this.toView(t,Uint8Array)}static toView(t,e){if(t.constructor===e)return t;if(this.isArrayBuffer(t))return new e(t);if(this.isArrayBufferView(t))return new e(t.buffer,t.byteOffset,t.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(t){return this.isArrayBufferView(t)||this.isArrayBuffer(t)}static isArrayBufferView(t){return ArrayBuffer.isView(t)||t&&this.isArrayBuffer(t.buffer)}static isEqual(t,e){let n=r.toUint8Array(t),s=r.toUint8Array(e);if(n.length!==s.byteLength)return!1;for(let o=0;o<n.length;o++)if(n[o]!==s[o])return!1;return!0}static concat(...t){let e;Array.isArray(t[0])&&!(t[1]instanceof Function)||Array.isArray(t[0])&&t[1]instanceof Function?e=t[0]:t[t.length-1]instanceof Function?e=t.slice(0,t.length-1):e=t;let n=0;for(let i of e)n+=i.byteLength;let s=new Uint8Array(n),o=0;for(let i of e){let c=this.toUint8Array(i);s.set(c,o),o+=c.length}return t[t.length-1]instanceof Function?this.toView(s,t[t.length-1]):s.buffer}},mo="string",If=/^[0-9a-f\s]+$/i,Nf=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,Cf=/^[a-zA-Z0-9-_]+$/,rn=class{static fromString(t){let e=unescape(encodeURIComponent(t)),n=new Uint8Array(e.length);for(let s=0;s<e.length;s++)n[s]=e.charCodeAt(s);return n.buffer}static toString(t){let e=Wt.toUint8Array(t),n="";for(let o=0;o<e.length;o++)n+=String.fromCharCode(e[o]);return decodeURIComponent(escape(n))}},kt=class{static toString(t,e=!1){let n=Wt.toArrayBuffer(t),s=new DataView(n),o="";for(let i=0;i<n.byteLength;i+=2){let c=s.getUint16(i,e);o+=String.fromCharCode(c)}return o}static fromString(t,e=!1){let n=new ArrayBuffer(t.length*2),s=new DataView(n);for(let o=0;o<t.length;o++)s.setUint16(o*2,t.charCodeAt(o),e);return n}},nn=class r{static isHex(t){return typeof t===mo&&If.test(t)}static isBase64(t){return typeof t===mo&&Nf.test(t)}static isBase64Url(t){return typeof t===mo&&Cf.test(t)}static ToString(t,e="utf8"){let n=Wt.toUint8Array(t);switch(e.toLowerCase()){case"utf8":return this.ToUtf8String(n);case"binary":return this.ToBinary(n);case"hex":return this.ToHex(n);case"base64":return this.ToBase64(n);case"base64url":return this.ToBase64Url(n);case"utf16le":return kt.toString(n,!0);case"utf16":case"utf16be":return kt.toString(n);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromString(t,e="utf8"){if(!t)return new ArrayBuffer(0);switch(e.toLowerCase()){case"utf8":return this.FromUtf8String(t);case"binary":return this.FromBinary(t);case"hex":return this.FromHex(t);case"base64":return this.FromBase64(t);case"base64url":return this.FromBase64Url(t);case"utf16le":return kt.fromString(t,!0);case"utf16":case"utf16be":return kt.fromString(t);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToBase64(t){let e=Wt.toUint8Array(t);if(typeof btoa<"u"){let n=this.ToString(e,"binary");return btoa(n)}else return Buffer.from(e).toString("base64")}static FromBase64(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isBase64(e))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return typeof atob<"u"?this.FromBinary(atob(e)):new Uint8Array(Buffer.from(e,"base64")).buffer}static FromBase64Url(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isBase64Url(e))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(e.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(t){return this.ToBase64(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(t,e=r.DEFAULT_UTF8_ENCODING){switch(e){case"ascii":return this.FromBinary(t);case"utf8":return rn.fromString(t);case"utf16":case"utf16be":return kt.fromString(t);case"utf16le":case"usc2":return kt.fromString(t,!0);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToUtf8String(t,e=r.DEFAULT_UTF8_ENCODING){switch(e){case"ascii":return this.ToBinary(t);case"utf8":return rn.toString(t);case"utf16":case"utf16be":return kt.toString(t);case"utf16le":case"usc2":return kt.toString(t,!0);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromBinary(t){let e=t.length,n=new Uint8Array(e);for(let s=0;s<e;s++)n[s]=t.charCodeAt(s);return n.buffer}static ToBinary(t){let e=Wt.toUint8Array(t),n="";for(let s=0;s<e.length;s++)n+=String.fromCharCode(e[s]);return n}static ToHex(t){let e=Wt.toUint8Array(t),n="",s=e.length;for(let o=0;o<s;o++){let i=e[o];i<16&&(n+="0"),n+=i.toString(16)}return n}static FromHex(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!r.isHex(e))throw new TypeError("Argument 'hexString' is not HEX encoded");e.length%2&&(e=`0${e}`);let n=new Uint8Array(e.length/2);for(let s=0;s<e.length;s=s+2){let o=e.slice(s,s+2);n[s/2]=parseInt(o,16)}return n.buffer}static ToUtf16String(t,e=!1){return kt.toString(t,e)}static FromUtf16String(t,e=!1){return kt.fromString(t,e)}static Base64Padding(t){let e=4-t.length%4;if(e<4)for(let n=0;n<e;n++)t+="=";return t}static formatString(t){return t?.replace(/[\n\r\t ]/g,"")||""}};nn.DEFAULT_UTF8_ENCODING="utf8";function Tf(r,...t){let e=arguments[0];for(let n=1;n<arguments.length;n++){let s=arguments[n];for(let o in s)e[o]=s[o]}return e}function Uf(...r){let t=r.map(s=>s.byteLength).reduce((s,o)=>s+o),e=new Uint8Array(t),n=0;return r.map(s=>new Uint8Array(s)).forEach(s=>{for(let o of s)e[n++]=o}),e.buffer}function Lf(r,t){if(!(r&&t)||r.byteLength!==t.byteLength)return!1;let e=new Uint8Array(r),n=new Uint8Array(t);for(let s=0;s<r.byteLength;s++)if(e[s]!==n[s])return!1;return!0}Ze.BufferSourceConverter=Wt;Ze.Convert=nn;Ze.assign=Tf;Ze.combine=Uf;Ze.isEqual=Lf});var yh={};mt(yh,{PubSubPeerDiscovery:()=>ns,TOPIC:()=>Ha,pubsubPeerDiscovery:()=>bh});var Qo=Symbol.for("@libp2p/peer-discovery");var os=Symbol.for("@libp2p/peer-id");var xt=class extends Error{static name="InvalidParametersError";constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}},Ue=class extends Error{static name="InvalidPublicKeyError";constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}};var Le=class extends Error{static name="UnsupportedKeyTypeError";constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}};var ti=(r,...t)=>{try{[...t]}catch{}};var Tr=class extends EventTarget{#t=new Map;constructor(){super(),ti(1/0,this)}listenerCount(t){let e=this.#t.get(t);return e==null?0:e.length}addEventListener(t,e,n){super.addEventListener(t,e,n);let s=this.#t.get(t);s==null&&(s=[],this.#t.set(t,s)),s.push({callback:e,once:(n!==!0&&n!==!1&&n?.once)??!1})}removeEventListener(t,e,n){super.removeEventListener(t.toString(),e??null,n);let s=this.#t.get(t);s!=null&&(s=s.filter(({callback:o})=>o!==e),this.#t.set(t,s))}dispatchEvent(t){let e=super.dispatchEvent(t),n=this.#t.get(t.type);return n==null||(n=n.filter(({once:s})=>!s),this.#t.set(t.type,n)),e}safeDispatchEvent(t,e={}){return this.dispatchEvent(new CustomEvent(t,e))}};var us={};mt(us,{base58btc:()=>J,base58flickr:()=>nl});var Ih=new Uint8Array(0);function ei(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function Kt(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function ri(r){return new TextEncoder().encode(r)}function ni(r){return new TextDecoder().decode(r)}function Xa(r,t){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),n=0;n<e.length;n++)e[n]=255;for(var s=0;s<r.length;s++){var o=r.charAt(s),i=o.charCodeAt(0);if(e[i]!==255)throw new TypeError(o+" is ambiguous");e[i]=s}var c=r.length,a=r.charAt(0),f=Math.log(c)/Math.log(256),l=Math.log(256)/Math.log(c);function u(y){if(y instanceof Uint8Array||(ArrayBuffer.isView(y)?y=new Uint8Array(y.buffer,y.byteOffset,y.byteLength):Array.isArray(y)&&(y=Uint8Array.from(y))),!(y instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(y.length===0)return"";for(var b=0,d=0,v=0,A=y.length;v!==A&&y[v]===0;)v++,b++;for(var g=(A-v)*l+1>>>0,k=new Uint8Array(g);v!==A;){for(var L=y[v],U=0,I=g-1;(L!==0||U<d)&&I!==-1;I--,U++)L+=256*k[I]>>>0,k[I]=L%c>>>0,L=L/c>>>0;if(L!==0)throw new Error("Non-zero carry");d=U,v++}for(var T=g-d;T!==g&&k[T]===0;)T++;for(var N=a.repeat(b);T<g;++T)N+=r.charAt(k[T]);return N}function h(y){if(typeof y!="string")throw new TypeError("Expected String");if(y.length===0)return new Uint8Array;var b=0;if(y[b]!==" "){for(var d=0,v=0;y[b]===a;)d++,b++;for(var A=(y.length-b)*f+1>>>0,g=new Uint8Array(A);y[b];){var k=e[y.charCodeAt(b)];if(k===255)return;for(var L=0,U=A-1;(k!==0||L<v)&&U!==-1;U--,L++)k+=c*g[U]>>>0,g[U]=k%256>>>0,k=k/256>>>0;if(k!==0)throw new Error("Non-zero carry");v=L,b++}if(y[b]!==" "){for(var I=A-v;I!==A&&g[I]===0;)I++;for(var T=new Uint8Array(d+(A-I)),N=d;I!==A;)T[N++]=g[I++];return T}}}function x(y){var b=h(y);if(b)return b;throw new Error(`Non-${t} character`)}return{encode:u,decodeUnsafe:h,decode:x}}var Qa=Xa,tl=Qa,oi=tl;var is=class{name;prefix;baseEncode;constructor(t,e,n){this.name=t,this.prefix=e,this.baseEncode=n}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}},cs=class{name;prefix;baseDecode;prefixCodePoint;constructor(t,e,n){this.name=t,this.prefix=e;let s=e.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=n}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return ii(this,t)}},as=class{decoders;constructor(t){this.decoders=t}or(t){return ii(this,t)}decode(t){let e=t[0],n=this.decoders[e];if(n!=null)return n.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};function ii(r,t){return new as({...r.decoders??{[r.prefix]:r},...t.decoders??{[t.prefix]:t}})}var ls=class{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(t,e,n,s){this.name=t,this.prefix=e,this.baseEncode=n,this.baseDecode=s,this.encoder=new is(t,e,n),this.decoder=new cs(t,e,s)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}};function Re({name:r,prefix:t,encode:e,decode:n}){return new ls(r,t,e,n)}function ne({name:r,prefix:t,alphabet:e}){let{encode:n,decode:s}=oi(e,r);return Re({prefix:t,name:r,encode:n,decode:o=>Kt(s(o))})}function el(r,t,e,n){let s={};for(let l=0;l<t.length;++l)s[t[l]]=l;let o=r.length;for(;r[o-1]==="=";)--o;let i=new Uint8Array(o*e/8|0),c=0,a=0,f=0;for(let l=0;l<o;++l){let u=s[r[l]];if(u===void 0)throw new SyntaxError(`Non-${n} character`);a=a<<e|u,c+=e,c>=8&&(c-=8,i[f++]=255&a>>c)}if(c>=e||255&a<<8-c)throw new SyntaxError("Unexpected end of data");return i}function rl(r,t,e){let n=t[t.length-1]==="=",s=(1<<e)-1,o="",i=0,c=0;for(let a=0;a<r.length;++a)for(c=c<<8|r[a],i+=8;i>e;)i-=e,o+=t[s&c>>i];if(i!==0&&(o+=t[s&c<<e-i]),n)for(;o.length*e&7;)o+="=";return o}function X({name:r,prefix:t,bitsPerChar:e,alphabet:n}){return Re({prefix:t,name:r,encode(s){return rl(s,n,e)},decode(s){return el(s,n,e,r)}})}var J=ne({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),nl=ne({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var fs={};mt(fs,{base32:()=>qt,base32hex:()=>cl,base32hexpad:()=>ll,base32hexpadupper:()=>ul,base32hexupper:()=>al,base32pad:()=>ol,base32padupper:()=>il,base32upper:()=>sl,base32z:()=>fl});var qt=X({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),sl=X({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),ol=X({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),il=X({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),cl=X({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),al=X({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),ll=X({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),ul=X({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),fl=X({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var hs={};mt(hs,{base36:()=>nr,base36upper:()=>hl});var nr=ne({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),hl=ne({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var dl=li,ci=128,pl=127,gl=~pl,ml=Math.pow(2,31);function li(r,t,e){t=t||[],e=e||0;for(var n=e;r>=ml;)t[e++]=r&255|ci,r/=128;for(;r&gl;)t[e++]=r&255|ci,r>>>=7;return t[e]=r|0,li.bytes=e-n+1,t}var xl=ds,bl=128,ai=127;function ds(r,n){var e=0,n=n||0,s=0,o=n,i,c=r.length;do{if(o>=c)throw ds.bytes=0,new RangeError("Could not decode varint");i=r[o++],e+=s<28?(i&ai)<<s:(i&ai)*Math.pow(2,s),s+=7}while(i>=bl);return ds.bytes=o-n,e}var yl=Math.pow(2,7),wl=Math.pow(2,14),vl=Math.pow(2,21),Bl=Math.pow(2,28),El=Math.pow(2,35),Al=Math.pow(2,42),Sl=Math.pow(2,49),kl=Math.pow(2,56),Il=Math.pow(2,63),Nl=function(r){return r<yl?1:r<wl?2:r<vl?3:r<Bl?4:r<El?5:r<Al?6:r<Sl?7:r<kl?8:r<Il?9:10},Cl={encode:dl,decode:xl,encodingLength:Nl},Tl=Cl,sr=Tl;function or(r,t=0){return[sr.decode(r,t),sr.decode.bytes]}function Ve(r,t,e=0){return sr.encode(r,t,e),t}function He(r){return sr.encodingLength(r)}function It(r,t){let e=t.byteLength,n=He(r),s=n+He(e),o=new Uint8Array(s+e);return Ve(r,o,0),Ve(e,o,n),o.set(t,s),new _e(r,e,t,o)}function ir(r){let t=Kt(r),[e,n]=or(t),[s,o]=or(t.subarray(n)),i=t.subarray(n+o);if(i.byteLength!==s)throw new Error("Incorrect length");return new _e(e,s,i,t)}function ui(r,t){if(r===t)return!0;{let e=t;return r.code===e.code&&r.size===e.size&&e.bytes instanceof Uint8Array&&ei(r.bytes,e.bytes)}}var _e=class{code;size;digest;bytes;constructor(t,e,n,s){this.code=t,this.size=e,this.digest=n,this.bytes=s}};function fi(r,t){let{bytes:e,version:n}=r;switch(n){case 0:return Ll(e,ps(r),t??J.encoder);default:return Rl(e,ps(r),t??qt.encoder)}}var hi=new WeakMap;function ps(r){let t=hi.get(r);if(t==null){let e=new Map;return hi.set(r,e),e}return t}var ct=class r{code;version;multihash;bytes;"/";constructor(t,e,n,s){this.code=e,this.version=t,this.multihash=n,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{let{code:t,multihash:e}=this;if(t!==cr)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==Vl)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return r.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{let{code:t,digest:e}=this.multihash,n=It(t,e);return r.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return r.equals(this,t)}static equals(t,e){let n=e;return n!=null&&t.code===n.code&&t.version===n.version&&ui(t.multihash,n.multihash)}toString(t){return fi(this,t)}toJSON(){return{"/":fi(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;let e=t;if(e instanceof r)return e;if(e["/"]!=null&&e["/"]===e.bytes||e.asCID===e){let{version:n,code:s,multihash:o,bytes:i}=e;return new r(n,s,o,i??di(n,s,o.bytes))}else if(e[Hl]===!0){let{version:n,multihash:s,code:o}=e,i=ir(s);return r.create(n,o,i)}else return null}static create(t,e,n){if(typeof e!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(e!==cr)throw new Error(`Version 0 CID must use dag-pb (code: ${cr}) block encoding`);return new r(t,e,n,n.bytes)}case 1:{let s=di(t,e,n.bytes);return new r(t,e,n,s)}default:throw new Error("Invalid version")}}static createV0(t){return r.create(0,cr,t)}static createV1(t,e){return r.create(1,t,e)}static decode(t){let[e,n]=r.decodeFirst(t);if(n.length!==0)throw new Error("Incorrect length");return e}static decodeFirst(t){let e=r.inspectBytes(t),n=e.size-e.multihashSize,s=Kt(t.subarray(n,n+e.multihashSize));if(s.byteLength!==e.multihashSize)throw new Error("Incorrect length");let o=s.subarray(e.multihashSize-e.digestSize),i=new _e(e.multihashCode,e.digestSize,o,s);return[e.version===0?r.createV0(i):r.createV1(e.codec,i),t.subarray(e.size)]}static inspectBytes(t){let e=0,n=()=>{let[u,h]=or(t.subarray(e));return e+=h,u},s=n(),o=cr;if(s===18?(s=0,e=0):o=n(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);let i=e,c=n(),a=n(),f=e+a,l=f-i;return{version:s,codec:o,multihashCode:c,digestSize:a,multihashSize:l,size:f}}static parse(t,e){let[n,s]=Ul(t,e),o=r.decode(s);if(o.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return ps(o).set(n,t),o}};function Ul(r,t){switch(r[0]){case"Q":{let e=t??J;return[J.prefix,e.decode(`${J.prefix}${r}`)]}case J.prefix:{let e=t??J;return[J.prefix,e.decode(r)]}case qt.prefix:{let e=t??qt;return[qt.prefix,e.decode(r)]}case nr.prefix:{let e=t??nr;return[nr.prefix,e.decode(r)]}default:{if(t==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],t.decode(r)]}}}function Ll(r,t,e){let{prefix:n}=e;if(n!==J.prefix)throw Error(`Cannot string encode V0 in ${e.name} encoding`);let s=t.get(n);if(s==null){let o=e.encode(r).slice(1);return t.set(n,o),o}else return s}function Rl(r,t,e){let{prefix:n}=e,s=t.get(n);if(s==null){let o=e.encode(r);return t.set(n,o),o}else return s}var cr=112,Vl=18;function di(r,t,e){let n=He(r),s=n+He(t),o=new Uint8Array(s+e.byteLength);return Ve(r,o,0),Ve(t,o,n),o.set(e,s),o}var Hl=Symbol.for("@ipld/js-cid/CID");var gs={};mt(gs,{identity:()=>se});var pi=0,_l="identity",gi=Kt;function Ml(r){return It(pi,gi(r))}var se={code:pi,name:_l,encode:gi,digest:Ml};function St(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function mi(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function Ol(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Me(r,...t){if(!Ol(r))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(r.length))throw new Error("Uint8Array expected of length "+t+", got length="+r.length)}function xi(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");mi(r.outputLen),mi(r.blockLen)}function Oe(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function bi(r,t){Me(r);let e=t.outputLen;if(r.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}var we=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var Lr=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),Nt=(r,t)=>r<<32-t|r>>>t;function yi(r){if(typeof r!="string")throw new Error("utf8ToBytes expected string, got "+typeof r);return new Uint8Array(new TextEncoder().encode(r))}function ar(r){return typeof r=="string"&&(r=yi(r)),Me(r),r}function ms(...r){let t=0;for(let n=0;n<r.length;n++){let s=r[n];Me(s),t+=s.length}let e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){let o=r[n];e.set(o,s),s+=o.length}return e}var De=class{clone(){return this._cloneInto()}};function Rr(r){let t=n=>r().update(ar(n)).digest(),e=r();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>r(),t}function Vr(r=32){if(we&&typeof we.getRandomValues=="function")return we.getRandomValues(new Uint8Array(r));if(we&&typeof we.randomBytes=="function")return we.randomBytes(r);throw new Error("crypto.getRandomValues must be defined")}function Dl(r,t,e,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(t,e,n);let s=BigInt(32),o=BigInt(4294967295),i=Number(e>>s&o),c=Number(e&o),a=n?4:0,f=n?0:4;r.setUint32(t+a,i,n),r.setUint32(t+f,c,n)}var wi=(r,t,e)=>r&t^~r&e,vi=(r,t,e)=>r&t^r&e^t&e,Pe=class extends De{constructor(t,e,n,s){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=Lr(this.buffer)}update(t){Oe(this);let{view:e,buffer:n,blockLen:s}=this;t=ar(t);let o=t.length;for(let i=0;i<o;){let c=Math.min(s-this.pos,o-i);if(c===s){let a=Lr(t);for(;s<=o-i;i+=s)this.process(a,i);continue}n.set(t.subarray(i,i+c),this.pos),this.pos+=c,i+=c,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Oe(this),bi(t,this),this.finished=!0;let{buffer:e,view:n,blockLen:s,isLE:o}=this,{pos:i}=this;e[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>s-i&&(this.process(n,0),i=0);for(let u=i;u<s;u++)e[u]=0;Dl(n,s-8,BigInt(this.length*8),o),this.process(n,0);let c=Lr(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let f=a/4,l=this.get();if(f>l.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<f;u++)c.setUint32(4*u,l[u],o)}digest(){let{buffer:t,outputLen:e}=this;this.digestInto(t);let n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:e,buffer:n,length:s,finished:o,destroyed:i,pos:c}=this;return t.length=s,t.pos=c,t.finished=o,t.destroyed=i,s%e&&t.buffer.set(n),t}};var Hr=BigInt(4294967295),xs=BigInt(32);function Bi(r,t=!1){return t?{h:Number(r&Hr),l:Number(r>>xs&Hr)}:{h:Number(r>>xs&Hr)|0,l:Number(r&Hr)|0}}function Pl(r,t=!1){let e=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let s=0;s<r.length;s++){let{h:o,l:i}=Bi(r[s],t);[e[s],n[s]]=[o,i]}return[e,n]}var Fl=(r,t)=>BigInt(r>>>0)<<xs|BigInt(t>>>0),Kl=(r,t,e)=>r>>>e,ql=(r,t,e)=>r<<32-e|t>>>e,zl=(r,t,e)=>r>>>e|t<<32-e,$l=(r,t,e)=>r<<32-e|t>>>e,jl=(r,t,e)=>r<<64-e|t>>>e-32,Gl=(r,t,e)=>r>>>e-32|t<<64-e,Zl=(r,t)=>t,Wl=(r,t)=>r,Jl=(r,t,e)=>r<<e|t>>>32-e,Yl=(r,t,e)=>t<<e|r>>>32-e,Xl=(r,t,e)=>t<<e-32|r>>>64-e,Ql=(r,t,e)=>r<<e-32|t>>>64-e;function tu(r,t,e,n){let s=(t>>>0)+(n>>>0);return{h:r+e+(s/2**32|0)|0,l:s|0}}var eu=(r,t,e)=>(r>>>0)+(t>>>0)+(e>>>0),ru=(r,t,e,n)=>t+e+n+(r/2**32|0)|0,nu=(r,t,e,n)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0),su=(r,t,e,n,s)=>t+e+n+s+(r/2**32|0)|0,ou=(r,t,e,n,s)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(s>>>0),iu=(r,t,e,n,s,o)=>t+e+n+s+o+(r/2**32|0)|0;var cu={fromBig:Bi,split:Pl,toBig:Fl,shrSH:Kl,shrSL:ql,rotrSH:zl,rotrSL:$l,rotrBH:jl,rotrBL:Gl,rotr32H:Zl,rotr32L:Wl,rotlSH:Jl,rotlSL:Yl,rotlBH:Xl,rotlBL:Ql,add:tu,add3L:eu,add3H:ru,add4L:nu,add4H:su,add5H:iu,add5L:ou},_=cu;var[au,lu]=_.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),oe=new Uint32Array(80),ie=new Uint32Array(80),bs=class extends Pe{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){let{Ah:t,Al:e,Bh:n,Bl:s,Ch:o,Cl:i,Dh:c,Dl:a,Eh:f,El:l,Fh:u,Fl:h,Gh:x,Gl:y,Hh:b,Hl:d}=this;return[t,e,n,s,o,i,c,a,f,l,u,h,x,y,b,d]}set(t,e,n,s,o,i,c,a,f,l,u,h,x,y,b,d){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=c|0,this.Dl=a|0,this.Eh=f|0,this.El=l|0,this.Fh=u|0,this.Fl=h|0,this.Gh=x|0,this.Gl=y|0,this.Hh=b|0,this.Hl=d|0}process(t,e){for(let g=0;g<16;g++,e+=4)oe[g]=t.getUint32(e),ie[g]=t.getUint32(e+=4);for(let g=16;g<80;g++){let k=oe[g-15]|0,L=ie[g-15]|0,U=_.rotrSH(k,L,1)^_.rotrSH(k,L,8)^_.shrSH(k,L,7),I=_.rotrSL(k,L,1)^_.rotrSL(k,L,8)^_.shrSL(k,L,7),T=oe[g-2]|0,N=ie[g-2]|0,G=_.rotrSH(T,N,19)^_.rotrBH(T,N,61)^_.shrSH(T,N,6),F=_.rotrSL(T,N,19)^_.rotrBL(T,N,61)^_.shrSL(T,N,6),O=_.add4L(I,F,ie[g-7],ie[g-16]),tt=_.add4H(O,U,G,oe[g-7],oe[g-16]);oe[g]=tt|0,ie[g]=O|0}let{Ah:n,Al:s,Bh:o,Bl:i,Ch:c,Cl:a,Dh:f,Dl:l,Eh:u,El:h,Fh:x,Fl:y,Gh:b,Gl:d,Hh:v,Hl:A}=this;for(let g=0;g<80;g++){let k=_.rotrSH(u,h,14)^_.rotrSH(u,h,18)^_.rotrBH(u,h,41),L=_.rotrSL(u,h,14)^_.rotrSL(u,h,18)^_.rotrBL(u,h,41),U=u&x^~u&b,I=h&y^~h&d,T=_.add5L(A,L,I,lu[g],ie[g]),N=_.add5H(T,v,k,U,au[g],oe[g]),G=T|0,F=_.rotrSH(n,s,28)^_.rotrBH(n,s,34)^_.rotrBH(n,s,39),O=_.rotrSL(n,s,28)^_.rotrBL(n,s,34)^_.rotrBL(n,s,39),tt=n&o^n&c^o&c,B=s&i^s&a^i&a;v=b|0,A=d|0,b=x|0,d=y|0,x=u|0,y=h|0,{h:u,l:h}=_.add(f|0,l|0,N|0,G|0),f=c|0,l=a|0,c=o|0,a=i|0,o=n|0,i=s|0;let C=_.add3L(G,O,B);n=_.add3H(C,N,F,tt),s=C|0}({h:n,l:s}=_.add(this.Ah|0,this.Al|0,n|0,s|0)),{h:o,l:i}=_.add(this.Bh|0,this.Bl|0,o|0,i|0),{h:c,l:a}=_.add(this.Ch|0,this.Cl|0,c|0,a|0),{h:f,l}=_.add(this.Dh|0,this.Dl|0,f|0,l|0),{h:u,l:h}=_.add(this.Eh|0,this.El|0,u|0,h|0),{h:x,l:y}=_.add(this.Fh|0,this.Fl|0,x|0,y|0),{h:b,l:d}=_.add(this.Gh|0,this.Gl|0,b|0,d|0),{h:v,l:A}=_.add(this.Hh|0,this.Hl|0,v|0,A|0),this.set(n,s,o,i,c,a,f,l,u,h,x,y,b,d,v,A)}roundClean(){oe.fill(0),ie.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}};var Ei=Rr(()=>new bs);var Or={};mt(Or,{aInRange:()=>wt,abool:()=>Ct,abytes:()=>Fe,bitGet:()=>gu,bitLen:()=>Bs,bitMask:()=>ur,bitSet:()=>mu,bytesToHex:()=>$t,bytesToNumberBE:()=>jt,bytesToNumberLE:()=>ae,concatBytes:()=>Gt,createHmacDrbg:()=>Es,ensureBytes:()=>Y,equalBytes:()=>du,hexToBytes:()=>Be,hexToNumber:()=>vs,inRange:()=>lr,isBytes:()=>ce,memoized:()=>Ae,notImplemented:()=>bu,numberToBytesBE:()=>le,numberToBytesLE:()=>Ee,numberToHexUnpadded:()=>ve,numberToVarBytesBE:()=>hu,utf8ToBytes:()=>pu,validateObject:()=>_t});var _r=BigInt(0),Mr=BigInt(1),uu=BigInt(2);function ce(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Fe(r){if(!ce(r))throw new Error("Uint8Array expected")}function Ct(r,t){if(typeof t!="boolean")throw new Error(r+" boolean expected, got "+t)}var fu=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function $t(r){Fe(r);let t="";for(let e=0;e<r.length;e++)t+=fu[r[e]];return t}function ve(r){let t=r.toString(16);return t.length&1?"0"+t:t}function vs(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?_r:BigInt("0x"+r)}var zt={_0:48,_9:57,A:65,F:70,a:97,f:102};function Ai(r){if(r>=zt._0&&r<=zt._9)return r-zt._0;if(r>=zt.A&&r<=zt.F)return r-(zt.A-10);if(r>=zt.a&&r<=zt.f)return r-(zt.a-10)}function Be(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);let t=r.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);let n=new Uint8Array(e);for(let s=0,o=0;s<e;s++,o+=2){let i=Ai(r.charCodeAt(o)),c=Ai(r.charCodeAt(o+1));if(i===void 0||c===void 0){let a=r[o]+r[o+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+o)}n[s]=i*16+c}return n}function jt(r){return vs($t(r))}function ae(r){return Fe(r),vs($t(Uint8Array.from(r).reverse()))}function le(r,t){return Be(r.toString(16).padStart(t*2,"0"))}function Ee(r,t){return le(r,t).reverse()}function hu(r){return Be(ve(r))}function Y(r,t,e){let n;if(typeof t=="string")try{n=Be(t)}catch(o){throw new Error(r+" must be hex string or Uint8Array, cause: "+o)}else if(ce(t))n=Uint8Array.from(t);else throw new Error(r+" must be hex string or Uint8Array");let s=n.length;if(typeof e=="number"&&s!==e)throw new Error(r+" of length "+e+" expected, got "+s);return n}function Gt(...r){let t=0;for(let n=0;n<r.length;n++){let s=r[n];Fe(s),t+=s.length}let e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){let o=r[n];e.set(o,s),s+=o.length}return e}function du(r,t){if(r.length!==t.length)return!1;let e=0;for(let n=0;n<r.length;n++)e|=r[n]^t[n];return e===0}function pu(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}var ys=r=>typeof r=="bigint"&&_r<=r;function lr(r,t,e){return ys(r)&&ys(t)&&ys(e)&&t<=r&&r<e}function wt(r,t,e,n){if(!lr(t,e,n))throw new Error("expected valid "+r+": "+e+" <= n < "+n+", got "+t)}function Bs(r){let t;for(t=0;r>_r;r>>=Mr,t+=1);return t}function gu(r,t){return r>>BigInt(t)&Mr}function mu(r,t,e){return r|(e?Mr:_r)<<BigInt(t)}var ur=r=>(uu<<BigInt(r-1))-Mr,ws=r=>new Uint8Array(r),Si=r=>Uint8Array.from(r);function Es(r,t,e){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let n=ws(r),s=ws(r),o=0,i=()=>{n.fill(1),s.fill(0),o=0},c=(...u)=>e(s,n,...u),a=(u=ws())=>{s=c(Si([0]),u),n=c(),u.length!==0&&(s=c(Si([1]),u),n=c())},f=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let u=0,h=[];for(;u<t;){n=c();let x=n.slice();h.push(x),u+=n.length}return Gt(...h)};return(u,h)=>{i(),a(u);let x;for(;!(x=h(f()));)a();return i(),x}}var xu={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||ce(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,t)=>t.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function _t(r,t,e={}){let n=(s,o,i)=>{let c=xu[o];if(typeof c!="function")throw new Error("invalid validator function");let a=r[s];if(!(i&&a===void 0)&&!c(a,r))throw new Error("param "+String(s)+" is invalid. Expected "+o+", got "+a)};for(let[s,o]of Object.entries(t))n(s,o,!1);for(let[s,o]of Object.entries(e))n(s,o,!0);return r}var bu=()=>{throw new Error("not implemented")};function Ae(r){let t=new WeakMap;return(e,...n)=>{let s=t.get(e);if(s!==void 0)return s;let o=r(e,...n);return t.set(e,o),o}}var et=BigInt(0),Z=BigInt(1),Se=BigInt(2),yu=BigInt(3),As=BigInt(4),ki=BigInt(5),Ii=BigInt(8),wu=BigInt(9),vu=BigInt(16);function z(r,t){let e=r%t;return e>=et?e:t+e}function Bu(r,t,e){if(t<et)throw new Error("invalid exponent, negatives unsupported");if(e<=et)throw new Error("invalid modulus");if(e===Z)return et;let n=Z;for(;t>et;)t&Z&&(n=n*r%e),r=r*r%e,t>>=Z;return n}function W(r,t,e){let n=r;for(;t-- >et;)n*=n,n%=e;return n}function Dr(r,t){if(r===et)throw new Error("invert: expected non-zero number");if(t<=et)throw new Error("invert: expected positive modulus, got "+t);let e=z(r,t),n=t,s=et,o=Z,i=Z,c=et;for(;e!==et;){let f=n/e,l=n%e,u=s-i*f,h=o-c*f;n=e,e=l,s=i,o=c,i=u,c=h}if(n!==Z)throw new Error("invert: does not exist");return z(s,t)}function Eu(r){let t=(r-Z)/Se,e,n,s;for(e=r-Z,n=0;e%Se===et;e/=Se,n++);for(s=Se;s<r&&Bu(s,t,r)!==r-Z;s++)if(s>1e3)throw new Error("Cannot find square root: likely non-prime P");if(n===1){let i=(r+Z)/As;return function(a,f){let l=a.pow(f,i);if(!a.eql(a.sqr(l),f))throw new Error("Cannot find square root");return l}}let o=(e+Z)/Se;return function(c,a){if(c.pow(a,t)===c.neg(c.ONE))throw new Error("Cannot find square root");let f=n,l=c.pow(c.mul(c.ONE,s),e),u=c.pow(a,o),h=c.pow(a,e);for(;!c.eql(h,c.ONE);){if(c.eql(h,c.ZERO))return c.ZERO;let x=1;for(let b=c.sqr(h);x<f&&!c.eql(b,c.ONE);x++)b=c.sqr(b);let y=c.pow(l,Z<<BigInt(f-x-1));l=c.sqr(y),u=c.mul(u,y),h=c.mul(h,l),f=x}return u}}function Au(r){if(r%As===yu){let t=(r+Z)/As;return function(n,s){let o=n.pow(s,t);if(!n.eql(n.sqr(o),s))throw new Error("Cannot find square root");return o}}if(r%Ii===ki){let t=(r-ki)/Ii;return function(n,s){let o=n.mul(s,Se),i=n.pow(o,t),c=n.mul(s,i),a=n.mul(n.mul(c,Se),i),f=n.mul(c,n.sub(a,n.ONE));if(!n.eql(n.sqr(f),s))throw new Error("Cannot find square root");return f}}return r%vu,Eu(r)}var Ni=(r,t)=>(z(r,t)&Z)===Z,Su=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ss(r){let t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Su.reduce((n,s)=>(n[s]="function",n),t);return _t(r,e)}function ku(r,t,e){if(e<et)throw new Error("invalid exponent, negatives unsupported");if(e===et)return r.ONE;if(e===Z)return t;let n=r.ONE,s=t;for(;e>et;)e&Z&&(n=r.mul(n,s)),s=r.sqr(s),e>>=Z;return n}function Iu(r,t){let e=new Array(t.length),n=t.reduce((o,i,c)=>r.is0(i)?o:(e[c]=o,r.mul(o,i)),r.ONE),s=r.inv(n);return t.reduceRight((o,i,c)=>r.is0(i)?o:(e[c]=r.mul(o,e[c]),r.mul(o,i)),s),e}function ks(r,t){let e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}function ue(r,t,e=!1,n={}){if(r<=et)throw new Error("invalid field: expected ORDER > 0, got "+r);let{nBitLength:s,nByteLength:o}=ks(r,t);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let i,c=Object.freeze({ORDER:r,BITS:s,BYTES:o,MASK:ur(s),ZERO:et,ONE:Z,create:a=>z(a,r),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return et<=a&&a<r},is0:a=>a===et,isOdd:a=>(a&Z)===Z,neg:a=>z(-a,r),eql:(a,f)=>a===f,sqr:a=>z(a*a,r),add:(a,f)=>z(a+f,r),sub:(a,f)=>z(a-f,r),mul:(a,f)=>z(a*f,r),pow:(a,f)=>ku(c,a,f),div:(a,f)=>z(a*Dr(f,r),r),sqrN:a=>a*a,addN:(a,f)=>a+f,subN:(a,f)=>a-f,mulN:(a,f)=>a*f,inv:a=>Dr(a,r),sqrt:n.sqrt||(a=>(i||(i=Au(r)),i(c,a))),invertBatch:a=>Iu(c,a),cmov:(a,f,l)=>l?f:a,toBytes:a=>e?Ee(a,o):le(a,o),fromBytes:a=>{if(a.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+a.length);return e?ae(a):jt(a)}});return Object.freeze(c)}function Ci(r){if(typeof r!="bigint")throw new Error("field order must be bigint");let t=r.toString(2).length;return Math.ceil(t/8)}function Is(r){let t=Ci(r);return t+Math.ceil(t/2)}function Ti(r,t,e=!1){let n=r.length,s=Ci(t),o=Is(t);if(n<16||n<o||n>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+n);let i=e?jt(r):ae(r),c=z(i,t-Z)+Z;return e?Ee(c,s):le(c,s)}var Ui=BigInt(0),Pr=BigInt(1);function Ns(r,t){let e=t.negate();return r?e:t}function Li(r,t){if(!Number.isSafeInteger(r)||r<=0||r>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+r)}function Cs(r,t){Li(r,t);let e=Math.ceil(t/r)+1,n=2**(r-1);return{windows:e,windowSize:n}}function Cu(r,t){if(!Array.isArray(r))throw new Error("array expected");r.forEach((e,n)=>{if(!(e instanceof t))throw new Error("invalid point at index "+n)})}function Tu(r,t){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((e,n)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+n)})}var Ts=new WeakMap,Ri=new WeakMap;function Us(r){return Ri.get(r)||1}function Fr(r,t){return{constTimeNegate:Ns,hasPrecomputes(e){return Us(e)!==1},unsafeLadder(e,n,s=r.ZERO){let o=e;for(;n>Ui;)n&Pr&&(s=s.add(o)),o=o.double(),n>>=Pr;return s},precomputeWindow(e,n){let{windows:s,windowSize:o}=Cs(n,t),i=[],c=e,a=c;for(let f=0;f<s;f++){a=c,i.push(a);for(let l=1;l<o;l++)a=a.add(c),i.push(a);c=a.double()}return i},wNAF(e,n,s){let{windows:o,windowSize:i}=Cs(e,t),c=r.ZERO,a=r.BASE,f=BigInt(2**e-1),l=2**e,u=BigInt(e);for(let h=0;h<o;h++){let x=h*i,y=Number(s&f);s>>=u,y>i&&(y-=l,s+=Pr);let b=x,d=x+Math.abs(y)-1,v=h%2!==0,A=y<0;y===0?a=a.add(Ns(v,n[b])):c=c.add(Ns(A,n[d]))}return{p:c,f:a}},wNAFUnsafe(e,n,s,o=r.ZERO){let{windows:i,windowSize:c}=Cs(e,t),a=BigInt(2**e-1),f=2**e,l=BigInt(e);for(let u=0;u<i;u++){let h=u*c;if(s===Ui)break;let x=Number(s&a);if(s>>=l,x>c&&(x-=f,s+=Pr),x===0)continue;let y=n[h+Math.abs(x)-1];x<0&&(y=y.negate()),o=o.add(y)}return o},getPrecomputes(e,n,s){let o=Ts.get(n);return o||(o=this.precomputeWindow(n,e),e!==1&&Ts.set(n,s(o))),o},wNAFCached(e,n,s){let o=Us(e);return this.wNAF(o,this.getPrecomputes(o,e,s),n)},wNAFCachedUnsafe(e,n,s,o){let i=Us(e);return i===1?this.unsafeLadder(e,n,o):this.wNAFUnsafe(i,this.getPrecomputes(i,e,s),n,o)},setWindowSize(e,n){Li(n,t),Ri.set(e,n),Ts.delete(e)}}}function Kr(r,t,e,n){if(Cu(e,r),Tu(n,t),e.length!==n.length)throw new Error("arrays of points and scalars must have equal length");let s=r.ZERO,o=Bs(BigInt(e.length)),i=o>12?o-3:o>4?o-2:o?2:1,c=(1<<i)-1,a=new Array(c+1).fill(s),f=Math.floor((t.BITS-1)/i)*i,l=s;for(let u=f;u>=0;u-=i){a.fill(s);for(let x=0;x<n.length;x++){let y=n[x],b=Number(y>>BigInt(u)&BigInt(c));a[b]=a[b].add(e[x])}let h=s;for(let x=a.length-1,y=s;x>0;x--)y=y.add(a[x]),h=h.add(y);if(l=l.add(h),u!==0)for(let x=0;x<i;x++)l=l.double()}return l}function fr(r){return Ss(r.Fp),_t(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...ks(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}var Tt=BigInt(0),vt=BigInt(1),qr=BigInt(2),Uu=BigInt(8),Lu={zip215:!0};function Ru(r){let t=fr(r);return _t(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}function Vi(r){let t=Ru(r),{Fp:e,n,prehash:s,hash:o,randomBytes:i,nByteLength:c,h:a}=t,f=qr<<BigInt(c*8)-vt,l=e.create,u=ue(t.n,t.nBitLength),h=t.uvRatio||((m,p)=>{try{return{isValid:!0,value:e.sqrt(m*e.inv(p))}}catch{return{isValid:!1,value:Tt}}}),x=t.adjustScalarBytes||(m=>m),y=t.domain||((m,p,w)=>{if(Ct("phflag",w),p.length||w)throw new Error("Contexts/pre-hash are not supported");return m});function b(m,p){wt("coordinate "+m,p,Tt,f)}function d(m){if(!(m instanceof g))throw new Error("ExtendedPoint expected")}let v=Ae((m,p)=>{let{ex:w,ey:S,ez:R}=m,V=m.is0();p==null&&(p=V?Uu:e.inv(R));let M=l(w*p),P=l(S*p),H=l(R*p);if(V)return{x:Tt,y:vt};if(H!==vt)throw new Error("invZ was invalid");return{x:M,y:P}}),A=Ae(m=>{let{a:p,d:w}=t;if(m.is0())throw new Error("bad point: ZERO");let{ex:S,ey:R,ez:V,et:M}=m,P=l(S*S),H=l(R*R),q=l(V*V),j=l(q*q),nt=l(P*p),st=l(q*l(nt+H)),it=l(j+l(w*l(P*H)));if(st!==it)throw new Error("bad point: equation left != right (1)");let ft=l(S*R),yt=l(V*M);if(ft!==yt)throw new Error("bad point: equation left != right (2)");return!0});class g{constructor(p,w,S,R){this.ex=p,this.ey=w,this.ez=S,this.et=R,b("x",p),b("y",w),b("z",S),b("t",R),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(p){if(p instanceof g)throw new Error("extended point not allowed");let{x:w,y:S}=p||{};return b("x",w),b("y",S),new g(w,S,vt,l(w*S))}static normalizeZ(p){let w=e.invertBatch(p.map(S=>S.ez));return p.map((S,R)=>S.toAffine(w[R])).map(g.fromAffine)}static msm(p,w){return Kr(g,u,p,w)}_setWindowSize(p){U.setWindowSize(this,p)}assertValidity(){A(this)}equals(p){d(p);let{ex:w,ey:S,ez:R}=this,{ex:V,ey:M,ez:P}=p,H=l(w*P),q=l(V*R),j=l(S*P),nt=l(M*R);return H===q&&j===nt}is0(){return this.equals(g.ZERO)}negate(){return new g(l(-this.ex),this.ey,this.ez,l(-this.et))}double(){let{a:p}=t,{ex:w,ey:S,ez:R}=this,V=l(w*w),M=l(S*S),P=l(qr*l(R*R)),H=l(p*V),q=w+S,j=l(l(q*q)-V-M),nt=H+M,st=nt-P,it=H-M,ft=l(j*st),yt=l(nt*it),gt=l(j*it),Ht=l(st*nt);return new g(ft,yt,Ht,gt)}add(p){d(p);let{a:w,d:S}=t,{ex:R,ey:V,ez:M,et:P}=this,{ex:H,ey:q,ez:j,et:nt}=p;if(w===BigInt(-1)){let $o=l((V-R)*(q+H)),jo=l((V+R)*(q-H)),ss=l(jo-$o);if(ss===Tt)return this.double();let Go=l(M*qr*nt),Zo=l(P*qr*j),Wo=Zo+Go,Jo=jo+$o,Yo=Zo-Go,Pa=l(Wo*ss),Fa=l(Jo*Yo),Ka=l(Wo*Yo),qa=l(ss*Jo);return new g(Pa,Fa,qa,Ka)}let st=l(R*H),it=l(V*q),ft=l(P*S*nt),yt=l(M*j),gt=l((R+V)*(H+q)-st-it),Ht=yt-ft,Ft=yt+ft,rr=l(it-w*st),_a=l(gt*Ht),Ma=l(Ft*rr),Oa=l(gt*rr),Da=l(Ht*Ft);return new g(_a,Ma,Da,Oa)}subtract(p){return this.add(p.negate())}wNAF(p){return U.wNAFCached(this,p,g.normalizeZ)}multiply(p){let w=p;wt("scalar",w,vt,n);let{p:S,f:R}=this.wNAF(w);return g.normalizeZ([S,R])[0]}multiplyUnsafe(p,w=g.ZERO){let S=p;return wt("scalar",S,Tt,n),S===Tt?L:this.is0()||S===vt?this:U.wNAFCachedUnsafe(this,S,g.normalizeZ,w)}isSmallOrder(){return this.multiplyUnsafe(a).is0()}isTorsionFree(){return U.unsafeLadder(this,n).is0()}toAffine(p){return v(this,p)}clearCofactor(){let{h:p}=t;return p===vt?this:this.multiplyUnsafe(p)}static fromHex(p,w=!1){let{d:S,a:R}=t,V=e.BYTES;p=Y("pointHex",p,V),Ct("zip215",w);let M=p.slice(),P=p[V-1];M[V-1]=P&-129;let H=ae(M),q=w?f:e.ORDER;wt("pointHex.y",H,Tt,q);let j=l(H*H),nt=l(j-vt),st=l(S*j-R),{isValid:it,value:ft}=h(nt,st);if(!it)throw new Error("Point.fromHex: invalid y coordinate");let yt=(ft&vt)===vt,gt=(P&128)!==0;if(!w&&ft===Tt&&gt)throw new Error("Point.fromHex: x=0 and x_0=1");return gt!==yt&&(ft=l(-ft)),g.fromAffine({x:ft,y:H})}static fromPrivateKey(p){return N(p).point}toRawBytes(){let{x:p,y:w}=this.toAffine(),S=Ee(w,e.BYTES);return S[S.length-1]|=p&vt?128:0,S}toHex(){return $t(this.toRawBytes())}}g.BASE=new g(t.Gx,t.Gy,vt,l(t.Gx*t.Gy)),g.ZERO=new g(Tt,vt,vt,Tt);let{BASE:k,ZERO:L}=g,U=Fr(g,c*8);function I(m){return z(m,n)}function T(m){return I(ae(m))}function N(m){let p=e.BYTES;m=Y("private key",m,p);let w=Y("hashed private key",o(m),2*p),S=x(w.slice(0,p)),R=w.slice(p,2*p),V=T(S),M=k.multiply(V),P=M.toRawBytes();return{head:S,prefix:R,scalar:V,point:M,pointBytes:P}}function G(m){return N(m).pointBytes}function F(m=new Uint8Array,...p){let w=Gt(...p);return T(o(y(w,Y("context",m),!!s)))}function O(m,p,w={}){m=Y("message",m),s&&(m=s(m));let{prefix:S,scalar:R,pointBytes:V}=N(p),M=F(w.context,S,m),P=k.multiply(M).toRawBytes(),H=F(w.context,P,V,m),q=I(M+H*R);wt("signature.s",q,Tt,n);let j=Gt(P,Ee(q,e.BYTES));return Y("result",j,e.BYTES*2)}let tt=Lu;function B(m,p,w,S=tt){let{context:R,zip215:V}=S,M=e.BYTES;m=Y("signature",m,2*M),p=Y("message",p),w=Y("publicKey",w,M),V!==void 0&&Ct("zip215",V),s&&(p=s(p));let P=ae(m.slice(M,2*M)),H,q,j;try{H=g.fromHex(w,V),q=g.fromHex(m.slice(0,M),V),j=k.multiplyUnsafe(P)}catch{return!1}if(!V&&H.isSmallOrder())return!1;let nt=F(R,q.toRawBytes(),H.toRawBytes(),p);return q.add(H.multiplyUnsafe(nt)).subtract(j).clearCofactor().equals(g.ZERO)}return k._setWindowSize(8),{CURVE:t,getPublicKey:G,sign:O,verify:B,ExtendedPoint:g,utils:{getExtendedPublicKey:N,randomPrivateKey:()=>i(e.BYTES),precompute(m=8,p=g.BASE){return p._setWindowSize(m),p.multiply(BigInt(3)),p}}}}var Ls=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Hi=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),bd=BigInt(0),Vu=BigInt(1),_i=BigInt(2),yd=BigInt(3),Hu=BigInt(5),_u=BigInt(8);function Mu(r){let t=BigInt(10),e=BigInt(20),n=BigInt(40),s=BigInt(80),o=Ls,c=r*r%o*r%o,a=W(c,_i,o)*c%o,f=W(a,Vu,o)*r%o,l=W(f,Hu,o)*f%o,u=W(l,t,o)*l%o,h=W(u,e,o)*u%o,x=W(h,n,o)*h%o,y=W(x,s,o)*x%o,b=W(y,s,o)*x%o,d=W(b,t,o)*l%o;return{pow_p_5_8:W(d,_i,o)*r%o,b2:c}}function Ou(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function Du(r,t){let e=Ls,n=z(t*t*t,e),s=z(n*n*t,e),o=Mu(r*s).pow_p_5_8,i=z(r*n*o,e),c=z(t*i*i,e),a=i,f=z(i*Hi,e),l=c===r,u=c===z(-r,e),h=c===z(-r*Hi,e);return l&&(i=a),(u||h)&&(i=f),Ni(i,e)&&(i=z(-i,e)),{isValid:l||u,value:i}}var Pu=ue(Ls,void 0,!0),Fu={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:Pu,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:_u,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Ei,randomBytes:Vr,adjustScalarBytes:Ou,uvRatio:Du},Mi=Vi(Fu);var zr=32;function Oi(r,t,e){return Mi.verify(t,e instanceof Uint8Array?e:e.subarray(),r)}var $r=class{type="Ed25519";raw;constructor(t){this.raw=Rs(t,zr)}toMultihash(){return se.digest(Ke(this))}toCID(){return ct.createV1(114,this.toMultihash())}toString(){return J.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:St(this.raw,t.raw)}verify(t,e){return Oi(this.raw,e,t)}};function Pi(r){return r=Rs(r,zr),new $r(r)}function Rs(r,t){if(r=Uint8Array.from(r??[]),r.length!==t)throw new xt(`Key must be a Uint8Array of length ${t}, got ${r.length}`);return r}function Fi(r=0){return new Uint8Array(r)}function Ut(r=0){return new Uint8Array(r)}var qu=Math.pow(2,7),zu=Math.pow(2,14),$u=Math.pow(2,21),Vs=Math.pow(2,28),Hs=Math.pow(2,35),_s=Math.pow(2,42),Ms=Math.pow(2,49),K=128,ht=127;function Bt(r){if(r<qu)return 1;if(r<zu)return 2;if(r<$u)return 3;if(r<Vs)return 4;if(r<Hs)return 5;if(r<_s)return 6;if(r<Ms)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function Os(r,t,e=0){switch(Bt(r)){case 8:t[e++]=r&255|K,r/=128;case 7:t[e++]=r&255|K,r/=128;case 6:t[e++]=r&255|K,r/=128;case 5:t[e++]=r&255|K,r/=128;case 4:t[e++]=r&255|K,r>>>=7;case 3:t[e++]=r&255|K,r>>>=7;case 2:t[e++]=r&255|K,r>>>=7;case 1:{t[e++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return t}function ju(r,t,e=0){switch(Bt(r)){case 8:t.set(e++,r&255|K),r/=128;case 7:t.set(e++,r&255|K),r/=128;case 6:t.set(e++,r&255|K),r/=128;case 5:t.set(e++,r&255|K),r/=128;case 4:t.set(e++,r&255|K),r>>>=7;case 3:t.set(e++,r&255|K),r>>>=7;case 2:t.set(e++,r&255|K),r>>>=7;case 1:{t.set(e++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return t}function Ds(r,t){let e=r[t],n=0;if(n+=e&ht,e<K||(e=r[t+1],n+=(e&ht)<<7,e<K)||(e=r[t+2],n+=(e&ht)<<14,e<K)||(e=r[t+3],n+=(e&ht)<<21,e<K)||(e=r[t+4],n+=(e&ht)*Vs,e<K)||(e=r[t+5],n+=(e&ht)*Hs,e<K)||(e=r[t+6],n+=(e&ht)*_s,e<K)||(e=r[t+7],n+=(e&ht)*Ms,e<K))return n;throw new RangeError("Could not decode varint")}function Gu(r,t){let e=r.get(t),n=0;if(n+=e&ht,e<K||(e=r.get(t+1),n+=(e&ht)<<7,e<K)||(e=r.get(t+2),n+=(e&ht)<<14,e<K)||(e=r.get(t+3),n+=(e&ht)<<21,e<K)||(e=r.get(t+4),n+=(e&ht)*Vs,e<K)||(e=r.get(t+5),n+=(e&ht)*Hs,e<K)||(e=r.get(t+6),n+=(e&ht)*_s,e<K)||(e=r.get(t+7),n+=(e&ht)*Ms,e<K))return n;throw new RangeError("Could not decode varint")}function qe(r,t,e=0){return t==null&&(t=Ut(Bt(r))),t instanceof Uint8Array?Os(r,t,e):ju(r,t,e)}function ke(r,t=0){return r instanceof Uint8Array?Ds(r,t):Gu(r,t)}var Ps=new Float32Array([-0]),fe=new Uint8Array(Ps.buffer);function qi(r,t,e){Ps[0]=r,t[e]=fe[0],t[e+1]=fe[1],t[e+2]=fe[2],t[e+3]=fe[3]}function zi(r,t){return fe[0]=r[t],fe[1]=r[t+1],fe[2]=r[t+2],fe[3]=r[t+3],Ps[0]}var Fs=new Float64Array([-0]),dt=new Uint8Array(Fs.buffer);function $i(r,t,e){Fs[0]=r,t[e]=dt[0],t[e+1]=dt[1],t[e+2]=dt[2],t[e+3]=dt[3],t[e+4]=dt[4],t[e+5]=dt[5],t[e+6]=dt[6],t[e+7]=dt[7]}function ji(r,t){return dt[0]=r[t],dt[1]=r[t+1],dt[2]=r[t+2],dt[3]=r[t+3],dt[4]=r[t+4],dt[5]=r[t+5],dt[6]=r[t+6],dt[7]=r[t+7],Fs[0]}var Zu=BigInt(Number.MAX_SAFE_INTEGER),Wu=BigInt(Number.MIN_SAFE_INTEGER),At=class r{lo;hi;constructor(t,e){this.lo=t|0,this.hi=e|0}toNumber(t=!1){if(!t&&this.hi>>>31>0){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(e+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(t=!1){if(t)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){let e=~this.lo+1>>>0,n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(BigInt(e)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(t=!1){return this.toBigInt(t).toString()}zzEncode(){let t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this}zzDecode(){let t=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this}length(){let t=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?e===0?t<16384?t<128?1:2:t<2097152?3:4:e<16384?e<128?5:6:e<2097152?7:8:n<128?9:10}static fromBigInt(t){if(t===0n)return Ie;if(t<Zu&&t>Wu)return this.fromNumber(Number(t));let e=t<0n;e&&(t=-t);let n=t>>32n,s=t-(n<<32n);return e&&(n=~n|0n,s=~s|0n,++s>Gi&&(s=0n,++n>Gi&&(n=0n))),new r(Number(s),Number(n))}static fromNumber(t){if(t===0)return Ie;let e=t<0;e&&(t=-t);let n=t>>>0,s=(t-n)/4294967296>>>0;return e&&(s=~s>>>0,n=~n>>>0,++n>4294967295&&(n=0,++s>4294967295&&(s=0))),new r(n,s)}static from(t){return typeof t=="number"?r.fromNumber(t):typeof t=="bigint"?r.fromBigInt(t):typeof t=="string"?r.fromBigInt(BigInt(t)):t.low!=null||t.high!=null?new r(t.low>>>0,t.high>>>0):Ie}},Ie=new At(0,0);Ie.toBigInt=function(){return 0n};Ie.zzEncode=Ie.zzDecode=function(){return this};Ie.length=function(){return 1};var Gi=4294967296n;function Zi(r){let t=0,e=0;for(let n=0;n<r.length;++n)e=r.charCodeAt(n),e<128?t+=1:e<2048?t+=2:(e&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,t+=4):t+=3;return t}function Wi(r,t,e){if(e-t<1)return"";let s,o=[],i=0,c;for(;t<e;)c=r[t++],c<128?o[i++]=c:c>191&&c<224?o[i++]=(c&31)<<6|r[t++]&63:c>239&&c<365?(c=((c&7)<<18|(r[t++]&63)<<12|(r[t++]&63)<<6|r[t++]&63)-65536,o[i++]=55296+(c>>10),o[i++]=56320+(c&1023)):o[i++]=(c&15)<<12|(r[t++]&63)<<6|r[t++]&63,i>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,o)),i=0);return s!=null?(i>0&&s.push(String.fromCharCode.apply(String,o.slice(0,i))),s.join("")):String.fromCharCode.apply(String,o.slice(0,i))}function Ks(r,t,e){let n=e,s,o;for(let i=0;i<r.length;++i)s=r.charCodeAt(i),s<128?t[e++]=s:s<2048?(t[e++]=s>>6|192,t[e++]=s&63|128):(s&64512)===55296&&((o=r.charCodeAt(i+1))&64512)===56320?(s=65536+((s&1023)<<10)+(o&1023),++i,t[e++]=s>>18|240,t[e++]=s>>12&63|128,t[e++]=s>>6&63|128,t[e++]=s&63|128):(t[e++]=s>>12|224,t[e++]=s>>6&63|128,t[e++]=s&63|128);return e-n}function Lt(r,t){return RangeError(`index out of range: ${r.pos} + ${t??1} > ${r.len}`)}function jr(r,t){return(r[t-4]|r[t-3]<<8|r[t-2]<<16|r[t-1]<<24)>>>0}var qs=class{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(t){this.buf=t,this.pos=0,this.len=t.length}uint32(){let t=4294967295;if(t=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(t=(t|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return t;if((this.pos+=5)>this.len)throw this.pos=this.len,Lt(this,10);return t}int32(){return this.uint32()|0}sint32(){let t=this.uint32();return t>>>1^-(t&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw Lt(this,4);return jr(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw Lt(this,4);return jr(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw Lt(this,4);let t=zi(this.buf,this.pos);return this.pos+=4,t}double(){if(this.pos+8>this.len)throw Lt(this,4);let t=ji(this.buf,this.pos);return this.pos+=8,t}bytes(){let t=this.uint32(),e=this.pos,n=this.pos+t;if(n>this.len)throw Lt(this,t);return this.pos+=t,e===n?new Uint8Array(0):this.buf.subarray(e,n)}string(){let t=this.bytes();return Wi(t,0,t.length)}skip(t){if(typeof t=="number"){if(this.pos+t>this.len)throw Lt(this,t);this.pos+=t}else do if(this.pos>=this.len)throw Lt(this);while(this.buf[this.pos++]&128);return this}skipType(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${t} at offset ${this.pos}`)}return this}readLongVarint(){let t=new At(0,0),e=0;if(this.len-this.pos>4){for(;e<4;++e)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw Lt(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,t}if(this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw Lt(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw Lt(this,8);let t=jr(this.buf,this.pos+=4),e=jr(this.buf,this.pos+=4);return new At(t,e)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){let t=Ds(this.buf,this.pos);return this.pos+=Bt(t),t}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}};function zs(r){return new qs(r instanceof Uint8Array?r:r.subarray())}function ze(r,t,e){let n=zs(r);return t.decode(n,void 0,e)}var $s={};mt($s,{base10:()=>Ju});var Ju=ne({prefix:"9",name:"base10",alphabet:"0123456789"});var js={};mt(js,{base16:()=>Yu,base16upper:()=>Xu});var Yu=X({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Xu=X({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var Gs={};mt(Gs,{base2:()=>Qu});var Qu=X({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var Zs={};mt(Zs,{base256emoji:()=>sf});var Yi=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),tf=Yi.reduce((r,t,e)=>(r[e]=t,r),[]),ef=Yi.reduce((r,t,e)=>{let n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);return r[n]=e,r},[]);function rf(r){return r.reduce((t,e)=>(t+=tf[e],t),"")}function nf(r){let t=[];for(let e of r){let n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);let s=ef[n];if(s==null)throw new Error(`Non-base256emoji character: ${e}`);t.push(s)}return new Uint8Array(t)}var sf=Re({prefix:"\u{1F680}",name:"base256emoji",encode:rf,decode:nf});var Ws={};mt(Ws,{base64:()=>of,base64pad:()=>cf,base64url:()=>af,base64urlpad:()=>lf});var of=X({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),cf=X({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),af=X({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),lf=X({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var Js={};mt(Js,{base8:()=>uf});var uf=X({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var Ys={};mt(Ys,{identity:()=>ff});var ff=Re({prefix:"\0",name:"identity",encode:r=>ni(r),decode:r=>ri(r)});var e0=new TextEncoder,r0=new TextDecoder;var to={};mt(to,{sha256:()=>Gr,sha512:()=>pf});function Qs({name:r,code:t,encode:e}){return new Xs(r,t,e)}var Xs=class{name;code;encode;constructor(t,e,n){this.name=t,this.code=e,this.encode=n}digest(t){if(t instanceof Uint8Array){let e=this.encode(t);return e instanceof Uint8Array?It(this.code,e):e.then(n=>It(this.code,n))}else throw Error("Unknown type, must be binary type")}};function Qi(r){return async t=>new Uint8Array(await crypto.subtle.digest(r,t))}var Gr=Qs({name:"sha2-256",code:18,encode:Qi("SHA-256")}),pf=Qs({name:"sha2-512",code:19,encode:Qi("SHA-512")});var hr={...Ys,...Gs,...Js,...$s,...js,...fs,...hs,...us,...Ws,...Zs},p0={...to,...gs};function ec(r,t,e,n){return{name:r,prefix:t,encoder:{name:r,prefix:t,encode:e},decoder:{decode:n}}}var tc=ec("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),eo=ec("ascii","a",r=>{let t="a";for(let e=0;e<r.length;e++)t+=String.fromCharCode(r[e]);return t},r=>{r=r.substring(1);let t=Ut(r.length);for(let e=0;e<r.length;e++)t[e]=r.charCodeAt(e);return t}),gf={utf8:tc,"utf-8":tc,hex:hr.base16,latin1:eo,ascii:eo,binary:eo,...hr},Zr=gf;function Q(r,t="utf8"){let e=Zr[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.decoder.decode(`${e.prefix}${r}`)}function ro(r){let t=r??8192,e=t>>>1,n,s=t;return function(i){if(i<1||i>e)return Ut(i);s+i>t&&(n=Ut(t),s=0);let c=n.subarray(s,s+=i);return s&7&&(s=(s|7)+1),c}}var Ne=class{fn;len;next;val;constructor(t,e,n){this.fn=t,this.len=e,this.next=void 0,this.val=n}};function no(){}var oo=class{head;tail;len;next;constructor(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}},mf=ro();function xf(r){return globalThis.Buffer!=null?Ut(r):mf(r)}var pr=class{len;head;tail;states;constructor(){this.len=0,this.head=new Ne(no,0,0),this.tail=this.head,this.states=null}_push(t,e,n){return this.tail=this.tail.next=new Ne(t,e,n),this.len+=e,this}uint32(t){return this.len+=(this.tail=this.tail.next=new io((t=t>>>0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this}int32(t){return t<0?this._push(Wr,10,At.fromNumber(t)):this.uint32(t)}sint32(t){return this.uint32((t<<1^t>>31)>>>0)}uint64(t){let e=At.fromBigInt(t);return this._push(Wr,e.length(),e)}uint64Number(t){return this._push(Os,Bt(t),t)}uint64String(t){return this.uint64(BigInt(t))}int64(t){return this.uint64(t)}int64Number(t){return this.uint64Number(t)}int64String(t){return this.uint64String(t)}sint64(t){let e=At.fromBigInt(t).zzEncode();return this._push(Wr,e.length(),e)}sint64Number(t){let e=At.fromNumber(t).zzEncode();return this._push(Wr,e.length(),e)}sint64String(t){return this.sint64(BigInt(t))}bool(t){return this._push(so,1,t?1:0)}fixed32(t){return this._push(dr,4,t>>>0)}sfixed32(t){return this.fixed32(t)}fixed64(t){let e=At.fromBigInt(t);return this._push(dr,4,e.lo)._push(dr,4,e.hi)}fixed64Number(t){let e=At.fromNumber(t);return this._push(dr,4,e.lo)._push(dr,4,e.hi)}fixed64String(t){return this.fixed64(BigInt(t))}sfixed64(t){return this.fixed64(t)}sfixed64Number(t){return this.fixed64Number(t)}sfixed64String(t){return this.fixed64String(t)}float(t){return this._push(qi,4,t)}double(t){return this._push($i,8,t)}bytes(t){let e=t.length>>>0;return e===0?this._push(so,1,0):this.uint32(e)._push(yf,e,t)}string(t){let e=Zi(t);return e!==0?this.uint32(e)._push(Ks,e,t):this._push(so,1,0)}fork(){return this.states=new oo(this),this.head=this.tail=new Ne(no,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Ne(no,0,0),this.len=0),this}ldelim(){let t=this.head,e=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=t.next,this.tail=e,this.len+=n),this}finish(){let t=this.head.next,e=xf(this.len),n=0;for(;t!=null;)t.fn(t.val,e,n),n+=t.len,t=t.next;return e}};function so(r,t,e){t[e]=r&255}function bf(r,t,e){for(;r>127;)t[e++]=r&127|128,r>>>=7;t[e]=r}var io=class extends Ne{next;constructor(t,e){super(bf,t,e),this.next=void 0}};function Wr(r,t,e){for(;r.hi!==0;)t[e++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)t[e++]=r.lo&127|128,r.lo=r.lo>>>7;t[e++]=r.lo}function dr(r,t,e){t[e]=r&255,t[e+1]=r>>>8&255,t[e+2]=r>>>16&255,t[e+3]=r>>>24}function yf(r,t,e){t.set(r,e)}globalThis.Buffer!=null&&(pr.prototype.bytes=function(r){let t=r.length>>>0;return this.uint32(t),t>0&&this._push(wf,t,r),this},pr.prototype.string=function(r){let t=globalThis.Buffer.byteLength(r);return this.uint32(t),t>0&&this._push(vf,t,r),this});function wf(r,t,e){t.set(r,e)}function vf(r,t,e){r.length<40?Ks(r,t,e):t.utf8Write!=null?t.utf8Write(r,e):t.set(Q(r),e)}function co(){return new pr}function $e(r,t){let e=co();return t.encode(r,e,{lengthDelimited:!1}),e.finish()}var je;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(je||(je={}));function Jr(r,t,e,n){return{name:r,type:t,encode:e,decode:n}}function ao(r){function t(s){if(r[s.toString()]==null)throw new Error("Invalid enum value");return r[s]}let e=function(o,i){let c=t(o);i.int32(c)},n=function(o){let i=o.int32();return t(i)};return Jr("enum",je.VARINT,e,n)}function Ge(r,t){return Jr("message",je.LENGTH_DELIMITED,r,t)}var Yr=class extends Error{code="ERR_MAX_LENGTH";name="MaxLengthError"};var at;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1"})(at||(at={}));var lo;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1"})(lo||(lo={}));(function(r){r.codec=()=>ao(lo)})(at||(at={}));var Zt;(function(r){let t;r.codec=()=>(t==null&&(t=Ge((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),at.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{let o={},i=n==null?e.len:e.pos+n;for(;e.pos<i;){let c=e.uint32();switch(c>>>3){case 1:{o.Type=at.codec().decode(e);break}case 2:{o.Data=e.bytes();break}default:{e.skipType(c&7);break}}}return o})),t),r.encode=e=>$e(e,r.codec()),r.decode=(e,n)=>ze(e,r.codec(),n)})(Zt||(Zt={}));var uo;(function(r){let t;r.codec=()=>(t==null&&(t=Ge((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),at.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{let o={},i=n==null?e.len:e.pos+n;for(;e.pos<i;){let c=e.uint32();switch(c>>>3){case 1:{o.Type=at.codec().decode(e);break}case 2:{o.Data=e.bytes();break}default:{e.skipType(c&7);break}}}return o})),t),r.encode=e=>$e(e,r.codec()),r.decode=(e,n)=>ze(e,r.codec(),n)})(uo||(uo={}));var Ar={};mt(Ar,{MAX_RSA_KEY_SIZE:()=>Gn,generateRSAKeyPair:()=>ra,jwkToJWKKeyPair:()=>na,jwkToPkcs1:()=>Pf,jwkToPkix:()=>Eo,jwkToRSAPrivateKey:()=>ea,pkcs1ToJwk:()=>Xc,pkcs1ToRSAPrivateKey:()=>ta,pkixToJwk:()=>Qc,pkixToRSAPublicKey:()=>Ao});function Bf(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function fo(r,...t){if(!Bf(r))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(r.length))throw new Error("Uint8Array expected of length "+t+", got length="+r.length)}function ho(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function nc(r,t){fo(r);let e=t.outputLen;if(r.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}var Qr=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),Rt=(r,t)=>r<<32-t|r>>>t;function Ef(r){if(typeof r!="string")throw new Error("utf8ToBytes expected string, got "+typeof r);return new Uint8Array(new TextEncoder().encode(r))}function po(r){return typeof r=="string"&&(r=Ef(r)),fo(r),r}var Xr=class{clone(){return this._cloneInto()}};function sc(r){let t=n=>r().update(po(n)).digest(),e=r();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>r(),t}function Af(r,t,e,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(t,e,n);let s=BigInt(32),o=BigInt(4294967295),i=Number(e>>s&o),c=Number(e&o),a=n?4:0,f=n?0:4;r.setUint32(t+a,i,n),r.setUint32(t+f,c,n)}var oc=(r,t,e)=>r&t^~r&e,ic=(r,t,e)=>r&t^r&e^t&e,tn=class extends Xr{constructor(t,e,n,s){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=Qr(this.buffer)}update(t){ho(this);let{view:e,buffer:n,blockLen:s}=this;t=po(t);let o=t.length;for(let i=0;i<o;){let c=Math.min(s-this.pos,o-i);if(c===s){let a=Qr(t);for(;s<=o-i;i+=s)this.process(a,i);continue}n.set(t.subarray(i,i+c),this.pos),this.pos+=c,i+=c,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){ho(this),nc(t,this),this.finished=!0;let{buffer:e,view:n,blockLen:s,isLE:o}=this,{pos:i}=this;e[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>s-i&&(this.process(n,0),i=0);for(let u=i;u<s;u++)e[u]=0;Af(n,s-8,BigInt(this.length*8),o),this.process(n,0);let c=Qr(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let f=a/4,l=this.get();if(f>l.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<f;u++)c.setUint32(4*u,l[u],o)}digest(){let{buffer:t,outputLen:e}=this;this.digestInto(t);let n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:e,buffer:n,length:s,finished:o,destroyed:i,pos:c}=this;return t.length=s,t.pos=c,t.finished=o,t.destroyed=i,s%e&&t.buffer.set(n),t}};var Sf=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),he=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),de=new Uint32Array(64),go=class extends tn{constructor(){super(64,32,8,!1),this.A=he[0]|0,this.B=he[1]|0,this.C=he[2]|0,this.D=he[3]|0,this.E=he[4]|0,this.F=he[5]|0,this.G=he[6]|0,this.H=he[7]|0}get(){let{A:t,B:e,C:n,D:s,E:o,F:i,G:c,H:a}=this;return[t,e,n,s,o,i,c,a]}set(t,e,n,s,o,i,c,a){this.A=t|0,this.B=e|0,this.C=n|0,this.D=s|0,this.E=o|0,this.F=i|0,this.G=c|0,this.H=a|0}process(t,e){for(let u=0;u<16;u++,e+=4)de[u]=t.getUint32(e,!1);for(let u=16;u<64;u++){let h=de[u-15],x=de[u-2],y=Rt(h,7)^Rt(h,18)^h>>>3,b=Rt(x,17)^Rt(x,19)^x>>>10;de[u]=b+de[u-7]+y+de[u-16]|0}let{A:n,B:s,C:o,D:i,E:c,F:a,G:f,H:l}=this;for(let u=0;u<64;u++){let h=Rt(c,6)^Rt(c,11)^Rt(c,25),x=l+h+oc(c,a,f)+Sf[u]+de[u]|0,b=(Rt(n,2)^Rt(n,13)^Rt(n,22))+ic(n,s,o)|0;l=f,f=a,a=c,c=i+x|0,i=o,o=s,s=n,n=x+b|0}n=n+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,c=c+this.E|0,a=a+this.F|0,f=f+this.G|0,l=l+this.H|0,this.set(n,s,o,i,c,a,f,l)}roundClean(){de.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var en=sc(()=>new go);var D=Ja(cc());function Ce(r,t){let e=0;if(r.length===1)return r[0];for(let n=r.length-1;n>=0;n--)e+=r[r.length-1-n]*Math.pow(2,t*n);return e}function pe(r,t,e=-1){let n=e,s=r,o=0,i=Math.pow(2,t);for(let c=1;c<8;c++){if(r<i){let a;if(n<0)a=new ArrayBuffer(c),o=c;else{if(n<c)return new ArrayBuffer(0);a=new ArrayBuffer(n),o=n}let f=new Uint8Array(a);for(let l=c-1;l>=0;l--){let u=Math.pow(2,l*t);f[o-l-1]=Math.floor(s/u),s-=f[o-l-1]*u}return a}i*=Math.pow(2,t)}return new ArrayBuffer(0)}function sn(...r){let t=0,e=0;for(let o of r)t+=o.length;let n=new ArrayBuffer(t),s=new Uint8Array(n);for(let o of r)s.set(o,e),e+=o.length;return s}function xo(){let r=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){let c=r[0]===255&&r[1]&128,a=r[0]===0&&(r[1]&128)===0;(c||a)&&this.warnings.push("Needlessly long format")}let t=new ArrayBuffer(this.valueHex.byteLength),e=new Uint8Array(t);for(let c=0;c<this.valueHex.byteLength;c++)e[c]=0;e[0]=r[0]&128;let n=Ce(e,8),s=new ArrayBuffer(this.valueHex.byteLength),o=new Uint8Array(s);for(let c=0;c<this.valueHex.byteLength;c++)o[c]=r[c];return o[0]&=127,Ce(o,8)-n}function ac(r){let t=r<0?r*-1:r,e=128;for(let n=1;n<8;n++){if(t<=e){if(r<0){let i=e-t,c=pe(i,8,n),a=new Uint8Array(c);return a[0]|=128,c}let s=pe(t,8,n),o=new Uint8Array(s);if(o[0]&128){let i=s.slice(0),c=new Uint8Array(i);s=new ArrayBuffer(s.byteLength+1),o=new Uint8Array(s);for(let a=0;a<i.byteLength;a++)o[a+1]=c[a];o[0]=0}return s}e*=Math.pow(2,8)}return new ArrayBuffer(0)}function lc(r,t){if(r.byteLength!==t.byteLength)return!1;let e=new Uint8Array(r),n=new Uint8Array(t);for(let s=0;s<e.length;s++)if(e[s]!==n[s])return!1;return!0}function Et(r,t){let e=r.toString(10);if(t<e.length)return"";let n=t-e.length,s=new Array(n);for(let i=0;i<n;i++)s[i]="0";return s.join("").concat(e)}var ep=Math.log(2);function on(){if(typeof BigInt>"u")throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function bo(r){let t=0,e=0;for(let s=0;s<r.length;s++){let o=r[s];t+=o.byteLength}let n=new Uint8Array(t);for(let s=0;s<r.length;s++){let o=r[s];n.set(new Uint8Array(o),e),e+=o.byteLength}return n.buffer}function Qt(r,t,e,n){return t instanceof Uint8Array?t.byteLength?e<0?(r.error="Wrong parameter: inputOffset less than zero",!1):n<0?(r.error="Wrong parameter: inputLength less than zero",!1):t.byteLength-e-n<0?(r.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):!0:(r.error="Wrong parameter: inputBuffer has zero length",!1):(r.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}var mr=class{constructor(){this.items=[]}write(t){this.items.push(t)}final(){return bo(this.items)}},gr=[new Uint8Array([1])],uc="0123456789";var Xe="",Vt=new ArrayBuffer(0),yo=new Uint8Array(0),xr="EndOfContent",hc="OCTET STRING",dc="BIT STRING";function te(r){var t;return t=class extends r{constructor(...n){var s;super(...n);let o=n[0]||{};this.isHexOnly=(s=o.isHexOnly)!==null&&s!==void 0?s:!1,this.valueHexView=o.valueHex?D.BufferSourceConverter.toUint8Array(o.valueHex):yo}get valueHex(){return this.valueHexView.slice().buffer}set valueHex(n){this.valueHexView=new Uint8Array(n)}fromBER(n,s,o){let i=n instanceof ArrayBuffer?new Uint8Array(n):n;if(!Qt(this,i,s,o))return-1;let c=s+o;return this.valueHexView=i.subarray(s,c),this.valueHexView.length?(this.blockLength=o,c):(this.warnings.push("Zero buffer length"),s)}toBER(n=!1){return this.isHexOnly?n?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",Vt)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:D.Convert.ToHex(this.valueHexView)}}},t.NAME="hexBlock",t}var Jt=class{constructor({blockLength:t=0,error:e=Xe,warnings:n=[],valueBeforeDecode:s=yo}={}){this.blockLength=t,this.error=e,this.warnings=n,this.valueBeforeDecodeView=D.BufferSourceConverter.toUint8Array(s)}static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(t){this.valueBeforeDecodeView=new Uint8Array(t)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:D.Convert.ToHex(this.valueBeforeDecodeView)}}};Jt.NAME="baseBlock";var pt=class extends Jt{fromBER(t,e,n){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(t,e){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}};pt.NAME="valueBlock";var cn=class extends te(Jt){constructor({idBlock:t={}}={}){var e,n,s,o;super(),t?(this.isHexOnly=(e=t.isHexOnly)!==null&&e!==void 0?e:!1,this.valueHexView=t.valueHex?D.BufferSourceConverter.toUint8Array(t.valueHex):yo,this.tagClass=(n=t.tagClass)!==null&&n!==void 0?n:-1,this.tagNumber=(s=t.tagNumber)!==null&&s!==void 0?s:-1,this.isConstructed=(o=t.isConstructed)!==null&&o!==void 0?o:!1):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(t=!1){let e=0;switch(this.tagClass){case 1:e|=0;break;case 2:e|=64;break;case 3:e|=128;break;case 4:e|=192;break;default:return this.error="Unknown tag class",Vt}if(this.isConstructed&&(e|=32),this.tagNumber<31&&!this.isHexOnly){let s=new Uint8Array(1);if(!t){let o=this.tagNumber;o&=31,e|=o,s[0]=e}return s.buffer}if(!this.isHexOnly){let s=pe(this.tagNumber,7),o=new Uint8Array(s),i=s.byteLength,c=new Uint8Array(i+1);if(c[0]=e|31,!t){for(let a=0;a<i-1;a++)c[a+1]=o[a]|128;c[i]=o[i-1]}return c.buffer}let n=new Uint8Array(this.valueHexView.byteLength+1);if(n[0]=e|31,!t){let s=this.valueHexView;for(let o=0;o<s.length-1;o++)n[o+1]=s[o]|128;n[this.valueHexView.byteLength]=s[s.length-1]}return n.buffer}fromBER(t,e,n){let s=D.BufferSourceConverter.toUint8Array(t);if(!Qt(this,s,e,n))return-1;let o=s.subarray(e,e+n);if(o.length===0)return this.error="Zero buffer length",-1;switch(o[0]&192){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=(o[0]&32)===32,this.isHexOnly=!1;let c=o[0]&31;if(c!==31)this.tagNumber=c,this.blockLength=1;else{let a=1,f=this.valueHexView=new Uint8Array(255),l=255;for(;o[a]&128;){if(f[a-1]=o[a]&127,a++,a>=o.length)return this.error="End of input reached before message was fully decoded",-1;if(a===l){l+=255;let h=new Uint8Array(l);for(let x=0;x<f.length;x++)h[x]=f[x];f=this.valueHexView=new Uint8Array(l)}}this.blockLength=a+1,f[a-1]=o[a]&127;let u=new Uint8Array(a);for(let h=0;h<a;h++)u[h]=f[h];f=this.valueHexView=new Uint8Array(a),f.set(u),this.blockLength<=9?this.tagNumber=Ce(f,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(this.tagClass===1&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return e+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}};cn.NAME="identificationBlock";var an=class extends Jt{constructor({lenBlock:t={}}={}){var e,n,s;super(),this.isIndefiniteForm=(e=t.isIndefiniteForm)!==null&&e!==void 0?e:!1,this.longFormUsed=(n=t.longFormUsed)!==null&&n!==void 0?n:!1,this.length=(s=t.length)!==null&&s!==void 0?s:0}fromBER(t,e,n){let s=D.BufferSourceConverter.toUint8Array(t);if(!Qt(this,s,e,n))return-1;let o=s.subarray(e,e+n);if(o.length===0)return this.error="Zero buffer length",-1;if(o[0]===255)return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=o[0]===128,this.isIndefiniteForm)return this.blockLength=1,e+this.blockLength;if(this.longFormUsed=!!(o[0]&128),this.longFormUsed===!1)return this.length=o[0],this.blockLength=1,e+this.blockLength;let i=o[0]&127;if(i>8)return this.error="Too big integer",-1;if(i+1>o.length)return this.error="End of input reached before message was fully decoded",-1;let c=e+1,a=s.subarray(c,c+i);return a[i-1]===0&&this.warnings.push("Needlessly long encoded length"),this.length=Ce(a,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=i+1,e+this.blockLength}toBER(t=!1){let e,n;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return e=new ArrayBuffer(1),t===!1&&(n=new Uint8Array(e),n[0]=128),e;if(this.longFormUsed){let s=pe(this.length,8);if(s.byteLength>127)return this.error="Too big length",Vt;if(e=new ArrayBuffer(s.byteLength+1),t)return e;let o=new Uint8Array(s);n=new Uint8Array(e),n[0]=s.byteLength|128;for(let i=0;i<s.byteLength;i++)n[i+1]=o[i];return e}return e=new ArrayBuffer(1),t===!1&&(n=new Uint8Array(e),n[0]=this.length),e}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}};an.NAME="lengthBlock";var E={},lt=class extends Jt{constructor({name:t=Xe,optional:e=!1,primitiveSchema:n,...s}={},o){super(s),this.name=t,this.optional=e,n&&(this.primitiveSchema=n),this.idBlock=new cn(s),this.lenBlock=new an(s),this.valueBlock=o?new o(s):new pt(s)}fromBER(t,e,n){let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}toBER(t,e){let n=e||new mr;e||pc(this);let s=this.idBlock.toBER(t);if(n.write(s),this.lenBlock.isIndefiniteForm)n.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(t,n),n.write(new ArrayBuffer(2));else{let o=this.valueBlock.toBER(t);this.lenBlock.length=o.byteLength;let i=this.lenBlock.toBER(t);n.write(i),n.write(o)}return e?Vt:n.final()}toJSON(){let t={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(t.primitiveSchema=this.primitiveSchema.toJSON()),t}toString(t="ascii"){return t==="ascii"?this.onAsciiEncoding():D.Convert.ToHex(this.toBER())}onAsciiEncoding(){return`${this.constructor.NAME} : ${D.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`}isEqual(t){if(this===t)return!0;if(!(t instanceof this.constructor))return!1;let e=this.toBER(),n=t.toBER();return lc(e,n)}};lt.NAME="BaseBlock";function pc(r){if(r instanceof E.Constructed)for(let t of r.valueBlock.value)pc(t)&&(r.lenBlock.isIndefiniteForm=!0);return!!r.lenBlock.isIndefiniteForm}var ln=class extends lt{constructor({value:t=Xe,...e}={},n){super(e,n),t&&this.fromString(t)}getValue(){return this.valueBlock.value}setValue(t){this.valueBlock.value=t}fromBER(t,e,n){let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}};ln.NAME="BaseStringBlock";var un=class extends te(pt){constructor({isHexOnly:t=!0,...e}={}){super(e),this.isHexOnly=t}};un.NAME="PrimitiveValueBlock";var gc,fn=class extends lt{constructor(t={}){super(t,un),this.idBlock.isConstructed=!1}};gc=fn;E.Primitive=gc;fn.NAME="PRIMITIVE";function Vf(r,t){if(r instanceof t)return r;let e=new t;return e.idBlock=r.idBlock,e.lenBlock=r.lenBlock,e.warnings=r.warnings,e.valueBeforeDecodeView=r.valueBeforeDecodeView,e}function $n(r,t=0,e=r.length){let n=t,s=new lt({},pt),o=new Jt;if(!Qt(o,r,t,e))return s.error=o.error,{offset:-1,result:s};if(!r.subarray(t,t+e).length)return s.error="Zero buffer length",{offset:-1,result:s};let c=s.idBlock.fromBER(r,t,e);if(s.idBlock.warnings.length&&s.warnings.concat(s.idBlock.warnings),c===-1)return s.error=s.idBlock.error,{offset:-1,result:s};if(t=c,e-=s.idBlock.blockLength,c=s.lenBlock.fromBER(r,t,e),s.lenBlock.warnings.length&&s.warnings.concat(s.lenBlock.warnings),c===-1)return s.error=s.lenBlock.error,{offset:-1,result:s};if(t=c,e-=s.lenBlock.blockLength,!s.idBlock.isConstructed&&s.lenBlock.isIndefiniteForm)return s.error="Indefinite length form used for primitive encoding form",{offset:-1,result:s};let a=lt;switch(s.idBlock.tagClass){case 1:if(s.idBlock.tagNumber>=37&&s.idBlock.isHexOnly===!1)return s.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:s};switch(s.idBlock.tagNumber){case 0:if(s.idBlock.isConstructed&&s.lenBlock.length>0)return s.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:s};a=E.EndOfContent;break;case 1:a=E.Boolean;break;case 2:a=E.Integer;break;case 3:a=E.BitString;break;case 4:a=E.OctetString;break;case 5:a=E.Null;break;case 6:a=E.ObjectIdentifier;break;case 10:a=E.Enumerated;break;case 12:a=E.Utf8String;break;case 13:a=E.RelativeObjectIdentifier;break;case 14:a=E.TIME;break;case 15:return s.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:s};case 16:a=E.Sequence;break;case 17:a=E.Set;break;case 18:a=E.NumericString;break;case 19:a=E.PrintableString;break;case 20:a=E.TeletexString;break;case 21:a=E.VideotexString;break;case 22:a=E.IA5String;break;case 23:a=E.UTCTime;break;case 24:a=E.GeneralizedTime;break;case 25:a=E.GraphicString;break;case 26:a=E.VisibleString;break;case 27:a=E.GeneralString;break;case 28:a=E.UniversalString;break;case 29:a=E.CharacterString;break;case 30:a=E.BmpString;break;case 31:a=E.DATE;break;case 32:a=E.TimeOfDay;break;case 33:a=E.DateTime;break;case 34:a=E.Duration;break;default:{let f=s.idBlock.isConstructed?new E.Constructed:new E.Primitive;f.idBlock=s.idBlock,f.lenBlock=s.lenBlock,f.warnings=s.warnings,s=f}}break;case 2:case 3:case 4:default:a=s.idBlock.isConstructed?E.Constructed:E.Primitive}return s=Vf(s,a),c=s.fromBER(r,t,s.lenBlock.isIndefiniteForm?e:s.lenBlock.length),s.valueBeforeDecodeView=r.subarray(n,n+s.blockLength),{offset:c,result:s}}function wo(r){if(!r.byteLength){let t=new lt({},pt);return t.error="Input buffer has zero length",{offset:-1,result:t}}return $n(D.BufferSourceConverter.toUint8Array(r).slice(),0,r.byteLength)}function Hf(r,t){return r?1:t}var Mt=class extends pt{constructor({value:t=[],isIndefiniteForm:e=!1,...n}={}){super(n),this.value=t,this.isIndefiniteForm=e}fromBER(t,e,n){let s=D.BufferSourceConverter.toUint8Array(t);if(!Qt(this,s,e,n))return-1;if(this.valueBeforeDecodeView=s.subarray(e,e+n),this.valueBeforeDecodeView.length===0)return this.warnings.push("Zero buffer length"),e;let o=e;for(;Hf(this.isIndefiniteForm,n)>0;){let i=$n(s,o,n);if(i.offset===-1)return this.error=i.result.error,this.warnings.concat(i.result.warnings),-1;if(o=i.offset,this.blockLength+=i.result.blockLength,n-=i.result.blockLength,this.value.push(i.result),this.isIndefiniteForm&&i.result.constructor.NAME===xr)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===xr?this.value.pop():this.warnings.push("No EndOfContent block encoded")),o}toBER(t,e){let n=e||new mr;for(let s=0;s<this.value.length;s++)this.value[s].toBER(t,n);return e?Vt:n.final()}toJSON(){let t={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(let e of this.value)t.value.push(e.toJSON());return t}};Mt.NAME="ConstructedValueBlock";var mc,ge=class extends lt{constructor(t={}){super(t,Mt),this.idBlock.isConstructed=!0}fromBER(t,e,n){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;let s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){let t=[];for(let n of this.valueBlock.value)t.push(n.toString("ascii").split(`
./node_modules/@libp2p/circuit-relay-v2/dist/index.min.js:2:"use strict";var Libp2PCircuitRelayV2=(()=>{var Mf=Object.create;var Bn=Object.defineProperty;var Pf=Object.getOwnPropertyDescriptor;var Vf=Object.getOwnPropertyNames;var Hf=Object.getPrototypeOf,Ff=Object.prototype.hasOwnProperty;var Mi=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),ke=(r,e)=>{for(var t in e)Bn(r,t,{get:e[t],enumerable:!0})},sc=(r,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of Vf(e))!Ff.call(r,s)&&s!==t&&Bn(r,s,{get:()=>e[s],enumerable:!(n=Pf(e,s))||n.enumerable});return r};var ic=(r,e,t)=>(t=r!=null?Mf(Hf(r)):{},sc(e||!r||!r.__esModule?Bn(t,"default",{value:r,enumerable:!0}):t,r)),Kf=r=>sc(Bn({},"__esModule",{value:!0}),r);var hl=Mi(Er=>{"use strict";var hp="[object ArrayBuffer]",xt=class r{static isArrayBuffer(e){return Object.prototype.toString.call(e)===hp}static toArrayBuffer(e){return this.isArrayBuffer(e)?e:e.byteLength===e.buffer.byteLength||e.byteOffset===0&&e.byteLength===e.buffer.byteLength?e.buffer:this.toUint8Array(e.buffer).slice(e.byteOffset,e.byteOffset+e.byteLength).buffer}static toUint8Array(e){return this.toView(e,Uint8Array)}static toView(e,t){if(e.constructor===t)return e;if(this.isArrayBuffer(e))return new t(e);if(this.isArrayBufferView(e))return new t(e.buffer,e.byteOffset,e.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(e){return this.isArrayBufferView(e)||this.isArrayBuffer(e)}static isArrayBufferView(e){return ArrayBuffer.isView(e)||e&&this.isArrayBuffer(e.buffer)}static isEqual(e,t){let n=r.toUint8Array(e),s=r.toUint8Array(t);if(n.length!==s.byteLength)return!1;for(let i=0;i<n.length;i++)if(n[i]!==s[i])return!1;return!0}static concat(...e){let t;Array.isArray(e[0])&&!(e[1]instanceof Function)||Array.isArray(e[0])&&e[1]instanceof Function?t=e[0]:e[e.length-1]instanceof Function?t=e.slice(0,e.length-1):t=e;let n=0;for(let o of t)n+=o.byteLength;let s=new Uint8Array(n),i=0;for(let o of t){let a=this.toUint8Array(o);s.set(a,i),i+=a.length}return e[e.length-1]instanceof Function?this.toView(s,e[e.length-1]):s.buffer}},Zo="string",dp=/^[0-9a-f\s]+$/i,pp=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,mp=/^[a-zA-Z0-9-_]+$/,Zn=class{static fromString(e){let t=unescape(encodeURIComponent(e)),n=new Uint8Array(t.length);for(let s=0;s<t.length;s++)n[s]=t.charCodeAt(s);return n.buffer}static toString(e){let t=xt.toUint8Array(e),n="";for(let i=0;i<t.length;i++)n+=String.fromCharCode(t[i]);return decodeURIComponent(escape(n))}},Ge=class{static toString(e,t=!1){let n=xt.toArrayBuffer(e),s=new DataView(n),i="";for(let o=0;o<n.byteLength;o+=2){let a=s.getUint16(o,t);i+=String.fromCharCode(a)}return i}static fromString(e,t=!1){let n=new ArrayBuffer(e.length*2),s=new DataView(n);for(let i=0;i<e.length;i++)s.setUint16(i*2,e.charCodeAt(i),t);return n}},jn=class r{static isHex(e){return typeof e===Zo&&dp.test(e)}static isBase64(e){return typeof e===Zo&&pp.test(e)}static isBase64Url(e){return typeof e===Zo&&mp.test(e)}static ToString(e,t="utf8"){let n=xt.toUint8Array(e);switch(t.toLowerCase()){case"utf8":return this.ToUtf8String(n);case"binary":return this.ToBinary(n);case"hex":return this.ToHex(n);case"base64":return this.ToBase64(n);case"base64url":return this.ToBase64Url(n);case"utf16le":return Ge.toString(n,!0);case"utf16":case"utf16be":return Ge.toString(n);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromString(e,t="utf8"){if(!e)return new ArrayBuffer(0);switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(e);case"binary":return this.FromBinary(e);case"hex":return this.FromHex(e);case"base64":return this.FromBase64(e);case"base64url":return this.FromBase64Url(e);case"utf16le":return Ge.fromString(e,!0);case"utf16":case"utf16be":return Ge.fromString(e);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(e){let t=xt.toUint8Array(e);if(typeof btoa<"u"){let n=this.ToString(t,"binary");return btoa(n)}else return Buffer.from(t).toString("base64")}static FromBase64(e){let t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!r.isBase64(t))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return typeof atob<"u"?this.FromBinary(atob(t)):new Uint8Array(Buffer.from(t,"base64")).buffer}static FromBase64Url(e){let t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!r.isBase64Url(t))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(t.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(e){return this.ToBase64(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(e,t=r.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.FromBinary(e);case"utf8":return Zn.fromString(e);case"utf16":case"utf16be":return Ge.fromString(e);case"utf16le":case"usc2":return Ge.fromString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToUtf8String(e,t=r.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.ToBinary(e);case"utf8":return Zn.toString(e);case"utf16":case"utf16be":return Ge.toString(e);case"utf16le":case"usc2":return Ge.toString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromBinary(e){let t=e.length,n=new Uint8Array(t);for(let s=0;s<t;s++)n[s]=e.charCodeAt(s);return n.buffer}static ToBinary(e){let t=xt.toUint8Array(e),n="";for(let s=0;s<t.length;s++)n+=String.fromCharCode(t[s]);return n}static ToHex(e){let t=xt.toUint8Array(e),n="",s=t.length;for(let i=0;i<s;i++){let o=t[i];o<16&&(n+="0"),n+=o.toString(16)}return n}static FromHex(e){let t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!r.isHex(t))throw new TypeError("Argument 'hexString' is not HEX encoded");t.length%2&&(t=`0${t}`);let n=new Uint8Array(t.length/2);for(let s=0;s<t.length;s=s+2){let i=t.slice(s,s+2);n[s/2]=parseInt(i,16)}return n.buffer}static ToUtf16String(e,t=!1){return Ge.toString(e,t)}static FromUtf16String(e,t=!1){return Ge.fromString(e,t)}static Base64Padding(e){let t=4-e.length%4;if(t<4)for(let n=0;n<t;n++)e+="=";return e}static formatString(e){return e?.replace(/[\n\r\t ]/g,"")||""}};jn.DEFAULT_UTF8_ENCODING="utf8";function gp(r,...e){let t=arguments[0];for(let n=1;n<arguments.length;n++){let s=arguments[n];for(let i in s)t[i]=s[i]}return t}function yp(...r){let e=r.map(s=>s.byteLength).reduce((s,i)=>s+i),t=new Uint8Array(e),n=0;return r.map(s=>new Uint8Array(s)).forEach(s=>{for(let i of s)t[n++]=i}),t.buffer}function bp(r,e){if(!(r&&e)||r.byteLength!==e.byteLength)return!1;let t=new Uint8Array(r),n=new Uint8Array(e);for(let s=0;s<r.byteLength;s++)if(t[s]!==n[s])return!1;return!0}Er.BufferSourceConverter=xt;Er.Convert=jn;Er.assign=gp;Er.combine=yp;Er.isEqual=bp});var cf=Mi((En,Ei)=>{(function(r,e){"use strict";var t={version:"3.0.0",x86:{},x64:{},inputValidation:!0};function n(l){if(!Array.isArray(l)&&!ArrayBuffer.isView(l))return!1;for(var d=0;d<l.length;d++)if(!Number.isInteger(l[d])||l[d]<0||l[d]>255)return!1;return!0}function s(l,d){return(l&65535)*d+(((l>>>16)*d&65535)<<16)}function i(l,d){return l<<d|l>>>32-d}function o(l){return l^=l>>>16,l=s(l,2246822507),l^=l>>>13,l=s(l,3266489909),l^=l>>>16,l}function a(l,d){l=[l[0]>>>16,l[0]&65535,l[1]>>>16,l[1]&65535],d=[d[0]>>>16,d[0]&65535,d[1]>>>16,d[1]&65535];var m=[0,0,0,0];return m[3]+=l[3]+d[3],m[2]+=m[3]>>>16,m[3]&=65535,m[2]+=l[2]+d[2],m[1]+=m[2]>>>16,m[2]&=65535,m[1]+=l[1]+d[1],m[0]+=m[1]>>>16,m[1]&=65535,m[0]+=l[0]+d[0],m[0]&=65535,[m[0]<<16|m[1],m[2]<<16|m[3]]}function c(l,d){l=[l[0]>>>16,l[0]&65535,l[1]>>>16,l[1]&65535],d=[d[0]>>>16,d[0]&65535,d[1]>>>16,d[1]&65535];var m=[0,0,0,0];return m[3]+=l[3]*d[3],m[2]+=m[3]>>>16,m[3]&=65535,m[2]+=l[2]*d[3],m[1]+=m[2]>>>16,m[2]&=65535,m[2]+=l[3]*d[2],m[1]+=m[2]>>>16,m[2]&=65535,m[1]+=l[1]*d[3],m[0]+=m[1]>>>16,m[1]&=65535,m[1]+=l[2]*d[2],m[0]+=m[1]>>>16,m[1]&=65535,m[1]+=l[3]*d[1],m[0]+=m[1]>>>16,m[1]&=65535,m[0]+=l[0]*d[3]+l[1]*d[2]+l[2]*d[1]+l[3]*d[0],m[0]&=65535,[m[0]<<16|m[1],m[2]<<16|m[3]]}function h(l,d){return d%=64,d===32?[l[1],l[0]]:d<32?[l[0]<<d|l[1]>>>32-d,l[1]<<d|l[0]>>>32-d]:(d-=32,[l[1]<<d|l[0]>>>32-d,l[0]<<d|l[1]>>>32-d])}function f(l,d){return d%=64,d===0?l:d<32?[l[0]<<d|l[1]>>>32-d,l[1]<<d]:[l[1]<<d-32,0]}function u(l,d){return[l[0]^d[0],l[1]^d[1]]}function g(l){return l=u(l,[0,l[0]>>>1]),l=c(l,[4283543511,3981806797]),l=u(l,[0,l[0]>>>1]),l=c(l,[3301882366,444984403]),l=u(l,[0,l[0]>>>1]),l}t.x86.hash32=function(l,d){if(t.inputValidation&&!n(l))return e;d=d||0;for(var m=l.length%4,y=l.length-m,b=d,w=0,p=3432918353,E=461845907,A=0;A<y;A=A+4)w=l[A]|l[A+1]<<8|l[A+2]<<16|l[A+3]<<24,w=s(w,p),w=i(w,15),w=s(w,E),b^=w,b=i(b,13),b=s(b,5)+3864292196;switch(w=0,m){case 3:w^=l[A+2]<<16;case 2:w^=l[A+1]<<8;case 1:w^=l[A],w=s(w,p),w=i(w,15),w=s(w,E),b^=w}return b^=l.length,b=o(b),b>>>0},t.x86.hash128=function(l,d){if(t.inputValidation&&!n(l))return e;d=d||0;for(var m=l.length%16,y=l.length-m,b=d,w=d,p=d,E=d,A=0,_=0,x=0,I=0,C=597399067,j=2869860233,V=951274213,P=2716044179,L=0;L<y;L=L+16)A=l[L]|l[L+1]<<8|l[L+2]<<16|l[L+3]<<24,_=l[L+4]|l[L+5]<<8|l[L+6]<<16|l[L+7]<<24,x=l[L+8]|l[L+9]<<8|l[L+10]<<16|l[L+11]<<24,I=l[L+12]|l[L+13]<<8|l[L+14]<<16|l[L+15]<<24,A=s(A,C),A=i(A,15),A=s(A,j),b^=A,b=i(b,19),b+=w,b=s(b,5)+1444728091,_=s(_,j),_=i(_,16),_=s(_,V),w^=_,w=i(w,17),w+=p,w=s(w,5)+197830471,x=s(x,V),x=i(x,17),x=s(x,P),p^=x,p=i(p,15),p+=E,p=s(p,5)+2530024501,I=s(I,P),I=i(I,18),I=s(I,C),E^=I,E=i(E,13),E+=b,E=s(E,5)+850148119;switch(A=0,_=0,x=0,I=0,m){case 15:I^=l[L+14]<<16;case 14:I^=l[L+13]<<8;case 13:I^=l[L+12],I=s(I,P),I=i(I,18),I=s(I,C),E^=I;case 12:x^=l[L+11]<<24;case 11:x^=l[L+10]<<16;case 10:x^=l[L+9]<<8;case 9:x^=l[L+8],x=s(x,V),x=i(x,17),x=s(x,P),p^=x;case 8:_^=l[L+7]<<24;case 7:_^=l[L+6]<<16;case 6:_^=l[L+5]<<8;case 5:_^=l[L+4],_=s(_,j),_=i(_,16),_=s(_,V),w^=_;case 4:A^=l[L+3]<<24;case 3:A^=l[L+2]<<16;case 2:A^=l[L+1]<<8;case 1:A^=l[L],A=s(A,C),A=i(A,15),A=s(A,j),b^=A}return b^=l.length,w^=l.length,p^=l.length,E^=l.length,b+=w,b+=p,b+=E,w+=b,p+=b,E+=b,b=o(b),w=o(w),p=o(p),E=o(E),b+=w,b+=p,b+=E,w+=b,p+=b,E+=b,("00000000"+(b>>>0).toString(16)).slice(-8)+("00000000"+(w>>>0).toString(16)).slice(-8)+("00000000"+(p>>>0).toString(16)).slice(-8)+("00000000"+(E>>>0).toString(16)).slice(-8)},t.x64.hash128=function(l,d){if(t.inputValidation&&!n(l))return e;d=d||0;for(var m=l.length%16,y=l.length-m,b=[0,d],w=[0,d],p=[0,0],E=[0,0],A=[2277735313,289559509],_=[1291169091,658871167],x=0;x<y;x=x+16)p=[l[x+4]|l[x+5]<<8|l[x+6]<<16|l[x+7]<<24,l[x]|l[x+1]<<8|l[x+2]<<16|l[x+3]<<24],E=[l[x+12]|l[x+13]<<8|l[x+14]<<16|l[x+15]<<24,l[x+8]|l[x+9]<<8|l[x+10]<<16|l[x+11]<<24],p=c(p,A),p=h(p,31),p=c(p,_),b=u(b,p),b=h(b,27),b=a(b,w),b=a(c(b,[0,5]),[0,1390208809]),E=c(E,_),E=h(E,33),E=c(E,A),w=u(w,E),w=h(w,31),w=a(w,b),w=a(c(w,[0,5]),[0,944331445]);switch(p=[0,0],E=[0,0],m){case 15:E=u(E,f([0,l[x+14]],48));case 14:E=u(E,f([0,l[x+13]],40));case 13:E=u(E,f([0,l[x+12]],32));case 12:E=u(E,f([0,l[x+11]],24));case 11:E=u(E,f([0,l[x+10]],16));case 10:E=u(E,f([0,l[x+9]],8));case 9:E=u(E,[0,l[x+8]]),E=c(E,_),E=h(E,33),E=c(E,A),w=u(w,E);case 8:p=u(p,f([0,l[x+7]],56));case 7:p=u(p,f([0,l[x+6]],48));case 6:p=u(p,f([0,l[x+5]],40));case 5:p=u(p,f([0,l[x+4]],32));case 4:p=u(p,f([0,l[x+3]],24));case 3:p=u(p,f([0,l[x+2]],16));case 2:p=u(p,f([0,l[x+1]],8));case 1:p=u(p,[0,l[x]]),p=c(p,A),p=h(p,31),p=c(p,_),b=u(b,p)}return b=u(b,[0,l.length]),w=u(w,[0,l.length]),b=a(b,w),w=a(w,b),b=g(b),w=g(w),b=a(b,w),w=a(w,b),("00000000"+(b[0]>>>0).toString(16)).slice(-8)+("00000000"+(b[1]>>>0).toString(16)).slice(-8)+("00000000"+(w[0]>>>0).toString(16)).slice(-8)+("00000000"+(w[1]>>>0).toString(16)).slice(-8)},typeof En<"u"?(typeof Ei<"u"&&Ei.exports&&(En=Ei.exports=t),En.murmurHash3=t):typeof define=="function"&&define.amd?define([],function(){return t}):(t._murmurHash3=r.murmurHash3,t.noConflict=function(){return r.murmurHash3=t._murmurHash3,t._murmurHash3=e,t.noConflict=e,t},r.murmurHash3=t)})(En)});var uf=Mi((wv,lf)=>{lf.exports=cf()});var L0={};ke(L0,{RELAY_V2_HOP_CODEC:()=>We,RELAY_V2_STOP_CODEC:()=>sr,circuitRelayServer:()=>gf,circuitRelayTransport:()=>Tf});var Pi=Symbol.for("@libp2p/peer-id");var Vi="keep-alive";var ac=Symbol.for("@libp2p/transport");var oc;(function(r){r[r.FATAL_ALL=0]="FATAL_ALL",r[r.NO_FATAL=1]="NO_FATAL"})(oc||(oc={}));var ft=class extends Error{static name="AbortError";constructor(e="The operation was aborted"){super(e),this.name="AbortError"}};var ve=class extends Error{static name="InvalidParametersError";constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},cr=class extends Error{static name="InvalidPublicKeyError";constructor(e="Invalid public key"){super(e),this.name="InvalidPublicKeyError"}};var _n=class extends Error{static name="InvalidMultihashError";constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}};var In=class extends Error{static name="InvalidMessageError";constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}};var Vr=class extends Error{static name="DialError";constructor(e="Dial error"){super(e),this.name="DialError"}},Gt=class extends Error{static name="ListenError";constructor(e="Listen error"){super(e),this.name="ListenError"}};var lr=class extends Error{static name="UnsupportedKeyTypeError";constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}};var Re=(r,...e)=>{try{[...e]}catch{}};var qe=class extends EventTarget{#e=new Map;constructor(){super(),Re(1/0,this)}listenerCount(e){let t=this.#e.get(e);return t==null?0:t.length}addEventListener(e,t,n){super.addEventListener(e,t,n);let s=this.#e.get(e);s==null&&(s=[],this.#e.set(e,s)),s.push({callback:t,once:(n!==!0&&n!==!1&&n?.once)??!1})}removeEventListener(e,t,n){super.removeEventListener(e.toString(),t??null,n);let s=this.#e.get(e);s!=null&&(s=s.filter(({callback:i})=>i!==t),this.#e.set(e,s))}dispatchEvent(e){let t=super.dispatchEvent(e),n=this.#e.get(e.type);return n==null||(n=n.filter(({once:s})=>!s),this.#e.set(e.type,n)),t}safeDispatchEvent(e,t={}){return this.dispatchEvent(new CustomEvent(e,t))}};function cc(r){return r!=null&&typeof r.start=="function"&&typeof r.stop=="function"}async function lc(...r){let e=[];for(let t of r)cc(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStart!=null&&await t.beforeStart()})),await Promise.all(e.map(async t=>{await t.start()})),await Promise.all(e.map(async t=>{t.afterStart!=null&&await t.afterStart()}))}async function uc(...r){let e=[];for(let t of r)cc(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStop!=null&&await t.beforeStop()})),await Promise.all(e.map(async t=>{await t.stop()})),await Promise.all(e.map(async t=>{t.afterStop!=null&&await t.afterStop()}))}var fc=Symbol.for("@libp2p/service-capabilities"),hc=Symbol.for("@libp2p/service-dependencies");var zi={};ke(zi,{base58btc:()=>ee,base58flickr:()=>Zf});var hm=new Uint8Array(0);function dc(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function ht(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function pc(r){return new TextEncoder().encode(r)}function mc(r){return new TextDecoder().decode(r)}function qf(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),n=0;n<t.length;n++)t[n]=255;for(var s=0;s<r.length;s++){var i=r.charAt(s),o=i.charCodeAt(0);if(t[o]!==255)throw new TypeError(i+" is ambiguous");t[o]=s}var a=r.length,c=r.charAt(0),h=Math.log(a)/Math.log(256),f=Math.log(256)/Math.log(a);function u(d){if(d instanceof Uint8Array||(ArrayBuffer.isView(d)?d=new Uint8Array(d.buffer,d.byteOffset,d.byteLength):Array.isArray(d)&&(d=Uint8Array.from(d))),!(d instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(d.length===0)return"";for(var m=0,y=0,b=0,w=d.length;b!==w&&d[b]===0;)b++,m++;for(var p=(w-b)*f+1>>>0,E=new Uint8Array(p);b!==w;){for(var A=d[b],_=0,x=p-1;(A!==0||_<y)&&x!==-1;x--,_++)A+=256*E[x]>>>0,E[x]=A%a>>>0,A=A/a>>>0;if(A!==0)throw new Error("Non-zero carry");y=_,b++}for(var I=p-y;I!==p&&E[I]===0;)I++;for(var C=c.repeat(m);I<p;++I)C+=r.charAt(E[I]);return C}function g(d){if(typeof d!="string")throw new TypeError("Expected String");if(d.length===0)return new Uint8Array;var m=0;if(d[m]!==" "){for(var y=0,b=0;d[m]===c;)y++,m++;for(var w=(d.length-m)*h+1>>>0,p=new Uint8Array(w);d[m];){var E=t[d.charCodeAt(m)];if(E===255)return;for(var A=0,_=w-1;(E!==0||A<b)&&_!==-1;_--,A++)E+=a*p[_]>>>0,p[_]=E%256>>>0,E=E/256>>>0;if(E!==0)throw new Error("Non-zero carry");b=A,m++}if(d[m]!==" "){for(var x=w-b;x!==w&&p[x]===0;)x++;for(var I=new Uint8Array(y+(w-x)),C=y;x!==w;)I[C++]=p[x++];return I}}}function l(d){var m=g(d);if(m)return m;throw new Error(`Non-${e} character`)}return{encode:u,decodeUnsafe:g,decode:l}}var zf=qf,$f=zf,yc=$f;var Hi=class{name;prefix;baseEncode;constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},Fi=class{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,n){this.name=e,this.prefix=t;let s=t.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return bc(this,e)}},Ki=class{decoders;constructor(e){this.decoders=e}or(e){return bc(this,e)}decode(e){let t=e[0],n=this.decoders[t];if(n!=null)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};function bc(r,e){return new Ki({...r.decoders??{[r.prefix]:r},...e.decoders??{[e.prefix]:e}})}var qi=class{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,n,s){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=s,this.encoder=new Hi(e,t,n),this.decoder=new Fi(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}};function ur({name:r,prefix:e,encode:t,decode:n}){return new qi(r,e,t,n)}function kt({name:r,prefix:e,alphabet:t}){let{encode:n,decode:s}=yc(t,r);return ur({prefix:e,name:r,encode:n,decode:i=>ht(s(i))})}function Gf(r,e,t,n){let s={};for(let f=0;f<e.length;++f)s[e[f]]=f;let i=r.length;for(;r[i-1]==="=";)--i;let o=new Uint8Array(i*t/8|0),a=0,c=0,h=0;for(let f=0;f<i;++f){let u=s[r[f]];if(u===void 0)throw new SyntaxError(`Non-${n} character`);c=c<<t|u,a+=t,a>=8&&(a-=8,o[h++]=255&c>>a)}if(a>=t||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return o}function Wf(r,e,t){let n=e[e.length-1]==="=",s=(1<<t)-1,i="",o=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],o+=8;o>t;)o-=t,i+=e[s&a>>o];if(o!==0&&(i+=e[s&a<<t-o]),n)for(;i.length*t&7;)i+="=";return i}function le({name:r,prefix:e,bitsPerChar:t,alphabet:n}){return ur({prefix:e,name:r,encode(s){return Wf(s,n,t)},decode(s){return Gf(s,n,t,r)}})}var ee=kt({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Zf=kt({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var $i={};ke($i,{base32:()=>dt,base32hex:()=>Jf,base32hexpad:()=>eh,base32hexpadupper:()=>th,base32hexupper:()=>Qf,base32pad:()=>Yf,base32padupper:()=>Xf,base32upper:()=>jf,base32z:()=>rh});var dt=le({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),jf=le({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Yf=le({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Xf=le({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Jf=le({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Qf=le({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),eh=le({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),th=le({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),rh=le({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var Gi={};ke(Gi,{base36:()=>Hr,base36upper:()=>nh});var Hr=kt({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),nh=kt({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var sh=vc,wc=128,ih=127,oh=~ih,ah=Math.pow(2,31);function vc(r,e,t){e=e||[],t=t||0;for(var n=t;r>=ah;)e[t++]=r&255|wc,r/=128;for(;r&oh;)e[t++]=r&255|wc,r>>>=7;return e[t]=r|0,vc.bytes=t-n+1,e}var ch=Wi,lh=128,xc=127;function Wi(r,n){var t=0,n=n||0,s=0,i=n,o,a=r.length;do{if(i>=a)throw Wi.bytes=0,new RangeError("Could not decode varint");o=r[i++],t+=s<28?(o&xc)<<s:(o&xc)*Math.pow(2,s),s+=7}while(o>=lh);return Wi.bytes=i-n,t}var uh=Math.pow(2,7),fh=Math.pow(2,14),hh=Math.pow(2,21),dh=Math.pow(2,28),ph=Math.pow(2,35),mh=Math.pow(2,42),gh=Math.pow(2,49),yh=Math.pow(2,56),bh=Math.pow(2,63),wh=function(r){return r<uh?1:r<fh?2:r<hh?3:r<dh?4:r<ph?5:r<mh?6:r<gh?7:r<yh?8:r<bh?9:10},xh={encode:sh,decode:ch,encodingLength:wh},vh=xh,Fr=vh;function Kr(r,e=0){return[Fr.decode(r,e),Fr.decode.bytes]}function fr(r,e,t=0){return Fr.encode(r,e,t),e}function hr(r){return Fr.encodingLength(r)}function Ze(r,e){let t=e.byteLength,n=hr(r),s=n+hr(t),i=new Uint8Array(s+t);return fr(r,i,0),fr(t,i,n),i.set(e,s),new dr(r,t,e,i)}function ze(r){let e=ht(r),[t,n]=Kr(e),[s,i]=Kr(e.subarray(n)),o=e.subarray(n+i);if(o.byteLength!==s)throw new Error("Incorrect length");return new dr(t,s,o,e)}function Ec(r,e){if(r===e)return!0;{let t=e;return r.code===t.code&&r.size===t.size&&t.bytes instanceof Uint8Array&&dc(r.bytes,t.bytes)}}var dr=class{code;size;digest;bytes;constructor(e,t,n,s){this.code=e,this.size=t,this.digest=n,this.bytes=s}};function Sc(r,e){let{bytes:t,version:n}=r;switch(n){case 0:return Sh(t,Zi(r),e??ee.encoder);default:return Ah(t,Zi(r),e??dt.encoder)}}var Ac=new WeakMap;function Zi(r){let e=Ac.get(r);if(e==null){let t=new Map;return Ac.set(r,t),t}return e}var pe=class r{code;version;multihash;bytes;"/";constructor(e,t,n,s){this.code=t,this.version=e,this.multihash=n,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{let{code:e,multihash:t}=this;if(e!==qr)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==Bh)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return r.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{let{code:e,digest:t}=this.multihash,n=Ze(e,t);return r.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return r.equals(this,e)}static equals(e,t){let n=t;return n!=null&&e.code===n.code&&e.version===n.version&&Ec(e.multihash,n.multihash)}toString(e){return Sc(this,e)}toJSON(){return{"/":Sc(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;let t=e;if(t instanceof r)return t;if(t["/"]!=null&&t["/"]===t.bytes||t.asCID===t){let{version:n,code:s,multihash:i,bytes:o}=t;return new r(n,s,i,o??Bc(n,s,i.bytes))}else if(t[_h]===!0){let{version:n,multihash:s,code:i}=t,o=ze(s);return r.create(n,i,o)}else return null}static create(e,t,n){if(typeof t!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(t!==qr)throw new Error(`Version 0 CID must use dag-pb (code: ${qr}) block encoding`);return new r(e,t,n,n.bytes)}case 1:{let s=Bc(e,t,n.bytes);return new r(e,t,n,s)}default:throw new Error("Invalid version")}}static createV0(e){return r.create(0,qr,e)}static createV1(e,t){return r.create(1,e,t)}static decode(e){let[t,n]=r.decodeFirst(e);if(n.length!==0)throw new Error("Incorrect length");return t}static decodeFirst(e){let t=r.inspectBytes(e),n=t.size-t.multihashSize,s=ht(e.subarray(n,n+t.multihashSize));if(s.byteLength!==t.multihashSize)throw new Error("Incorrect length");let i=s.subarray(t.multihashSize-t.digestSize),o=new dr(t.multihashCode,t.digestSize,i,s);return[t.version===0?r.createV0(o):r.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0,n=()=>{let[u,g]=Kr(e.subarray(t));return t+=g,u},s=n(),i=qr;if(s===18?(s=0,t=0):i=n(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);let o=t,a=n(),c=n(),h=t+c,f=h-o;return{version:s,codec:i,multihashCode:a,digestSize:c,multihashSize:f,size:h}}static parse(e,t){let[n,s]=Eh(e,t),i=r.decode(s);if(i.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Zi(i).set(n,e),i}};function Eh(r,e){switch(r[0]){case"Q":{let t=e??ee;return[ee.prefix,t.decode(`${ee.prefix}${r}`)]}case ee.prefix:{let t=e??ee;return[ee.prefix,t.decode(r)]}case dt.prefix:{let t=e??dt;return[dt.prefix,t.decode(r)]}case Hr.prefix:{let t=e??Hr;return[Hr.prefix,t.decode(r)]}default:{if(e==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],e.decode(r)]}}}function Sh(r,e,t){let{prefix:n}=t;if(n!==ee.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);let s=e.get(n);if(s==null){let i=t.encode(r).slice(1);return e.set(n,i),i}else return s}function Ah(r,e,t){let{prefix:n}=t,s=e.get(n);if(s==null){let i=t.encode(r);return e.set(n,i),i}else return s}var qr=112,Bh=18;function Bc(r,e,t){let n=hr(r),s=n+hr(e),i=new Uint8Array(s+t.byteLength);return fr(r,i,0),fr(e,i,n),i.set(t,s),i}var _h=Symbol.for("@ipld/js-cid/CID");var ji={};ke(ji,{identity:()=>pt});var _c=0,Ih="identity",Ic=ht;function Th(r){return Ze(_c,Ic(r))}var pt={code:_c,name:Ih,encode:Ic,digest:Th};function me(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function Tc(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function kh(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function pr(r,...e){if(!kh(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error("Uint8Array expected of length "+e+", got length="+r.length)}function kc(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Tc(r.outputLen),Tc(r.blockLen)}function mr(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function Cc(r,e){pr(r);let t=e.outputLen;if(r.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}var Wt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var kn=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),je=(r,e)=>r<<32-e|r>>>e;function Nc(r){if(typeof r!="string")throw new Error("utf8ToBytes expected string, got "+typeof r);return new Uint8Array(new TextEncoder().encode(r))}function zr(r){return typeof r=="string"&&(r=Nc(r)),pr(r),r}function Yi(...r){let e=0;for(let n=0;n<r.length;n++){let s=r[n];pr(s),e+=s.length}let t=new Uint8Array(e);for(let n=0,s=0;n<r.length;n++){let i=r[n];t.set(i,s),s+=i.length}return t}var gr=class{clone(){return this._cloneInto()}};function Cn(r){let e=n=>r().update(zr(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function Nn(r=32){if(Wt&&typeof Wt.getRandomValues=="function")return Wt.getRandomValues(new Uint8Array(r));if(Wt&&typeof Wt.randomBytes=="function")return Wt.randomBytes(r);throw new Error("crypto.getRandomValues must be defined")}function Ch(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);let s=BigInt(32),i=BigInt(4294967295),o=Number(t>>s&i),a=Number(t&i),c=n?4:0,h=n?0:4;r.setUint32(e+c,o,n),r.setUint32(e+h,a,n)}var Rc=(r,e,t)=>r&e^~r&t,Lc=(r,e,t)=>r&e^r&t^e&t,yr=class extends gr{constructor(e,t,n,s){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=kn(this.buffer)}update(e){mr(this);let{view:t,buffer:n,blockLen:s}=this;e=zr(e);let i=e.length;for(let o=0;o<i;){let a=Math.min(s-this.pos,i-o);if(a===s){let c=kn(e);for(;s<=i-o;o+=s)this.process(c,o);continue}n.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){mr(this),Cc(e,this),this.finished=!0;let{buffer:t,view:n,blockLen:s,isLE:i}=this,{pos:o}=this;t[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>s-o&&(this.process(n,0),o=0);for(let u=o;u<s;u++)t[u]=0;Ch(n,s-8,BigInt(this.length*8),i),this.process(n,0);let a=kn(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let h=c/4,f=this.get();if(h>f.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<h;u++)a.setUint32(4*u,f[u],i)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:n,length:s,finished:i,destroyed:o,pos:a}=this;return e.length=s,e.pos=a,e.finished=i,e.destroyed=o,s%t&&e.buffer.set(n),e}};var Rn=BigInt(4294967295),Xi=BigInt(32);function Uc(r,e=!1){return e?{h:Number(r&Rn),l:Number(r>>Xi&Rn)}:{h:Number(r>>Xi&Rn)|0,l:Number(r&Rn)|0}}function Nh(r,e=!1){let t=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let s=0;s<r.length;s++){let{h:i,l:o}=Uc(r[s],e);[t[s],n[s]]=[i,o]}return[t,n]}var Rh=(r,e)=>BigInt(r>>>0)<<Xi|BigInt(e>>>0),Lh=(r,e,t)=>r>>>t,Uh=(r,e,t)=>r<<32-t|e>>>t,Dh=(r,e,t)=>r>>>t|e<<32-t,Oh=(r,e,t)=>r<<32-t|e>>>t,Mh=(r,e,t)=>r<<64-t|e>>>t-32,Ph=(r,e,t)=>r>>>t-32|e<<64-t,Vh=(r,e)=>e,Hh=(r,e)=>r,Fh=(r,e,t)=>r<<t|e>>>32-t,Kh=(r,e,t)=>e<<t|r>>>32-t,qh=(r,e,t)=>e<<t-32|r>>>64-t,zh=(r,e,t)=>r<<t-32|e>>>64-t;function $h(r,e,t,n){let s=(e>>>0)+(n>>>0);return{h:r+t+(s/2**32|0)|0,l:s|0}}var Gh=(r,e,t)=>(r>>>0)+(e>>>0)+(t>>>0),Wh=(r,e,t,n)=>e+t+n+(r/2**32|0)|0,Zh=(r,e,t,n)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0),jh=(r,e,t,n,s)=>e+t+n+s+(r/2**32|0)|0,Yh=(r,e,t,n,s)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0)+(s>>>0),Xh=(r,e,t,n,s,i)=>e+t+n+s+i+(r/2**32|0)|0;var Jh={fromBig:Uc,split:Nh,toBig:Rh,shrSH:Lh,shrSL:Uh,rotrSH:Dh,rotrSL:Oh,rotrBH:Mh,rotrBL:Ph,rotr32H:Vh,rotr32L:Hh,rotlSH:Fh,rotlSL:Kh,rotlBH:qh,rotlBL:zh,add:$h,add3L:Gh,add3H:Wh,add4L:Zh,add4H:jh,add5H:Xh,add5L:Yh},M=Jh;var[Qh,ed]=M.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),Ct=new Uint32Array(80),Nt=new Uint32Array(80),Ji=class extends yr{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){let{Ah:e,Al:t,Bh:n,Bl:s,Ch:i,Cl:o,Dh:a,Dl:c,Eh:h,El:f,Fh:u,Fl:g,Gh:l,Gl:d,Hh:m,Hl:y}=this;return[e,t,n,s,i,o,a,c,h,f,u,g,l,d,m,y]}set(e,t,n,s,i,o,a,c,h,f,u,g,l,d,m,y){this.Ah=e|0,this.Al=t|0,this.Bh=n|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=h|0,this.El=f|0,this.Fh=u|0,this.Fl=g|0,this.Gh=l|0,this.Gl=d|0,this.Hh=m|0,this.Hl=y|0}process(e,t){for(let p=0;p<16;p++,t+=4)Ct[p]=e.getUint32(t),Nt[p]=e.getUint32(t+=4);for(let p=16;p<80;p++){let E=Ct[p-15]|0,A=Nt[p-15]|0,_=M.rotrSH(E,A,1)^M.rotrSH(E,A,8)^M.shrSH(E,A,7),x=M.rotrSL(E,A,1)^M.rotrSL(E,A,8)^M.shrSL(E,A,7),I=Ct[p-2]|0,C=Nt[p-2]|0,j=M.rotrSH(I,C,19)^M.rotrBH(I,C,61)^M.shrSH(I,C,6),V=M.rotrSL(I,C,19)^M.rotrBL(I,C,61)^M.shrSL(I,C,6),P=M.add4L(x,V,Nt[p-7],Nt[p-16]),L=M.add4H(P,_,j,Ct[p-7],Ct[p-16]);Ct[p]=L|0,Nt[p]=P|0}let{Ah:n,Al:s,Bh:i,Bl:o,Ch:a,Cl:c,Dh:h,Dl:f,Eh:u,El:g,Fh:l,Fl:d,Gh:m,Gl:y,Hh:b,Hl:w}=this;for(let p=0;p<80;p++){let E=M.rotrSH(u,g,14)^M.rotrSH(u,g,18)^M.rotrBH(u,g,41),A=M.rotrSL(u,g,14)^M.rotrSL(u,g,18)^M.rotrBL(u,g,41),_=u&l^~u&m,x=g&d^~g&y,I=M.add5L(w,A,x,ed[p],Nt[p]),C=M.add5H(I,b,E,_,Qh[p],Ct[p]),j=I|0,V=M.rotrSH(n,s,28)^M.rotrBH(n,s,34)^M.rotrBH(n,s,39),P=M.rotrSL(n,s,28)^M.rotrBL(n,s,34)^M.rotrBL(n,s,39),L=n&i^n&a^i&a,T=s&o^s&c^o&c;b=m|0,w=y|0,m=l|0,y=d|0,l=u|0,d=g|0,{h:u,l:g}=M.add(h|0,f|0,C|0,j|0),h=a|0,f=c|0,a=i|0,c=o|0,i=n|0,o=s|0;let R=M.add3L(j,P,T);n=M.add3H(R,C,V,L),s=R|0}({h:n,l:s}=M.add(this.Ah|0,this.Al|0,n|0,s|0)),{h:i,l:o}=M.add(this.Bh|0,this.Bl|0,i|0,o|0),{h:a,l:c}=M.add(this.Ch|0,this.Cl|0,a|0,c|0),{h,l:f}=M.add(this.Dh|0,this.Dl|0,h|0,f|0),{h:u,l:g}=M.add(this.Eh|0,this.El|0,u|0,g|0),{h:l,l:d}=M.add(this.Fh|0,this.Fl|0,l|0,d|0),{h:m,l:y}=M.add(this.Gh|0,this.Gl|0,m|0,y|0),{h:b,l:w}=M.add(this.Hh|0,this.Hl|0,b|0,w|0),this.set(n,s,i,o,a,c,h,f,u,g,l,d,m,y,b,w)}roundClean(){Ct.fill(0),Nt.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}};var Dc=Cn(()=>new Ji);var Dn={};ke(Dn,{aInRange:()=>Le,abool:()=>Ye,abytes:()=>br,bitGet:()=>od,bitLen:()=>ro,bitMask:()=>Gr,bitSet:()=>ad,bytesToHex:()=>gt,bytesToNumberBE:()=>yt,bytesToNumberLE:()=>Lt,concatBytes:()=>bt,createHmacDrbg:()=>no,ensureBytes:()=>oe,equalBytes:()=>sd,hexToBytes:()=>jt,hexToNumber:()=>to,inRange:()=>$r,isBytes:()=>Rt,memoized:()=>Xt,notImplemented:()=>ld,numberToBytesBE:()=>Ut,numberToBytesLE:()=>Yt,numberToHexUnpadded:()=>Zt,numberToVarBytesBE:()=>nd,utf8ToBytes:()=>id,validateObject:()=>it});var Ln=BigInt(0),Un=BigInt(1),td=BigInt(2);function Rt(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function br(r){if(!Rt(r))throw new Error("Uint8Array expected")}function Ye(r,e){if(typeof e!="boolean")throw new Error(r+" boolean expected, got "+e)}var rd=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function gt(r){br(r);let e="";for(let t=0;t<r.length;t++)e+=rd[r[t]];return e}function Zt(r){let e=r.toString(16);return e.length&1?"0"+e:e}function to(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?Ln:BigInt("0x"+r)}var mt={_0:48,_9:57,A:65,F:70,a:97,f:102};function Oc(r){if(r>=mt._0&&r<=mt._9)return r-mt._0;if(r>=mt.A&&r<=mt.F)return r-(mt.A-10);if(r>=mt.a&&r<=mt.f)return r-(mt.a-10)}function jt(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);let e=r.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);let n=new Uint8Array(t);for(let s=0,i=0;s<t;s++,i+=2){let o=Oc(r.charCodeAt(i)),a=Oc(r.charCodeAt(i+1));if(o===void 0||a===void 0){let c=r[i]+r[i+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+i)}n[s]=o*16+a}return n}function yt(r){return to(gt(r))}function Lt(r){return br(r),to(gt(Uint8Array.from(r).reverse()))}function Ut(r,e){return jt(r.toString(16).padStart(e*2,"0"))}function Yt(r,e){return Ut(r,e).reverse()}function nd(r){return jt(Zt(r))}function oe(r,e,t){let n;if(typeof e=="string")try{n=jt(e)}catch(i){throw new Error(r+" must be hex string or Uint8Array, cause: "+i)}else if(Rt(e))n=Uint8Array.from(e);else throw new Error(r+" must be hex string or Uint8Array");let s=n.length;if(typeof t=="number"&&s!==t)throw new Error(r+" of length "+t+" expected, got "+s);return n}function bt(...r){let e=0;for(let n=0;n<r.length;n++){let s=r[n];br(s),e+=s.length}let t=new Uint8Array(e);for(let n=0,s=0;n<r.length;n++){let i=r[n];t.set(i,s),s+=i.length}return t}function sd(r,e){if(r.length!==e.length)return!1;let t=0;for(let n=0;n<r.length;n++)t|=r[n]^e[n];return t===0}function id(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}var Qi=r=>typeof r=="bigint"&&Ln<=r;function $r(r,e,t){return Qi(r)&&Qi(e)&&Qi(t)&&e<=r&&r<t}function Le(r,e,t,n){if(!$r(e,t,n))throw new Error("expected valid "+r+": "+t+" <= n < "+n+", got "+e)}function ro(r){let e;for(e=0;r>Ln;r>>=Un,e+=1);return e}function od(r,e){return r>>BigInt(e)&Un}function ad(r,e,t){return r|(t?Un:Ln)<<BigInt(e)}var Gr=r=>(td<<BigInt(r-1))-Un,eo=r=>new Uint8Array(r),Mc=r=>Uint8Array.from(r);function no(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=eo(r),s=eo(r),i=0,o=()=>{n.fill(1),s.fill(0),i=0},a=(...u)=>t(s,n,...u),c=(u=eo())=>{s=a(Mc([0]),u),n=a(),u.length!==0&&(s=a(Mc([1]),u),n=a())},h=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let u=0,g=[];for(;u<e;){n=a();let l=n.slice();g.push(l),u+=n.length}return bt(...g)};return(u,g)=>{o(),c(u);let l;for(;!(l=g(h()));)c();return o(),l}}var cd={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||Rt(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,e)=>e.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function it(r,e,t={}){let n=(s,i,o)=>{let a=cd[i];if(typeof a!="function")throw new Error("invalid validator function");let c=r[s];if(!(o&&c===void 0)&&!a(c,r))throw new Error("param "+String(s)+" is invalid. Expected "+i+", got "+c)};for(let[s,i]of Object.entries(e))n(s,i,!1);for(let[s,i]of Object.entries(t))n(s,i,!0);return r}var ld=()=>{throw new Error("not implemented")};function Xt(r){let e=new WeakMap;return(t,...n)=>{let s=e.get(t);if(s!==void 0)return s;let i=r(t,...n);return e.set(t,i),i}}var ue=BigInt(0),se=BigInt(1),Jt=BigInt(2),ud=BigInt(3),so=BigInt(4),Pc=BigInt(5),Vc=BigInt(8),fd=BigInt(9),hd=BigInt(16);function J(r,e){let t=r%e;return t>=ue?t:e+t}function dd(r,e,t){if(e<ue)throw new Error("invalid exponent, negatives unsupported");if(t<=ue)throw new Error("invalid modulus");if(t===se)return ue;let n=se;for(;e>ue;)e&se&&(n=n*r%t),r=r*r%t,e>>=se;return n}function ie(r,e,t){let n=r;for(;e-- >ue;)n*=n,n%=t;return n}function On(r,e){if(r===ue)throw new Error("invert: expected non-zero number");if(e<=ue)throw new Error("invert: expected positive modulus, got "+e);let t=J(r,e),n=e,s=ue,i=se,o=se,a=ue;for(;t!==ue;){let h=n/t,f=n%t,u=s-o*h,g=i-a*h;n=t,t=f,s=o,i=a,o=u,a=g}if(n!==se)throw new Error("invert: does not exist");return J(s,e)}function pd(r){let e=(r-se)/Jt,t,n,s;for(t=r-se,n=0;t%Jt===ue;t/=Jt,n++);for(s=Jt;s<r&&dd(s,e,r)!==r-se;s++)if(s>1e3)throw new Error("Cannot find square root: likely non-prime P");if(n===1){let o=(r+se)/so;return function(c,h){let f=c.pow(h,o);if(!c.eql(c.sqr(f),h))throw new Error("Cannot find square root");return f}}let i=(t+se)/Jt;return function(a,c){if(a.pow(c,e)===a.neg(a.ONE))throw new Error("Cannot find square root");let h=n,f=a.pow(a.mul(a.ONE,s),t),u=a.pow(c,i),g=a.pow(c,t);for(;!a.eql(g,a.ONE);){if(a.eql(g,a.ZERO))return a.ZERO;let l=1;for(let m=a.sqr(g);l<h&&!a.eql(m,a.ONE);l++)m=a.sqr(m);let d=a.pow(f,se<<BigInt(h-l-1));f=a.sqr(d),u=a.mul(u,d),g=a.mul(g,f),h=l}return u}}function md(r){if(r%so===ud){let e=(r+se)/so;return function(n,s){let i=n.pow(s,e);if(!n.eql(n.sqr(i),s))throw new Error("Cannot find square root");return i}}if(r%Vc===Pc){let e=(r-Pc)/Vc;return function(n,s){let i=n.mul(s,Jt),o=n.pow(i,e),a=n.mul(s,o),c=n.mul(n.mul(a,Jt),o),h=n.mul(a,n.sub(c,n.ONE));if(!n.eql(n.sqr(h),s))throw new Error("Cannot find square root");return h}}return r%hd,pd(r)}var Hc=(r,e)=>(J(r,e)&se)===se,gd=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function io(r){let e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=gd.reduce((n,s)=>(n[s]="function",n),e);return it(r,t)}function yd(r,e,t){if(t<ue)throw new Error("invalid exponent, negatives unsupported");if(t===ue)return r.ONE;if(t===se)return e;let n=r.ONE,s=e;for(;t>ue;)t&se&&(n=r.mul(n,s)),s=r.sqr(s),t>>=se;return n}function bd(r,e){let t=new Array(e.length),n=e.reduce((i,o,a)=>r.is0(o)?i:(t[a]=i,r.mul(i,o)),r.ONE),s=r.inv(n);return e.reduceRight((i,o,a)=>r.is0(o)?i:(t[a]=r.mul(i,t[a]),r.mul(i,o)),s),t}function oo(r,e){let t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function Dt(r,e,t=!1,n={}){if(r<=ue)throw new Error("invalid field: expected ORDER > 0, got "+r);let{nBitLength:s,nByteLength:i}=oo(r,e);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o,a=Object.freeze({ORDER:r,isLE:t,BITS:s,BYTES:i,MASK:Gr(s),ZERO:ue,ONE:se,create:c=>J(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return ue<=c&&c<r},is0:c=>c===ue,isOdd:c=>(c&se)===se,neg:c=>J(-c,r),eql:(c,h)=>c===h,sqr:c=>J(c*c,r),add:(c,h)=>J(c+h,r),sub:(c,h)=>J(c-h,r),mul:(c,h)=>J(c*h,r),pow:(c,h)=>yd(a,c,h),div:(c,h)=>J(c*On(h,r),r),sqrN:c=>c*c,addN:(c,h)=>c+h,subN:(c,h)=>c-h,mulN:(c,h)=>c*h,inv:c=>On(c,r),sqrt:n.sqrt||(c=>(o||(o=md(r)),o(a,c))),invertBatch:c=>bd(a,c),cmov:(c,h,f)=>f?h:c,toBytes:c=>t?Yt(c,i):Ut(c,i),fromBytes:c=>{if(c.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+c.length);return t?Lt(c):yt(c)}});return Object.freeze(a)}function Fc(r){if(typeof r!="bigint")throw new Error("field order must be bigint");let e=r.toString(2).length;return Math.ceil(e/8)}function ao(r){let e=Fc(r);return e+Math.ceil(e/2)}function Kc(r,e,t=!1){let n=r.length,s=Fc(e),i=ao(e);if(n<16||n<i||n>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+n);let o=t?Lt(r):yt(r),a=J(o,e-se)+se;return t?Yt(a,s):Ut(a,s)}var qc=BigInt(0),Mn=BigInt(1);function co(r,e){let t=e.negate();return r?t:e}function zc(r,e){if(!Number.isSafeInteger(r)||r<=0||r>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+r)}function lo(r,e){zc(r,e);let t=Math.ceil(e/r)+1,n=2**(r-1);return{windows:t,windowSize:n}}function xd(r,e){if(!Array.isArray(r))throw new Error("array expected");r.forEach((t,n)=>{if(!(t instanceof e))throw new Error("invalid point at index "+n)})}function vd(r,e){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((t,n)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+n)})}var uo=new WeakMap,$c=new WeakMap;function fo(r){return $c.get(r)||1}function Pn(r,e){return{constTimeNegate:co,hasPrecomputes(t){return fo(t)!==1},unsafeLadder(t,n,s=r.ZERO){let i=t;for(;n>qc;)n&Mn&&(s=s.add(i)),i=i.double(),n>>=Mn;return s},precomputeWindow(t,n){let{windows:s,windowSize:i}=lo(n,e),o=[],a=t,c=a;for(let h=0;h<s;h++){c=a,o.push(c);for(let f=1;f<i;f++)c=c.add(a),o.push(c);a=c.double()}return o},wNAF(t,n,s){let{windows:i,windowSize:o}=lo(t,e),a=r.ZERO,c=r.BASE,h=BigInt(2**t-1),f=2**t,u=BigInt(t);for(let g=0;g<i;g++){let l=g*o,d=Number(s&h);s>>=u,d>o&&(d-=f,s+=Mn);let m=l,y=l+Math.abs(d)-1,b=g%2!==0,w=d<0;d===0?c=c.add(co(b,n[m])):a=a.add(co(w,n[y]))}return{p:a,f:c}},wNAFUnsafe(t,n,s,i=r.ZERO){let{windows:o,windowSize:a}=lo(t,e),c=BigInt(2**t-1),h=2**t,f=BigInt(t);for(let u=0;u<o;u++){let g=u*a;if(s===qc)break;let l=Number(s&c);if(s>>=f,l>a&&(l-=h,s+=Mn),l===0)continue;let d=n[g+Math.abs(l)-1];l<0&&(d=d.negate()),i=i.add(d)}return i},getPrecomputes(t,n,s){let i=uo.get(n);return i||(i=this.precomputeWindow(n,t),t!==1&&uo.set(n,s(i))),i},wNAFCached(t,n,s){let i=fo(t);return this.wNAF(i,this.getPrecomputes(i,t,s),n)},wNAFCachedUnsafe(t,n,s,i){let o=fo(t);return o===1?this.unsafeLadder(t,n,i):this.wNAFUnsafe(o,this.getPrecomputes(o,t,s),n,i)},setWindowSize(t,n){zc(n,e),$c.set(t,n),uo.delete(t)}}}function Vn(r,e,t,n){if(xd(t,r),vd(n,e),t.length!==n.length)throw new Error("arrays of points and scalars must have equal length");let s=r.ZERO,i=ro(BigInt(t.length)),o=i>12?i-3:i>4?i-2:i?2:1,a=(1<<o)-1,c=new Array(a+1).fill(s),h=Math.floor((e.BITS-1)/o)*o,f=s;for(let u=h;u>=0;u-=o){c.fill(s);for(let l=0;l<n.length;l++){let d=n[l],m=Number(d>>BigInt(u)&BigInt(a));c[m]=c[m].add(t[l])}let g=s;for(let l=c.length-1,d=s;l>0;l--)d=d.add(c[l]),g=g.add(d);if(f=f.add(g),u!==0)for(let l=0;l<o;l++)f=f.double()}return f}function Wr(r){return io(r.Fp),it(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...oo(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}var Xe=BigInt(0),Ue=BigInt(1),Hn=BigInt(2),Ed=BigInt(8),Sd={zip215:!0};function Ad(r){let e=Wr(r);return it(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function Gc(r){let e=Ad(r),{Fp:t,n,prehash:s,hash:i,randomBytes:o,nByteLength:a,h:c}=e,h=Hn<<BigInt(a*8)-Ue,f=t.create,u=Dt(e.n,e.nBitLength),g=e.uvRatio||((S,v)=>{try{return{isValid:!0,value:t.sqrt(S*t.inv(v))}}catch{return{isValid:!1,value:Xe}}}),l=e.adjustScalarBytes||(S=>S),d=e.domain||((S,v,B)=>{if(Ye("phflag",B),v.length||B)throw new Error("Contexts/pre-hash are not supported");return S});function m(S,v){Le("coordinate "+S,v,Xe,h)}function y(S){if(!(S instanceof p))throw new Error("ExtendedPoint expected")}let b=Xt((S,v)=>{let{ex:B,ey:N,ez:U}=S,D=S.is0();v==null&&(v=D?Ed:t.inv(U));let H=f(B*v),$=f(N*v),O=f(U*v);if(D)return{x:Xe,y:Ue};if(O!==Ue)throw new Error("invZ was invalid");return{x:H,y:$}}),w=Xt(S=>{let{a:v,d:B}=e;if(S.is0())throw new Error("bad point: ZERO");let{ex:N,ey:U,ez:D,et:H}=S,$=f(N*N),O=f(U*U),Y=f(D*D),re=f(Y*Y),he=f($*v),de=f(Y*f(he+O)),ye=f(re+f(B*f($*O)));if(de!==ye)throw new Error("bad point: equation left != right (1)");let xe=f(N*U),Ne=f(D*H);if(xe!==Ne)throw new Error("bad point: equation left != right (2)");return!0});class p{constructor(v,B,N,U){this.ex=v,this.ey=B,this.ez=N,this.et=U,m("x",v),m("y",B),m("z",N),m("t",U),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(v){if(v instanceof p)throw new Error("extended point not allowed");let{x:B,y:N}=v||{};return m("x",B),m("y",N),new p(B,N,Ue,f(B*N))}static normalizeZ(v){let B=t.invertBatch(v.map(N=>N.ez));return v.map((N,U)=>N.toAffine(B[U])).map(p.fromAffine)}static msm(v,B){return Vn(p,u,v,B)}_setWindowSize(v){_.setWindowSize(this,v)}assertValidity(){w(this)}equals(v){y(v);let{ex:B,ey:N,ez:U}=this,{ex:D,ey:H,ez:$}=v,O=f(B*$),Y=f(D*U),re=f(N*$),he=f(H*U);return O===Y&&re===he}is0(){return this.equals(p.ZERO)}negate(){return new p(f(-this.ex),this.ey,this.ez,f(-this.et))}double(){let{a:v}=e,{ex:B,ey:N,ez:U}=this,D=f(B*B),H=f(N*N),$=f(Hn*f(U*U)),O=f(v*D),Y=B+N,re=f(f(Y*Y)-D-H),he=O+H,de=he-$,ye=O-H,xe=f(re*de),Ne=f(he*ye),Te=f(re*ye),nt=f(de*he);return new p(xe,Ne,nt,Te)}add(v){y(v);let{a:B,d:N}=e,{ex:U,ey:D,ez:H,et:$}=this,{ex:O,ey:Y,ez:re,et:he}=v;if(B===BigInt(-1)){let Xa=f((D-U)*(Y+O)),Ja=f((D+U)*(Y-O)),Oi=f(Ja-Xa);if(Oi===Xe)return this.double();let Qa=f(H*Hn*he),ec=f($*Hn*re),tc=ec+Qa,rc=Ja+Xa,nc=ec-Qa,Lf=f(tc*Oi),Uf=f(rc*nc),Df=f(tc*nc),Of=f(Oi*rc);return new p(Lf,Uf,Of,Df)}let de=f(U*O),ye=f(D*Y),xe=f($*N*he),Ne=f(H*re),Te=f((U+D)*(O+Y)-de-ye),nt=Ne-xe,ut=Ne+xe,Pr=f(ye-B*de),kf=f(Te*nt),Cf=f(ut*Pr),Nf=f(Te*Pr),Rf=f(nt*ut);return new p(kf,Cf,Rf,Nf)}subtract(v){return this.add(v.negate())}wNAF(v){return _.wNAFCached(this,v,p.normalizeZ)}multiply(v){let B=v;Le("scalar",B,Ue,n);let{p:N,f:U}=this.wNAF(B);return p.normalizeZ([N,U])[0]}multiplyUnsafe(v,B=p.ZERO){let N=v;return Le("scalar",N,Xe,n),N===Xe?A:this.is0()||N===Ue?this:_.wNAFCachedUnsafe(this,N,p.normalizeZ,B)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return _.unsafeLadder(this,n).is0()}toAffine(v){return b(this,v)}clearCofactor(){let{h:v}=e;return v===Ue?this:this.multiplyUnsafe(v)}static fromHex(v,B=!1){let{d:N,a:U}=e,D=t.BYTES;v=oe("pointHex",v,D),Ye("zip215",B);let H=v.slice(),$=v[D-1];H[D-1]=$&-129;let O=Lt(H),Y=B?h:t.ORDER;Le("pointHex.y",O,Xe,Y);let re=f(O*O),he=f(re-Ue),de=f(N*re-U),{isValid:ye,value:xe}=g(he,de);if(!ye)throw new Error("Point.fromHex: invalid y coordinate");let Ne=(xe&Ue)===Ue,Te=($&128)!==0;if(!B&&xe===Xe&&Te)throw new Error("Point.fromHex: x=0 and x_0=1");return Te!==Ne&&(xe=f(-xe)),p.fromAffine({x:xe,y:O})}static fromPrivateKey(v){return C(v).point}toRawBytes(){let{x:v,y:B}=this.toAffine(),N=Yt(B,t.BYTES);return N[N.length-1]|=v&Ue?128:0,N}toHex(){return gt(this.toRawBytes())}}p.BASE=new p(e.Gx,e.Gy,Ue,f(e.Gx*e.Gy)),p.ZERO=new p(Xe,Ue,Ue,Xe);let{BASE:E,ZERO:A}=p,_=Pn(p,a*8);function x(S){return J(S,n)}function I(S){return x(Lt(S))}function C(S){let v=t.BYTES;S=oe("private key",S,v);let B=oe("hashed private key",i(S),2*v),N=l(B.slice(0,v)),U=B.slice(v,2*v),D=I(N),H=E.multiply(D),$=H.toRawBytes();return{head:N,prefix:U,scalar:D,point:H,pointBytes:$}}function j(S){return C(S).pointBytes}function V(S=new Uint8Array,...v){let B=bt(...v);return I(i(d(B,oe("context",S),!!s)))}function P(S,v,B={}){S=oe("message",S),s&&(S=s(S));let{prefix:N,scalar:U,pointBytes:D}=C(v),H=V(B.context,N,S),$=E.multiply(H).toRawBytes(),O=V(B.context,$,D,S),Y=x(H+O*U);Le("signature.s",Y,Xe,n);let re=bt($,Yt(Y,t.BYTES));return oe("result",re,t.BYTES*2)}let L=Sd;function T(S,v,B,N=L){let{context:U,zip215:D}=N,H=t.BYTES;S=oe("signature",S,2*H),v=oe("message",v),B=oe("publicKey",B,H),D!==void 0&&Ye("zip215",D),s&&(v=s(v));let $=Lt(S.slice(H,2*H)),O,Y,re;try{O=p.fromHex(B,D),Y=p.fromHex(S.slice(0,H),D),re=E.multiplyUnsafe($)}catch{return!1}if(!D&&O.isSmallOrder())return!1;let he=V(U,Y.toRawBytes(),O.toRawBytes(),v);return Y.add(O.multiplyUnsafe(he)).subtract(re).clearCofactor().equals(p.ZERO)}return E._setWindowSize(8),{CURVE:e,getPublicKey:j,sign:P,verify:T,ExtendedPoint:p,utils:{getExtendedPublicKey:C,randomPrivateKey:()=>o(t.BYTES),precompute(S=8,v=p.BASE){return v._setWindowSize(S),v.multiply(BigInt(3)),v}}}}var ho=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Wc=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),ng=BigInt(0),Bd=BigInt(1),Zc=BigInt(2),sg=BigInt(3),_d=BigInt(5),Id=BigInt(8);function Td(r){let e=BigInt(10),t=BigInt(20),n=BigInt(40),s=BigInt(80),i=ho,a=r*r%i*r%i,c=ie(a,Zc,i)*a%i,h=ie(c,Bd,i)*r%i,f=ie(h,_d,i)*h%i,u=ie(f,e,i)*f%i,g=ie(u,t,i)*u%i,l=ie(g,n,i)*g%i,d=ie(l,s,i)*l%i,m=ie(d,s,i)*l%i,y=ie(m,e,i)*f%i;return{pow_p_5_8:ie(y,Zc,i)*r%i,b2:a}}function kd(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function Cd(r,e){let t=ho,n=J(e*e*e,t),s=J(n*n*e,t),i=Td(r*s).pow_p_5_8,o=J(r*n*i,t),a=J(e*o*o,t),c=o,h=J(o*Wc,t),f=a===r,u=a===J(-r,t),g=a===J(-r*Wc,t);return f&&(o=c),(u||g)&&(o=h),Hc(o,t)&&(o=J(-o,t)),{isValid:f||u,value:o}}var Nd=Dt(ho,void 0,!0),Rd={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:Nd,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:Id,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Dc,randomBytes:Nn,adjustScalarBytes:kd,uvRatio:Cd},jc=Gc(Rd);var Fn=32;function Yc(r,e,t){return jc.verify(e,t instanceof Uint8Array?t:t.subarray(),r)}var Kn=class{type="Ed25519";raw;constructor(e){this.raw=po(e,Fn)}toMultihash(){return pt.digest(Ot(this))}toCID(){return pe.createV1(114,this.toMultihash())}toString(){return ee.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:me(this.raw,e.raw)}verify(e,t){return Yc(this.raw,t,e)}};function mo(r){return r=po(r,Fn),new Kn(r)}function po(r,e){if(r=Uint8Array.from(r??[]),r.length!==e)throw new ve(`Key must be a Uint8Array of length ${e}, got ${r.length}`);return r}function ae(r=0){return new Uint8Array(r)}function De(r=0){return new Uint8Array(r)}var Ud=Math.pow(2,7),Dd=Math.pow(2,14),Od=Math.pow(2,21),go=Math.pow(2,28),yo=Math.pow(2,35),bo=Math.pow(2,42),wo=Math.pow(2,49),Z=128,Ee=127;function Se(r){if(r<Ud)return 1;if(r<Dd)return 2;if(r<Od)return 3;if(r<go)return 4;if(r<yo)return 5;if(r<bo)return 6;if(r<wo)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function xo(r,e,t=0){switch(Se(r)){case 8:e[t++]=r&255|Z,r/=128;case 7:e[t++]=r&255|Z,r/=128;case 6:e[t++]=r&255|Z,r/=128;case 5:e[t++]=r&255|Z,r/=128;case 4:e[t++]=r&255|Z,r>>>=7;case 3:e[t++]=r&255|Z,r>>>=7;case 2:e[t++]=r&255|Z,r>>>=7;case 1:{e[t++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return e}function Md(r,e,t=0){switch(Se(r)){case 8:e.set(t++,r&255|Z),r/=128;case 7:e.set(t++,r&255|Z),r/=128;case 6:e.set(t++,r&255|Z),r/=128;case 5:e.set(t++,r&255|Z),r/=128;case 4:e.set(t++,r&255|Z),r>>>=7;case 3:e.set(t++,r&255|Z),r>>>=7;case 2:e.set(t++,r&255|Z),r>>>=7;case 1:{e.set(t++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return e}function vo(r,e){let t=r[e],n=0;if(n+=t&Ee,t<Z||(t=r[e+1],n+=(t&Ee)<<7,t<Z)||(t=r[e+2],n+=(t&Ee)<<14,t<Z)||(t=r[e+3],n+=(t&Ee)<<21,t<Z)||(t=r[e+4],n+=(t&Ee)*go,t<Z)||(t=r[e+5],n+=(t&Ee)*yo,t<Z)||(t=r[e+6],n+=(t&Ee)*bo,t<Z)||(t=r[e+7],n+=(t&Ee)*wo,t<Z))return n;throw new RangeError("Could not decode varint")}function Pd(r,e){let t=r.get(e),n=0;if(n+=t&Ee,t<Z||(t=r.get(e+1),n+=(t&Ee)<<7,t<Z)||(t=r.get(e+2),n+=(t&Ee)<<14,t<Z)||(t=r.get(e+3),n+=(t&Ee)<<21,t<Z)||(t=r.get(e+4),n+=(t&Ee)*go,t<Z)||(t=r.get(e+5),n+=(t&Ee)*yo,t<Z)||(t=r.get(e+6),n+=(t&Ee)*bo,t<Z)||(t=r.get(e+7),n+=(t&Ee)*wo,t<Z))return n;throw new RangeError("Could not decode varint")}function $e(r,e,t=0){return e==null&&(e=De(Se(r))),e instanceof Uint8Array?xo(r,e,t):Md(r,e,t)}function wt(r,e=0){return r instanceof Uint8Array?vo(r,e):Pd(r,e)}var Eo=new Float32Array([-0]),Mt=new Uint8Array(Eo.buffer);function Jc(r,e,t){Eo[0]=r,e[t]=Mt[0],e[t+1]=Mt[1],e[t+2]=Mt[2],e[t+3]=Mt[3]}function Qc(r,e){return Mt[0]=r[e],Mt[1]=r[e+1],Mt[2]=r[e+2],Mt[3]=r[e+3],Eo[0]}var So=new Float64Array([-0]),Ae=new Uint8Array(So.buffer);function el(r,e,t){So[0]=r,e[t]=Ae[0],e[t+1]=Ae[1],e[t+2]=Ae[2],e[t+3]=Ae[3],e[t+4]=Ae[4],e[t+5]=Ae[5],e[t+6]=Ae[6],e[t+7]=Ae[7]}function tl(r,e){return Ae[0]=r[e],Ae[1]=r[e+1],Ae[2]=r[e+2],Ae[3]=r[e+3],Ae[4]=r[e+4],Ae[5]=r[e+5],Ae[6]=r[e+6],Ae[7]=r[e+7],So[0]}var Vd=BigInt(Number.MAX_SAFE_INTEGER),Hd=BigInt(Number.MIN_SAFE_INTEGER),He=class r{lo;hi;constructor(e,t){this.lo=e|0,this.hi=t|0}toNumber(e=!1){if(!e&&this.hi>>>31>0){let t=~this.lo+1>>>0,n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(t+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(e=!1){if(e)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){let t=~this.lo+1>>>0,n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(BigInt(t)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(e=!1){return this.toBigInt(e).toString()}zzEncode(){let e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this}zzDecode(){let e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this}length(){let e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?t===0?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:n<128?9:10}static fromBigInt(e){if(e===0n)return Qt;if(e<Vd&&e>Hd)return this.fromNumber(Number(e));let t=e<0n;t&&(e=-e);let n=e>>32n,s=e-(n<<32n);return t&&(n=~n|0n,s=~s|0n,++s>rl&&(s=0n,++n>rl&&(n=0n))),new r(Number(s),Number(n))}static fromNumber(e){if(e===0)return Qt;let t=e<0;t&&(e=-e);let n=e>>>0,s=(e-n)/4294967296>>>0;return t&&(s=~s>>>0,n=~n>>>0,++n>4294967295&&(n=0,++s>4294967295&&(s=0))),new r(n,s)}static from(e){return typeof e=="number"?r.fromNumber(e):typeof e=="bigint"?r.fromBigInt(e):typeof e=="string"?r.fromBigInt(BigInt(e)):e.low!=null||e.high!=null?new r(e.low>>>0,e.high>>>0):Qt}},Qt=new He(0,0);Qt.toBigInt=function(){return 0n};Qt.zzEncode=Qt.zzDecode=function(){return this};Qt.length=function(){return 1};var rl=4294967296n;function nl(r){let e=0,t=0;for(let n=0;n<r.length;++n)t=r.charCodeAt(n),t<128?e+=1:t<2048?e+=2:(t&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,e+=4):e+=3;return e}function sl(r,e,t){if(t-e<1)return"";let s,i=[],o=0,a;for(;e<t;)a=r[e++],a<128?i[o++]=a:a>191&&a<224?i[o++]=(a&31)<<6|r[e++]&63:a>239&&a<365?(a=((a&7)<<18|(r[e++]&63)<<12|(r[e++]&63)<<6|r[e++]&63)-65536,i[o++]=55296+(a>>10),i[o++]=56320+(a&1023)):i[o++]=(a&15)<<12|(r[e++]&63)<<6|r[e++]&63,o>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,i)),o=0);return s!=null?(o>0&&s.push(String.fromCharCode.apply(String,i.slice(0,o))),s.join("")):String.fromCharCode.apply(String,i.slice(0,o))}function Ao(r,e,t){let n=t,s,i;for(let o=0;o<r.length;++o)s=r.charCodeAt(o),s<128?e[t++]=s:s<2048?(e[t++]=s>>6|192,e[t++]=s&63|128):(s&64512)===55296&&((i=r.charCodeAt(o+1))&64512)===56320?(s=65536+((s&1023)<<10)+(i&1023),++o,e[t++]=s>>18|240,e[t++]=s>>12&63|128,e[t++]=s>>6&63|128,e[t++]=s&63|128):(e[t++]=s>>12|224,e[t++]=s>>6&63|128,e[t++]=s&63|128);return t-n}function Je(r,e){return RangeError(`index out of range: ${r.pos} + ${e??1} > ${r.len}`)}function zn(r,e){return(r[e-4]|r[e-3]<<8|r[e-2]<<16|r[e-1]<<24)>>>0}var Bo=class{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(e){this.buf=e,this.pos=0,this.len=e.length}uint32(){let e=4294967295;if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,Je(this,10);return e}int32(){return this.uint32()|0}sint32(){let e=this.uint32();return e>>>1^-(e&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw Je(this,4);return zn(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw Je(this,4);return zn(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw Je(this,4);let e=Qc(this.buf,this.pos);return this.pos+=4,e}double(){if(this.pos+8>this.len)throw Je(this,4);let e=tl(this.buf,this.pos);return this.pos+=8,e}bytes(){let e=this.uint32(),t=this.pos,n=this.pos+e;if(n>this.len)throw Je(this,e);return this.pos+=e,t===n?new Uint8Array(0):this.buf.subarray(t,n)}string(){let e=this.bytes();return sl(e,0,e.length)}skip(e){if(typeof e=="number"){if(this.pos+e>this.len)throw Je(this,e);this.pos+=e}else do if(this.pos>=this.len)throw Je(this);while(this.buf[this.pos++]&128);return this}skipType(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(e=this.uint32()&7)!==4;)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${e} at offset ${this.pos}`)}return this}readLongVarint(){let e=new He(0,0),t=0;if(this.len-this.pos>4){for(;t<4;++t)if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(this.buf[this.pos]&127)<<28)>>>0,e.hi=(e.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return e;t=0}else{for(;t<3;++t){if(this.pos>=this.len)throw Je(this);if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(this.buf[this.pos++]&127)<<t*7)>>>0,e}if(this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw Je(this);if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw Je(this,8);let e=zn(this.buf,this.pos+=4),t=zn(this.buf,this.pos+=4);return new He(e,t)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){let e=vo(this.buf,this.pos);return this.pos+=Se(e),e}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}};function _o(r){return new Bo(r instanceof Uint8Array?r:r.subarray())}function Oe(r,e,t){let n=_o(r);return e.decode(n,void 0,t)}var Io={};ke(Io,{base10:()=>Fd});var Fd=kt({prefix:"9",name:"base10",alphabet:"0123456789"});var To={};ke(To,{base16:()=>Kd,base16upper:()=>qd});var Kd=le({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),qd=le({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var ko={};ke(ko,{base2:()=>zd});var zd=le({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var Co={};ke(Co,{base256emoji:()=>jd});var ol=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),$d=ol.reduce((r,e,t)=>(r[t]=e,r),[]),Gd=ol.reduce((r,e,t)=>{let n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);return r[n]=t,r},[]);function Wd(r){return r.reduce((e,t)=>(e+=$d[t],e),"")}function Zd(r){let e=[];for(let t of r){let n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);let s=Gd[n];if(s==null)throw new Error(`Non-base256emoji character: ${t}`);e.push(s)}return new Uint8Array(e)}var jd=ur({prefix:"\u{1F680}",name:"base256emoji",encode:Wd,decode:Zd});var Ro={};ke(Ro,{base64:()=>Yd,base64pad:()=>Xd,base64url:()=>No,base64urlpad:()=>Jd});var Yd=le({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Xd=le({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),No=le({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Jd=le({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var Lo={};ke(Lo,{base8:()=>Qd});var Qd=le({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var Uo={};ke(Uo,{identity:()=>ep});var ep=ur({prefix:"\0",name:"identity",encode:r=>mc(r),decode:r=>pc(r)});var Hg=new TextEncoder,Fg=new TextDecoder;var Mo={};ke(Mo,{sha256:()=>wr,sha512:()=>np});function Oo({name:r,code:e,encode:t}){return new Do(r,e,t)}var Do=class{name;code;encode;constructor(e,t,n){this.name=e,this.code=t,this.encode=n}digest(e){if(e instanceof Uint8Array){let t=this.encode(e);return t instanceof Uint8Array?Ze(this.code,t):t.then(n=>Ze(this.code,n))}else throw Error("Unknown type, must be binary type")}};function cl(r){return async e=>new Uint8Array(await crypto.subtle.digest(r,e))}var wr=Oo({name:"sha2-256",code:18,encode:cl("SHA-256")}),np=Oo({name:"sha2-512",code:19,encode:cl("SHA-512")});var Zr={...Uo,...ko,...Lo,...Io,...To,...$i,...Gi,...zi,...Ro,...Co},Qg={...Mo,...ji};function ul(r,e,t,n){return{name:r,prefix:e,encoder:{name:r,prefix:e,encode:t},decoder:{decode:n}}}var ll=ul("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),Po=ul("ascii","a",r=>{let e="a";for(let t=0;t<r.length;t++)e+=String.fromCharCode(r[t]);return e},r=>{r=r.substring(1);let e=De(r.length);for(let t=0;t<r.length;t++)e[t]=r.charCodeAt(t);return e}),sp={utf8:ll,"utf-8":ll,hex:Zr.base16,latin1:Po,ascii:Po,binary:Po,...Zr},$n=sp;function G(r,e="utf8"){let t=$n[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.decoder.decode(`${t.prefix}${r}`)}function Vo(r){let e=r??8192,t=e>>>1,n,s=e;return function(o){if(o<1||o>t)return De(o);s+o>e&&(n=De(e),s=0);let a=n.subarray(s,s+=o);return s&7&&(s=(s|7)+1),a}}var er=class{fn;len;next;val;constructor(e,t,n){this.fn=e,this.len=t,this.next=void 0,this.val=n}};function Ho(){}var Ko=class{head;tail;len;next;constructor(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}},ip=Vo();function op(r){return globalThis.Buffer!=null?De(r):ip(r)}var Yr=class{len;head;tail;states;constructor(){this.len=0,this.head=new er(Ho,0,0),this.tail=this.head,this.states=null}_push(e,t,n){return this.tail=this.tail.next=new er(e,t,n),this.len+=t,this}uint32(e){return this.len+=(this.tail=this.tail.next=new qo((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this}int32(e){return e<0?this._push(Gn,10,He.fromNumber(e)):this.uint32(e)}sint32(e){return this.uint32((e<<1^e>>31)>>>0)}uint64(e){let t=He.fromBigInt(e);return this._push(Gn,t.length(),t)}uint64Number(e){return this._push(xo,Se(e),e)}uint64String(e){return this.uint64(BigInt(e))}int64(e){return this.uint64(e)}int64Number(e){return this.uint64Number(e)}int64String(e){return this.uint64String(e)}sint64(e){let t=He.fromBigInt(e).zzEncode();return this._push(Gn,t.length(),t)}sint64Number(e){let t=He.fromNumber(e).zzEncode();return this._push(Gn,t.length(),t)}sint64String(e){return this.sint64(BigInt(e))}bool(e){return this._push(Fo,1,e?1:0)}fixed32(e){return this._push(jr,4,e>>>0)}sfixed32(e){return this.fixed32(e)}fixed64(e){let t=He.fromBigInt(e);return this._push(jr,4,t.lo)._push(jr,4,t.hi)}fixed64Number(e){let t=He.fromNumber(e);return this._push(jr,4,t.lo)._push(jr,4,t.hi)}fixed64String(e){return this.fixed64(BigInt(e))}sfixed64(e){return this.fixed64(e)}sfixed64Number(e){return this.fixed64Number(e)}sfixed64String(e){return this.fixed64String(e)}float(e){return this._push(Jc,4,e)}double(e){return this._push(el,8,e)}bytes(e){let t=e.length>>>0;return t===0?this._push(Fo,1,0):this.uint32(t)._push(cp,t,e)}string(e){let t=nl(e);return t!==0?this.uint32(t)._push(Ao,t,e):this._push(Fo,1,0)}fork(){return this.states=new Ko(this),this.head=this.tail=new er(Ho,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new er(Ho,0,0),this.len=0),this}ldelim(){let e=this.head,t=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=e.next,this.tail=t,this.len+=n),this}finish(){let e=this.head.next,t=op(this.len),n=0;for(;e!=null;)e.fn(e.val,t,n),n+=e.len,e=e.next;return t}};function Fo(r,e,t){e[t]=r&255}function ap(r,e,t){for(;r>127;)e[t++]=r&127|128,r>>>=7;e[t]=r}var qo=class extends er{next;constructor(e,t){super(ap,e,t),this.next=void 0}};function Gn(r,e,t){for(;r.hi!==0;)e[t++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)e[t++]=r.lo&127|128,r.lo=r.lo>>>7;e[t++]=r.lo}function jr(r,e,t){e[t]=r&255,e[t+1]=r>>>8&255,e[t+2]=r>>>16&255,e[t+3]=r>>>24}function cp(r,e,t){e.set(r,t)}globalThis.Buffer!=null&&(Yr.prototype.bytes=function(r){let e=r.length>>>0;return this.uint32(e),e>0&&this._push(lp,e,r),this},Yr.prototype.string=function(r){let e=globalThis.Buffer.byteLength(r);return this.uint32(e),e>0&&this._push(up,e,r),this});function lp(r,e,t){e.set(r,t)}function up(r,e,t){r.length<40?Ao(r,e,t):e.utf8Write!=null?e.utf8Write(r,t):e.set(G(r),t)}function zo(){return new Yr}function Me(r,e){let t=zo();return e.encode(r,t,{lengthDelimited:!1}),t.finish()}var xr;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(xr||(xr={}));function Wn(r,e,t,n){return{name:r,type:e,encode:t,decode:n}}function tr(r){function e(s){if(r[s.toString()]==null)throw new Error("Invalid enum value");return r[s]}let t=function(i,o){let a=e(i);o.int32(a)},n=function(i){let o=i.int32();return e(o)};return Wn("enum",xr.VARINT,t,n)}function Pe(r,e){return Wn("message",xr.LENGTH_DELIMITED,r,e)}var Xr=class extends Error{code="ERR_MAX_LENGTH";name="MaxLengthError"};var fe;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1"})(fe||(fe={}));var $o;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1"})($o||($o={}));(function(r){r.codec=()=>tr($o)})(fe||(fe={}));var ot;(function(r){let e;r.codec=()=>(e==null&&(e=Pe((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),fe.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{let i={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){let a=t.uint32();switch(a>>>3){case 1:{i.Type=fe.codec().decode(t);break}case 2:{i.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>Me(t,r.codec()),r.decode=(t,n)=>Oe(t,r.codec(),n)})(ot||(ot={}));var Go;(function(r){let e;r.codec=()=>(e==null&&(e=Pe((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),fe.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{let i={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){let a=t.uint32();switch(a>>>3){case 1:{i.Type=fe.codec().decode(t);break}case 2:{i.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>Me(t,r.codec()),r.decode=(t,n)=>Oe(t,r.codec(),n)})(Go||(Go={}));var cn={};ke(cn,{MAX_RSA_KEY_SIZE:()=>Ps,generateRSAKeyPair:()=>au,jwkToJWKKeyPair:()=>cu,jwkToPkcs1:()=>_p,jwkToPkix:()=>ta,jwkToRSAPrivateKey:()=>ou,pkcs1ToJwk:()=>nu,pkcs1ToRSAPrivateKey:()=>iu,pkixToJwk:()=>su,pkixToRSAPublicKey:()=>ra});var fp=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Pt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Vt=new Uint32Array(64),Wo=class extends yr{constructor(){super(64,32,8,!1),this.A=Pt[0]|0,this.B=Pt[1]|0,this.C=Pt[2]|0,this.D=Pt[3]|0,this.E=Pt[4]|0,this.F=Pt[5]|0,this.G=Pt[6]|0,this.H=Pt[7]|0}get(){let{A:e,B:t,C:n,D:s,E:i,F:o,G:a,H:c}=this;return[e,t,n,s,i,o,a,c]}set(e,t,n,s,i,o,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=a|0,this.H=c|0}process(e,t){for(let u=0;u<16;u++,t+=4)Vt[u]=e.getUint32(t,!1);for(let u=16;u<64;u++){let g=Vt[u-15],l=Vt[u-2],d=je(g,7)^je(g,18)^g>>>3,m=je(l,17)^je(l,19)^l>>>10;Vt[u]=m+Vt[u-7]+d+Vt[u-16]|0}let{A:n,B:s,C:i,D:o,E:a,F:c,G:h,H:f}=this;for(let u=0;u<64;u++){let g=je(a,6)^je(a,11)^je(a,25),l=f+g+Rc(a,c,h)+fp[u]+Vt[u]|0,m=(je(n,2)^je(n,13)^je(n,22))+Lc(n,s,i)|0;f=h,h=c,c=a,a=o+l|0,o=i,i=s,s=n,n=l+m|0}n=n+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,h=h+this.G|0,f=f+this.H|0,this.set(n,s,i,o,a,c,h,f)}roundClean(){Vt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var vr=Cn(()=>new Wo);var z=ic(hl());function rr(r,e){let t=0;if(r.length===1)return r[0];for(let n=r.length-1;n>=0;n--)t+=r[r.length-1-n]*Math.pow(2,e*n);return t}function Ht(r,e,t=-1){let n=t,s=r,i=0,o=Math.pow(2,e);for(let a=1;a<8;a++){if(r<o){let c;if(n<0)c=new ArrayBuffer(a),i=a;else{if(n<a)return new ArrayBuffer(0);c=new ArrayBuffer(n),i=n}let h=new Uint8Array(c);for(let f=a-1;f>=0;f--){let u=Math.pow(2,f*e);h[i-f-1]=Math.floor(s/u),s-=h[i-f-1]*u}return c}o*=Math.pow(2,e)}return new ArrayBuffer(0)}function Yn(...r){let e=0,t=0;for(let i of r)e+=i.length;let n=new ArrayBuffer(e),s=new Uint8Array(n);for(let i of r)s.set(i,t),t+=i.length;return s}function jo(){let r=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){let a=r[0]===255&&r[1]&128,c=r[0]===0&&(r[1]&128)===0;(a||c)&&this.warnings.push("Needlessly long format")}let e=new ArrayBuffer(this.valueHex.byteLength),t=new Uint8Array(e);for(let a=0;a<this.valueHex.byteLength;a++)t[a]=0;t[0]=r[0]&128;let n=rr(t,8),s=new ArrayBuffer(this.valueHex.byteLength),i=new Uint8Array(s);for(let a=0;a<this.valueHex.byteLength;a++)i[a]=r[a];return i[0]&=127,rr(i,8)-n}function dl(r){let e=r<0?r*-1:r,t=128;for(let n=1;n<8;n++){if(e<=t){if(r<0){let o=t-e,a=Ht(o,8,n),c=new Uint8Array(a);return c[0]|=128,a}let s=Ht(e,8,n),i=new Uint8Array(s);if(i[0]&128){let o=s.slice(0),a=new Uint8Array(o);s=new ArrayBuffer(s.byteLength+1),i=new Uint8Array(s);for(let c=0;c<o.byteLength;c++)i[c+1]=a[c];i[0]=0}return s}t*=Math.pow(2,8)}return new ArrayBuffer(0)}function pl(r,e){if(r.byteLength!==e.byteLength)return!1;let t=new Uint8Array(r),n=new Uint8Array(e);for(let s=0;s<t.length;s++)if(t[s]!==n[s])return!1;return!0}function Ve(r,e){let t=r.toString(10);if(e<t.length)return"";let n=e-t.length,s=new Array(n);for(let o=0;o<n;o++)s[o]="0";return s.join("").concat(t)}var Uy=Math.log(2);function Xn(){if(typeof BigInt>"u")throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function Yo(r){let e=0,t=0;for(let s=0;s<r.length;s++){let i=r[s];e+=i.byteLength}let n=new Uint8Array(e);for(let s=0;s<r.length;s++){let i=r[s];n.set(new Uint8Array(i),t),t+=i.byteLength}return n.buffer}function At(r,e,t,n){return e instanceof Uint8Array?e.byteLength?t<0?(r.error="Wrong parameter: inputOffset less than zero",!1):n<0?(r.error="Wrong parameter: inputLength less than zero",!1):e.byteLength-t-n<0?(r.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):!0:(r.error="Wrong parameter: inputBuffer has zero length",!1):(r.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}var Qr=class{constructor(){this.items=[]}write(e){this.items.push(e)}final(){return Yo(this.items)}},Jr=[new Uint8Array([1])],ml="0123456789";var _r="",Qe=new ArrayBuffer(0),Xo=new Uint8Array(0),en="EndOfContent",yl="OCTET STRING",bl="BIT STRING";function Bt(r){var e;return e=class extends r{constructor(...n){var s;super(...n);let i=n[0]||{};this.isHexOnly=(s=i.isHexOnly)!==null&&s!==void 0?s:!1,this.valueHexView=i.valueHex?z.BufferSourceConverter.toUint8Array(i.valueHex):Xo}get valueHex(){return this.valueHexView.slice().buffer}set valueHex(n){this.valueHexView=new Uint8Array(n)}fromBER(n,s,i){let o=n instanceof ArrayBuffer?new Uint8Array(n):n;if(!At(this,o,s,i))return-1;let a=s+i;return this.valueHexView=o.subarray(s,a),this.valueHexView.length?(this.blockLength=i,a):(this.warnings.push("Zero buffer length"),s)}toBER(n=!1){return this.isHexOnly?n?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",Qe)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:z.Convert.ToHex(this.valueHexView)}}},e.NAME="hexBlock",e}var vt=class{constructor({blockLength:e=0,error:t=_r,warnings:n=[],valueBeforeDecode:s=Xo}={}){this.blockLength=e,this.error=t,this.warnings=n,this.valueBeforeDecodeView=z.BufferSourceConverter.toUint8Array(s)}static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(e){this.valueBeforeDecodeView=new Uint8Array(e)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:z.Convert.ToHex(this.valueBeforeDecodeView)}}};vt.NAME="baseBlock";var Be=class extends vt{fromBER(e,t,n){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(e,t){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}};Be.NAME="valueBlock";var Jn=class extends Bt(vt){constructor({idBlock:e={}}={}){var t,n,s,i;super(),e?(this.isHexOnly=(t=e.isHexOnly)!==null&&t!==void 0?t:!1,this.valueHexView=e.valueHex?z.BufferSourceConverter.toUint8Array(e.valueHex):Xo,this.tagClass=(n=e.tagClass)!==null&&n!==void 0?n:-1,this.tagNumber=(s=e.tagNumber)!==null&&s!==void 0?s:-1,this.isConstructed=(i=e.isConstructed)!==null&&i!==void 0?i:!1):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(e=!1){let t=0;switch(this.tagClass){case 1:t|=0;break;case 2:t|=64;break;case 3:t|=128;break;case 4:t|=192;break;default:return this.error="Unknown tag class",Qe}if(this.isConstructed&&(t|=32),this.tagNumber<31&&!this.isHexOnly){let s=new Uint8Array(1);if(!e){let i=this.tagNumber;i&=31,t|=i,s[0]=t}return s.buffer}if(!this.isHexOnly){let s=Ht(this.tagNumber,7),i=new Uint8Array(s),o=s.byteLength,a=new Uint8Array(o+1);if(a[0]=t|31,!e){for(let c=0;c<o-1;c++)a[c+1]=i[c]|128;a[o]=i[o-1]}return a.buffer}let n=new Uint8Array(this.valueHexView.byteLength+1);if(n[0]=t|31,!e){let s=this.valueHexView;for(let i=0;i<s.length-1;i++)n[i+1]=s[i]|128;n[this.valueHexView.byteLength]=s[s.length-1]}return n.buffer}fromBER(e,t,n){let s=z.BufferSourceConverter.toUint8Array(e);if(!At(this,s,t,n))return-1;let i=s.subarray(t,t+n);if(i.length===0)return this.error="Zero buffer length",-1;switch(i[0]&192){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=(i[0]&32)===32,this.isHexOnly=!1;let a=i[0]&31;if(a!==31)this.tagNumber=a,this.blockLength=1;else{let c=1,h=this.valueHexView=new Uint8Array(255),f=255;for(;i[c]&128;){if(h[c-1]=i[c]&127,c++,c>=i.length)return this.error="End of input reached before message was fully decoded",-1;if(c===f){f+=255;let g=new Uint8Array(f);for(let l=0;l<h.length;l++)g[l]=h[l];h=this.valueHexView=new Uint8Array(f)}}this.blockLength=c+1,h[c-1]=i[c]&127;let u=new Uint8Array(c);for(let g=0;g<c;g++)u[g]=h[g];h=this.valueHexView=new Uint8Array(c),h.set(u),this.blockLength<=9?this.tagNumber=rr(h,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(this.tagClass===1&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}};Jn.NAME="identificationBlock";var Qn=class extends vt{constructor({lenBlock:e={}}={}){var t,n,s;super(),this.isIndefiniteForm=(t=e.isIndefiniteForm)!==null&&t!==void 0?t:!1,this.longFormUsed=(n=e.longFormUsed)!==null&&n!==void 0?n:!1,this.length=(s=e.length)!==null&&s!==void 0?s:0}fromBER(e,t,n){let s=z.BufferSourceConverter.toUint8Array(e);if(!At(this,s,t,n))return-1;let i=s.subarray(t,t+n);if(i.length===0)return this.error="Zero buffer length",-1;if(i[0]===255)return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=i[0]===128,this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(i[0]&128),this.longFormUsed===!1)return this.length=i[0],this.blockLength=1,t+this.blockLength;let o=i[0]&127;if(o>8)return this.error="Too big integer",-1;if(o+1>i.length)return this.error="End of input reached before message was fully decoded",-1;let a=t+1,c=s.subarray(a,a+o);return c[o-1]===0&&this.warnings.push("Needlessly long encoded length"),this.length=rr(c,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=o+1,t+this.blockLength}toBER(e=!1){let t,n;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),e===!1&&(n=new Uint8Array(t),n[0]=128),t;if(this.longFormUsed){let s=Ht(this.length,8);if(s.byteLength>127)return this.error="Too big length",Qe;if(t=new ArrayBuffer(s.byteLength+1),e)return t;let i=new Uint8Array(s);n=new Uint8Array(t),n[0]=s.byteLength|128;for(let o=0;o<s.byteLength;o++)n[o+1]=i[o];return t}return t=new ArrayBuffer(1),e===!1&&(n=new Uint8Array(t),n[0]=this.length),t}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}};Qn.NAME="lengthBlock";var k={},be=class extends vt{constructor({name:e=_r,optional:t=!1,primitiveSchema:n,...s}={},i){super(s),this.name=e,this.optional=t,n&&(this.primitiveSchema=n),this.idBlock=new Jn(s),this.lenBlock=new Qn(s),this.valueBlock=i?new i(s):new Be(s)}fromBER(e,t,n){let s=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}toBER(e,t){let n=t||new Qr;t||wl(this);let s=this.idBlock.toBER(e);if(n.write(s),this.lenBlock.isIndefiniteForm)n.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(e,n),n.write(new ArrayBuffer(2));else{let i=this.valueBlock.toBER(e);this.lenBlock.length=i.byteLength;let o=this.lenBlock.toBER(e);n.write(o),n.write(i)}return t?Qe:n.final()}toJSON(){let e={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}toString(e="ascii"){return e==="ascii"?this.onAsciiEncoding():z.Convert.ToHex(this.toBER())}onAsciiEncoding(){return`${this.constructor.NAME} : ${z.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`}isEqual(e){if(this===e)return!0;if(!(e instanceof this.constructor))return!1;let t=this.toBER(),n=e.toBER();return pl(t,n)}};be.NAME="BaseBlock";function wl(r){if(r instanceof k.Constructed)for(let e of r.valueBlock.value)wl(e)&&(r.lenBlock.isIndefiniteForm=!0);return!!r.lenBlock.isIndefiniteForm}var es=class extends be{constructor({value:e=_r,...t}={},n){super(t,n),e&&this.fromString(e)}getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}fromBER(e,t,n){let s=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}};es.NAME="BaseStringBlock";var ts=class extends Bt(Be){constructor({isHexOnly:e=!0,...t}={}){super(t),this.isHexOnly=e}};ts.NAME="PrimitiveValueBlock";var xl,rs=class extends be{constructor(e={}){super(e,ts),this.idBlock.isConstructed=!1}};xl=rs;k.Primitive=xl;rs.NAME="PRIMITIVE";function xp(r,e){if(r instanceof e)return r;let t=new e;return t.idBlock=r.idBlock,t.lenBlock=r.lenBlock,t.warnings=r.warnings,t.valueBeforeDecodeView=r.valueBeforeDecodeView,t}function Os(r,e=0,t=r.length){let n=e,s=new be({},Be),i=new vt;if(!At(i,r,e,t))return s.error=i.error,{offset:-1,result:s};if(!r.subarray(e,e+t).length)return s.error="Zero buffer length",{offset:-1,result:s};let a=s.idBlock.fromBER(r,e,t);if(s.idBlock.warnings.length&&s.warnings.concat(s.idBlock.warnings),a===-1)return s.error=s.idBlock.error,{offset:-1,result:s};if(e=a,t-=s.idBlock.blockLength,a=s.lenBlock.fromBER(r,e,t),s.lenBlock.warnings.length&&s.warnings.concat(s.lenBlock.warnings),a===-1)return s.error=s.lenBlock.error,{offset:-1,result:s};if(e=a,t-=s.lenBlock.blockLength,!s.idBlock.isConstructed&&s.lenBlock.isIndefiniteForm)return s.error="Indefinite length form used for primitive encoding form",{offset:-1,result:s};let c=be;switch(s.idBlock.tagClass){case 1:if(s.idBlock.tagNumber>=37&&s.idBlock.isHexOnly===!1)return s.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:s};switch(s.idBlock.tagNumber){case 0:if(s.idBlock.isConstructed&&s.lenBlock.length>0)return s.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:s};c=k.EndOfContent;break;case 1:c=k.Boolean;break;case 2:c=k.Integer;break;case 3:c=k.BitString;break;case 4:c=k.OctetString;break;case 5:c=k.Null;break;case 6:c=k.ObjectIdentifier;break;case 10:c=k.Enumerated;break;case 12:c=k.Utf8String;break;case 13:c=k.RelativeObjectIdentifier;break;case 14:c=k.TIME;break;case 15:return s.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:s};case 16:c=k.Sequence;break;case 17:c=k.Set;break;case 18:c=k.NumericString;break;case 19:c=k.PrintableString;break;case 20:c=k.TeletexString;break;case 21:c=k.VideotexString;break;case 22:c=k.IA5String;break;case 23:c=k.UTCTime;break;case 24:c=k.GeneralizedTime;break;case 25:c=k.GraphicString;break;case 26:c=k.VisibleString;break;case 27:c=k.GeneralString;break;case 28:c=k.UniversalString;break;case 29:c=k.CharacterString;break;case 30:c=k.BmpString;break;case 31:c=k.DATE;break;case 32:c=k.TimeOfDay;break;case 33:c=k.DateTime;break;case 34:c=k.Duration;break;default:{let h=s.idBlock.isConstructed?new k.Constructed:new k.Primitive;h.idBlock=s.idBlock,h.lenBlock=s.lenBlock,h.warnings=s.warnings,s=h}}break;case 2:case 3:case 4:default:c=s.idBlock.isConstructed?k.Constructed:k.Primitive}return s=xp(s,c),a=s.fromBER(r,e,s.lenBlock.isIndefiniteForm?t:s.lenBlock.length),s.valueBeforeDecodeView=r.subarray(n,n+s.blockLength),{offset:a,result:s}}function Jo(r){if(!r.byteLength){let e=new be({},Be);return e.error="Input buffer has zero length",{offset:-1,result:e}}return Os(z.BufferSourceConverter.toUint8Array(r).slice(),0,r.byteLength)}function vp(r,e){return r?1:e}var at=class extends Be{constructor({value:e=[],isIndefiniteForm:t=!1,...n}={}){super(n),this.value=e,this.isIndefiniteForm=t}fromBER(e,t,n){let s=z.BufferSourceConverter.toUint8Array(e);if(!At(this,s,t,n))return-1;if(this.valueBeforeDecodeView=s.subarray(t,t+n),this.valueBeforeDecodeView.length===0)return this.warnings.push("Zero buffer length"),t;let i=t;for(;vp(this.isIndefiniteForm,n)>0;){let o=Os(s,i,n);if(o.offset===-1)return this.error=o.result.error,this.warnings.concat(o.result.warnings),-1;if(i=o.offset,this.blockLength+=o.result.blockLength,n-=o.result.blockLength,this.value.push(o.result),this.isIndefiniteForm&&o.result.constructor.NAME===en)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===en?this.value.pop():this.warnings.push("No EndOfContent block encoded")),i}toBER(e,t){let n=t||new Qr;for(let s=0;s<this.value.length;s++)this.value[s].toBER(e,n);return t?Qe:n.final()}toJSON(){let e={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(let t of this.value)e.value.push(t.toJSON());return e}};at.NAME="ConstructedValueBlock";var vl,Ft=class extends be{constructor(e={}){super(e,at),this.idBlock.isConstructed=!0}fromBER(e,t,n){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;let s=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){let e=[];for(let n of this.valueBlock.value)e.push(n.toString("ascii").split(`
./node_modules/@libp2p/circuit-relay-v2/dist/index.min.js:6:`)}`:`${t} :`}};vl=Ft;k.Constructed=vl;Ft.NAME="CONSTRUCTED";var ns=class extends Be{fromBER(e,t,n){return t}toBER(e){return Qe}};ns.override="EndOfContentValueBlock";var El,ss=class extends be{constructor(e={}){super(e,ns),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}};El=ss;k.EndOfContent=El;ss.NAME=en;var Sl,Sr=class extends be{constructor(e={}){super(e,Be),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}fromBER(e,t,n){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=n,t+n>e.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):t+n}toBER(e,t){let n=new ArrayBuffer(2);if(!e){let s=new Uint8Array(n);s[0]=5,s[1]=0}return t&&t.write(n),n}onAsciiEncoding(){return`${this.constructor.NAME}`}};Sl=Sr;k.Null=Sl;Sr.NAME="NULL";var is=class extends Bt(Be){constructor({value:e,...t}={}){super(t),t.valueHex?this.valueHexView=z.BufferSourceConverter.toUint8Array(t.valueHex):this.valueHexView=new Uint8Array(1),e&&(this.value=e)}get value(){for(let e of this.valueHexView)if(e>0)return!0;return!1}set value(e){this.valueHexView[0]=e?255:0}fromBER(e,t,n){let s=z.BufferSourceConverter.toUint8Array(e);return At(this,s,t,n)?(this.valueHexView=s.subarray(t,t+n),n>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,jo.call(this),this.blockLength=n,t+n):-1}toBER(){return this.valueHexView.slice()}toJSON(){return{...super.toJSON(),value:this.value}}};is.NAME="BooleanValueBlock";var Al,os=class extends be{constructor(e={}){super(e,is),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.getValue}`}};Al=os;k.Boolean=Al;os.NAME="BOOLEAN";var as=class extends Bt(at){constructor({isConstructed:e=!1,...t}={}){super(t),this.isConstructed=e}fromBER(e,t,n){let s=0;if(this.isConstructed){if(this.isHexOnly=!1,s=at.prototype.fromBER.call(this,e,t,n),s===-1)return s;for(let i=0;i<this.value.length;i++){let o=this.value[i].constructor.NAME;if(o===en){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(o!==yl)return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,s=super.fromBER(e,t,n),this.blockLength=n;return s}toBER(e,t){return this.isConstructed?at.prototype.toBER.call(this,e,t):e?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),isConstructed:this.isConstructed}}};as.NAME="OctetStringValueBlock";var Bl,cs=class r extends be{constructor({idBlock:e={},lenBlock:t={},...n}={}){var s,i;(s=n.isConstructed)!==null&&s!==void 0||(n.isConstructed=!!(!((i=n.value)===null||i===void 0)&&i.length)),super({idBlock:{isConstructed:n.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!n.isIndefiniteForm},...n},as),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,n){if(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,n===0)return this.idBlock.error.length===0&&(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length===0&&(this.blockLength+=this.lenBlock.blockLength),t;if(!this.valueBlock.isConstructed){let i=(e instanceof ArrayBuffer?new Uint8Array(e):e).subarray(t,t+n);try{if(i.byteLength){let o=Os(i,0,i.byteLength);o.offset!==-1&&o.offset===n&&(this.valueBlock.value=[o.result])}}catch{}}return super.fromBER(e,t,n)}onAsciiEncoding(){return this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length?Ft.prototype.onAsciiEncoding.call(this):`${this.constructor.NAME} : ${z.Convert.ToHex(this.valueBlock.valueHexView)}`}getValue(){if(!this.idBlock.isConstructed)return this.valueBlock.valueHexView.slice().buffer;let e=[];for(let t of this.valueBlock.value)t instanceof r&&e.push(t.valueBlock.valueHexView);return z.BufferSourceConverter.concat(e)}};Bl=cs;k.OctetString=Bl;cs.NAME=yl;var ls=class extends Bt(at){constructor({unusedBits:e=0,isConstructed:t=!1,...n}={}){super(n),this.unusedBits=e,this.isConstructed=t,this.blockLength=this.valueHexView.byteLength}fromBER(e,t,n){if(!n)return t;let s=-1;if(this.isConstructed){if(s=at.prototype.fromBER.call(this,e,t,n),s===-1)return s;for(let a of this.value){let c=a.constructor.NAME;if(c===en){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(c!==bl)return this.error="BIT STRING may consists of BIT STRINGs only",-1;let h=a.valueBlock;if(this.unusedBits>0&&h.unusedBits>0)return this.error='Using of "unused bits" inside constructive BIT STRING allowed for least one only',-1;this.unusedBits=h.unusedBits}return s}let i=z.BufferSourceConverter.toUint8Array(e);if(!At(this,i,t,n))return-1;let o=i.subarray(t,t+n);if(this.unusedBits=o[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;if(!this.unusedBits){let a=o.subarray(1);try{if(a.byteLength){let c=Os(a,0,a.byteLength);c.offset!==-1&&c.offset===n-1&&(this.value=[c.result])}}catch{}}return this.valueHexView=o.subarray(1),this.blockLength=o.length,t+n}toBER(e,t){if(this.isConstructed)return at.prototype.toBER.call(this,e,t);if(e)return new ArrayBuffer(this.valueHexView.byteLength+1);if(!this.valueHexView.byteLength)return Qe;let n=new Uint8Array(this.valueHexView.length+1);return n[0]=this.unusedBits,n.set(this.valueHexView,1),n.buffer}toJSON(){return{...super.toJSON(),unusedBits:this.unusedBits,isConstructed:this.isConstructed}}};ls.NAME="BitStringValueBlock";var _l,Ar=class extends be{constructor({idBlock:e={},lenBlock:t={},...n}={}){var s,i;(s=n.isConstructed)!==null&&s!==void 0||(n.isConstructed=!!(!((i=n.value)===null||i===void 0)&&i.length)),super({idBlock:{isConstructed:n.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!n.isIndefiniteForm},...n},ls),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}fromBER(e,t,n){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,n)}onAsciiEncoding(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return Ft.prototype.onAsciiEncoding.call(this);{let e=[],t=this.valueBlock.valueHexView;for(let s of t)e.push(s.toString(2).padStart(8,"0"));let n=e.join("");return`${this.constructor.NAME} : ${n.substring(0,n.length-this.valueBlock.unusedBits)}`}}};_l=Ar;k.BitString=_l;Ar.NAME=bl;var Il;function Ep(r,e){let t=new Uint8Array([0]),n=new Uint8Array(r),s=new Uint8Array(e),i=n.slice(0),o=i.length-1,a=s.slice(0),c=a.length-1,h=0,f=c<o?o:c,u=0;for(let g=f;g>=0;g--,u++){switch(!0){case u<a.length:h=i[o-u]+a[c-u]+t[0];break;default:h=i[o-u]+t[0]}switch(t[0]=h/10,!0){case u>=i.length:i=Yn(new Uint8Array([h%10]),i);break;default:i[o-u]=h%10}}return t[0]>0&&(i=Yn(t,i)),i}function gl(r){if(r>=Jr.length)for(let e=Jr.length;e<=r;e++){let t=new Uint8Array([0]),n=Jr[e-1].slice(0);for(let s=n.length-1;s>=0;s--){let i=new Uint8Array([(n[s]<<1)+t[0]]);t[0]=i[0]/10,n[s]=i[0]%10}t[0]>0&&(n=Yn(t,n)),Jr.push(n)}return Jr[r]}function Sp(r,e){let t=0,n=new Uint8Array(r),s=new Uint8Array(e),i=n.slice(0),o=i.length-1,a=s.slice(0),c=a.length-1,h,f=0;for(let u=c;u>=0;u--,f++)switch(h=i[o-f]-a[c-f]-t,!0){case h<0:t=1,i[o-f]=h+10;break;default:t=0,i[o-f]=h}if(t>0)for(let u=o-c+1;u>=0;u--,f++)if(h=i[o-f]-t,h<0)t=1,i[o-f]=h+10;else{t=0,i[o-f]=h;break}return i.slice()}var tn=class extends Bt(Be){constructor({value:e,...t}={}){super(t),this._valueDec=0,t.valueHex&&this.setValueHex(),e!==void 0&&(this.valueDec=e)}setValueHex(){this.valueHexView.length>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,this.valueHexView.length>0&&(this._valueDec=jo.call(this)))}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this.valueHexView=new Uint8Array(dl(e))}get valueDec(){return this._valueDec}fromDER(e,t,n,s=0){let i=this.fromBER(e,t,n);if(i===-1)return i;let o=this.valueHexView;return o[0]===0&&o[1]&128?this.valueHexView=o.subarray(1):s!==0&&o.length<s&&(s-o.length>1&&(s=o.length+1),this.valueHexView=o.subarray(s-o.length)),i}toDER(e=!1){let t=this.valueHexView;switch(!0){case(t[0]&128)!==0:{let n=new Uint8Array(this.valueHexView.length+1);n[0]=0,n.set(t,1),this.valueHexView=n}break;case(t[0]===0&&(t[1]&128)===0):this.valueHexView=this.valueHexView.subarray(1);break}return this.toBER(e)}fromBER(e,t,n){let s=super.fromBER(e,t,n);return s===-1||this.setValueHex(),s}toBER(e){return e?new ArrayBuffer(this.valueHexView.length):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}toString(){let e=this.valueHexView.length*8-1,t=new Uint8Array(this.valueHexView.length*8/3),n=0,s,i=this.valueHexView,o="",a=!1;for(let c=i.byteLength-1;c>=0;c--){s=i[c];for(let h=0;h<8;h++){if((s&1)===1)switch(n){case e:t=Sp(gl(n),t),o="-";break;default:t=Ep(t,gl(n))}n++,s>>=1}}for(let c=0;c<t.length;c++)t[c]&&(a=!0),a&&(o+=ml.charAt(t[c]));return a===!1&&(o+=ml.charAt(0)),o}};Il=tn;tn.NAME="IntegerValueBlock";Object.defineProperty(Il.prototype,"valueHex",{set:function(r){this.valueHexView=new Uint8Array(r),this.setValueHex()},get:function(){return this.valueHexView.slice().buffer}});var Tl,we=class r extends be{constructor(e={}){super(e,tn),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}toBigInt(){return Xn(),BigInt(this.valueBlock.toString())}static fromBigInt(e){Xn();let t=BigInt(e),n=new Qr,s=t.toString(16).replace(/^-/,""),i=new Uint8Array(z.Convert.FromHex(s));if(t<0){let a=new Uint8Array(i.length+(i[0]&128?1:0));a[0]|=128;let h=BigInt(`0x${z.Convert.ToHex(a)}`)+t,f=z.BufferSourceConverter.toUint8Array(z.Convert.FromHex(h.toString(16)));f[0]|=128,n.write(f)}else i[0]&128&&n.write(new Uint8Array([0])),n.write(i);return new r({valueHex:n.final()})}convertToDER(){let e=new r({valueHex:this.valueBlock.valueHexView});return e.valueBlock.toDER(),e}convertFromDER(){return new r({valueHex:this.valueBlock.valueHexView[0]===0?this.valueBlock.valueHexView.subarray(1):this.valueBlock.valueHexView})}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()}`}};Tl=we;k.Integer=Tl;we.NAME="INTEGER";var kl,us=class extends we{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}};kl=us;k.Enumerated=kl;us.NAME="ENUMERATED";var rn=class extends Bt(Be){constructor({valueDec:e=-1,isFirstSid:t=!1,...n}={}){super(n),this.valueDec=e,this.isFirstSid=t}fromBER(e,t,n){if(!n)return t;let s=z.BufferSourceConverter.toUint8Array(e);if(!At(this,s,t,n))return-1;let i=s.subarray(t,t+n);this.valueHexView=new Uint8Array(n);for(let a=0;a<n&&(this.valueHexView[a]=i[a]&127,this.blockLength++,!!(i[a]&128));a++);let o=new Uint8Array(this.blockLength);for(let a=0;a<this.blockLength;a++)o[a]=this.valueHexView[a];return this.valueHexView=o,i[this.blockLength-1]&128?(this.error="End of input reached before message was fully decoded",-1):(this.valueHexView[0]===0&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=rr(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}set valueBigInt(e){Xn();let t=BigInt(e).toString(2);for(;t.length%7;)t="0"+t;let n=new Uint8Array(t.length/7);for(let s=0;s<n.length;s++)n[s]=parseInt(t.slice(s*7,s*7+7),2)+(s+1<n.length?128:0);this.fromBER(n.buffer,0,n.length)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);let s=this.valueHexView,i=new Uint8Array(this.blockLength);for(let o=0;o<this.blockLength-1;o++)i[o]=s[o]|128;return i[this.blockLength-1]=s[this.blockLength-1],i.buffer}let t=Ht(this.valueDec,7);if(t.byteLength===0)return this.error="Error during encoding SID value",Qe;let n=new Uint8Array(t.byteLength);if(!e){let s=new Uint8Array(t),i=t.byteLength-1;for(let o=0;o<i;o++)n[o]=s[o]|128;n[i]=s[i]}return n}toString(){let e="";if(this.isHexOnly)e=z.Convert.ToHex(this.valueHexView);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec,isFirstSid:this.isFirstSid}}};rn.NAME="sidBlock";var fs=class extends Be{constructor({value:e=_r,...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,n){let s=t;for(;n>0;){let i=new rn;if(s=i.fromBER(e,s,n),s===-1)return this.blockLength=0,this.error=i.error,s;this.value.length===0&&(i.isFirstSid=!0),this.blockLength+=i.blockLength,n-=i.blockLength,this.value.push(i)}return s}toBER(e){let t=[];for(let n=0;n<this.value.length;n++){let s=this.value[n].toBER(e);if(s.byteLength===0)return this.error=this.value[n].error,Qe;t.push(s)}return Yo(t)}fromString(e){this.value=[];let t=0,n=0,s="",i=!1;do if(n=e.indexOf(".",t),n===-1?s=e.substring(t):s=e.substring(t,n),t=n+1,i){let o=this.value[0],a=0;switch(o.valueDec){case 0:break;case 1:a=40;break;case 2:a=80;break;default:this.value=[];return}let c=parseInt(s,10);if(isNaN(c))return;o.valueDec=c+a,i=!1}else{let o=new rn;if(s>Number.MAX_SAFE_INTEGER){Xn();let a=BigInt(s);o.valueBigInt=a}else if(o.valueDec=parseInt(s,10),isNaN(o.valueDec))return;this.value.length||(o.isFirstSid=!0,i=!0),this.value.push(o)}while(n!==-1)}toString(){let e="",t=!1;for(let n=0;n<this.value.length;n++){t=this.value[n].isHexOnly;let s=this.value[n].toString();n!==0&&(e=`${e}.`),t?(s=`{${s}}`,this.value[n].isFirstSid?e=`2.{${s} - 80}`:e+=s):e+=s}return e}toJSON(){let e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}};fs.NAME="ObjectIdentifierValueBlock";var Cl,Br=class extends be{constructor(e={}){super(e,fs),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}};Cl=Br;k.ObjectIdentifier=Cl;Br.NAME="OBJECT IDENTIFIER";var nn=class extends Bt(vt){constructor({valueDec:e=0,...t}={}){super(t),this.valueDec=e}fromBER(e,t,n){if(n===0)return t;let s=z.BufferSourceConverter.toUint8Array(e);if(!At(this,s,t,n))return-1;let i=s.subarray(t,t+n);this.valueHexView=new Uint8Array(n);for(let a=0;a<n&&(this.valueHexView[a]=i[a]&127,this.blockLength++,!!(i[a]&128));a++);let o=new Uint8Array(this.blockLength);for(let a=0;a<this.blockLength;a++)o[a]=this.valueHexView[a];return this.valueHexView=o,i[this.blockLength-1]&128?(this.error="End of input reached before message was fully decoded",-1):(this.valueHexView[0]===0&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=rr(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);let s=this.valueHexView,i=new Uint8Array(this.blockLength);for(let o=0;o<this.blockLength-1;o++)i[o]=s[o]|128;return i[this.blockLength-1]=s[this.blockLength-1],i.buffer}let t=Ht(this.valueDec,7);if(t.byteLength===0)return this.error="Error during encoding SID value",Qe;let n=new Uint8Array(t.byteLength);if(!e){let s=new Uint8Array(t),i=t.byteLength-1;for(let o=0;o<i;o++)n[o]=s[o]|128;n[i]=s[i]}return n.buffer}toString(){let e="";return this.isHexOnly?e=z.Convert.ToHex(this.valueHexView):e=this.valueDec.toString(),e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}};nn.NAME="relativeSidBlock";var hs=class extends Be{constructor({value:e=_r,...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,n){let s=t;for(;n>0;){let i=new nn;if(s=i.fromBER(e,s,n),s===-1)return this.blockLength=0,this.error=i.error,s;this.blockLength+=i.blockLength,n-=i.blockLength,this.value.push(i)}return s}toBER(e,t){let n=[];for(let s=0;s<this.value.length;s++){let i=this.value[s].toBER(e);if(i.byteLength===0)return this.error=this.value[s].error,Qe;n.push(i)}return Yo(n)}fromString(e){this.value=[];let t=0,n=0,s="";do{n=e.indexOf(".",t),n===-1?s=e.substring(t):s=e.substring(t,n),t=n+1;let i=new nn;if(i.valueDec=parseInt(s,10),isNaN(i.valueDec))return!0;this.value.push(i)}while(n!==-1);return!0}toString(){let e="",t=!1;for(let n=0;n<this.value.length;n++){t=this.value[n].isHexOnly;let s=this.value[n].toString();n!==0&&(e=`${e}.`),t&&(s=`{${s}}`),e+=s}return e}toJSON(){let e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}};hs.NAME="RelativeObjectIdentifierValueBlock";var Nl,ds=class extends be{constructor(e={}){super(e,hs),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}};Nl=ds;k.RelativeObjectIdentifier=Nl;ds.NAME="RelativeObjectIdentifier";var Rl,Et=class extends Ft{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}};Rl=Et;k.Sequence=Rl;Et.NAME="SEQUENCE";var Ll,ps=class extends Ft{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}};Ll=ps;k.Set=Ll;ps.NAME="SET";var ms=class extends Bt(Be){constructor({...e}={}){super(e),this.isHexOnly=!0,this.value=_r}toJSON(){return{...super.toJSON(),value:this.value}}};ms.NAME="StringValueBlock";var gs=class extends ms{};gs.NAME="SimpleStringValueBlock";var Ce=class extends es{constructor({...e}={}){super(e,gs)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,z.BufferSourceConverter.toUint8Array(e))}fromString(e){let t=e.length,n=this.valueBlock.valueHexView=new Uint8Array(t);for(let s=0;s<t;s++)n[s]=e.charCodeAt(s);this.valueBlock.value=e}};Ce.NAME="SIMPLE STRING";var ys=class extends Ce{fromBuffer(e){this.valueBlock.valueHexView=z.BufferSourceConverter.toUint8Array(e);try{this.valueBlock.value=z.Convert.ToUtf8String(e)}catch(t){this.warnings.push(`Error during "decodeURIComponent": ${t}, using raw string`),this.valueBlock.value=z.Convert.ToBinary(e)}}fromString(e){this.valueBlock.valueHexView=new Uint8Array(z.Convert.FromUtf8String(e)),this.valueBlock.value=e}};ys.NAME="Utf8StringValueBlock";var Ul,St=class extends ys{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}};Ul=St;k.Utf8String=Ul;St.NAME="UTF8String";var bs=class extends Ce{fromBuffer(e){this.valueBlock.value=z.Convert.ToUtf16String(e),this.valueBlock.valueHexView=z.BufferSourceConverter.toUint8Array(e)}fromString(e){this.valueBlock.value=e,this.valueBlock.valueHexView=new Uint8Array(z.Convert.FromUtf16String(e))}};bs.NAME="BmpStringValueBlock";var Dl,ws=class extends bs{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}};Dl=ws;k.BmpString=Dl;ws.NAME="BMPString";var xs=class extends Ce{fromBuffer(e){let t=ArrayBuffer.isView(e)?e.slice().buffer:e.slice(0),n=new Uint8Array(t);for(let s=0;s<n.length;s+=4)n[s]=n[s+3],n[s+1]=n[s+2],n[s+2]=0,n[s+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){let t=e.length,n=this.valueBlock.valueHexView=new Uint8Array(t*4);for(let s=0;s<t;s++){let i=Ht(e.charCodeAt(s),8),o=new Uint8Array(i);if(o.length>4)continue;let a=4-o.length;for(let c=o.length-1;c>=0;c--)n[s*4+c+a]=o[c]}this.valueBlock.value=e}};xs.NAME="UniversalStringValueBlock";var Ol,vs=class extends xs{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}};Ol=vs;k.UniversalString=Ol;vs.NAME="UniversalString";var Ml,Es=class extends Ce{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}};Ml=Es;k.NumericString=Ml;Es.NAME="NumericString";var Pl,Ss=class extends Ce{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}};Pl=Ss;k.PrintableString=Pl;Ss.NAME="PrintableString";var Vl,As=class extends Ce{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}};Vl=As;k.TeletexString=Vl;As.NAME="TeletexString";var Hl,Bs=class extends Ce{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}};Hl=Bs;k.VideotexString=Hl;Bs.NAME="VideotexString";var Fl,_s=class extends Ce{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}};Fl=_s;k.IA5String=Fl;_s.NAME="IA5String";var Kl,Is=class extends Ce{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}};Kl=Is;k.GraphicString=Kl;Is.NAME="GraphicString";var ql,sn=class extends Ce{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}};ql=sn;k.VisibleString=ql;sn.NAME="VisibleString";var zl,Ts=class extends Ce{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}};zl=Ts;k.GeneralString=zl;Ts.NAME="GeneralString";var $l,ks=class extends Ce{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}};$l=ks;k.CharacterString=$l;ks.NAME="CharacterString";var Gl,on=class extends sn{constructor({value:e,valueDate:t,...n}={}){if(super(n),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,e){this.fromString(e),this.valueBlock.valueHexView=new Uint8Array(e.length);for(let s=0;s<e.length;s++)this.valueBlock.valueHexView[s]=e.charCodeAt(s)}t&&(this.fromDate(t),this.valueBlock.valueHexView=new Uint8Array(this.toBuffer())),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,z.BufferSourceConverter.toUint8Array(e)))}toBuffer(){let e=this.toString(),t=new ArrayBuffer(e.length),n=new Uint8Array(t);for(let s=0;s<e.length;s++)n[s]=e.charCodeAt(s);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){let n=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig.exec(e);if(n===null){this.error="Wrong input string for conversion";return}let s=parseInt(n[1],10);s>=50?this.year=1900+s:this.year=2e3+s,this.month=parseInt(n[2],10),this.day=parseInt(n[3],10),this.hour=parseInt(n[4],10),this.minute=parseInt(n[5],10),this.second=parseInt(n[6],10)}toString(e="iso"){if(e==="iso"){let t=new Array(7);return t[0]=Ve(this.year<2e3?this.year-1900:this.year-2e3,2),t[1]=Ve(this.month,2),t[2]=Ve(this.day,2),t[3]=Ve(this.hour,2),t[4]=Ve(this.minute,2),t[5]=Ve(this.second,2),t[6]="Z",t.join("")}return super.toString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.toDate().toISOString()}`}toJSON(){return{...super.toJSON(),year:this.year,month:this.month,day:this.day,hour:this.hour,minute:this.minute,second:this.second}}};Gl=on;k.UTCTime=Gl;on.NAME="UTCTime";var Wl,Cs=class extends on{constructor(e={}){var t;super(e),(t=this.millisecond)!==null&&t!==void 0||(this.millisecond=0),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromDate(e){super.fromDate(e),this.millisecond=e.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(e){let t=!1,n="",s="",i=0,o,a=0,c=0;if(e[e.length-1]==="Z")n=e.substring(0,e.length-1),t=!0;else{let u=new Number(e[e.length-1]);if(isNaN(u.valueOf()))throw new Error("Wrong input string for conversion");n=e}if(t){if(n.indexOf("+")!==-1)throw new Error("Wrong input string for conversion");if(n.indexOf("-")!==-1)throw new Error("Wrong input string for conversion")}else{let u=1,g=n.indexOf("+"),l="";if(g===-1&&(g=n.indexOf("-"),u=-1),g!==-1){if(l=n.substring(g+1),n=n.substring(0,g),l.length!==2&&l.length!==4)throw new Error("Wrong input string for conversion");let d=parseInt(l.substring(0,2),10);if(isNaN(d.valueOf()))throw new Error("Wrong input string for conversion");if(a=u*d,l.length===4){if(d=parseInt(l.substring(2,4),10),isNaN(d.valueOf()))throw new Error("Wrong input string for conversion");c=u*d}}}let h=n.indexOf(".");if(h===-1&&(h=n.indexOf(",")),h!==-1){let u=new Number(`0${n.substring(h)}`);if(isNaN(u.valueOf()))throw new Error("Wrong input string for conversion");i=u.valueOf(),s=n.substring(0,h)}else s=n;switch(!0){case s.length===8:if(o=/(\d{4})(\d{2})(\d{2})/ig,h!==-1)throw new Error("Wrong input string for conversion");break;case s.length===10:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})/ig,h!==-1){let u=60*i;this.minute=Math.floor(u),u=60*(u-this.minute),this.second=Math.floor(u),u=1e3*(u-this.second),this.millisecond=Math.floor(u)}break;case s.length===12:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig,h!==-1){let u=60*i;this.second=Math.floor(u),u=1e3*(u-this.second),this.millisecond=Math.floor(u)}break;case s.length===14:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig,h!==-1){let u=1e3*i;this.millisecond=Math.floor(u)}break;default:throw new Error("Wrong input string for conversion")}let f=o.exec(s);if(f===null)throw new Error("Wrong input string for conversion");for(let u=1;u<f.length;u++)switch(u){case 1:this.year=parseInt(f[u],10);break;case 2:this.month=parseInt(f[u],10);break;case 3:this.day=parseInt(f[u],10);break;case 4:this.hour=parseInt(f[u],10)+a;break;case 5:this.minute=parseInt(f[u],10)+c;break;case 6:this.second=parseInt(f[u],10);break;default:throw new Error("Wrong input string for conversion")}if(t===!1){let u=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=u.getUTCFullYear(),this.month=u.getUTCMonth(),this.day=u.getUTCDay(),this.hour=u.getUTCHours(),this.minute=u.getUTCMinutes(),this.second=u.getUTCSeconds(),this.millisecond=u.getUTCMilliseconds()}}toString(e="iso"){if(e==="iso"){let t=[];return t.push(Ve(this.year,4)),t.push(Ve(this.month,2)),t.push(Ve(this.day,2)),t.push(Ve(this.hour,2)),t.push(Ve(this.minute,2)),t.push(Ve(this.second,2)),this.millisecond!==0&&(t.push("."),t.push(Ve(this.millisecond,3))),t.push("Z"),t.join("")}return super.toString(e)}toJSON(){return{...super.toJSON(),millisecond:this.millisecond}}};Wl=Cs;k.GeneralizedTime=Wl;Cs.NAME="GeneralizedTime";var Zl,Ns=class extends St{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}};Zl=Ns;k.DATE=Zl;Ns.NAME="DATE";var jl,Rs=class extends St{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}};jl=Rs;k.TimeOfDay=jl;Rs.NAME="TimeOfDay";var Yl,Ls=class extends St{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}};Yl=Ls;k.DateTime=Yl;Ls.NAME="DateTime";var Xl,Us=class extends St{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}};Xl=Us;k.Duration=Xl;Us.NAME="Duration";var Jl,Ds=class extends St{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}};Jl=Ds;k.TIME=Jl;Ds.NAME="TIME";function ce(r,e="utf8"){let t=$n[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.encoder.encode(r).substring(1)}var an=class extends Error{constructor(e="An error occurred while verifying a message"){super(e),this.name="VerificationError"}},Ms=class extends Error{constructor(e="Missing Web Crypto API"){super(e),this.name="WebCryptoMissingError"}};var Ql={get(r=globalThis){let e=r.crypto;if(e?.subtle==null)throw new Ms("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return e}};var Kt=Ql;async function eu(r){let e=await Kt.get().subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:r,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),t=await Bp(e);return{privateKey:t[0],publicKey:t[1]}}async function tu(r,e){let t=await Kt.get().subtle.importKey("jwk",r,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["sign"]),n=await Kt.get().subtle.sign({name:"RSASSA-PKCS1-v1_5"},t,e instanceof Uint8Array?e:e.subarray());return new Uint8Array(n,0,n.byteLength)}async function ru(r,e,t){let n=await Kt.get().subtle.importKey("jwk",r,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);return Kt.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},n,e,t instanceof Uint8Array?t:t.subarray())}async function Bp(r){if(r.privateKey==null||r.publicKey==null)throw new ve("Private and public key are required");return Promise.all([Kt.get().subtle.exportKey("jwk",r.privateKey),Kt.get().subtle.exportKey("jwk",r.publicKey)])}function Qo(r){if(r.kty!=="RSA")throw new ve("invalid key type");if(r.n==null)throw new ve("invalid key modulus");return G(r.n,"base64url").length*8}var Ir=class{type="RSA";_key;_raw;_multihash;constructor(e,t){this._key=e,this._multihash=t}get raw(){return this._raw==null&&(this._raw=cn.jwkToPkix(this._key)),this._raw}toMultihash(){return this._multihash}toCID(){return pe.createV1(114,this._multihash)}toString(){return ee.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:me(this.raw,e.raw)}verify(e,t){return ru(this._key,t,e)}},ln=class{type="RSA";_key;_raw;publicKey;constructor(e,t){this._key=e,this.publicKey=t}get raw(){return this._raw==null&&(this._raw=cn.jwkToPkcs1(this._key)),this._raw}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:me(this.raw,e.raw)}sign(e){return tu(this._key,e)}};var Ps=8192,ea=18;function nu(r){let{result:e}=Jo(r),t=e.valueBlock.value;return{n:ct(t[1]),e:ct(t[2]),d:ct(t[3]),p:ct(t[4]),q:ct(t[5]),dp:ct(t[6]),dq:ct(t[7]),qi:ct(t[8]),kty:"RSA",alg:"RS256"}}function _p(r){if(r.n==null||r.e==null||r.d==null||r.p==null||r.q==null||r.dp==null||r.dq==null||r.qi==null)throw new ve("JWK was missing components");let t=new Et({value:[new we({value:0}),we.fromBigInt(lt(G(r.n,"base64url"))),we.fromBigInt(lt(G(r.e,"base64url"))),we.fromBigInt(lt(G(r.d,"base64url"))),we.fromBigInt(lt(G(r.p,"base64url"))),we.fromBigInt(lt(G(r.q,"base64url"))),we.fromBigInt(lt(G(r.dp,"base64url"))),we.fromBigInt(lt(G(r.dq,"base64url"))),we.fromBigInt(lt(G(r.qi,"base64url")))]}).toBER();return new Uint8Array(t,0,t.byteLength)}function su(r){let{result:e}=Jo(r),t=e.valueBlock.value[1].valueBlock.value[0].valueBlock.value;return{kty:"RSA",n:ct(t[0]),e:ct(t[1])}}function ta(r){if(r.n==null||r.e==null)throw new ve("JWK was missing components");let t=new Et({value:[new Et({value:[new Br({value:"1.2.840.113549.1.1.1"}),new Sr]}),new Ar({valueHex:new Et({value:[we.fromBigInt(lt(G(r.n,"base64url"))),we.fromBigInt(lt(G(r.e,"base64url")))]}).toBER()})]}).toBER();return new Uint8Array(t,0,t.byteLength)}function ct(r){let e=r.valueBlock.valueHexView;for(;e[0]===0;)e=e.subarray(1);return ce(e,"base64url")}function lt(r){let e=[];return r.forEach(function(t){let n=t.toString(16);n.length%2>0&&(n=`0${n}`),e.push(n)}),BigInt("0x"+e.join(""))}function iu(r){let e=nu(r);return ou(e)}function ra(r){let e=su(r);if(Qo(e)>Ps)throw new cr("Key size is too large");let t=vr(ot.encode({Type:fe.RSA,Data:r})),n=Ze(ea,t);return new Ir(e,n)}function ou(r){if(Qo(r)>Ps)throw new ve("Key size is too large");let e=cu(r),t=vr(ot.encode({Type:fe.RSA,Data:ta(e.publicKey)})),n=Ze(ea,t);return new ln(e.privateKey,new Ir(e.publicKey,n))}async function au(r){if(r>Ps)throw new ve("Key size is too large");let e=await eu(r),t=vr(ot.encode({Type:fe.RSA,Data:ta(e.publicKey)})),n=Ze(ea,t);return new ln(e.privateKey,new Ir(e.publicKey,n))}function cu(r){if(r==null)throw new ve("Missing key parameter");return{privateKey:r,publicKey:{kty:r.kty,n:r.n,e:r.e}}}var Vs=class extends gr{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,kc(e);let n=zr(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let s=this.blockLen,i=new Uint8Array(s);i.set(n.length>s?e.create().update(n).digest():n);for(let o=0;o<i.length;o++)i[o]^=54;this.iHash.update(i),this.oHash=e.create();for(let o=0;o<i.length;o++)i[o]^=106;this.oHash.update(i),i.fill(0)}update(e){return mr(this),this.iHash.update(e),this}digestInto(e){mr(this),pr(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){let e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));let{oHash:t,iHash:n,finished:s,destroyed:i,blockLen:o,outputLen:a}=this;return e=e,e.finished=s,e.destroyed=i,e.blockLen=o,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},na=(r,e,t)=>new Vs(r,e).update(t).digest();na.create=(r,e)=>new Vs(r,e);function lu(r){r.lowS!==void 0&&Ye("lowS",r.lowS),r.prehash!==void 0&&Ye("prehash",r.prehash)}function Ip(r){let e=Wr(r);it(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:t,Fp:n,a:s}=e;if(t){if(!n.eql(s,n.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}var{bytesToNumberBE:Tp,hexToBytes:kp}=Dn,sa=class extends Error{constructor(e=""){super(e)}},_t={Err:sa,_tlv:{encode:(r,e)=>{let{Err:t}=_t;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");let n=e.length/2,s=Zt(n);if(s.length/2&128)throw new t("tlv.encode: long form length too big");let i=n>127?Zt(s.length/2|128):"";return Zt(r)+i+s+e},decode(r,e){let{Err:t}=_t,n=0;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[n++]!==r)throw new t("tlv.decode: wrong tlv");let s=e[n++],i=!!(s&128),o=0;if(!i)o=s;else{let c=s&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");let h=e.subarray(n,n+c);if(h.length!==c)throw new t("tlv.decode: length bytes not complete");if(h[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(let f of h)o=o<<8|f;if(n+=c,o<128)throw new t("tlv.decode(long): not minimal encoding")}let a=e.subarray(n,n+o);if(a.length!==o)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(n+o)}}},_int:{encode(r){let{Err:e}=_t;if(r<It)throw new e("integer: negative integers are not allowed");let t=Zt(r);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(r){let{Err:e}=_t;if(r[0]&128)throw new e("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return Tp(r)}},toSig(r){let{Err:e,_int:t,_tlv:n}=_t,s=typeof r=="string"?kp(r):r;br(s);let{v:i,l:o}=n.decode(48,s);if(o.length)throw new e("invalid signature: left bytes after parsing");let{v:a,l:c}=n.decode(2,i),{v:h,l:f}=n.decode(2,c);if(f.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(h)}},hexFromSig(r){let{_tlv:e,_int:t}=_t,n=e.encode(2,t.encode(r.r)),s=e.encode(2,t.encode(r.s)),i=n+s;return e.encode(48,i)}},It=BigInt(0),ge=BigInt(1),fb=BigInt(2),uu=BigInt(3),hb=BigInt(4);function Cp(r){let e=Ip(r),{Fp:t}=e,n=Dt(e.n,e.nBitLength),s=e.toBytes||((m,y,b)=>{let w=y.toAffine();return bt(Uint8Array.from([4]),t.toBytes(w.x),t.toBytes(w.y))}),i=e.fromBytes||(m=>{let y=m.subarray(1),b=t.fromBytes(y.subarray(0,t.BYTES)),w=t.fromBytes(y.subarray(t.BYTES,2*t.BYTES));return{x:b,y:w}});function o(m){let{a:y,b}=e,w=t.sqr(m),p=t.mul(w,m);return t.add(t.add(p,t.mul(m,y)),b)}if(!t.eql(t.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function a(m){return $r(m,ge,e.n)}function c(m){let{allowedPrivateKeyLengths:y,nByteLength:b,wrapPrivateKey:w,n:p}=e;if(y&&typeof m!="bigint"){if(Rt(m)&&(m=gt(m)),typeof m!="string"||!y.includes(m.length))throw new Error("invalid private key");m=m.padStart(b*2,"0")}let E;try{E=typeof m=="bigint"?m:yt(oe("private key",m,b))}catch{throw new Error("invalid private key, expected hex or "+b+" bytes, got "+typeof m)}return w&&(E=J(E,p)),Le("private key",E,ge,p),E}function h(m){if(!(m instanceof g))throw new Error("ProjectivePoint expected")}let f=Xt((m,y)=>{let{px:b,py:w,pz:p}=m;if(t.eql(p,t.ONE))return{x:b,y:w};let E=m.is0();y==null&&(y=E?t.ONE:t.inv(p));let A=t.mul(b,y),_=t.mul(w,y),x=t.mul(p,y);if(E)return{x:t.ZERO,y:t.ZERO};if(!t.eql(x,t.ONE))throw new Error("invZ was invalid");return{x:A,y:_}}),u=Xt(m=>{if(m.is0()){if(e.allowInfinityPoint&&!t.is0(m.py))return;throw new Error("bad point: ZERO")}let{x:y,y:b}=m.toAffine();if(!t.isValid(y)||!t.isValid(b))throw new Error("bad point: x or y not FE");let w=t.sqr(b),p=o(y);if(!t.eql(w,p))throw new Error("bad point: equation left != right");if(!m.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class g{constructor(y,b,w){if(this.px=y,this.py=b,this.pz=w,y==null||!t.isValid(y))throw new Error("x required");if(b==null||!t.isValid(b))throw new Error("y required");if(w==null||!t.isValid(w))throw new Error("z required");Object.freeze(this)}static fromAffine(y){let{x:b,y:w}=y||{};if(!y||!t.isValid(b)||!t.isValid(w))throw new Error("invalid affine point");if(y instanceof g)throw new Error("projective point not allowed");let p=E=>t.eql(E,t.ZERO);return p(b)&&p(w)?g.ZERO:new g(b,w,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(y){let b=t.invertBatch(y.map(w=>w.pz));return y.map((w,p)=>w.toAffine(b[p])).map(g.fromAffine)}static fromHex(y){let b=g.fromAffine(i(oe("pointHex",y)));return b.assertValidity(),b}static fromPrivateKey(y){return g.BASE.multiply(c(y))}static msm(y,b){return Vn(g,n,y,b)}_setWindowSize(y){d.setWindowSize(this,y)}assertValidity(){u(this)}hasEvenY(){let{y}=this.toAffine();if(t.isOdd)return!t.isOdd(y);throw new Error("Field doesn't support isOdd")}equals(y){h(y);let{px:b,py:w,pz:p}=this,{px:E,py:A,pz:_}=y,x=t.eql(t.mul(b,_),t.mul(E,p)),I=t.eql(t.mul(w,_),t.mul(A,p));return x&&I}negate(){return new g(this.px,t.neg(this.py),this.pz)}double(){let{a:y,b}=e,w=t.mul(b,uu),{px:p,py:E,pz:A}=this,_=t.ZERO,x=t.ZERO,I=t.ZERO,C=t.mul(p,p),j=t.mul(E,E),V=t.mul(A,A),P=t.mul(p,E);return P=t.add(P,P),I=t.mul(p,A),I=t.add(I,I),_=t.mul(y,I),x=t.mul(w,V),x=t.add(_,x),_=t.sub(j,x),x=t.add(j,x),x=t.mul(_,x),_=t.mul(P,_),I=t.mul(w,I),V=t.mul(y,V),P=t.sub(C,V),P=t.mul(y,P),P=t.add(P,I),I=t.add(C,C),C=t.add(I,C),C=t.add(C,V),C=t.mul(C,P),x=t.add(x,C),V=t.mul(E,A),V=t.add(V,V),C=t.mul(V,P),_=t.sub(_,C),I=t.mul(V,j),I=t.add(I,I),I=t.add(I,I),new g(_,x,I)}add(y){h(y);let{px:b,py:w,pz:p}=this,{px:E,py:A,pz:_}=y,x=t.ZERO,I=t.ZERO,C=t.ZERO,j=e.a,V=t.mul(e.b,uu),P=t.mul(b,E),L=t.mul(w,A),T=t.mul(p,_),R=t.add(b,w),S=t.add(E,A);R=t.mul(R,S),S=t.add(P,L),R=t.sub(R,S),S=t.add(b,p);let v=t.add(E,_);return S=t.mul(S,v),v=t.add(P,T),S=t.sub(S,v),v=t.add(w,p),x=t.add(A,_),v=t.mul(v,x),x=t.add(L,T),v=t.sub(v,x),C=t.mul(j,S),x=t.mul(V,T),C=t.add(x,C),x=t.sub(L,C),C=t.add(L,C),I=t.mul(x,C),L=t.add(P,P),L=t.add(L,P),T=t.mul(j,T),S=t.mul(V,S),L=t.add(L,T),T=t.sub(P,T),T=t.mul(j,T),S=t.add(S,T),P=t.mul(L,S),I=t.add(I,P),P=t.mul(v,S),x=t.mul(R,x),x=t.sub(x,P),P=t.mul(R,L),C=t.mul(v,C),C=t.add(C,P),new g(x,I,C)}subtract(y){return this.add(y.negate())}is0(){return this.equals(g.ZERO)}wNAF(y){return d.wNAFCached(this,y,g.normalizeZ)}multiplyUnsafe(y){let{endo:b,n:w}=e;Le("scalar",y,It,w);let p=g.ZERO;if(y===It)return p;if(this.is0()||y===ge)return this;if(!b||d.hasPrecomputes(this))return d.wNAFCachedUnsafe(this,y,g.normalizeZ);let{k1neg:E,k1:A,k2neg:_,k2:x}=b.splitScalar(y),I=p,C=p,j=this;for(;A>It||x>It;)A&ge&&(I=I.add(j)),x&ge&&(C=C.add(j)),j=j.double(),A>>=ge,x>>=ge;return E&&(I=I.negate()),_&&(C=C.negate()),C=new g(t.mul(C.px,b.beta),C.py,C.pz),I.add(C)}multiply(y){let{endo:b,n:w}=e;Le("scalar",y,ge,w);let p,E;if(b){let{k1neg:A,k1:_,k2neg:x,k2:I}=b.splitScalar(y),{p:C,f:j}=this.wNAF(_),{p:V,f:P}=this.wNAF(I);C=d.constTimeNegate(A,C),V=d.constTimeNegate(x,V),V=new g(t.mul(V.px,b.beta),V.py,V.pz),p=C.add(V),E=j.add(P)}else{let{p:A,f:_}=this.wNAF(y);p=A,E=_}return g.normalizeZ([p,E])[0]}multiplyAndAddUnsafe(y,b,w){let p=g.BASE,E=(_,x)=>x===It||x===ge||!_.equals(p)?_.multiplyUnsafe(x):_.multiply(x),A=E(this,b).add(E(y,w));return A.is0()?void 0:A}toAffine(y){return f(this,y)}isTorsionFree(){let{h:y,isTorsionFree:b}=e;if(y===ge)return!0;if(b)return b(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:y,clearCofactor:b}=e;return y===ge?this:b?b(g,this):this.multiplyUnsafe(e.h)}toRawBytes(y=!0){return Ye("isCompressed",y),this.assertValidity(),s(g,this,y)}toHex(y=!0){return Ye("isCompressed",y),gt(this.toRawBytes(y))}}g.BASE=new g(e.Gx,e.Gy,t.ONE),g.ZERO=new g(t.ZERO,t.ONE,t.ZERO);let l=e.nBitLength,d=Pn(g,e.endo?Math.ceil(l/2):l);return{CURVE:e,ProjectivePoint:g,normPrivateKeyToScalar:c,weierstrassEquation:o,isWithinCurveOrder:a}}function Np(r){let e=Wr(r);return it(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function fu(r){let e=Np(r),{Fp:t,n}=e,s=t.BYTES+1,i=2*t.BYTES+1;function o(T){return J(T,n)}function a(T){return On(T,n)}let{ProjectivePoint:c,normPrivateKeyToScalar:h,weierstrassEquation:f,isWithinCurveOrder:u}=Cp({...e,toBytes(T,R,S){let v=R.toAffine(),B=t.toBytes(v.x),N=bt;return Ye("isCompressed",S),S?N(Uint8Array.from([R.hasEvenY()?2:3]),B):N(Uint8Array.from([4]),B,t.toBytes(v.y))},fromBytes(T){let R=T.length,S=T[0],v=T.subarray(1);if(R===s&&(S===2||S===3)){let B=yt(v);if(!$r(B,ge,t.ORDER))throw new Error("Point is not on curve");let N=f(B),U;try{U=t.sqrt(N)}catch($){let O=$ instanceof Error?": "+$.message:"";throw new Error("Point is not on curve"+O)}let D=(U&ge)===ge;return(S&1)===1!==D&&(U=t.neg(U)),{x:B,y:U}}else if(R===i&&S===4){let B=t.fromBytes(v.subarray(0,t.BYTES)),N=t.fromBytes(v.subarray(t.BYTES,2*t.BYTES));return{x:B,y:N}}else{let B=s,N=i;throw new Error("invalid Point, expected length of "+B+", or uncompressed "+N+", got "+R)}}}),g=T=>gt(Ut(T,e.nByteLength));function l(T){let R=n>>ge;return T>R}function d(T){return l(T)?o(-T):T}let m=(T,R,S)=>yt(T.slice(R,S));class y{constructor(R,S,v){this.r=R,this.s=S,this.recovery=v,this.assertValidity()}static fromCompact(R){let S=e.nByteLength;return R=oe("compactSignature",R,S*2),new y(m(R,0,S),m(R,S,2*S))}static fromDER(R){let{r:S,s:v}=_t.toSig(oe("DER",R));return new y(S,v)}assertValidity(){Le("r",this.r,ge,n),Le("s",this.s,ge,n)}addRecoveryBit(R){return new y(this.r,this.s,R)}recoverPublicKey(R){let{r:S,s:v,recovery:B}=this,N=_(oe("msgHash",R));if(B==null||![0,1,2,3].includes(B))throw new Error("recovery id invalid");let U=B===2||B===3?S+e.n:S;if(U>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");let D=B&1?"03":"02",H=c.fromHex(D+g(U)),$=a(U),O=o(-N*$),Y=o(v*$),re=c.BASE.multiplyAndAddUnsafe(H,O,Y);if(!re)throw new Error("point at infinify");return re.assertValidity(),re}hasHighS(){return l(this.s)}normalizeS(){return this.hasHighS()?new y(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return jt(this.toDERHex())}toDERHex(){return _t.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return jt(this.toCompactHex())}toCompactHex(){return g(this.r)+g(this.s)}}let b={isValidPrivateKey(T){try{return h(T),!0}catch{return!1}},normPrivateKeyToScalar:h,randomPrivateKey:()=>{let T=ao(e.n);return Kc(e.randomBytes(T),e.n)},precompute(T=8,R=c.BASE){return R._setWindowSize(T),R.multiply(BigInt(3)),R}};function w(T,R=!0){return c.fromPrivateKey(T).toRawBytes(R)}function p(T){let R=Rt(T),S=typeof T=="string",v=(R||S)&&T.length;return R?v===s||v===i:S?v===2*s||v===2*i:T instanceof c}function E(T,R,S=!0){if(p(T))throw new Error("first arg must be private key");if(!p(R))throw new Error("second arg must be public key");return c.fromHex(R).multiply(h(T)).toRawBytes(S)}let A=e.bits2int||function(T){if(T.length>8192)throw new Error("input is too large");let R=yt(T),S=T.length*8-e.nBitLength;return S>0?R>>BigInt(S):R},_=e.bits2int_modN||function(T){return o(A(T))},x=Gr(e.nBitLength);function I(T){return Le("num < 2^"+e.nBitLength,T,It,x),Ut(T,e.nByteLength)}function C(T,R,S=j){if(["recovered","canonical"].some(de=>de in S))throw new Error("sign() legacy options not supported");let{hash:v,randomBytes:B}=e,{lowS:N,prehash:U,extraEntropy:D}=S;N==null&&(N=!0),T=oe("msgHash",T),lu(S),U&&(T=oe("prehashed msgHash",v(T)));let H=_(T),$=h(R),O=[I($),I(H)];if(D!=null&&D!==!1){let de=D===!0?B(t.BYTES):D;O.push(oe("extraEntropy",de))}let Y=bt(...O),re=H;function he(de){let ye=A(de);if(!u(ye))return;let xe=a(ye),Ne=c.BASE.multiply(ye).toAffine(),Te=o(Ne.x);if(Te===It)return;let nt=o(xe*o(re+Te*$));if(nt===It)return;let ut=(Ne.x===Te?0:2)|Number(Ne.y&ge),Pr=nt;return N&&l(nt)&&(Pr=d(nt),ut^=1),new y(Te,Pr,ut)}return{seed:Y,k2sig:he}}let j={lowS:e.lowS,prehash:!1},V={lowS:e.lowS,prehash:!1};function P(T,R,S=j){let{seed:v,k2sig:B}=C(T,R,S),N=e;return no(N.hash.outputLen,N.nByteLength,N.hmac)(v,B)}c.BASE._setWindowSize(8);function L(T,R,S,v=V){let B=T;R=oe("msgHash",R),S=oe("publicKey",S);let{lowS:N,prehash:U,format:D}=v;if(lu(v),"strict"in v)throw new Error("options.strict was renamed to lowS");if(D!==void 0&&D!=="compact"&&D!=="der")throw new Error("format must be compact or der");let H=typeof B=="string"||Rt(B),$=!H&&!D&&typeof B=="object"&&B!==null&&typeof B.r=="bigint"&&typeof B.s=="bigint";if(!H&&!$)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let O,Y;try{if($&&(O=new y(B.r,B.s)),H){try{D!=="compact"&&(O=y.fromDER(B))}catch(ut){if(!(ut instanceof _t.Err))throw ut}!O&&D!=="der"&&(O=y.fromCompact(B))}Y=c.fromHex(S)}catch{return!1}if(!O||N&&O.hasHighS())return!1;U&&(R=e.hash(R));let{r:re,s:he}=O,de=_(R),ye=a(he),xe=o(de*ye),Ne=o(re*ye),Te=c.BASE.multiplyAndAddUnsafe(Y,xe,Ne)?.toAffine();return Te?o(Te.x)===re:!1}return{CURVE:e,getPublicKey:w,getSharedSecret:E,sign:P,verify:L,ProjectivePoint:c,Signature:y,utils:b}}function Rp(r){return{hash:r,hmac:(e,...t)=>na(r,e,Yi(...t)),randomBytes:Nn}}function hu(r,e){let t=n=>fu({...r,...Rp(n)});return{...t(e),create:t}}var mu=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),du=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Lp=BigInt(1),ia=BigInt(2),pu=(r,e)=>(r+e/ia)/e;function Up(r){let e=mu,t=BigInt(3),n=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),h=r*r*r%e,f=h*h*r%e,u=ie(f,t,e)*f%e,g=ie(u,t,e)*f%e,l=ie(g,ia,e)*h%e,d=ie(l,s,e)*l%e,m=ie(d,i,e)*d%e,y=ie(m,a,e)*m%e,b=ie(y,c,e)*y%e,w=ie(b,a,e)*m%e,p=ie(w,t,e)*f%e,E=ie(p,o,e)*d%e,A=ie(E,n,e)*h%e,_=ie(A,ia,e);if(!oa.eql(oa.sqr(_),r))throw new Error("Cannot find square root");return _}var oa=Dt(mu,void 0,void 0,{sqrt:Up}),nr=hu({a:BigInt(0),b:BigInt(7),Fp:oa,n:du,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{let e=du,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Lp*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=t,o=BigInt("0x100000000000000000000000000000000"),a=pu(i*r,e),c=pu(-n*r,e),h=J(r-a*t-c*s,e),f=J(-a*n-c*i,e),u=h>o,g=f>o;if(u&&(h=e-h),g&&(f=e-f),h>o||f>o)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:u,k1:h,k2neg:g,k2:f}}}},vr),vb=BigInt(0);var Eb=nr.ProjectivePoint;function Fe(r,e){e==null&&(e=r.reduce((s,i)=>s+i.length,0));let t=De(e),n=0;for(let s of r)t.set(s,n),n+=s.length;return t}function gu(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}function yu(r,e,t){let n=wr.digest(t instanceof Uint8Array?t:t.subarray());if(gu(n))return n.then(({digest:s})=>nr.verify(e,s,r)).catch(s=>{throw new an(String(s))});try{return nr.verify(e,n.digest,r)}catch(s){throw new an(String(s))}}var Hs=class{type="secp256k1";raw;_key;constructor(e){this._key=wu(e),this.raw=bu(this._key)}toMultihash(){return pt.digest(Ot(this))}toCID(){return pe.createV1(114,this.toMultihash())}toString(){return ee.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:me(this.raw,e.raw)}verify(e,t){return yu(this._key,t,e)}};function aa(r){return new Hs(r)}function bu(r){return nr.ProjectivePoint.fromHex(r).toRawBytes(!0)}function wu(r){try{return nr.ProjectivePoint.fromHex(r),r}catch(e){throw new cr(String(e))}}function xu(r){let{Type:e,Data:t}=ot.decode(r),n=t??new Uint8Array;switch(e){case fe.RSA:return ra(n);case fe.Ed25519:return mo(n);case fe.secp256k1:return aa(n);default:throw new lr}}function vu(r){let{Type:e,Data:t}=ot.decode(r.digest),n=t??new Uint8Array;switch(e){case fe.Ed25519:return mo(n);case fe.secp256k1:return aa(n);default:throw new lr}}function Ot(r){return ot.encode({Type:fe[r.type],Data:r.raw})}var Eu=Symbol.for("nodejs.util.inspect.custom"),Dp=114,un=class{type;multihash;publicKey;string;constructor(e){this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}[Pi]=!0;toString(){return this.string==null&&(this.string=ee.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return pe.createV1(Dp,this.multihash)}toJSON(){return this.toString()}equals(e){if(e==null)return!1;if(e instanceof Uint8Array)return me(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(e?.toMultihash()?.bytes!=null)return me(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[Eu](){return`PeerId(${this.toString()})`}},Fs=class extends un{type="RSA";publicKey;constructor(e){super({...e,type:"RSA"}),this.publicKey=e.publicKey}},Ks=class extends un{type="Ed25519";publicKey;constructor(e){super({...e,type:"Ed25519"}),this.publicKey=e.publicKey}},qs=class extends un{type="secp256k1";publicKey;constructor(e){super({...e,type:"secp256k1"}),this.publicKey=e.publicKey}},Op=2336,zs=class{type="url";multihash;publicKey;url;constructor(e){this.url=e.toString(),this.multihash=pt.digest(G(this.url))}[Eu](){return`PeerId(${this.url})`}[Pi]=!0;toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return pe.createV1(Op,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=ce(e)),e.toString()===this.toString())}};function ca(r,e){let t;if(r.charAt(0)==="1"||r.charAt(0)==="Q")t=ze(ee.decode(`z${r}`));else{if(e==null)throw new ve('Please pass a multibase decoder for strings that do not start with "1" or "Q"');t=ze(e.decode(r))}return fn(t)}function fn(r){if(Pp(r))return new Fs({multihash:r});if(Mp(r))try{let e=vu(r);if(e.type==="Ed25519")return new Ks({multihash:r,publicKey:e});if(e.type==="secp256k1")return new qs({multihash:r,publicKey:e})}catch{let t=ce(r.digest);return new zs(new URL(t))}throw new _n("Supplied PeerID Multihash is invalid")}function Mp(r){return r.code===pt.code}function Pp(r){return r.code===wr.code}var Au=Symbol.for("@achingbrain/uint8arraylist");function Su(r,e){if(e==null||e<0)throw new RangeError("index is out of bounds");let t=0;for(let n of r){let s=t+n.byteLength;if(e<s)return{buf:n,index:e-t};t=s}throw new RangeError("index is out of bounds")}function $s(r){return!!r?.[Au]}var et=class r{bufs;length;[Au]=!0;constructor(...e){this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(let n of e)if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.push(n);else if($s(n))t+=n.byteLength,this.bufs.push(...n.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(let n of e.reverse())if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.unshift(n);else if($s(n))t+=n.byteLength,this.bufs.unshift(...n.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}get(e){let t=Su(this.bufs,e);return t.buf[t.index]}set(e,t){let n=Su(this.bufs,e);n.buf[n.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let n=0;n<e.length;n++)this.set(t+n,e[n]);else if($s(e))for(let n=0;n<e.length;n++)this.set(t+n,e.get(n));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(e>=this.bufs[0].byteLength)e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}}}slice(e,t){let{bufs:n,length:s}=this._subList(e,t);return Fe(n,s)}subarray(e,t){let{bufs:n,length:s}=this._subList(e,t);return n.length===1?n[0]:Fe(n,s)}sublist(e,t){let{bufs:n,length:s}=this._subList(e,t),i=new r;return i.length=s,i.bufs=[...n],i}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(e===0&&t===this.length)return{bufs:this.bufs,length:this.length};let n=[],s=0;for(let i=0;i<this.bufs.length;i++){let o=this.bufs[i],a=s,c=a+o.byteLength;if(s=c,e>=c)continue;let h=e>=a&&e<c,f=t>a&&t<=c;if(h&&f){if(e===a&&t===c){n.push(o);break}let u=e-a;n.push(o.subarray(u,u+(t-e)));break}if(h){if(e===0){n.push(o);continue}n.push(o.subarray(e-a));continue}if(f){if(t===c){n.push(o);break}n.push(o.subarray(0,t-a));break}n.push(o)}return{bufs:n,length:t-e}}indexOf(e,t=0){if(!$s(e)&&!(e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');let n=e instanceof Uint8Array?e:e.subarray();if(t=Number(t??0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),e.length===0)return t>this.length?this.length:t;let s=n.byteLength;if(s===0)throw new TypeError("search must be at least 1 byte long");let i=256,o=new Int32Array(i);for(let u=0;u<i;u++)o[u]=-1;for(let u=0;u<s;u++)o[n[u]]=u;let a=o,c=this.byteLength-n.byteLength,h=n.byteLength-1,f;for(let u=t;u<=c;u+=f){f=0;for(let g=h;g>=0;g--){let l=this.get(u+g);if(n[g]!==l){f=Math.max(1,g-a[l]);break}}if(f===0)return u}return-1}getInt8(e){let t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,t){let n=De(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt8(0,t),this.write(n,e)}getInt16(e,t){let n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt16(0,t)}setInt16(e,t,n){let s=ae(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt16(0,t,n),this.write(s,e)}getInt32(e,t){let n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt32(0,t)}setInt32(e,t,n){let s=ae(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt32(0,t,n),this.write(s,e)}getBigInt64(e,t){let n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigInt64(0,t)}setBigInt64(e,t,n){let s=ae(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigInt64(0,t,n),this.write(s,e)}getUint8(e){let t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,t){let n=De(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint8(0,t),this.write(n,e)}getUint16(e,t){let n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint16(0,t)}setUint16(e,t,n){let s=ae(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint16(0,t,n),this.write(s,e)}getUint32(e,t){let n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint32(0,t)}setUint32(e,t,n){let s=ae(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint32(0,t,n),this.write(s,e)}getBigUint64(e,t){let n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigUint64(0,t)}setBigUint64(e,t,n){let s=ae(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigUint64(0,t,n),this.write(s,e)}getFloat32(e,t){let n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat32(0,t)}setFloat32(e,t,n){let s=ae(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat32(0,t,n),this.write(s,e)}getFloat64(e,t){let n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat64(0,t)}setFloat64(e,t,n){let s=ae(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat64(0,t,n),this.write(s,e)}equals(e){if(e==null||!(e instanceof r)||e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!me(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){let n=new r;return n.bufs=e,t==null&&(t=e.reduce((s,i)=>s+i.byteLength,0)),n.length=t,n}};var hn;(function(r){let e;r.codec=()=>(e==null&&(e=Pe((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(n.uint32(10),n.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(n.uint32(18),n.bytes(t.payloadType)),t.payload!=null&&t.payload.byteLength>0&&(n.uint32(26),n.bytes(t.payload)),t.signature!=null&&t.signature.byteLength>0&&(n.uint32(42),n.bytes(t.signature)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{let i={publicKey:ae(0),payloadType:ae(0),payload:ae(0),signature:ae(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){let a=t.uint32();switch(a>>>3){case 1:{i.publicKey=t.bytes();break}case 2:{i.payloadType=t.bytes();break}case 3:{i.payload=t.bytes();break}case 5:{i.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>Me(t,r.codec()),r.decode=(t,n)=>Oe(t,r.codec(),n)})(hn||(hn={}));var Gs=class extends Error{constructor(e="Invalid signature"){super(e),this.name="InvalidSignatureError"}};var dn=class r{static createFromProtobuf=async e=>{let t=hn.decode(e),n=xu(t.publicKey);return new r({publicKey:n,payloadType:t.payloadType,payload:t.payload,signature:t.signature})};static seal=async(e,t)=>{if(t==null)throw new Error("Missing private key");let n=e.domain,s=e.codec,i=e.marshal(),o=Bu(n,s,i),a=await t.sign(o.subarray());return new r({publicKey:t.publicKey,payloadType:s,payload:i,signature:a})};static openAndCertify=async(e,t)=>{let n=await r.createFromProtobuf(e);if(!await n.validate(t))throw new Gs("Envelope signature is not valid for the given domain");return n};publicKey;payloadType;payload;signature;marshaled;constructor(e){let{publicKey:t,payloadType:n,payload:s,signature:i}=e;this.publicKey=t,this.payloadType=n,this.payload=s,this.signature=i}marshal(){return this.marshaled==null&&(this.marshaled=hn.encode({publicKey:Ot(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(e){return me(this.marshal(),e.marshal())}async validate(e){let t=Bu(e,this.payloadType,this.payload);return this.publicKey.verify(t.subarray(),this.signature)}},Bu=(r,e,t)=>{let n=G(r),s=$e(n.byteLength),i=$e(e.length),o=$e(t.length);return new et(s,n,i,e,o,t)};var Ws=class{index=0;input="";new(e){return this.index=0,this.input=e,this}readAtomically(e){let t=this.index,n=e();return n===void 0&&(this.index=t),n}parseWith(e){let t=e();if(this.index===this.input.length)return t}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(e){return this.readAtomically(()=>{let t=this.readChar();if(t===e)return t})}readSeparator(e,t,n){return this.readAtomically(()=>{if(!(t>0&&this.readGivenChar(e)===void 0))return n()})}readNumber(e,t,n,s){return this.readAtomically(()=>{let i=0,o=0,a=this.peekChar();if(a===void 0)return;let c=a==="0",h=2**(8*s)-1;for(;;){let f=this.readAtomically(()=>{let u=this.readChar();if(u===void 0)return;let g=Number.parseInt(u,e);if(!Number.isNaN(g))return g});if(f===void 0)break;if(i*=e,i+=f,i>h||(o+=1,t!==void 0&&o>t))return}if(o!==0)return!n&&c&&o>1?void 0:i})}readIPv4Addr(){return this.readAtomically(()=>{let e=new Uint8Array(4);for(let t=0;t<e.length;t++){let n=this.readSeparator(".",t,()=>this.readNumber(10,3,!1,1));if(n===void 0)return;e[t]=n}return e})}readIPv6Addr(){let e=t=>{for(let n=0;n<t.length/2;n++){let s=n*2;if(n<t.length-3){let o=this.readSeparator(":",n,()=>this.readIPv4Addr());if(o!==void 0)return t[s]=o[0],t[s+1]=o[1],t[s+2]=o[2],t[s+3]=o[3],[s+4,!0]}let i=this.readSeparator(":",n,()=>this.readNumber(16,4,!0,2));if(i===void 0)return[s,!1];t[s]=i>>8,t[s+1]=i&255}return[t.length,!1]};return this.readAtomically(()=>{let t=new Uint8Array(16),[n,s]=e(t);if(n===16)return t;if(s||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;let i=new Uint8Array(14),o=16-(n+2),[a]=e(i.subarray(0,o));return t.set(i.subarray(0,a),16-a),t})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}};var _u=45,Vp=15,Tr=new Ws;function la(r){if(!(r.length>Vp))return Tr.new(r).parseWith(()=>Tr.readIPv4Addr())}function ua(r){if(r.includes("%")&&(r=r.split("%")[0]),!(r.length>_u))return Tr.new(r).parseWith(()=>Tr.readIPv6Addr())}function Zs(r){if(r.includes("%")&&(r=r.split("%")[0]),!(r.length>_u))return Tr.new(r).parseWith(()=>Tr.readIPAddr())}var Qw=parseInt("0xFFFF",16),ex=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function js(r){return!!la(r)}function Ys(r){return!!ua(r)}function Xs(r){return!!Zs(r)}var ku=js,zp=Ys,fa=function(r){let e=0;if(r=r.toString().trim(),ku(r)){let t=new Uint8Array(e+4);return r.split(/\./g).forEach(n=>{t[e++]=parseInt(n,10)&255}),t}if(zp(r)){let t=r.split(":",8),n;for(n=0;n<t.length;n++){let i=ku(t[n]),o;i&&(o=fa(t[n]),t[n]=ce(o.slice(0,2),"base16")),o!=null&&++n<8&&t.splice(n,0,ce(o.slice(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(n=0;n<t.length&&t[n]!=="";n++);let i=[n,1];for(n=9-t.length;n>0;n--)i.push("0");t.splice.apply(t,i)}let s=new Uint8Array(e+16);for(n=0;n<t.length;n++){let i=parseInt(t[n],16);s[e++]=i>>8&255,s[e++]=i&255}return s}throw new Error("invalid ip address")},Cu=function(r,e=0,t){e=~~e,t=t??r.length-e;let n=new DataView(r.buffer);if(t===4){let s=[];for(let i=0;i<t;i++)s.push(r[e+i]);return s.join(".")}if(t===16){let s=[];for(let i=0;i<t;i+=2)s.push(n.getUint16(e+i).toString(16));return s.join(":").replace(/(^|:)0(:0)*:0(:|$)/,"$1::$3").replace(/:{3,4}/,"::")}return""};var kr={},ha={},Gp=[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,-1,"ip6zone"],[43,8,"ipcidr"],[53,-1,"dns",!0],[54,-1,"dns4",!0],[55,-1,"dns6",!0],[56,-1,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc-direct"],[281,0,"webrtc"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,-1,"unix",!1,!0],[421,-1,"ipfs"],[421,-1,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,-1,"garlic64"],[448,0,"tls"],[449,-1,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,-1,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[481,-1,"http-path"],[777,-1,"memory"]];Gp.forEach(r=>{let e=Wp(...r);ha[e.code]=e,kr[e.name]=e});function Wp(r,e,t,n,s){return{code:r,size:e,name:t,resolvable:!!n,path:!!s}}function te(r){if(typeof r=="number"){if(ha[r]!=null)return ha[r];throw new Error(`no protocol with code: ${r}`)}else if(typeof r=="string"){if(kr[r]!=null)return kr[r];throw new Error(`no protocol with name: ${r}`)}throw new Error(`invalid protocol id type: ${typeof r}`)}var Mx=te("ip4"),Px=te("ip6"),Vx=te("ipcidr");function ga(r,e){switch(te(r).code){case 4:case 41:return jp(e);case 42:return ma(e);case 43:return ce(e,"base10");case 6:case 273:case 33:case 132:return Lu(e).toString();case 53:case 54:case 55:case 56:case 400:case 449:case 777:return ma(e);case 421:return Qp(e);case 444:return Ru(e);case 445:return Ru(e);case 466:return Jp(e);case 481:return globalThis.encodeURIComponent(ma(e));default:return ce(e,"base16")}}function ya(r,e){switch(te(r).code){case 4:return Nu(e);case 41:return Nu(e);case 42:return pa(e);case 43:return G(e,"base10");case 6:case 273:case 33:case 132:return ba(parseInt(e,10));case 53:case 54:case 55:case 56:case 400:case 449:case 777:return pa(e);case 421:return Yp(e);case 444:return e0(e);case 445:return t0(e);case 466:return Xp(e);case 481:return pa(globalThis.decodeURIComponent(e));default:return G(e,"base16")}}var da=Object.values(Zr).map(r=>r.decoder),Zp=function(){let r=da[0].or(da[1]);return da.slice(2).forEach(e=>r=r.or(e)),r}();function Nu(r){if(!Xs(r))throw new Error("invalid ip address");return fa(r)}function jp(r){let e=Cu(r,0,r.length);if(e==null)throw new Error("ipBuff is required");if(!Xs(e))throw new Error("invalid ip address");return e}function ba(r){let e=new ArrayBuffer(2);return new DataView(e).setUint16(0,r),new Uint8Array(e)}function Lu(r){return new DataView(r.buffer).getUint16(r.byteOffset)}function pa(r){let e=G(r),t=Uint8Array.from($e(e.length));return Fe([t,e],t.length+e.length)}function ma(r){let e=wt(r);if(r=r.slice(Se(e)),r.length!==e)throw new Error("inconsistent lengths");return ce(r)}function Yp(r){let e;r[0]==="Q"||r[0]==="1"?e=ze(ee.decode(`z${r}`)).bytes:e=pe.parse(r).multihash.bytes;let t=Uint8Array.from($e(e.length));return Fe([t,e],t.length+e.length)}function Xp(r){let e=Zp.decode(r),t=Uint8Array.from($e(e.length));return Fe([t,e],t.length+e.length)}function Jp(r){let e=wt(r),t=r.slice(Se(e));if(t.length!==e)throw new Error("inconsistent lengths");return"u"+ce(t,"base64url")}function Qp(r){let e=wt(r),t=r.slice(Se(e));if(t.length!==e)throw new Error("inconsistent lengths");return ce(t,"base58btc")}function e0(r){let e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);let t=dt.decode("b"+e[0]),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");let s=ba(n);return Fe([t,s],t.length+s.length)}function t0(r){let e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);let t=dt.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");let s=ba(n);return Fe([t,s],t.length+s.length)}function Ru(r){let e=r.slice(0,r.length-2),t=r.slice(r.length-2),n=ce(e,"base32"),s=Lu(t);return`${n}:${s}`}function Uu(r){r=wa(r);let e=[],t=[],n=null,s=r.split("/").slice(1);if(s.length===1&&s[0]==="")return{bytes:new Uint8Array,string:"/",tuples:[],stringTuples:[],path:null};for(let i=0;i<s.length;i++){let o=s[i],a=te(o);if(a.size===0){e.push([a.code]),t.push([a.code]);continue}if(i++,i>=s.length)throw Ou("invalid address: "+r);if(a.path===!0){n=wa(s.slice(i).join("/")),e.push([a.code,ya(a.code,n)]),t.push([a.code,n]);break}let c=ya(a.code,s[i]);e.push([a.code,c]),t.push([a.code,ga(a.code,c)])}return{string:Du(t),bytes:va(e),tuples:e,stringTuples:t,path:n}}function xa(r){let e=[],t=[],n=null,s=0;for(;s<r.length;){let i=wt(r,s),o=Se(i),a=te(i),c=r0(a,r.slice(s+o));if(c===0){e.push([i]),t.push([i]),s+=o;continue}let h=r.slice(s+o,s+o+c);if(s+=c+o,s>r.length)throw Ou("Invalid address Uint8Array: "+ce(r,"base16"));e.push([i,h]);let f=ga(i,h);if(t.push([i,f]),a.path===!0){n=f;break}}return{bytes:Uint8Array.from(r),string:Du(t),tuples:e,stringTuples:t,path:n}}function Du(r){let e=[];return r.map(t=>{let n=te(t[0]);return e.push(n.name),t.length>1&&t[1]!=null&&e.push(t[1]),null}),wa(e.join("/"))}function va(r){return Fe(r.map(e=>{let t=te(e[0]),n=Uint8Array.from($e(t.code));return e.length>1&&e[1]!=null&&(n=Fe([n,e[1]])),n}))}function r0(r,e){if(r.size>0)return r.size/8;if(r.size===0)return 0;{let t=wt(e instanceof Uint8Array?e:Uint8Array.from(e));return t+Se(t)}}function wa(r){return"/"+r.trim().split("/").filter(e=>e).join("/")}function Ou(r){return new Error("Error parsing address: "+r)}var n0=Symbol.for("nodejs.util.inspect.custom"),Sa=Symbol.for("@multiformats/js-multiaddr/multiaddr"),s0=[te("dns").code,te("dns4").code,te("dns6").code,te("dnsaddr").code],Ea=class extends Error{constructor(e="No available resolver"){super(e),this.name="NoAvailableResolverError"}},Js=class r{bytes;#e;#t;#r;#n;[Sa]=!0;constructor(e){e==null&&(e="");let t;if(e instanceof Uint8Array)t=xa(e);else if(typeof e=="string"){if(e.length>0&&e.charAt(0)!=="/")throw new Error(`multiaddr "${e}" must start with a "/"`);t=Uu(e)}else if(Pu(e))t=xa(e.bytes);else throw new Error("addr must be a string, Buffer, or another Multiaddr");this.bytes=t.bytes,this.#e=t.string,this.#t=t.tuples,this.#r=t.stringTuples,this.#n=t.path}toString(){return this.#e}toJSON(){return this.toString()}toOptions(){let e,t,n,s,i="",o=te("tcp"),a=te("udp"),c=te("ip4"),h=te("ip6"),f=te("dns6"),u=te("ip6zone");for(let[l,d]of this.stringTuples())l===u.code&&(i=`%${d??""}`),s0.includes(l)&&(t=o.name,s=443,n=`${d??""}${i}`,e=l===f.code?6:4),(l===o.code||l===a.code)&&(t=te(l).name,s=parseInt(d??"")),(l===c.code||l===h.code)&&(t=te(l).name,n=`${d??""}${i}`,e=l===h.code?6:4);if(e==null||t==null||n==null||s==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:e,host:n,transport:t,port:s}}protos(){return this.#t.map(([e])=>Object.assign({},te(e)))}protoCodes(){return this.#t.map(([e])=>e)}protoNames(){return this.#t.map(([e])=>te(e).name)}tuples(){return this.#t.map(([e,t])=>t==null?[e]:[e,t])}stringTuples(){return this.#r.map(([e,t])=>t==null?[e]:[e,t])}encapsulate(e){return e=new r(e),new r(this.toString()+e.toString())}decapsulate(e){let t=e.toString(),n=this.toString(),s=n.lastIndexOf(t);if(s<0)throw new Error(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);return new r(n.slice(0,s))}decapsulateCode(e){let t=this.tuples();for(let n=t.length-1;n>=0;n--)if(t[n][0]===e)return new r(va(t.slice(0,n)));return this}getPeerId(){try{let e=[];this.stringTuples().forEach(([n,s])=>{n===kr.p2p.code&&e.push([n,s]),n===kr["p2p-circuit"].code&&(e=[])});let t=e.pop();if(t?.[1]!=null){let n=t[1];return n[0]==="Q"||n[0]==="1"?ce(ee.decode(`z${n}`),"base58btc"):ce(pe.parse(n).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){return this.#n}equals(e){return me(this.bytes,e.bytes)}async resolve(e){let t=this.protos().find(i=>i.resolvable);if(t==null)return[this];let n=Mu.get(t.name);if(n==null)throw new Ea(`no available resolver for ${t.name}`);return(await n(this,e)).map(i=>_e(i))}nodeAddress(){let e=this.toOptions();if(e.transport!=="tcp"&&e.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:e.family,address:e.host,port:e.port}}isThinWaistAddress(e){let t=(e??this).protos();return!(t.length!==2||t[0].code!==4&&t[0].code!==41||t[1].code!==6&&t[1].code!==273)}[n0](){return`Multiaddr(${this.#e})`}};var Mu=new Map;function Pu(r){return!!r?.[Sa]}function _e(r){return new Js(r)}function tt(){let r={};return r.promise=new Promise((e,t)=>{r.resolve=e,r.reject=t}),r}var Qs=class extends Error{type;code;constructor(e,t,n){super(e??"The operation was aborted"),this.type="aborted",this.name=n??"AbortError",this.code=t??"ABORT_ERR"}};async function ei(r,e,t){if(e==null)return r;if(e.aborted)return Promise.reject(new Qs(t?.errorMessage,t?.errorCode,t?.errorName));let n,s=new Qs(t?.errorMessage,t?.errorCode,t?.errorName);try{return await Promise.race([r,new Promise((i,o)=>{n=()=>{o(s)},e.addEventListener("abort",n)})])}finally{n!=null&&e.removeEventListener("abort",n)}}var Aa=class{readNext;haveNext;ended;nextResult;constructor(){this.ended=!1,this.readNext=tt(),this.haveNext=tt()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");let e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=tt(),e}async throw(e){return this.ended=!0,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){let e={done:!0,value:void 0};return await this._push(void 0),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=tt(),await ei(this.readNext.promise,t?.signal,t)}};function Vu(){return new Aa}var ti=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};var Ba=class extends Error{code;constructor(e,t){super(e),this.code=t}},_a=class extends Ba{type;constructor(e){super(e,"ABORT_ERR"),this.type="aborted",this.name="AbortError"}};function Hu(r,e){let t=Vu();r.sink(t).catch(async o=>{await t.end(o)}),r.sink=async o=>{for await(let a of o)await t.push(a);await t.end()};let n=r.source;r.source[Symbol.iterator]!=null?n=r.source[Symbol.iterator]():r.source[Symbol.asyncIterator]!=null&&(n=r.source[Symbol.asyncIterator]());let s=new et;return{read:async(o,a)=>{a?.signal?.throwIfAborted();let c,h=new Promise((f,u)=>{c=()=>{u(new _a("Read aborted"))},a?.signal?.addEventListener("abort",c)});try{if(o==null){let{done:u,value:g}=await Promise.race([n.next(),h]);return u===!0?new et:g}for(;s.byteLength<o;){let{value:u,done:g}=await Promise.race([n.next(),h]);if(g===!0)throw new ti("unexpected end of input");s.append(u)}let f=s.sublist(0,o);return s.consume(o),f}finally{c!=null&&a?.signal?.removeEventListener("abort",c)}},write:async(o,a)=>{a?.signal?.throwIfAborted(),o instanceof Uint8Array?await t.push(o,a):await t.push(o.subarray(),a)},unwrap:()=>{if(s.byteLength>0){let o=r.source;r.source=async function*(){e?.yieldBytes===!1?yield s:yield*s,yield*o}()}return r}}}var ri=class extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"},ni=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"},si=class extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"};function Fu(r,e={}){let t=Hu(r,e);e.maxDataLength!=null&&e.maxLengthLength==null&&(e.maxLengthLength=Se(e.maxDataLength));let n=e?.lengthDecoder??wt,s=e?.lengthEncoder??$e;return{read:async o=>{let a=-1,c=new et;for(;;){c.append(await t.read(1,o));try{a=n(c)}catch(h){if(h instanceof RangeError)continue;throw h}if(a<0)throw new ri("Invalid message length");if(e?.maxLengthLength!=null&&c.byteLength>e.maxLengthLength)throw new si("message length length too long");if(a>-1)break}if(e?.maxDataLength!=null&&a>e.maxDataLength)throw new ni("message length too long");return t.read(a,o)},write:async(o,a)=>{await t.write(new et(s(o.byteLength),o),a)},writeV:async(o,a)=>{let c=new et(...o.flatMap(h=>[s(h.byteLength),h]));await t.write(c,a)},unwrap:()=>t.unwrap()}}function qt(r,e){let t=Fu(r,e),n={read:async(s,i)=>{let o=await t.read(i);return s.decode(o)},write:async(s,i,o)=>{await t.write(i.encode(s),o)},writeV:async(s,i,o)=>{await t.writeV(s.map(a=>i.encode(a)),o)},pb:s=>({read:async i=>n.read(s,i),write:async(i,o)=>n.write(i,s,o),writeV:async(i,o)=>n.writeV(i,s,o),unwrap:()=>n}),unwrap:()=>t.unwrap()};return n}var Ia=1e3,Ku=60*Ia,ii=290,qu=15,zu=2*60*Ku,$u=1,oi=2e3,Gu=100,Ta="circuit-relay-source",pn=`${Vi}-circuit-relay`,ka=`${Vi}-circuit-relay-source`,Wu=2*Ku,Zu=BigInt(1<<17),We="/libp2p/circuit/relay/0.2.0/hop",sr="/libp2p/circuit/relay/0.2.0/stop",ju=30*Ia,k1=30*Ia,mn=300,Yu=4096,Xu=.001;var X;(function(r){let e;(function(s){s.RESERVE="RESERVE",s.CONNECT="CONNECT",s.STATUS="STATUS"})(e=r.Type||(r.Type={}));let t;(function(s){s[s.RESERVE=0]="RESERVE",s[s.CONNECT=1]="CONNECT",s[s.STATUS=2]="STATUS"})(t||(t={})),function(s){s.codec=()=>tr(t)}(e=r.Type||(r.Type={}));let n;r.codec=()=>(n==null&&(n=Pe((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.type!=null&&(i.uint32(8),r.Type.codec().encode(s.type,i)),s.peer!=null&&(i.uint32(18),Cr.codec().encode(s.peer,i)),s.reservation!=null&&(i.uint32(26),ai.codec().encode(s.reservation,i)),s.limit!=null&&(i.uint32(34),Nr.codec().encode(s.limit,i)),s.status!=null&&(i.uint32(40),K.codec().encode(s.status,i)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{let a={},c=i==null?s.len:s.pos+i;for(;s.pos<c;){let h=s.uint32();switch(h>>>3){case 1:{a.type=r.Type.codec().decode(s);break}case 2:{a.peer=Cr.codec().decode(s,s.uint32(),{limits:o.limits?.peer});break}case 3:{a.reservation=ai.codec().decode(s,s.uint32(),{limits:o.limits?.reservation});break}case 4:{a.limit=Nr.codec().decode(s,s.uint32(),{limits:o.limits?.limit});break}case 5:{a.status=K.codec().decode(s);break}default:{s.skipType(h&7);break}}}return a})),n),r.encode=s=>Me(s,r.codec()),r.decode=(s,i)=>Oe(s,r.codec(),i)})(X||(X={}));var Ke;(function(r){let e;(function(s){s.CONNECT="CONNECT",s.STATUS="STATUS"})(e=r.Type||(r.Type={}));let t;(function(s){s[s.CONNECT=0]="CONNECT",s[s.STATUS=1]="STATUS"})(t||(t={})),function(s){s.codec=()=>tr(t)}(e=r.Type||(r.Type={}));let n;r.codec=()=>(n==null&&(n=Pe((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.type!=null&&(i.uint32(8),r.Type.codec().encode(s.type,i)),s.peer!=null&&(i.uint32(18),Cr.codec().encode(s.peer,i)),s.limit!=null&&(i.uint32(26),Nr.codec().encode(s.limit,i)),s.status!=null&&(i.uint32(32),K.codec().encode(s.status,i)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{let a={},c=i==null?s.len:s.pos+i;for(;s.pos<c;){let h=s.uint32();switch(h>>>3){case 1:{a.type=r.Type.codec().decode(s);break}case 2:{a.peer=Cr.codec().decode(s,s.uint32(),{limits:o.limits?.peer});break}case 3:{a.limit=Nr.codec().decode(s,s.uint32(),{limits:o.limits?.limit});break}case 4:{a.status=K.codec().decode(s);break}default:{s.skipType(h&7);break}}}return a})),n),r.encode=s=>Me(s,r.codec()),r.decode=(s,i)=>Oe(s,r.codec(),i)})(Ke||(Ke={}));var Cr;(function(r){let e;r.codec=()=>(e==null&&(e=Pe((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.id!=null&&t.id.byteLength>0&&(n.uint32(10),n.bytes(t.id)),t.addrs!=null)for(let i of t.addrs)n.uint32(18),n.bytes(i);s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{let i={id:ae(0),addrs:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){let a=t.uint32();switch(a>>>3){case 1:{i.id=t.bytes();break}case 2:{if(s.limits?.addrs!=null&&i.addrs.length===s.limits.addrs)throw new Xr('Decode error - map field "addrs" had too many elements');i.addrs.push(t.bytes());break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>Me(t,r.codec()),r.decode=(t,n)=>Oe(t,r.codec(),n)})(Cr||(Cr={}));var ai;(function(r){let e;r.codec=()=>(e==null&&(e=Pe((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.expire!=null&&t.expire!==0n&&(n.uint32(8),n.uint64(t.expire)),t.addrs!=null)for(let i of t.addrs)n.uint32(18),n.bytes(i);t.voucher!=null&&(n.uint32(26),ci.codec().encode(t.voucher,n)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{let i={expire:0n,addrs:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){let a=t.uint32();switch(a>>>3){case 1:{i.expire=t.uint64();break}case 2:{if(s.limits?.addrs!=null&&i.addrs.length===s.limits.addrs)throw new Xr('Decode error - map field "addrs" had too many elements');i.addrs.push(t.bytes());break}case 3:{i.voucher=ci.codec().decode(t,t.uint32(),{limits:s.limits?.voucher});break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>Me(t,r.codec()),r.decode=(t,n)=>Oe(t,r.codec(),n)})(ai||(ai={}));var Nr;(function(r){let e;r.codec=()=>(e==null&&(e=Pe((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.duration!=null&&(n.uint32(8),n.uint32(t.duration)),t.data!=null&&(n.uint32(16),n.uint64(t.data)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{let i={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){let a=t.uint32();switch(a>>>3){case 1:{i.duration=t.uint32();break}case 2:{i.data=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>Me(t,r.codec()),r.decode=(t,n)=>Oe(t,r.codec(),n)})(Nr||(Nr={}));var K;(function(r){r.UNUSED="UNUSED",r.OK="OK",r.RESERVATION_REFUSED="RESERVATION_REFUSED",r.RESOURCE_LIMIT_EXCEEDED="RESOURCE_LIMIT_EXCEEDED",r.PERMISSION_DENIED="PERMISSION_DENIED",r.CONNECTION_FAILED="CONNECTION_FAILED",r.NO_RESERVATION="NO_RESERVATION",r.MALFORMED_MESSAGE="MALFORMED_MESSAGE",r.UNEXPECTED_MESSAGE="UNEXPECTED_MESSAGE"})(K||(K={}));var Ca;(function(r){r[r.UNUSED=0]="UNUSED",r[r.OK=100]="OK",r[r.RESERVATION_REFUSED=200]="RESERVATION_REFUSED",r[r.RESOURCE_LIMIT_EXCEEDED=201]="RESOURCE_LIMIT_EXCEEDED",r[r.PERMISSION_DENIED=202]="PERMISSION_DENIED",r[r.CONNECTION_FAILED=203]="CONNECTION_FAILED",r[r.NO_RESERVATION=204]="NO_RESERVATION",r[r.MALFORMED_MESSAGE=400]="MALFORMED_MESSAGE",r[r.UNEXPECTED_MESSAGE=401]="UNEXPECTED_MESSAGE"})(Ca||(Ca={}));(function(r){r.codec=()=>tr(Ca)})(K||(K={}));var Rr;(function(r){let e;r.codec=()=>(e==null&&(e=Pe((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.relay!=null&&t.relay.byteLength>0&&(n.uint32(10),n.bytes(t.relay)),t.peer!=null&&t.peer.byteLength>0&&(n.uint32(18),n.bytes(t.peer)),t.expiration!=null&&t.expiration!==0n&&(n.uint32(24),n.uint64(t.expiration)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{let i={relay:ae(0),peer:ae(0),expiration:0n},o=n==null?t.len:t.pos+n;for(;t.pos<o;){let a=t.uint32();switch(a>>>3){case 1:{i.relay=t.bytes();break}case 2:{i.peer=t.bytes();break}case 3:{i.expiration=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>Me(t,r.codec()),r.decode=(t,n)=>Oe(t,r.codec(),n)})(Rr||(Rr={}));var ci;(function(r){let e;r.codec=()=>(e==null&&(e=Pe((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(n.uint32(10),n.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(n.uint32(18),n.bytes(t.payloadType)),t.payload!=null&&(n.uint32(26),Rr.codec().encode(t.payload,n)),t.signature!=null&&t.signature.byteLength>0&&(n.uint32(42),n.bytes(t.signature)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{let i={publicKey:ae(0),payloadType:ae(0),signature:ae(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){let a=t.uint32();switch(a>>>3){case 1:{i.publicKey=t.bytes();break}case 2:{i.payloadType=t.bytes();break}case 3:{i.payload=Rr.codec().decode(t,t.uint32(),{limits:s.limits?.payload});break}case 5:{i.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>Me(t,r.codec()),r.decode=(t,n)=>Oe(t,r.codec(),n)})(ci||(ci={}));var i0=r=>r.toString().split("/").slice(1),Lr=r=>({match:e=>e.length<1?!1:r(e[0])?e.slice(1):!1,pattern:"fn"}),F=r=>({match:e=>Lr(t=>t===r).match(e),pattern:r}),ir=()=>({match:r=>Lr(e=>typeof e=="string").match(r),pattern:"{string}"}),gn=()=>({match:r=>Lr(e=>!isNaN(parseInt(e))).match(r),pattern:"{number}"}),Q=()=>({match:r=>{if(r.length<2||r[0]!=="p2p"&&r[0]!=="ipfs")return!1;if(r[1].startsWith("Q")||r[1].startsWith("1"))try{ee.decode(`z${r[1]}`)}catch{return!1}else return!1;return r.slice(2)},pattern:"/p2p/{peerid}"}),yn=()=>({match:r=>{if(r.length<2||r[0]!=="certhash")return!1;try{No.decode(r[1])}catch{return!1}return r.slice(2)},pattern:"/certhash/{certhash}"}),W=r=>({match:e=>{let t=r.match(e);return t===!1?e:t},pattern:`optional(${r.pattern})`}),Ie=(...r)=>({match:e=>{let t;for(let n of r){let s=n.match(e);s!==!1&&(t==null||s.length<t.length)&&(t=s)}return t??!1},pattern:`or(${r.map(e=>e.pattern).join(", ")})`}),q=(...r)=>({match:e=>{for(let t of r){let n=t.match(e);if(n===!1)return!1;e=n}return e},pattern:`and(${r.map(e=>e.pattern).join(", ")})`});function ne(...r){function e(s){let i=i0(s);for(let o of r){let a=o.match(i);if(a===!1)return!1;i=a}return i}function t(s){return e(s)!==!1}function n(s){let i=e(s);return i===!1?!1:i.length===0}return{matchers:r,matches:t,exactMatch:n}}var ui=q(F("dns4"),ir()),fi=q(F("dns6"),ir()),hi=q(F("dnsaddr"),ir()),Ra=q(F("dns"),ir()),V1=ne(ui,W(Q())),H1=ne(fi,W(Q())),F1=ne(hi,W(Q())),K1=ne(Ie(Ra,hi,ui,fi),W(Q())),Ju=q(F("ip4"),Lr(js)),Qu=q(F("ip6"),Lr(Ys)),La=Ie(Ju,Qu),Tt=Ie(La,Ra,ui,fi,hi),q1=ne(Ie(La,q(Ie(Ra,hi,ui,fi),W(Q())))),z1=ne(Ju),$1=ne(Qu),G1=ne(La),Ua=q(Tt,F("tcp"),gn()),bn=q(Tt,F("udp"),gn()),W1=ne(q(Ua,W(Q()))),Z1=ne(bn),Da=q(bn,F("quic"),W(Q())),di=q(bn,F("quic-v1"),W(Q())),o0=Ie(Da,di),j1=ne(Da),Y1=ne(di),Na=Ie(Tt,Ua,bn,Da,di),ef=Ie(q(Na,F("ws"),W(Q()))),X1=ne(ef),tf=Ie(q(Na,F("wss"),W(Q())),q(Na,F("tls"),W(q(F("sni"),ir())),F("ws"),W(Q()))),J1=ne(tf),rf=q(bn,F("webrtc-direct"),W(yn()),W(yn()),W(Q())),Q1=ne(rf),nf=q(di,F("webtransport"),W(yn()),W(yn()),W(Q())),ev=ne(nf),li=Ie(ef,tf,q(Ua,W(Q())),q(o0,W(Q())),q(Tt,W(Q())),rf,nf,Q()),sf=ne(li),a0=q(li,F("p2p-circuit"),Q()),pi=ne(a0),c0=Ie(q(li,F("p2p-circuit"),F("webrtc"),W(Q())),q(li,F("webrtc"),W(Q())),q(F("webrtc"),W(Q()))),tv=ne(c0),l0=Ie(q(Tt,F("tcp"),gn(),F("http"),W(Q())),q(Tt,F("http"),W(Q()))),rv=ne(l0),u0=Ie(q(Tt,F("tcp"),Ie(q(F("443"),F("http")),q(gn(),F("https"))),W(Q())),q(Tt,F("tls"),F("http"),W(Q())),q(Tt,F("https"),W(Q()))),nv=ne(u0),f0=Ie(q(F("memory"),ir(),W(Q()))),sv=ne(f0);function mi(r){let e=new globalThis.AbortController;function t(){e.abort();for(let i of r)i?.removeEventListener!=null&&i.removeEventListener("abort",t)}for(let i of r){if(i?.aborted===!0){t();break}i?.addEventListener!=null&&i.addEventListener("abort",t)}function n(){for(let i of r)i?.removeEventListener!=null&&i.removeEventListener("abort",t)}let s=e.signal;return s.clear=n,s}var gi=class extends Error{constructor(e="Transfer limit error"){super(e),this.name="TransferLimitError"}},wn=class extends Error{constructor(e="Duration limit error"){super(e),this.name="DurationLimitError"}},xn=class extends Error{static name="HadEnoughRelaysError";name="HadEnoughRelaysError"},yi=class extends Error{static name="DoubleRelayError";name="DoubleRelayError"},bi=class extends Error{static name="RelayQueueFullError";name="RelayQueueFullError"};async function*of(r,e,t){let n=e.remaining;for await(let s of r){let i=BigInt(s.byteLength);if(e.remaining-i<0){let o=Number(e.remaining);e.remaining=0n;try{o!==0&&(yield s.subarray(0,o))}catch(a){t.log.error(a)}throw new gi(`data limit of ${n} bytes exceeded`)}e.remaining-=i,yield s}}function af(r,e,t,n,s){function i(u){r.abort(u),e.abort(u)}let o=[t,n.signal];n.limit?.duration!=null&&(s.log("limiting relayed connection duration to %dms",n.limit.duration),o.push(AbortSignal.timeout(n.limit.duration)));let a=mi(o),c=!1,h=!1,f;n.limit?.data!=null&&(f={remaining:n.limit.data}),queueMicrotask(()=>{let u=()=>{s.log("relayed connection reached time limit"),e.abort(new wn(`duration limit of ${n.limit?.duration} ms exceeded`))};a.addEventListener("abort",u,{once:!0}),e.sink(f==null?r.source:of(r.source,f,s)).catch(g=>{s.log.error("error while relaying streams src -> dst",g),i(g)}).finally(()=>{c=!0,h&&(a.removeEventListener("abort",u),a.clear())})}),queueMicrotask(()=>{let u=()=>{s.log("relayed connection reached time limit"),r.abort(new wn(`duration limit of ${n.limit?.duration} ms exceeded`))};a.addEventListener("abort",u,{once:!0}),r.sink(f==null?e.source:of(e.source,f,s)).catch(g=>{s.log.error("error while relaying streams dst -> src",g),i(g)}).finally(()=>{h=!0,c&&(a.removeEventListener("abort",u),a.clear())})})}function Oa(r){let e=r*BigInt(1e3),t=new Date().getTime();return Number(e-BigInt(t))}var vn=class{expires;bytes;constructor(e){e?.duration!=null&&e?.duration!==0&&(this.expires=Date.now()+e.duration*1e3),this.bytes=e?.data,this.bytes===0n&&(this.bytes=void 0),this.onData=this.onData.bind(this)}onData(e){this.bytes!=null&&(this.bytes-=BigInt(e.byteLength),this.bytes<0n&&(this.bytes=0n))}getLimits(){if(this.expires==null&&this.bytes==null)return;let e={};if(this.bytes!=null){let t=this;Object.defineProperty(e,"bytes",{get(){return t.bytes}})}if(this.expires!=null){let t=this;Object.defineProperty(e,"seconds",{get(){return Math.round(((t.expires??0)-Date.now())/1e3)}})}return e}},wi=ne(q(sf.matchers[0],F("p2p-circuit"))),xi=ne(F("p2p-circuit"));function vi(r,e){let t={[Symbol.iterator]:()=>t,next:()=>{let n=r.next(),s=n.value;return n.done===!0||s==null?{done:!0,value:void 0}:{done:!1,value:e(s)}}};return t}var zt=class{map;constructor(e){if(this.map=new Map,e!=null)for(let[t,n]of e.entries())this.map.set(t.toString(),{key:t,value:n})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(e){return this.map.delete(e.toString())}entries(){return vi(this.map.entries(),e=>[e[1].key,e[1].value])}forEach(e){this.map.forEach((t,n)=>{e(t.value,t.key,this)})}get(e){return this.map.get(e.toString())?.value}has(e){return this.map.has(e.toString())}set(e,t){this.map.set(e.toString(),{key:e,value:t})}keys(){return vi(this.map.values(),e=>e.key)}values(){return vi(this.map.values(),e=>e.value)}get size(){return this.map.size}};var Ma=64,rt=class{fp;h;seed;constructor(e,t,n,s=2){if(s>Ma)throw new TypeError("Invalid Fingerprint Size");let i=t.hashV(e,n),o=ae(s);for(let a=0;a<o.length;a++)o[a]=i[a];o.length===0&&(o[0]=7),this.fp=o,this.h=t,this.seed=n}hash(){return this.h.hash(this.fp,this.seed)}equals(e){return e?.fp instanceof Uint8Array?me(this.fp,e.fp):!1}};function or(r,e){return Math.floor(Math.random()*(e-r))+r}var ar=class{contents;constructor(e){this.contents=new Array(e).fill(null)}has(e){if(!(e instanceof rt))throw new TypeError("Invalid Fingerprint");return this.contents.some(t=>e.equals(t))}add(e){if(!(e instanceof rt))throw new TypeError("Invalid Fingerprint");for(let t=0;t<this.contents.length;t++)if(this.contents[t]==null)return this.contents[t]=e,!0;return!0}swap(e){if(!(e instanceof rt))throw new TypeError("Invalid Fingerprint");let t=or(0,this.contents.length-1),n=this.contents[t];return this.contents[t]=e,n}remove(e){if(!(e instanceof rt))throw new TypeError("Invalid Fingerprint");let t=this.contents.findIndex(n=>e.equals(n));return t>-1?(this.contents[t]=null,!0):!1}};var Pa={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},ff={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},hf=new globalThis.TextEncoder;function h0(r,e){let t=Pa[e],n=ff[e];for(let s=0;s<r.length;s++)n^=BigInt(r[s]),n=BigInt.asUintN(e,n*t);return n}function d0(r,e,t){if(t.length===0)throw new Error("The `utf8Buffer` option must have a length greater than zero");let n=Pa[e],s=ff[e],i=r;for(;i.length>0;){let o=hf.encodeInto(i,t);i=i.slice(o.read);for(let a=0;a<o.written;a++)s^=BigInt(t[a]),s=BigInt.asUintN(e,s*n)}return s}function Va(r,{size:e=32,utf8Buffer:t}={}){if(!Pa[e])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if(typeof r=="string"){if(t)return d0(r,e,t);r=hf.encode(r)}return h0(r,e)}var p0=ic(uf(),1);var Sn={hash:r=>Number(Va(r,{size:32})),hashV:(r,e)=>m0(Sn.hash(r,e))};function m0(r){let e=r.toString(16);return e.length%2===1&&(e=`0${e}`),G(e,"base16")}var g0=500,An=class{bucketSize;filterSize;fingerprintSize;buckets;count;hash;seed;constructor(e){this.filterSize=e.filterSize,this.bucketSize=e.bucketSize??4,this.fingerprintSize=e.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=e.hash??Sn,this.seed=e.seed??or(0,Math.pow(2,10))}add(e){typeof e=="string"&&(e=G(e));let t=new rt(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=(n^t.hash())%this.filterSize;if(this.buckets[n]==null&&(this.buckets[n]=new ar(this.bucketSize)),this.buckets[s]==null&&(this.buckets[s]=new ar(this.bucketSize)),this.buckets[n].add(t)||this.buckets[s].add(t))return this.count++,!0;let i=[n,s],o=i[or(0,i.length-1)];this.buckets[o]==null&&(this.buckets[o]=new ar(this.bucketSize));for(let a=0;a<g0;a++){let c=this.buckets[o].swap(t);if(c!=null&&(o=(o^c.hash())%this.filterSize,this.buckets[o]==null&&(this.buckets[o]=new ar(this.bucketSize)),this.buckets[o].add(c)))return this.count++,!0}return!1}has(e){typeof e=="string"&&(e=G(e));let t=new rt(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=this.buckets[n]?.has(t)??!1;if(s)return s;let i=(n^t.hash())%this.filterSize;return this.buckets[i]?.has(t)??!1}remove(e){typeof e=="string"&&(e=G(e));let t=new rt(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=this.buckets[n]?.remove(t)??!1;if(s)return this.count--,s;let i=(n^t.hash())%this.filterSize,o=this.buckets[i]?.remove(t)??!1;return o&&this.count--,o}get reliable(){return Math.floor(100*(this.count/this.filterSize))<=90}},y0={1:.5,2:.84,4:.95,8:.98};function b0(r=.001){return r>.002?2:r>1e-5?4:8}function df(r,e=.001){let t=b0(e),n=y0[t],s=Math.round(r/n),i=Math.min(Math.ceil(Math.log2(1/e)+Math.log2(2*t)),Ma);return{filterSize:s,bucketSize:t,fingerprintSize:i}}var Si=class{filterSize;bucketSize;fingerprintSize;scale;filterSeries;hash;seed;constructor(e){this.bucketSize=e.bucketSize??4,this.filterSize=e.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=e.fingerprintSize??2,this.scale=e.scale??2,this.hash=e.hash??Sn,this.seed=e.seed??or(0,Math.pow(2,10)),this.filterSeries=[new An({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(e){if(typeof e=="string"&&(e=G(e)),this.has(e))return!0;let t=this.filterSeries.find(n=>n.reliable);if(t==null){let n=this.filterSize*Math.pow(this.scale,this.filterSeries.length);t=new An({filterSize:n,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(t)}return t.add(e)}has(e){typeof e=="string"&&(e=G(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].has(e))return!0;return!1}remove(e){typeof e=="string"&&(e=G(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].remove(e))return!0;return!1}get count(){return this.filterSeries.reduce((e,t)=>e+t.count,0)}};function Ur(r,e=.001,t){return new Si({...df(r,e),...t??{}})}var Ai=class{filter;constructor(e,t){this.filter=Ur(e,t)}has(e){return this.filter.has(e.toMultihash().bytes)}add(e){this.filter.add(e.toMultihash().bytes)}remove(e){this.filter.remove?.(e.toMultihash().bytes)}};function Ha(r,e=.001){return new Ai(r,e)}var Fa=class extends zt{metric;constructor(e){super();let{name:t,metrics:n}=e;this.metric=n.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){let t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}};function Ka(r){let{name:e,metrics:t}=r,n;return t!=null?n=new Fa({name:e,metrics:t}):n=new zt,n}var qa=class extends Error{type;code;constructor(e,t,n){super(e??"The operation was aborted"),this.type="aborted",this.name=n??"AbortError",this.code=t??"ABORT_ERR"}};function pf(r,e){let t=new qa(e?.errorMessage,e?.errorCode,e?.errorName),n=new AbortController,s=()=>{n.abort(t)},i=AbortSignal.timeout(r);i.addEventListener("abort",s);let o=n.signal;return o.reset=a=>{i?.removeEventListener("abort",s),i=AbortSignal.timeout(a??r),i.addEventListener("abort",()=>{n.abort(t)})},o.clear=()=>{i?.removeEventListener("abort",s),i=void 0},o}var Bi=class{reservations;maxReservations;applyDefaultLimit;reservationTtl;defaultDurationLimit;defaultDataLimit;log;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:circuit-relay:server:reservation-store"),this.maxReservations=t.maxReservations??qu,this.applyDefaultLimit=t.applyDefaultLimit!==!1,this.reservationTtl=t.reservationTtl??zu,this.defaultDurationLimit=t.defaultDurationLimit??Wu,this.defaultDataLimit=t.defaultDataLimit??Zu,this.reservations=Ka({metrics:e.metrics,name:"libp2p_circuit_relay_server_reservations_total"})}reserve(e,t,n){let s=this.reservations.get(e);if(this.reservations.size>=this.maxReservations&&s==null)return{status:K.RESERVATION_REFUSED};let i=new Date(Date.now()+this.reservationTtl),o;return this.applyDefaultLimit&&(o=n??{data:this.defaultDataLimit,duration:this.defaultDurationLimit}),s!=null?(this.log("refreshing reservation for client %p",e),s.signal.reset(this.reservationTtl)):(this.log("creating new reservation for client %p",e),s={addr:t,expiry:i,limit:o,signal:pf(this.reservationTtl)}),this.reservations.set(e,s),s.signal.addEventListener("abort",()=>{this.reservations.delete(e)}),{status:K.OK,expire:Math.round(i.getTime()/1e3)}}removeReservation(e){this.reservations.delete(e)}get(e){return this.reservations.get(e)}clear(){this.reservations.clear()}};var _i=class r{domain="libp2p-relay-rsvp";codec=new Uint8Array([3,2]);relay;peer;expiration;constructor({relay:e,peer:t,expiration:n}){this.relay=e,this.peer=t,this.expiration=n}marshal(){return Rr.encode({relay:this.relay.toMultihash().bytes,peer:this.peer.toMultihash().bytes,expiration:BigInt(this.expiration)})}equals(e){return!(!(e instanceof r)||!this.peer.equals(e.peer)||!this.relay.equals(e.relay)||this.expiration!==e.expiration)}};var mf=r=>r.protoCodes().includes(ii),w0={maxOutboundStopStreams:mn},za=class extends qe{registrar;peerStore;addressManager;peerId;privateKey;connectionManager;connectionGater;reservationStore;started;hopTimeout;shutdownController;maxInboundHopStreams;maxOutboundHopStreams;maxOutboundStopStreams;log;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:server"),this.registrar=e.registrar,this.peerStore=e.peerStore,this.addressManager=e.addressManager,this.peerId=e.peerId,this.privateKey=e.privateKey,this.connectionManager=e.connectionManager,this.connectionGater=e.connectionGater,this.started=!1,this.hopTimeout=t?.hopTimeout??ju,this.maxInboundHopStreams=t.maxInboundHopStreams,this.maxOutboundHopStreams=t.maxOutboundHopStreams,this.maxOutboundStopStreams=t.maxOutboundStopStreams??w0.maxOutboundStopStreams,this.reservationStore=new Bi(e,t.reservations),this.shutdownController=new AbortController,Re(1/0,this.shutdownController.signal)}[Symbol.toStringTag]="@libp2p/circuit-relay-v2-server";isStarted(){return this.started}async start(){this.started||(await this.registrar.handle(We,e=>{this.onHop(e).catch(t=>{this.log.error(t)})},{maxInboundStreams:this.maxInboundHopStreams,maxOutboundStreams:this.maxOutboundHopStreams,runOnLimitedConnection:!0}),this.started=!0)}async stop(){this.reservationStore.clear(),this.shutdownController.abort(),await this.registrar.unhandle(We),this.started=!1}async onHop({connection:e,stream:t}){this.log("received circuit v2 hop protocol stream from %p",e.remotePeer);let n={signal:AbortSignal.timeout(this.hopTimeout)},s=qt(t);try{let i=await s.pb(X).read(n);if(i?.type==null)throw new Error("request was invalid, could not read from stream");this.log("received",i.type),await this.handleHopProtocol({connection:e,stream:s,request:i},n)}catch(i){this.log.error("error while handling hop",i),await s.pb(X).write({type:X.Type.STATUS,status:K.MALFORMED_MESSAGE},n),t.abort(i)}}async handleHopProtocol({stream:e,request:t,connection:n},s){switch(this.log("received hop message"),t.type){case X.Type.RESERVE:await this.handleReserve({stream:e,request:t,connection:n},s);break;case X.Type.CONNECT:await this.handleConnect({stream:e,request:t,connection:n},s);break;default:this.log.error("invalid hop request type %s via peer %p",t.type,n.remotePeer),await e.pb(X).write({type:X.Type.STATUS,status:K.UNEXPECTED_MESSAGE})}}async handleReserve({stream:e,connection:t},n){let s=e.pb(X);if(this.log("hop reserve request from %p",t.remotePeer),mf(t.remoteAddr)){this.log.error("relay reservation over circuit connection denied for peer: %p",t.remotePeer),await s.write({type:X.Type.STATUS,status:K.PERMISSION_DENIED},n);return}if(await this.connectionGater.denyInboundRelayReservation?.(t.remotePeer)===!0){this.log.error("reservation for %p denied by connection gater",t.remotePeer),await s.write({type:X.Type.STATUS,status:K.PERMISSION_DENIED},n);return}let i=this.reservationStore.reserve(t.remotePeer,t.remoteAddr);try{if(i.status!==K.OK){await s.write({type:X.Type.STATUS,status:i.status},n);return}if(i.expire!=null){let o=i.expire*1e3-Date.now();await this.peerStore.merge(t.remotePeer,{tags:{[Ta]:{value:1,ttl:o},[ka]:{value:1,ttl:o}}})}await s.write({type:X.Type.STATUS,status:K.OK,reservation:await this.makeReservation(t.remotePeer,BigInt(i.expire??0)),limit:this.reservationStore.get(t.remotePeer)?.limit},n),this.log("sent confirmation response to %s",t.remotePeer)}catch(o){this.log.error("failed to send confirmation response to %p - %e",t.remotePeer,o),this.reservationStore.removeReservation(t.remotePeer);try{await this.peerStore.merge(t.remotePeer,{tags:{[Ta]:void 0,[ka]:void 0}})}catch(a){this.log.error("failed to untag relay source peer %p - %e",t.remotePeer,a)}}}async makeReservation(e,t){let n=[];for(let i of this.addressManager.getAddresses())i.toString().includes("/p2p-circuit")||n.push(i.bytes);let s=await dn.seal(new _i({peer:e,relay:this.peerId,expiration:t}),this.privateKey);return{addrs:n,expire:t,voucher:{publicKey:Ot(s.publicKey),payloadType:s.payloadType,payload:{peer:e.toMultihash().bytes,relay:this.peerId.toMultihash().bytes,expiration:t},signature:s.signature}}}async handleConnect({stream:e,request:t,connection:n},s){let i=e.pb(X);if(mf(n.remoteAddr)){this.log.error("relay reservation over circuit connection denied for peer: %p",n.remotePeer),await i.write({type:X.Type.STATUS,status:K.PERMISSION_DENIED},s);return}this.log("hop connect request from %p",n.remotePeer);let o;try{if(t.peer==null)throw this.log.error("no peer info in hop connect request"),new Error("no peer info in request");t.peer.addrs.forEach(_e),o=fn(ze(t.peer.id))}catch(g){this.log.error("invalid hop connect request via peer %p %s",n.remotePeer,g),await i.write({type:X.Type.STATUS,status:K.MALFORMED_MESSAGE},s);return}let a=this.reservationStore.get(o);if(a==null){this.log.error("hop connect denied for destination peer %p not having a reservation for %p with status %s",o,n.remotePeer,K.NO_RESERVATION),await i.write({type:X.Type.STATUS,status:K.NO_RESERVATION},s);return}if(await this.connectionGater.denyOutboundRelayedConnection?.(n.remotePeer,o)===!0){this.log.error("hop connect for %p to %p denied by connection gater",n.remotePeer,o),await i.write({type:X.Type.STATUS,status:K.PERMISSION_DENIED},s);return}let c=this.connectionManager.getConnections(o);if(c.length===0){this.log("hop connect denied for destination peer %p not having a connection for %p as there is no destination connection",o,n.remotePeer),await i.write({type:X.Type.STATUS,status:K.NO_RESERVATION},s);return}let h=c[0],f=await this.stopHop({connection:h,request:{type:Ke.Type.CONNECT,peer:{id:n.remotePeer.toMultihash().bytes,addrs:[]},limit:a?.limit}},s);if(f==null){this.log.error("failed to open stream to destination peer %p",h?.remotePeer),await i.write({type:X.Type.STATUS,status:K.CONNECTION_FAILED},s);return}await i.write({type:X.Type.STATUS,status:K.OK,limit:a?.limit},s);let u=e.unwrap();this.log("connection from %p to %p established - merging streams",n.remotePeer,o),af(u,f,this.shutdownController.signal,a,{log:this.log})}async stopHop({connection:e,request:t},n){this.log("starting circuit relay v2 stop request to %s",e.remotePeer);let s=await e.newStream([sr],{maxOutboundStreams:this.maxOutboundStopStreams,runOnLimitedConnection:!0,...n}),i=qt(s),o=i.pb(Ke);await o.write(t,n);let a;try{a=await o.read(n)}catch{this.log.error("error parsing stop message response from %p",e.remotePeer)}if(a==null){this.log.error("could not read response from %p",e.remotePeer),await s.close(n);return}if(a.status===K.OK)return this.log("stop request to %p was successful",e.remotePeer),i.unwrap();this.log("stop request failed with code %d",a.status),await s.close(n)}get reservations(){return this.reservationStore.reservations}};function gf(r={}){return e=>new za(e,r)}function x0(r){let[e,t]=r[Symbol.asyncIterator]!=null?[r[Symbol.asyncIterator](),Symbol.asyncIterator]:[r[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>e.next(),push:s=>{n.push(s)},next:()=>n.length>0?{done:!1,value:n.shift()}:e.next(),[t](){return this}}}var yf=x0;function v0(r){return r[Symbol.asyncIterator]!=null}function bf(r){return r?.then!=null}function E0(r,e){let t=0;if(v0(r))return async function*(){for await(let c of r){let h=e(c,t++);bf(h)&&await h,yield c}}();let n=yf(r),{value:s,done:i}=n.next();if(i===!0)return function*(){}();if(typeof e(s,t++)?.then=="function")return async function*(){yield s;for await(let c of n){let h=e(c,t++);bf(h)&&await h,yield c}}();let a=e;return function*(){yield s;for(let c of n)a(c,t++),yield c}()}var wf=E0;var Ii=class{buffer;mask;top;btm;next;constructor(e){if(!(e>0)||e-1&e)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){let e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}},Dr=class{size;hwm;head;tail;constructor(e={}){this.hwm=e.splitLimit??16,this.head=new Ii(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return e?.byteLength!=null?e.byteLength:1}push(e){if(e?.value!=null&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){let t=this.head;this.head=t.next=new Ii(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next!=null){let t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return e?.value!=null&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}};var $a=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}};function Or(r={}){return S0(t=>{let n=t.shift();if(n==null)return{done:!0};if(n.error!=null)throw n.error;return{done:n.done===!0,value:n.value}},r)}function S0(r,e){e=e??{};let t=e.onEnd,n=new Dr,s,i,o,a=tt(),c=async()=>{try{return n.isEmpty()?o?{done:!0}:await new Promise((y,b)=>{i=w=>{i=null,n.push(w);try{y(r(n))}catch(p){b(p)}return s}}):r(n)}finally{n.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=tt()})}},h=y=>i!=null?i(y):(n.push(y),s),f=y=>(n=new Dr,i!=null?i({error:y}):(n.push({error:y}),s)),u=y=>{if(o)return s;if(e?.objectMode!==!0&&y?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return h({done:!1,value:y})},g=y=>o?s:(o=!0,y!=null?f(y):h({done:!0})),l=()=>(n=new Dr,g(),{done:!0}),d=y=>(g(y),{done:!0});if(s={[Symbol.asyncIterator](){return this},next:c,return:l,throw:d,push:u,end:g,get readableLength(){return n.size},onEmpty:async y=>{let b=y?.signal;if(b?.throwIfAborted(),n.isEmpty())return;let w,p;b!=null&&(w=new Promise((E,A)=>{p=()=>{A(new $a)},b.addEventListener("abort",p)}));try{await Promise.race([a.promise,w])}finally{p!=null&&b!=null&&b?.removeEventListener("abort",p)}}},t==null)return s;let m=s;return s={[Symbol.asyncIterator](){return this},next(){return m.next()},throw(y){return m.throw(y),t!=null&&(t(y),t=void 0),{done:!0}},return(){return m.return(),t!=null&&(t(),t=void 0),{done:!0}},push:u,end(y){return m.end(y),t!=null&&(t(y),t=void 0),s},get readableLength(){return m.readableLength},onEmpty:y=>m.onEmpty(y)},s}function A0(r){return r[Symbol.asyncIterator]!=null}function B0(...r){let e=[];for(let t of r)A0(t)||e.push(t);return e.length===r.length?function*(){for(let t of e)yield*t}():async function*(){let t=Or({objectMode:!0});Promise.resolve().then(async()=>{try{await Promise.all(r.map(async n=>{for await(let s of n)t.push(s)})),t.end()}catch(n){t.end(n)}}),yield*t}()}var xf=B0;function vf(r,...e){if(r==null)throw new Error("Empty pipeline");if(Ga(r)){let n=r;r=()=>n.source}else if(Sf(r)||Ef(r)){let n=r;r=()=>n}let t=[r,...e];if(t.length>1&&Ga(t[t.length-1])&&(t[t.length-1]=t[t.length-1].sink),t.length>2)for(let n=1;n<t.length-1;n++)Ga(t[n])&&(t[n]=I0(t[n]));return _0(...t)}var _0=(...r)=>{let e;for(;r.length>0;)e=r.shift()(e);return e},Ef=r=>r?.[Symbol.asyncIterator]!=null,Sf=r=>r?.[Symbol.iterator]!=null,Ga=r=>r==null?!1:r.sink!=null&&r.source!=null,I0=r=>e=>{let t=r.sink(e);if(t?.then!=null){let n=Or({objectMode:!0});t.then(()=>{n.end()},o=>{n.end(o)});let s,i=r.source;if(Ef(i))s=async function*(){yield*i,n.end()};else if(Sf(i))s=function*(){yield*i,n.end()};else throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");return xf(n,s())}return r.source};function Wa(r){let{stream:e,remoteAddr:t,logger:n,onDataRead:s,onDataWrite:i}=r,o=n.forComponent("libp2p:stream:converter"),a=!1,c=!1,h=e.close.bind(e);e.close=async d=>{await h(d),l(!0)};let f=e.abort.bind(e);e.abort=d=>{f(d),l(!0)};let u=e.sink.bind(e);e.sink=async d=>{try{await u(vf(d,m=>wf(m,y=>i?.(y))))}catch(m){m.type!=="aborted"&&o.error("%s error in sink",t,m)}finally{c=!0,l()}};let g={log:o,sink:e.sink,source:async function*(){try{for await(let d of e.source)s?.(d),yield d}finally{a=!0,l()}}(),remoteAddr:t,timeline:{open:Date.now(),close:void 0},close:e.close,abort:e.abort};function l(d){d===!0&&(a=!0,c=!0),a&&c&&g.timeline.close==null&&(g.timeline.close=Date.now())}return g}var $t=class extends Event{type;detail;constructor(e,t){super(e),this.type=e,this.detail=t}};var Za=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.name="AbortError",this.code=t??"ABORT_ERR"}};async function Ti(r,e,t,n){let s=new Za(n?.errorMessage,n?.errorCode);return t?.aborted===!0?Promise.reject(s):new Promise((i,o)=>{function a(){t?.removeEventListener("abort",f),r.removeEventListener(e,c),n?.errorEvent!=null&&r.removeEventListener(n.errorEvent,h)}let c=u=>{try{if(n?.filter?.(u)===!1)return}catch(g){a(),o(g);return}a(),i(u)},h=u=>{a(),o(u.detail)},f=()=>{a(),o(s)};t?.addEventListener("abort",f),r.addEventListener(e,c),n?.errorEvent!=null&&r.addEventListener(n.errorEvent,h)})}var ki=class extends Error{static name="QueueFullError";constructor(e="The queue was full"){super(e),this.name="QueueFullError"}};var Ci=class{deferred;signal;constructor(e){this.signal=e,this.deferred=tt(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new ft)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}};function T0(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}var Ni=class{id;fn;options;recipients;status;timeline;controller;constructor(e,t){this.id=T0(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,Re(1/0,this.controller.signal),this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,n)=>t&&n.signal?.aborted===!0,!0)&&(this.controller.abort(new ft),this.cleanup())}async join(e={}){let t=new Ci(e.signal);return this.recipients.push(t),e.signal?.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();let e=await ei(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{e.cleanup(),e.signal?.removeEventListener("abort",this.onAbort)})}};var Ri=class extends qe{concurrency;maxSize;queue;pending;sort;constructor(e={}){super(),this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,e.metricName!=null&&e.metrics?.registerMetricGroup(e.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})}),this.sort=e.sort,this.queue=[]}tryToStartAnother(){if(this.size===0)return queueMicrotask(()=>{this.safeDispatchEvent("empty")}),this.running===0&&queueMicrotask(()=>{this.safeDispatchEvent("idle")}),!1;if(this.pending<this.concurrency){let e;for(let t of this.queue)if(t.status==="queued"){e=t;break}return e==null?!1:(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let t=0;t<this.queue.length;t++)if(this.queue[t]===e){this.queue.splice(t,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(e){this.queue.push(e),this.sort!=null&&this.queue.sort(this.sort)}async add(e,t){if(t?.signal?.throwIfAborted(),this.size===this.maxSize)throw new ki;let n=new Ni(e,t);return this.enqueue(n),this.safeDispatchEvent("add"),this.tryToStartAnother(),n.join(t).then(s=>(this.safeDispatchEvent("completed",{detail:s}),this.safeDispatchEvent("success",{detail:{job:n,result:s}}),s)).catch(s=>{if(n.status==="queued"){for(let i=0;i<this.queue.length;i++)if(this.queue[i]===n){this.queue.splice(i,1);break}}throw this.safeDispatchEvent("error",{detail:s}),this.safeDispatchEvent("failure",{detail:{job:n,error:s}}),s})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new ft)}),this.clear()}async onEmpty(e){this.size!==0&&await Ti(this,"empty",e?.signal)}async onSizeLessThan(e,t){this.size<e||await Ti(this,"next",t?.signal,{filter:()=>this.size<e})}async onIdle(e){this.pending===0&&this.size===0||await Ti(this,"idle",e?.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){e?.signal?.throwIfAborted();let t=Or({objectMode:!0}),n=c=>{c!=null?this.abort():this.clear(),t.end(c)},s=c=>{c.detail!=null&&t.push(c.detail)},i=c=>{n(c.detail)},o=()=>{n()},a=()=>{n(new ft("Queue aborted"))};this.addEventListener("completed",s),this.addEventListener("error",i),this.addEventListener("idle",o),e?.signal?.addEventListener("abort",a);try{yield*t}finally{this.removeEventListener("completed",s),this.removeEventListener("error",i),this.removeEventListener("idle",o),e?.signal?.removeEventListener("abort",a),n()}}};var Mr=class extends Ri{has(e){return this.find(e)!=null}find(e){return this.queue.find(t=>e.equals(t.options.peerId))}};var Li=class extends qe{peerStore;registrar;connectionManager;randomWalk;started;running;topologyId;log;discoveryController;filter;queue;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:discover-relays"),this.started=!1,this.running=!1,this.peerStore=e.peerStore,this.registrar=e.registrar,this.connectionManager=e.connectionManager,this.randomWalk=e.randomWalk,this.filter=t.filter,this.discoveryController=new AbortController,Re(1/0,this.discoveryController.signal)}isStarted(){return this.started}async start(){this.topologyId=await this.registrar.register(We,{filter:this.filter,onConnect:e=>{this.log.trace("discovered relay %p queue (length: %d, active %d)",e,this.queue?.size,this.queue?.running),this.safeDispatchEvent("relay:discover",{detail:e})}}),this.started=!0}stop(){this.topologyId!=null&&this.registrar.unregister(this.topologyId),this.discoveryController?.abort(),this.started=!1}startDiscovery(){this.running||(this.log("start discovery"),this.running=!0,this.discoveryController=new AbortController,Re(1/0,this.discoveryController.signal),Promise.resolve().then(async()=>{this.log("searching peer store for relays");let e=await this.peerStore.all({filters:[n=>n.protocols.includes(We)],orders:[()=>Math.random()<.5?1:-1,(n,s)=>{let i=Af(n),o=Af(s);return i>o?-1:o>i?1:0}]});for(let n of e)this.log.trace("found relay peer %p in peer store",n.id),this.safeDispatchEvent("relay:discover",{detail:n.id});this.log("found %d relay peers in peer store",e.length);let t=this.queue=new Mr({concurrency:5});this.log("start random walk");for await(let n of this.randomWalk.walk({signal:this.discoveryController.signal})){if(this.log.trace("found random peer %p",n.id),t.has(n.id)){this.log.trace("random peer %p was already in queue",n.id);continue}if(this.connectionManager.getConnections(n.id)?.length>0){this.log.trace("random peer %p was already connected",n.id);continue}if(!await this.connectionManager.isDialable(n.multiaddrs)){this.log.trace("random peer %p was not dialable",n.id,n.multiaddrs.map(s=>s.toString()));continue}t.queued>10&&(this.log.trace("wait for space in queue for %p",n.id),await t.onSizeLessThan(10,{signal:this.discoveryController.signal})),this.log("adding random peer %p to dial queue (length: %d, active %d)",n.id,t.size,t.running),t.add(async()=>{let s=mi([this.discoveryController.signal,AbortSignal.timeout(5e3)]);Re(1/0,s);try{await this.connectionManager.openConnection(n.id,{signal:s})}finally{s.clear()}},{peerId:n.id,signal:this.discoveryController.signal}).catch(s=>{this.log.error("error opening connection to random peer %p",n.id,s)})}this.log("stop random walk"),await t.onIdle()}).catch(e=>{this.discoveryController.signal.aborted||this.log.error("failed when finding relays on the network",e)}))}stopDiscovery(){this.log("stop discovery"),this.running=!1,this.discoveryController?.abort()}};function Af(r){let e=r.metadata.get("last-dial-success");return e==null?0:new Date(ce(e)).getTime()}var ja=class extends qe{peerId;connectionManager;addressManager;reservationStore;listeningAddrs;log;listenTimeout;reservationId;relay;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:transport:listener"),this.peerId=e.peerId,this.connectionManager=e.connectionManager,this.addressManager=e.addressManager,this.reservationStore=e.reservationStore,this.listeningAddrs=[],this.listenTimeout=t.listenTimeout??oi,this.reservationStore.addEventListener("relay:removed",this._onRemoveRelayPeer),this.reservationStore.addEventListener("relay:created-reservation",this._onAddRelayPeer)}_onRemoveRelayPeer=e=>{this.log("relay removed %p our relay %p",e.detail.relay,this.relay,this.relay?.equals(e.detail.relay)),this.relay?.equals(e.detail.relay)===!0&&(this.log("relay peer removed %p",e.detail.relay),this.listeningAddrs.forEach(t=>{this.addressManager.removeObservedAddr(t)}),this.listeningAddrs=[],this.safeDispatchEvent("listening"))};_onAddRelayPeer=e=>{let{details:t}=e.detail;t.type!=="configured"&&t.id===this.reservationId&&this.addedRelay(e.detail)};async listen(e){if(this.log("listen on %a",e),xi.exactMatch(e))this.reservationId=this.reservationStore.reserveRelay();else if(wi.exactMatch(e)){let t=AbortSignal.timeout(this.listenTimeout);Re(1/0,t);let n=e.decapsulate("/p2p-circuit"),s=await this.connectionManager.openConnection(n,{signal:t});if(!this.reservationStore.hasReservation(s.remotePeer)){this.log("making reservation on peer %p",s.remotePeer);let i=await this.reservationStore.addRelay(s.remotePeer,"configured");this.addedRelay(i)}}else throw new Gt(`Could not listen on p2p-circuit address "${e}"`)}getAddrs(){return[...this.listeningAddrs.values()].flat()}async close(){this.reservationStore.cancelReservations(),this.listeningAddrs=[],this.reservationStore.removeEventListener("relay:removed",this._onRemoveRelayPeer),queueMicrotask(()=>{this.safeDispatchEvent("close")})}addedRelay(e){this.log("relay peer added %p",e.relay),this.relay=e.relay,this.listeningAddrs=e.details.reservation.addrs.map(t=>_e(t).encapsulate("/p2p-circuit")),this.listeningAddrs.forEach(t=>{this.addressManager.confirmObservedAddr(t,{type:"transport"})}),queueMicrotask(()=>{this.safeDispatchEvent("listening")})}};function Bf(r){return new ja(r)}var _f="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";var If=(r=21)=>{let e="",t=crypto.getRandomValues(new Uint8Array(r|=0));for(;r--;)e+=_f[t[r]&63];return e};var k0=60*1e3*10,C0=60*1e3*5,N0=30*1e3,Ui=class extends qe{peerId;connectionManager;peerStore;events;reserveQueue;reservations;pendingReservations;maxReservationQueueLength;reservationCompletionTimeout;started;log;relayFilter;constructor(e,t){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:transport:reservation-store"),this.peerId=e.peerId,this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.reservations=new zt,this.pendingReservations=[],this.maxReservationQueueLength=t?.maxReservationQueueLength??Gu,this.reservationCompletionTimeout=t?.reservationCompletionTimeout??oi,this.started=!1,this.relayFilter=Ur(100),this.reserveQueue=new Mr({concurrency:t?.reservationConcurrency??$u,metricName:"libp2p_relay_reservation_queue",metrics:e.metrics}),this.events.addEventListener("connection:close",n=>{[...this.reservations.values()].find(i=>i.connection===n.detail.id)!=null&&this.#t(n.detail.remotePeer).catch(i=>{this.log("could not remove relay %p - %e",n.detail,i)})})}isStarted(){return this.started}start(){this.started=!0}afterStart(){Promise.resolve().then(async()=>{let e=await this.peerStore.all({filters:[t=>t.tags.has(pn)]});this.log("removing tag from %d old relays",e.length),await Promise.all(e.map(async t=>{await this.peerStore.merge(t.id,{tags:{[pn]:void 0}})})),this.log("redialing %d old relays",e.length),await Promise.all(e.map(async t=>this.addRelay(t.id,"discovered"))),this.#r()}).catch(e=>{this.log.error(e)})}stop(){this.reserveQueue.clear(),this.reservations.forEach(({timeout:e})=>{clearTimeout(e)}),this.reservations.clear(),this.started=!1}reserveRelay(){let e=If();return this.pendingReservations.push(e),this.#r(),e}async addRelay(e,t){if(this.peerId.equals(e))throw this.log.trace("not trying to use self as relay"),new Gt("Cannot use self as relay");if(this.reserveQueue.size>this.maxReservationQueueLength)throw new bi("The reservation queue is full");let n=this.reserveQueue.find(e);if(n!=null)return this.log.trace("potential relay peer %p is already in the reservation queue",e),n.join();if(this.relayFilter.has(e.toMultihash().bytes))throw new Gt("The relay was previously invalid");return this.log.trace("try to reserve relay slot with %p",e),this.reserveQueue.add(async()=>{let s=Date.now();try{let i=this.reservations.get(e);if(i!=null){let d=this.connectionManager.getConnections(e),m=!1;if(d.length===0&&this.log("already have relay reservation with %p but we are no longer connected",e),d.map(y=>y.id).includes(i.connection)&&(this.log("already have relay reservation with %p and the original connection is still open",e),m=!0),m&&Oa(i.reservation.expire)>k0)return this.log("already have relay reservation with %p but we are still connected and it does not expire soon",e),{relay:e,details:i};await this.#t(e)}if(t==="discovered"&&this.pendingReservations.length===0)throw new xn("Not making reservation on discovered relay because we do not need any more relays");let o=AbortSignal.timeout(this.reservationCompletionTimeout);Re(1/0,o);let a=await this.connectionManager.openConnection(e,{signal:o});if(pi.matches(a.remoteAddr))throw new yi("not creating reservation over relayed connection");let c=await this.#e(a,{signal:o}),h=Oa(c.expire);this.log("created reservation on relay peer %p, expiry date is %s",e,new Date(Date.now()+h).toString());let f=Math.min(Math.max(h-C0,N0),Math.pow(2,31)-1),u=setTimeout(()=>{this.log("refresh reservation to relay %p",e),this.addRelay(e,t).catch(async d=>{this.log.error("could not refresh reservation to relay %p - %e",e,d),await this.#t(e)}).catch(d=>{this.log.error("could not remove expired reservation to relay %p - %e",e,d)})},f),g;if(t==="discovered"){let d=this.pendingReservations.pop();if(d==null)throw new xn("Made reservation on relay but did not need any more discovered relays");g={timeout:u,reservation:c,type:t,connection:a.id,id:d}}else g={timeout:u,reservation:c,type:t,connection:a.id};this.reservations.set(e,g),await this.peerStore.merge(e,{tags:{[pn]:{value:1,ttl:h}}}),this.#r();let l={relay:e,details:g};return this.safeDispatchEvent("relay:created-reservation",{detail:l}),l}catch(i){throw t==="discovered"&&i.name==="HadEnoughRelaysError"||this.log.error("could not reserve slot on %p after %dms - %e",e,Date.now()-s,i),(i.name==="DialError"||i.name==="UnsupportedProtocolError")&&this.relayFilter.add(e.toMultihash().bytes),this.#t(e).catch(o=>{this.log.error("could not remove reservation on %p after reserving slot failed - %e",e,o)}),i}},{peerId:e})}hasReservation(e){return this.reservations.has(e)}getReservation(e){return this.reservations.get(e)?.reservation}reservationCount(e){return e==null?this.reservations.size:[...this.reservations.values()].reduce((t,n)=>(n.type===e&&t++,t),0)}cancelReservations(){[...this.reservations.values()].forEach(e=>{clearTimeout(e.timeout)}),this.reservations.clear()}async#e(e,t){t.signal?.throwIfAborted(),this.log("requesting reservation from %p",e.remotePeer);let n=await e.newStream(We,t),i=qt(n).pb(X);this.log.trace("send RESERVE to %p",e.remotePeer),await i.write({type:X.Type.RESERVE},t);let o;try{this.log.trace("reading response from %p",e.remotePeer),o=await i.read(t)}catch(c){throw n.abort(c),c}finally{n.status!=="closed"&&await n.close(t)}if(this.log.trace("read response %o",o),o.status===K.OK&&o.reservation!=null){let c=new Set;c.add(e.remoteAddr.toString());for(let h of o.reservation.addrs){let f=_e(h);f.getPeerId()==null&&(f=f.encapsulate(`/p2p/${e.remotePeer}`)),f=_e(f.toString().replace(`/p2p/${e.remotePeer}/p2p/${e.remotePeer}`,`/p2p/${e.remotePeer}`)),c.add(f.toString())}return o.reservation.addrs=[...c].map(h=>_e(h).bytes),o.reservation}let a=`reservation failed with status ${o.status??"undefined"}`;throw this.log.error(a),new Error(a)}async#t(e){let t=this.reservations.get(e);t!=null&&(this.log("removing relay reservation with %p from local store",e),clearTimeout(t.timeout),this.reservations.delete(e),t.type==="discovered"&&this.pendingReservations.push(t.id),await this.peerStore.merge(e,{tags:{[pn]:void 0}}),this.safeDispatchEvent("relay:removed",{detail:{relay:e,details:t}}),this.#r())}#r(){if(this.pendingReservations.length===0){this.log.trace("have discovered enough relays"),this.reserveQueue.clear(),this.safeDispatchEvent("relay:found-enough-relays");return}this.relayFilter=Ur(100),this.log("not discovered enough relays %d/%d",this.reservations.size,this.pendingReservations.length),this.safeDispatchEvent("relay:not-enough-relays")}};var R0=r=>{if(r.peer==null)return!1;try{r.peer.addrs.forEach(_e)}catch{return!1}return!0},Ya={maxInboundStopStreams:mn,maxOutboundStopStreams:mn,stopTimeout:3e4},Di=class{discovery;registrar;peerStore;connectionManager;transportManager;peerId;upgrader;addressManager;connectionGater;reservationStore;logger;maxInboundStopStreams;maxOutboundStopStreams;stopTimeout;started;log;constructor(e,t){this.log=e.logger.forComponent("libp2p:circuit-relay:transport"),this.registrar=e.registrar,this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.transportManager=e.transportManager,this.logger=e.logger,this.peerId=e.peerId,this.upgrader=e.upgrader,this.addressManager=e.addressManager,this.connectionGater=e.connectionGater,this.maxInboundStopStreams=t.maxInboundStopStreams??Ya.maxInboundStopStreams,this.maxOutboundStopStreams=t.maxOutboundStopStreams??Ya.maxOutboundStopStreams,this.stopTimeout=t.stopTimeout??Ya.stopTimeout,this.discovery=new Li(e,{filter:t.discoveryFilter??Ha(Yu,Xu)}),this.discovery.addEventListener("relay:discover",n=>{this.reservationStore.addRelay(n.detail,"discovered").catch(s=>{s.name!=="HadEnoughRelaysError"&&s.name!=="RelayQueueFullError"&&this.log.error("could not add discovered relay %p",n.detail,s)})}),this.reservationStore=new Ui(e,t),this.reservationStore.addEventListener("relay:not-enough-relays",()=>{this.discovery?.startDiscovery()}),this.reservationStore.addEventListener("relay:found-enough-relays",()=>{this.discovery?.stopDiscovery()}),this.started=!1}[Symbol.toStringTag]="@libp2p/circuit-relay-v2-transport";[fc]=["@libp2p/transport","@libp2p/circuit-relay-v2-transport"];get[hc](){return this.discovery!=null?["@libp2p/identify"]:[]}[ac]=!0;isStarted(){return this.started}async start(){await this.registrar.handle(sr,e=>{this.onStop(e).catch(t=>{this.log.error("error while handling STOP protocol",t),e.stream.abort(t)})},{maxInboundStreams:this.maxInboundStopStreams,maxOutboundStreams:this.maxOutboundStopStreams,runOnLimitedConnection:!0}),await lc(this.discovery,this.reservationStore),this.started=!0}async stop(){await uc(this.discovery,this.reservationStore),await this.registrar.unhandle(sr),this.started=!1}async dial(e,t){if(e.protoCodes().filter(l=>l===ii).length!==1){let l="Invalid circuit relay address";throw this.log.error(l,e),new Vr(l)}let n=e.toString().split("/p2p-circuit"),s=_e(n[0]),i=_e(n[n.length-1]),o=s.getPeerId(),a=i.getPeerId();if(o==null||a==null){let l=`ircuit relay dial to ${e.toString()} failed as address did not have both relay and destination PeerIDs`;throw this.log.error(`c${l}`),new Vr(`C${l}`)}let c=ca(o),h=ca(a),u=this.connectionManager.getConnections(c)[0];u==null?(await this.peerStore.merge(c,{multiaddrs:[s]}),t.onProgress?.(new $t("circuit-relay:open-connection")),u=await this.connectionManager.openConnection(c,t)):t.onProgress?.(new $t("circuit-relay:reuse-connection"));let g;try{t.onProgress?.(new $t("circuit-relay:open-hop-stream")),g=await u.newStream(We,t);let l=qt(g),d=l.pb(X);t.onProgress?.(new $t("circuit-relay:write-connect-message")),await d.write({type:X.Type.CONNECT,peer:{id:h.toMultihash().bytes,addrs:[_e(i).bytes]}},t),t.onProgress?.(new $t("circuit-relay:read-connect-response"));let m=await d.read(t);if(m.status!==K.OK)throw new In(`failed to connect via relay with status ${m?.status?.toString()??"undefined"}`);let y=new vn(m.limit),b=Wa({stream:l.unwrap(),remoteAddr:e,localAddr:s.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`),logger:this.logger,onDataRead:y.onData,onDataWrite:y.onData});return this.log("new outbound relayed connection %a",b.remoteAddr),await this.upgrader.upgradeOutbound(b,{...t,limits:y.getLimits()})}catch(l){throw this.log.error("circuit relay dial to destination %p via relay %p failed",h,c,l),g?.abort(l),l}}createListener(e){return Bf({peerId:this.peerId,connectionManager:this.connectionManager,addressManager:this.addressManager,reservationStore:this.reservationStore,logger:this.logger})}listenFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>wi.exactMatch(t)||xi.exactMatch(t))}dialFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>pi.exactMatch(t))}async onStop({connection:e,stream:t}){if(!this.reservationStore.hasReservation(e.remotePeer))try{this.log("dialed via relay we did not have a reservation on, start listening on that relay address"),await this.transportManager.listen([e.remoteAddr.encapsulate("/p2p-circuit")])}catch(u){this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on",u)}let n=AbortSignal.timeout(this.stopTimeout),s=qt(t).pb(Ke),i=await s.read({signal:n});if(this.log("new circuit relay v2 stop stream from %p with type %s",e.remotePeer,i.type),i?.type===void 0){this.log.error("type was missing from circuit v2 stop protocol request from %s",e.remotePeer),await s.write({type:Ke.Type.STATUS,status:K.MALFORMED_MESSAGE},{signal:n}),await t.close();return}if(i.type!==Ke.Type.CONNECT){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await s.write({type:Ke.Type.STATUS,status:K.UNEXPECTED_MESSAGE},{signal:n}),await t.close();return}if(!R0(i)){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await s.write({type:Ke.Type.STATUS,status:K.MALFORMED_MESSAGE},{signal:n}),await t.close();return}let o=fn(ze(i.peer.id));if(await this.connectionGater.denyInboundRelayedConnection?.(e.remotePeer,o)===!0){this.log.error("connection gater denied inbound relayed connection from %p",e.remotePeer),await s.write({type:Ke.Type.STATUS,status:K.PERMISSION_DENIED},{signal:n}),await t.close();return}this.log.trace("sending success response to %p",e.remotePeer),await s.write({type:Ke.Type.STATUS,status:K.OK},{signal:n});let a=new vn(i.limit),c=e.remoteAddr.encapsulate(`/p2p-circuit/p2p/${o.toString()}`),h=this.addressManager.getAddresses()[0],f=Wa({stream:s.unwrap().unwrap(),remoteAddr:c,localAddr:h,logger:this.logger,onDataRead:a.onData,onDataWrite:a.onData});this.log("new inbound relayed connection %a",f.remoteAddr),await this.upgrader.upgradeInbound(f,{limits:a.getLimits()}),this.log("%s connection %a upgraded","inbound",f.remoteAddr)}};function Tf(r={}){return e=>new Di(e,r)}return Kf(L0);})();
Binary file ./node_modules/lightningcss-darwin-arm64/lightningcss.darwin-arm64.node matches
./node_modules/@achingbrain/ssdp/node_modules/xml2js/lib/xml2js.bc.js:6057:     if(typeof globalThis.crypto.getRandomValues === "function"){
./node_modules/@achingbrain/ssdp/node_modules/xml2js/lib/xml2js.bc.js:6059:      globalThis.crypto.getRandomValues(a);
./node_modules/@noble/hashes/esm/utils.d.ts:117:/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */
./node_modules/@noble/hashes/esm/utils.js:201:/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */
./node_modules/@noble/hashes/esm/utils.js:203:    if (crypto && typeof crypto.getRandomValues === 'function') {
./node_modules/@noble/hashes/esm/utils.js:204:        return crypto.getRandomValues(new Uint8Array(bytesLength));
./node_modules/@noble/hashes/esm/utils.js:210:    throw new Error('crypto.getRandomValues must be defined');
./node_modules/@noble/hashes/README.md:456:[crypto.getRandomValues](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues)
./node_modules/@noble/hashes/utils.d.ts:117:/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */
./node_modules/@noble/hashes/utils.js:225:/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */
./node_modules/@noble/hashes/utils.js:227:    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
./node_modules/@noble/hashes/utils.js:228:        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
./node_modules/@noble/hashes/utils.js:234:    throw new Error('crypto.getRandomValues must be defined');
./node_modules/@noble/hashes/src/utils.ts:295:/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */
./node_modules/@noble/hashes/src/utils.ts:297:  if (crypto && typeof crypto.getRandomValues === 'function') {
./node_modules/@noble/hashes/src/utils.ts:298:    return crypto.getRandomValues(new Uint8Array(bytesLength));
./node_modules/@noble/hashes/src/utils.ts:304:  throw new Error('crypto.getRandomValues must be defined');
./node_modules/@noble/ciphers/webcrypto.d.ts:3: * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
./node_modules/@noble/ciphers/esm/webcrypto.d.ts:3: * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
./node_modules/@noble/ciphers/esm/webcrypto.js:13: * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
./node_modules/@noble/ciphers/esm/webcrypto.js:16:    if (crypto && typeof crypto.getRandomValues === 'function')
./node_modules/@noble/ciphers/esm/webcrypto.js:17:        return crypto.getRandomValues(new Uint8Array(bytesLength));
./node_modules/@noble/ciphers/esm/webcrypto.js:18:    throw new Error('crypto.getRandomValues must be defined');
./node_modules/@noble/ciphers/README.md:437:[crypto.getRandomValues](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues)
./node_modules/@noble/ciphers/webcrypto.js:19: * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
./node_modules/@noble/ciphers/webcrypto.js:22:    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function')
./node_modules/@noble/ciphers/webcrypto.js:23:        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
./node_modules/@noble/ciphers/webcrypto.js:24:    throw new Error('crypto.getRandomValues must be defined');
./node_modules/@noble/ciphers/src/webcrypto.ts:14: * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
./node_modules